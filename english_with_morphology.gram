
# This is the root nonterminal for declarative sentences.
S nonterminal {} {1.0} {1.0} {} 10 1.0 {}
S -> S':singular PERIOD:null
S -> S':plural PERIOD:null
S -> ADVP (COMMA) S
S -> S (COMMA) ADVP


S' nonterminal {has_not} {1.0, 1.0} {1.0, 1.0} {} 10 1.0 {}

# S' {g(a)} -> DP {^[Q]:Q(a)} VP {^[x]:g(x)}
# S' {~g(a)} -> DP {^[Q]:Q(a)} VP {^[x]:~g(x)}
S' -> DP:select_arg VP:delete_arg

# S' {![x]:(f(x) => g(h(x)))} -> DP {^[Q]:![x]:(f(x) -> Q(h(x)))} VP {^[x]:g(x)}
# S' {~![x]:(f(x) => g(h(x)))} -> DP {^[Q]:~![x]:(f(x) -> Q(h(x)))} VP {^[x]:g(x)}
# note: h is optional here (it could be the identity ^[x]:x)
S' -> DP:remove_consequent VP:select_consequent
# S' {~![x]:(f(x) => g(h(x)))} -> DP {^[Q]:![x]:(f(x) -> Q(h(x)))} VP {^[x]:~g(x)}
S' -> DP:remove_consequent_not VP:select_not_consequent

# S' {?[X1]:(F1(X1,^[x]:f1(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & ![x1]:(X1(x1) => ... => ![xn]:(Xn(xn) => g(h1(x1),...,hn(xn)))...))...)}
#  -> DP {^[Q]:?[X1]:(F1(X1,^[x]:f1(x)) & Q(^[g]:![x1]:(X1(x1) => g(h1(x1)))))}
#     VP {^[Q]:?[X2]:(F2(X2,^[x]:f2(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & Q(^[x1]:![x2]:(X2(x2) => ... => ![xn]:(Xn(xn) => g(x1,h2(x2),...,hn(xn)))...)))...)}
# S' {?[X1]:(F1(X1,^[x]:f1(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & ~![x1]:(X1(x1) => ... => ![xn]:(Xn(xn) => g(h1(x1),...,hn(xn)))...))...)}
#  -> DP {^[Q]:?[X1]:(F1(X1,^[x]:f1(x)) & Q(^[g]:~![x1]:(X1(x1) => g(h1(x1)))))}
#     VP {^[Q]:?[X2]:(F2(X2,^[x]:f2(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & Q(^[x1]:![x2]:(X2(x2) => ... => ![xn]:(Xn(xn) => g(x1,h2(x2),...,hn(xn)))...)))...)}
# S' {?[X1]:(F1(X1,^[x]:f1(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & ?[x1]:(X1(x1) & ... => ![xn]:(Xn(xn) => g(h1(x1),...,hn(xn)))...))...)}
#  -> DP {^[Q]:?[X1]:(F1(X1,^[x]:f1(x)) & Q(^[g]:?[x1]:(X1(x1) & g(h1(x1)))))}
#     VP {^[Q]:?[X2]:(F2(X2,^[x]:f2(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & Q(^[x1]:![x2]:(X2(x2) => ... => ![xn]:(Xn(xn) => g(x1,h2(x2),...,hn(xn)))...)))...)}
# S' {?[X1]:(F1(X1,^[x]:f1(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & ~?[x1]:(X1(x1) & ... => ![xn]:(Xn(xn) => g(h1(x1),...,hn(xn)))...))...)}
#  -> DP {^[Q]:?[X1]:(F1(X1,^[x]:f1(x)) & Q(^[g]:~?[x1]:(X1(x1) & g(h1(x)))))}
#     VP {^[Q]:?[X2]:(F2(X2,^[x]:f2(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & Q(^[x1]:![x2]:(X2(x2) => ... => ![xn]:(Xn(xn) => g(x1,h2(x2),...,hn(xn)))...)))...)}
# where F1,...,Fn are set-defining functions like subset or =
# note: h1, ..., hn are optional (they could be the identity ^[x]:x)
# TODO: add a version of these two rules for weak universal quantification
S' -> DP:remove_set_universal VP:select_set_consequent
# S' {?[X1]:(F1(X1,^[x]:f1(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & ~![x1]:(X1(x1) => ... => ![xn]:(Xn(xn) => g(h1(x1),...,hn(xn)))...))...)}
#  -> DP {^[Q]:?[X1]:(F1(X1,^[x]:f1(x)) & Q(^[g]:![x1]:(X1(x1) => g(h1(x1)))))}
#     VP {^[Q]:?[X2]:(F2(X2,^[x]:f2(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & Q(^[x1]:~![x2]:(X2(x2) => ... => ![xn]:(Xn(xn) => g(x1,h2(x2),...,hn(xn)))...)))...)}
# S' {?[X1]:(F1(X1,^[x]:f1(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & ~?[x1]:(X1(x1) & ... => ![xn]:(Xn(xn) => g(h1(x1),...,hn(xn)))...))...)}
#  -> DP {^[Q]:?[X1]:(F1(X1,^[x]:f1(x)) & Q(^[g]:?[x1]:(X1(x1) & g(h1(x1)))))}
#     VP {^[Q]:?[X2]:(F2(X2,^[x]:f2(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & Q(^[x1]:~![x2]:(X2(x2) => ... => ![xn]:(Xn(xn) => g(x1,h2(x2),...,hn(xn)))...)))...)}
S' -> DP:not_remove_set_universal VP:select_set_consequent

# S' {?[x]:f(x)} -> THERE IS DP {^[Q]:?[x]:(f(x) & Q(x))}
# S' {~?[x]:f(x)} -> THERE IS DP {^[Q]:~?[x]:(f(x) & Q(x))}
S' -> THERE:null IS:null DP:identity

# S' {?[x]:(f(x) & g(h(x)))} -> DP {^[Q]:?[x]:(f(x) & Q(h(x)))} VP:{^[x]:g(x)}
S' -> DP:remove_right_conjunct VP:select_right_conjunct


VP nonterminal {} {1.0} {1.0} {} 10 1.0 {}
VP -> VP COMMA:null VP
VP -> VP AND VP
VP -> VP COMMA:null AND VP
VP -> VP OR VP
VP -> VP COMMA:null OR VP


DP nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# DP {A} -> A NP {A}
DP -> DP'

# DP {^[Q]:?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & Q(^[g]:(~)![x]:(S(x) => ![y]:(x(y) => g(h(y))))))} if xi are set-valued
# or {^[Q]:?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & Q(^[g]:(~)![x]:(S(x) => g(h(x)))))} if xi are individuals
# or {^[Q]:?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & Q(^[g]:(~)?[x]:(S(x) & ?[y]:(x(y) & g(h(y))))))} if xi are set-valued
# or {^[Q]:?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & Q(^[g]:(~)?[x]:(S(x) & g(h(x)))))} if xi are individuals
#  -> DP {^[Q]:?[x1]:(f1(x1) & (~)Q(x1))} or {^[Q]:?[x1]:(f1(x1) & Q(^[g]:(~)![x]:(x1(x) => g(h(x)))))} if x1 is a set
#     COMMA
#     DP {^[Q]:?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & Q(^[g]:(~)![x]:(S(x) => ![y]:(x(y) => g(h(y))))))}
#     or {^[Q]:?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & Q(^[g]:(~)![x]:(S(x) => g(h(x)))))}
#     or {^[Q]:?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & Q(^[g]:(~)?[x]:(S(x) & ?[y]:(x(y) & g(h(y))))))}
#     or {^[Q]:?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & Q(^[g]:(~)?[x]:(S(x) & g(h(x)))))}
# note: xi could also be constants, rather than existentially-quantified variables
# note: if xi is a set containing a singleton, S would look like ^[x]:(... | x=^[y]:y=singleton | ...)
DP -> DP COMMA:null DP:comma

# DP {^[Q]:?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & Q(^[g]:(~)![x]:(S(x) => ![y]:(x(y) => g(h(y))))))}
# or {^[Q]:?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & Q(^[g]:(~)![x]:(S(x) => g(h(x)))))}
#  -> DP {^[Q]:?[x1]:(f1(x1) & (~)Q(x1))} or {^[Q]:?[x1]:(f1(x1) & Q(^[g]:(~)![x]:(x1(x) => g(h(x)))))} if x1 is a set
#     (COMMA) AND
#     DP {^[Q]:?[x2]:(f2(x2) & (~)Q(x2))} or {^[Q]:?[x2]:(f2(x2) & Q(^[g]:(~)![x]:(x2(x) => g(h(x)))))} if x2 is a set
# note: xi could also be constants, rather than existentially-quantified variables
DP -> DP AND:null DP
DP -> DP COMMA:null AND:null DP

# DP {^[Q]:?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & Q(^[g]:(~)?[x]:(S(x) & ?[y]:(x(y) & g(h(y))))))}
# or {^[Q]:?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & Q(^[g]:(~)?[x]:(S(x) & g(h(x)))))}
#  -> DP {^[Q]:?[x1]:(f1(x1) & (~)Q(x1))} or {^[Q]:?[x1]:(f1(x1) & Q(^[g]:(~)?[x]:(x1(x) & g(h(x)))))} if x1 is a set
#     (COMMA) AND
#     DP {^[Q]:?[x2]:(f2(x2) & (~)Q(x2))} or {^[Q]:?[x2]:(f2(x2) & Q(^[g]:(~)?[x]:(x2(x) & g(h(x)))))} if x2 is a set
# note: xi could also be constants, rather than existentially-quantified variables
DP -> DP OR:null DP
DP -> DP COMMA:null OR:null DP

# DP {^[Q]:~![x]:(f(x) -> Q(x))} -> A NP {^[Q]:![x]:(f(x) -> Q(x))}
# DP {^[Q]:~?[x]:(f(x) & Q(x))} -> A NP {^[Q]:?[x]:(f(x) & Q(x))}
# DP {^[Q]:![X]:(f(X) & Q(^[g]:~![x]:(X(x) => g(h(x)))))} -> A NP {^[Q]:![X]:(f(X) & Q(^[g]:![x]:(X(x) => g(h(x)))))}
# DP {^[Q]:![X]:(f(X) & Q(^[g]:~?[x]:(X(x) & g(h(x)))))} -> A NP {^[Q]:![X]:(f(X) & Q(^[g]:?[x]:(X(x) & g(h(x)))))}
DP -> NO NP
DP -> NOT DP

# DP {^[Q]:Q(a)} -> NAME {a}
DP -> NAME

DP -> ADV DP:adv
DP -> EACH:no_adv NP

# DP {A} -> A NP {A}
#   e.g. "A group of students walks down the street."
DP -> A:null NP:concord_singular

# DP {^[Q]:![X]:(F(subset(X,^[x]:f(x))) & Q(^[g]:![x]:(X(x) => g(h(x)))))} -> A NP {^[Q]:![X]:(F(X=^[x]:f(x)) & Q(^[g]:![x]:(X(x) => g(h(x)))))}
# DP {^[Q]:![X]:(F(subset(X,^[x]:f(x))) & Q(^[g]:?[x]:(X(x) & g(h(x)))))} -> A NP {^[Q]:![X]:(F(X=^[x]:f(x)) & Q(^[g]:?[x]:(X(x) & g(h(x)))))}
# this depends on whether the set is defined using `subset` rather than with functions like `half` or as S=^[x]:f(x);
DP -> SOME NP

# DP {A} -> DEF_DP {A}
DP -> DEF_DP

# DP {^[Q]:![X]:(F(X=^[x]:f(x)) & Q(^[g]:![x]:(X(x) => g(h(x)))))} -> A NP {^[Q]:![X]:(F(X=^[x]:f(x)) & Q(^[g]:![x]:(X(x) => g(h(x)))))}
# DP {^[Q]:![X]:(F(X=^[x]:f(x)) & Q(^[g]:?[x]:(X(x) & g(h(x)))))} -> A NP {^[Q]:![X]:(F(X=^[x]:f(x)) & Q(^[g]:?[x]:(X(x) & g(h(x)))))}
# this depends on whether the set is defined as S=^[x]:f(x) rather than with functions like `subset` or `half`;
# it also depends on whether the head predicate of the left conjunct is `this`, `that`, [TODO: add features for possessive]
DP -> ALL DEF_DP
DP -> ALL DP'

# DP {^[Q]:![X]:(F(half(X,^[x]:f(x))) & Q(^[g]:![x]:(X(x) => g(h(x)))))} -> A NP {^[Q]:![X]:(F(X=^[x]:f(x)) & Q(^[g]:![x]:(X(x) => g(h(x)))))}
# DP {^[Q]:![X]:(F(half(X,^[x]:f(x))) & Q(^[g]:?[x]:(X(x) & g(h(x)))))} -> A NP {^[Q]:![X]:(F(X=^[x]:f(x)) & Q(^[g]:?[x]:(X(x) & g(h(x)))))}
# this depends on whether the set is defined using `half` rather than with functions like `subset` or as S=^[x]:f(x);
# it also depends on whether the head predicate of the left conjunct is `this`, `that`, [TODO: add features for possessive]
DP -> HALF DEF_DP
DP -> HALF A NP


DEF_DP nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# DEF_DP {A} -> THE NP {A}
DEF_DP -> THE DP'

# DP {^[Q]:![x]:(this(x) & f(x) => Q(h(x)))} -> THIS NP {^[Q]:![x]:(f(x) => Q(h(x)))}
# DP {^[Q]:?[x]:(this(x) & Q(h(x)))} -> THIS NP {^[Q]:?[x]:Q(h(x))}
# DP {^[Q]:?[S]:(this(S) & F(S) & Q(^[g]:![x]:(S(x) => g(h(x)))))} -> THIS NP {^[Q]:?[S]:(F(S) & Q(^[g]:![x]:(S(x) => g(h(x)))))}
# DP {^[Q]:?[S]:(this(S) & F(S) & Q(^[g]:?[x]:(S(x) & g(h(x)))))} -> THIS NP {^[Q]:?[S]:(F(S) & Q(^[g]:?[x]:(S(x) & g(h(x)))))}
# this depends on whether the head predicate of the left conjunct is `this`
DEF_DP -> THIS DP'

# DP {^[Q]:![x]:(that(x) & f(x) => Q(h(x)))} -> THIS NP {^[Q]:![x]:(f(x) => Q(h(x)))}
# DP {^[Q]:?[x]:(that(x) & Q(h(x)))} -> THIS NP {^[Q]:?[x]:Q(h(x))}
# DP {^[Q]:?[S]:(that(S) & F(S) & Q(^[g]:![x]:(S(x) => g(h(x)))))} -> THIS NP {^[Q]:?[S]:(F(S) & Q(^[g]:![x]:(S(x) => g(h(x)))))}
# DP {^[Q]:?[S]:(that(S) & F(S) & Q(^[g]:?[x]:(S(x) & g(h(x)))))} -> THIS NP {^[Q]:?[S]:(F(S) & Q(^[g]:?[x]:(S(x) & g(h(x)))))}
# this depends on whether the head predicate of the left conjunct is `that`
DEF_DP -> THAT DP'

DEF_DP -> DP:poss DP'


DP' nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# DP {^[Q]:?[S]:(f(S) & F(S) & Q(^[g]:![x]:(S(x) => g(h(x)))))} -> Q {^[S]:f(S)} NP {^[Q]:?[S]:(F(S) & Q(^[g]:![x]:(S(x) => g(h(x)))))}
# this depends on whether the head predicate of the left conjunct is one that expresses information about the size of the set,
# and also on whether the set if defined using `subset` rather than `half`, or as S=^[x]:f(x)
DP' -> Q NP

# DEF_DP {A} -> THE NP {A}
DP' -> NP


Q nonterminal {} {1.0} {1.0} {} 10 1.0 {}
Q -> NUMBER
Q -> MUCH
Q -> MANY
Q -> MORE
Q -> MOST
Q -> FEW
Q -> FEWER
Q -> FEWEST
Q -> LESS
Q -> LEAST


NP nonterminal {} {1.0} {1.0} {} 10 1.0 {}
NP -> NP'
NP -> NP PP
NP -> NP COMP CP
NP -> NP VP:keep_present_participle
NP -> NP VP:flip_predicate_keep_past_participle
NP -> NP COMMA:null NP
NP -> NP AND NP
NP -> NP COMMA:null AND NP
NP -> NP OR NP
NP -> NP COMMA:null OR NP


NP' nonterminal {} {1.0} {1.0} {} 10 1.0 {}
NP' -> N
NP' -> ADJP NP'


PP nonterminal {} {1.0} {1.0} {} 10 1.0 {}
PP -> P DP
PP -> PP COMMA:null PP
PP -> PP AND PP
PP -> PP COMMA:null AND PP
PP -> PP OR PP
PP -> PP COMMA:null OR PP


ALL nonterminal {} {1.0} {1.0} {} 10 1.0 {}
ALL -> "every"
ALL -> "each"
ALL -> "all"
