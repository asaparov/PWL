# We use neo-Davidsonian/event semantics to represent meaning in logical form.
# Thus, all verbs, nouns, adjectives, adverbs, etc are expressed as quantified
# variables. The "head" of any logical form is the right-most scope (not
# necessarily the deepest). For example:
#
#  "cats are mammals"
#  ![x]:(U(0,x) & cat(x) => ?[s]:(arg1(s)=x & same(s) & present(s) & ?[m]:(U(1,m) & mammal(m) & arg2(t)=m)))
# where `present` is relative to the deictic origo, so it could be defined as
# something like ![x]:(present(x) = time(x)(T)) where time(x) returns the set
# of times at which the event x is true, and T is the current time in the
# discourse model (deictic origo). Also, `U` is the current universe of
# discourse. `U` can either contain the entire universe, as a default,
# U=^[x]:T, or it could change dynamically according to the discourse model.
# The first argument to `U` is an index that increases by one each time `U`
# function is invoked (and so its semantics can differ even within a sentence).
# We also might add an axiom like:
#     ![t,x,y]:((type(t) & arg1(t)=x & arg2(t)=y) = y(x))
#
# Generally, every event that corresponds to a verb is modified with
# information about the time at which the event occurs. We can do this with the
# following axioms:
#   ![x,t]:(progressive(x,t) = ?[r]:(r>0 & ![s]:(s>(t-r) & s<(t+r) => time(x)(t))))
#   ![x,t]:(perfect(x,t) = ![r]:(time(x)(r) => r<t))
#   ![x,t]:(perfect_progressive(x,t) = (perfect(x,t) & ?[r]:(r>0 & ![s]:(s>(t-r) & s<t => time(x)(t)))))
#   ![x]:(present(x) = time(x)(T))
#   ![x]:(present_progressive(x) = progressive(x,T))
#   ![x]:(present_perfect(x) = perfect(x,T))
#   ![x]:(present_perfect_progressive(x) = perfect_progressive(x,T))
#   ![x]:(past(x) = ?[t]:(t<T & time(x)(t)))
#   ![x]:(past_progressive(x) = ?[t]:(t<T & progressive(x,t)))
#   ![x]:(past_perfect(x) = ?[t]:(t<T & perfect(x,t)))
#   ![x]:(past_perfect_progressive(x) = ?[t]:(t<T & perfect_progressive(x,t)))
#   ![x]:(future(x) = ?[t]:(t>T & time(x)(t)))
#   ![x]:(future_progressive(x) = ?[t]:(t>T & progressive(x,t)))
#   ![x]:(future_perfect(x) = ?[t]:(t>T & perfect(x,t)))
#   ![x]:(future_perfect_progressive(x) = ?[t]:(t>T & perfect_progressive(x,t)))
#
#  "4 cats sleep"
#  ?[X]:(subset(X,^[x]:(U(0,x) & cat(x))) & size(X)=4 & ![x]:(X(x) => ?[s]:(arg1(s)=x & sleep(s) & present(s))))
#
#  "4 cats slept"
#  ?[X]:(subset(X,^[x]:(U(0,x) & cat(x))) & size(X)=4 & ![x]:(X(x) => ?[s]:(arg1(s)=x & sleep(s) & past(s))))
#
#  "4 cats will have been sleeping"
#  ?[X]:(subset(X,^[x]:(U(0,x) & cat(x))) & size(X)=4 & ![x]:(X(x) => ?[s]:(arg1(s)=x & sleep(s) & future_perfect_progressive(s))))
#
#  "there is a cat"
#  ?[x]:(U(0,x) & cat(x))
#    [OR]
#  ?[c]:(U(0,x) & cat(x) & ?[l]:(arg1(l)=x & position(l) & present(l) & arg2(l)=L))
# where L is the current discourse location (location of deictic origo).
#
#  "3 teachers grade 6 exams"
#  ?[X]:(subset(X,^[x]:(U(0,x) & teacher(x))) & size(X)=3 & ?[Y]:(subset(Y,^[y]:(U(1,y) & exam(y))) & size(Y)=6 & ![x,y]:(X(x) & Y(y) => ?[g]:(arg1(g)=x & grade(g) & present(g) & arg2(g)=y))))
#  ?[X]:(subset(X,^[x]:(U(0,x) & teacher(x))) & size(X)=3 & ?[Y]:(subset(Y,^[y]:(U(1,y) & exam(y))) & size(Y)=6 & !W[x,y]:(X(x) & Y(y) => ?[g]:(arg1(g)=x & grade(g) & present(g) & arg2(g)=y))))
#  ?[X]:(subset(X,^[x]:(U(0,x) & teacher(x))) & size(X)=3 & ![x]:(X(x) => ?[Y]:(subset(Y,^[y]:(U(1,y) & exam(y))) & size(Y)=6 & ![y]:(Y(y) => ?[g]:(arg1(g)=x & grade(g) & present(g) & arg2(g)=y)))))
# where !W is the weak universal quantifier, which is defined as:
# !W[x1,...,xn]:(X1(x1) & ... & Xn(xn) => f(x1,...,xn)) =
#     ![x1]:(X1(x1) => ?[x2,...,xn]:(X2(x2) & ... & Xn(xn) & f(x1,...,xn)))
#   & ![x2]:(X2(x2) => ?[x1,x3,...,xn]:(X1(x1) & X3(x3) & ... & Xn(xn) & f(x1,...,xn)))
#   & ![x3]:(X3(x3) => ?[x1,...,x2,x4,...,xn]:(X1(x1) & ... & X2(x2) & X4(x4) & ... & Xn(xn) & f(x1,...,xn)))
#   & ![x4]:(X4(x4) => ?[x1,...,x3,x5,...,xn]:(X1(x1) & ... & X3(x3) & X5(x5) & ... & Xn(xn) & f(x1,...,xn)))
#   & ... & ![xn]:(Xn(xn) => ?[x1,...,x(n-1)]:(X1(x1) & ... & X(n-1)(x(n-1)) & f(x1,...,xn)))
#
#  "a dog likes every cat"
#  ?[d]:(U(0,d) & dog(d) & ![c]:(U(1,c) & cat(c) => ?[l]:(arg1(l)=d & like(l) & present(l) & arg2(l)=c)))
#  ![c]:(U(0,c) & cat(c) => ?[d]:(U(1,d) & dog(d) & ?[l]:(arg1(l)=d & like(l) & present(l) & arg2(l)=c)))
#
#  "a dog is liked by every cat"
#  ?[d]:(U(0,d) & dog(d) & ![c]:(U(1,c) & cat(c) => ?[l]:(arg1(l)=d & inverse(like)(l) & present(l) & arg2(l)=c)))
#  ![c]:(U(0,c) & cat(c) => ?[d]:(U(1,d) & dog(d) & ?[l]:(arg1(l)=d & inverse(like)(l) & present(l) & arg2(l)=c)))
# where we can have an axiom like:
#    ![e,t,x,y]:((inverse(t)(e) & arg1(e)=x & arg2(e)=y) = (t(e) & arg1(e)=y & arg2(e)=x))
# In fact, the passive voice is always realized in semantics using the
# `inverse` function.
#
#  "Noah entertained and was reviewed"
#  ?[e]:(arg1(e)=noah & entertain(e) & past(e)) & ?[r]:(arg1(r)=noah & inverse(review)(r) & past(r))
# NOTE: We originally labeled this sentence with the following logical form:
#  ?[X]:(?[e]:(entertain(e) & past(e) & ?[r]:(inverse(review)(r) & past(r) & X=^[x]:(x=e | x=r))) & ^[x]:(X(x) => arg1(x)=noah))
# However, putting events into sets is problematic if one of the events is
# itself a set of events. See the later example "she made a big cake, and hung
# up some balloons".
#
#  "not every cat is a tabby"
#  "not all cats are tabbies"
#  ~![c]:(U(0,c) & cat(c) => ?[t]:(arg1(t)=c & type(t) & present(t) & arg2(t)=tabby))
#
#  "every cat isn't a tabby"
#  "all cats aren't tabbies"
#  ~![c]:(U(0,c) & cat(c) => ?[t]:(arg1(t)=c & type(t) & present(t) & arg2(t)=tabby))
#  ![c]:(U(0,c) & cat(c) => ~?[t]:(arg1(t)=c & type(t) & present(t) & arg2(t)=tabby))
#
#  "a cat and dog are sleeping"
#  ?[X]:(?[c]:(U(0,c) & cat(c) & ?[d]:(U(1,d) & dog(d) & X=^[x]:(x=c | x=d))) & ![x]:(X(x) => ?[s]:(arg1(s)=x & sleep(s) & present(s))))
#
#  "4 cats, 2 dogs, and a bird are sleeping"
#  ?[X]:(?[C]:(subset(C,^[x]:(U(0,x) & cat(x))) & size(C)=4 & ?[D]:(subset(D,^[x]:(U(1,x) & dog(x))) & size(D)=2 & ?[b]:(U(2,b) & bird(b) & X=^[x]:(x=C | x=D | x=^[y]:y=b)))) & ![Y]:(X(Y) => ![x]:(Y(x) => ?[s]:(arg1(s)=x & sleep(s) & present(s)))))
#
#  "a man and his dog were walking in the park"
#  ?[X]:(?[m]:(U(0,m) & man(m) & ?[h]:(U(1,h) & male_ref(0,h) & ?[d]:(U(2,d) & dog(d) & ?[o]:(arg1(o)=h & own(o) & arg2(o)=d) & X=^[x]:(x=m | x=d)))) & ![x]:(X(x) => ?[w]:(arg1(w)=x & walk(w) & past_progressive(w) & ?[p]:(U(3,p) & park(p) & arg2(w)=p))))
# where `male_ref` is defined in the pragmatics model. We could supervise the
# pragmatics model by specifying that h and m refer to the same object. We
# similarly define `female_ref` for grammatically female anaphora and `ref` for
# anaphora whose grammatical gender is either neutral or unspecified. The first
# argument of `male_ref` is an index parameter so that multiple uses of "he" in
# the same sentence can potentially refer to different objects (just as the
# first argument of `U`).
#
#  "10 girls and boys are in class"
#  ?[X]:(?[G]:(G=^[x]:(U(0,x) & girl(x)) & ?[B]:(B=^[x]:(U(1,x) & boy(x)) & X=^[x]:(x=G | x=B))) & ![Y]:(X(Y) => size(Y)=10) & ![Y]:(X(Y) => ![x]:(Y(x) => ?[p]:(arg1(p)=x & position(p) & ?[c]:(U(2,c) & class(c) & arg2(p)=c)))))
#  ?[X]:(?[G]:(G=^[x]:(U(0,x) & girl(x)) & ?[B]:(B=^[x]:(U(1,x) & boy(x)) & X=^[x]:(x=G | x=B))) & sum(X,^[Y]:size(Y))=10 & ![Y]:(X(Y) => ![x]:(Y(x) => ?[p]:(arg1(p)=x & position(p) & present(p) & ?[c]:(U(2,c) & class(c) & arg2(p)=c)))))
#
#  "a cat is not currently but will be in the room"
#  ?[c]:(U(0,c) & cat(c) & ?[r]:(U(1,r) & room(r) & ?[l]:(arg1(l)=c & located(l) & present(l) & arg2(l)=r & ?[c]:(currently(c) & arg1(c)=l)) & ?[l]:(arg1(l)=c & located(l) & future(l) & arg2(l)=r)))
#
#  "Jane is the only doctor"
#  ?[o]:(arg1(o)=jane & only(o) & present(o) & arg2(o)=^[x]:(U(0,x) & doctor(x)))
#    [or maybe we should do]
#  ?[o]:(arg1(o)=jane & only(o) & present(o) & ?[D]:(D=^[x]:(U(1,x) & doctor(x)) & arg2(o)=D))
#
#  "i did not get much money"
#  ?[m]:(U(0,m) & money(m) & ?[l]:(large_amount(l) & arg1(l)=m) & ~?[r]:(arg1(r)=me & receive(r) & past(r) & arg2(r)=m))
#
#  "i did not get very much money"
#  ?[m]:(U(0,m) & money(m) & ?[l]:(very(large_amount)(l) & arg1(l)=m) & ~?[r]:(arg1(r)=me & receive(r) & past(r) & arg2(r)=m))
#    [OR]
#  ?[m]:(U(0,m) & money(m) & ?[l]:(?[v]:(very(v) & arg1(v)=l) & large_amount(l) & arg1(l)=m) & ~?[r]:(arg1(r)=me & receive(r) & past(r) & arg2(r)=m))
#
#  "i don't like Ralph's destroying the barn"
#  "i don't like Ralph's destruction of the barn"
#  ?[d]:(arg1(d)=ralph & destroy(d) & progressive(d) & ?[b]:(U(0,b) & barn(b) & arg2(d)=b) & ~?[l]:(arg1(l)=me & like(l) & present(l) & arg2(l)=d))
# NOTE: We could require constant arguments (e.g. `ralph` and `me`) to be part
# of U in the discourse model.
#
#  "i don't like the destruction of the barns by the teenagers"
#  ![x]:(U(0,x) & teenager(x) => ![y]:(U(1,y) & barn(y) => ?[d]:(arg1(d)=x & destroy(d) & arg2(d)=y & ~?[l]:(like(l) & arg2(l)=d & arg1(l)=me))))
#    [OR]
#  ?[X]:(X=^[x]:(U(0,x) & teenager(x)) & ?[Y]:(Y=^[y]:(U(1,y) & barn(y)) & ![x]:(X(x) => ![y]:(Y(y) => ?[d]:(arg1(d)=x & destroy(d) & arg2(d)=y & ~?[l]:(arg1(l)=me & like(l) & arg2(l)=d))))))
#
#  "the cat's purring is soothing"
#  ?[p]:(?[c]:(U(0,c) & cat(c) & arg1(p)=c) & purr(p) & progressive(p) & ?[s]:(arg1(s)=p & sooth(s) & progressive(s)))
#
#  "Joan's pen is good"
#  ?[p]:(U(0,p) & pen(p) & ?[o]:(arg1(o)=joan & own(o) & arg2(o)=p) & ?[g]:(arg1(g)=p & good(g) & present(g)))
#
#  "Joan's pens are good"
#  ![x]:(U(0,x) & pen(x) & ?[o]:(arg1(o)=joan & own(o) & arg2(o)=x) => ?[g]:(arg1(g)=x & good(g) & present(g)))
#    [OR]
#  ?[X]:(X=^[p]:(U(0,p) & pen(p) & ?[o]:(arg1(o)=joan & own(o) & arg2(o)=p)) & ![x]:(X(x) => ?[g]:(arg1(g)=x & good(g) & present(g))))
#
#  "the students' pens are good"
#  ?[X]:(?[Y]:(Y=^[y]:(U(0,y) & student(y)) & X=^[x]:(U(1,x) & pen(x) & ?[y]:(Y(y) & ?[o]:(own(o) & arg2(o)=x & arg1(o)=y)))) & ![x]:(X(x) => ?[g]:(arg1(g)=x & good(g) & present(g))))
#
#  "i saw the trees by all the cats"
#  ?[X]:(X=^[x]:(U(0,x) & cat(x)) & ?[Y]:(Y=^[y]:(U(1,y) & tree(y) & ![x]:(X(x) => ?[n]:(near(n) & arg2(n)=y & arg1(n)=x))) & ![y]:(Y(y) => ?[s]:(arg1(s)=me & see(s) & past(s) & arg2(s)=y))))
#    [OR]
#  ![y]:(U(0,y) & tree(y) & ![x]:(U(1,x) & cat(x) => ?[n]:(near(n) & arg2(n)=y & arg1(n)=x)) => ?[s]:(arg1(s)=me & see(s) & past(s) & arg2(s)=y))
#
#  "he works a lot to earn money for school"
#  ?[h]:(U(0,h) & male_ref(0,h) & ?[w]:(arg1(w)=h & work(w) & present(w) & ?[l]:(large_duration(l) & arg1(l)=w) & ?[p]:(purpose(p) & ?[e]:(earn(e) & ?[m]:(U(1,m) & money(m) & arg2(e)=m) & arg2(p)=e) & arg1(p)=w)))
#
#  "the ladder collapsed because it was old"
#  ?[l]:(U(0,l) & ladder(l) & ?[c]:(arg1(c)=l & collapse(c) & past(c) & ?[r]:(reason(r) & ?[i]:(U(0,i) & ref(0,i) & ?[o]:(old(o) & past(o) & arg1(o)=i & arg2(r)=o)) & arg1(r)=c)))
#
#  "Mr. Bibby wrote the letter with a pencil"
#  ?[p]:(U(0,p) & pencil(p) & ?[l]:(U(1,l) & letter(l) & ?[w]:(arg1(x)=w & write(w) & arg2(w)=l & arg1(w)=bibby & ?[x]:(with(x) & arg2(x)=p))))
#
#  "the students wrote the letters with the pencils"
#  ?[S]:(S=^[s]:(U(0,s) & student(s)) & ?[L]:(L=^[l]:(U(1,l) & letter(l)) & ?[P]:(P=^[p]:(U(2,p) & pencil(p)) & !W[s,l,p]:(S(s) & L(l) & P(p) => ?[w]:(arg1(w)=s & wrote(w) & past(w) & arg2(w)=l & ?[x]:(with(x) & arg2(x)=p & arg1(x)=w))))))
#
#  "she sat on the table"
#  ?[x]:(U(0,x) & female_ref(0,x) & ?[s]:(arg1(s)=x & sit(s) & past(s) & ?[o]:(on_top_of(o) & ?[t]:(U(1,t) & table(t) & arg2(o)=t) & arg1(o)=s)))
#
#  "the birds hear each other"
#  ?[X]:(X=^[x]:(U(0,x) & bird(x)) & ![x,y]:(X(x) & Y(x) & ~(x=y) => ?[h]:(arg1(h)=x & hear(h) & arg2(h)=y)))
#
#  "some relative of each villager and some relative of each townsman hate each other"
#  ?[a]:(U(0,a) & ![x]:(U(1,x) & villager(x) => ?[r]:(related_to(r) & arg2(r)=x & arg1(r)=a)) & ?[b]:(U(2,b) & ![x]:(U(3,x) & townsman(x) => ?[r]:(related_to(r) & arg2(r)=x & arg1(r)=b)) & ?[X]:(X=^[x]:(x=a | x=b) & ![x,y]:(X(x) & Y(x) & ~(x=y) => ?[h]:(arg1(h)=x & hate(h) & arg2(h)=y)))))
#
#  "in either case, i am going"
#  ?[X]:(subset(X,^[x]:(U(0,x) & case(x))) & size(X)=2 & ![x]:(X(x) => (true(x) => ?[g]:(arg1(g)=me & go(g) & progressive(g)))))
#
#  "if it rains, the grass will be wet"
#  "the grass, if it rains, will be wet"
#  ?[i]:(U(0,i) & ref(0,i) & ?[r]:(rain(r) & present(r) & arg1(r)=i)) => ?[g]:(U(1,g) & grass(g) & ?[w]:(wet(w) & future(w) & arg1(w)=g))
#
#  "he ran with difficulty"
#  ?[h]:(U(0,h) & male_ref(0,h) & ?[r]:(arg1(r)=h & run(r) & past(r) & ?[d]:(difficult(d) & arg1(d)=r)))
#
#  "he stood in silence"
#  ?[h]:(U(0,h) & male_ref(0,h) & ?[s]:(arg1(s)=h & stand(s) & past(s) & ?[x]:(silently(x) & arg1(x)=s)))
# where we could define ![x]:(silently(x) = ?[s]:(is_silent(s) & arg1(s)=arg1(x) & ![t]:(time(x)(t) => time(s)(t))))
#
#  "she helped me with my homework"
#  ?[s]:(U(0,s) & female_ref(0,s) & ?[h]:(arg1(h)=s & help(h) & past(h) & arg2(h)=me & ?[o]:(own(o) & arg2(o)=x & arg1(o)=me) & ?[w]:(with(w) & ?[x]:(U(1,x) & homework(x) & arg2(w)=x & arg1(w)=h))))
#
#  "he stayed for two weeks"
#  ?[h]:(U(0,h) & male_ref(0,h) & ?[s]:(arg1(s)=h & stay(s) & past(s) & ?[d]:(duration(d) & arg2(d)=(2*week) & arg1(d)=s)))
#
#  "it is under the bush"
#  ?[i]:(U(0,i) & ref(0,i) & ?[u]:(arg1(u)=i & is_under(u) & present(u) & ?[b]:(U(1,b) & bush(b) & arg2(u)=b)))
#
#  "the party is at seven o'clock"
#  ?[p]:(U(0,p) & party(p) & ?[s]:(arg1(s)=p & start_time(s) & present(s) & arg2(s)=(7:00pm)))
# where we could define ![x,t]:((start_time(x)=t) = ![s]:(time(x)(s) => t<=s)),
# or perhaps `start_time` and `end_time` should be the elementary event time
# predicates rather than `time`.
# TODO: how do we represent date/time constants?
#
#  "she will leave after she has had breakfast"
#  ?[s]:(U(0,s) & female_ref(0,s) & ?[l]:(arg1(l)=s & leave(l) & future(l) & ?[a]:(arg1(a)=l & after(a) & ?[r]:(U(1,r) & female_ref(1,r) & ?[e]:(eat(e) & ?[b]:(U(2,b) & breakfast(b) & arg2(e)=b) & arg1(e)=r & arg2(a)=e)))))
# where we could define ![a,x,y]:((after(a) & arg1(a)=x & arg2(a)=y) = ~?[s,t]:(time(x)(s) & time(y)(t) & s<t))
#
#  "the ball rotated quickly and heated up slowly"
#  ?[b]:(U(0,b) & ball(b) & ?[r]:(arg1(r)=b & rotate(r) & past(r) & ?[q]:(quickly(q) & arg1(q)=r)) & ?[h]:(arg1(h)=b & heat_up(h) & past(h) & ?[s]:(slowly(s) & arg1(s)=h)))
# NOTE: We originally labeled this sentence with the following logical form:
#  ?[b]:(U(0,b) & ball(b) & ?[r]:(rotate(r) & past(r) & ?[q]:(quickly(q) & arg1(q)=r) & ?[h]:(heat_up(h) & past(h) & ?[s]:(slowly(s) & arg1(s)=h) & ?[X]:(X=^[x]:(x=r | x=h) & ![x]:(X(x) => arg1(x)=b)))))
# However, putting events into sets is problematic if one of the events is
# itself a set of events. See the later example "she made a big cake, and hung
# up some balloons".
#
#  "the ball rotated and heated up slowly"
#  ?[b]:(U(0,b) & ball(b) & ?[r]:(arg1(r)=b & rotate(r) & past(r) & ?[s]:(slowly(s) & arg1(s)=r)) & ?[h]:(arg1(h)=b & heat_up(h) & past(h) & ?[s]:(slowly(s) & arg1(s)=h)))
# NOTE: We originally labeled this sentence with the following logical form:
#  ?[b]:(U(0,b) & ball(b) & ?[r]:(rotate(r) & past(r) & ?[h]:(heat_up(h) & past(h) & ?[X]:(X=^[x]:(x=r | x=h) & ![x]:(X(x) => ?[s]:(slowly(s) & arg1(s)=x) & arg1(x)=b)))))
# However, putting events into sets is problematic if one of the events is
# itself a set of events. See the later example "she made a big cake, and hung
# up some balloons".
#
#  "slowly, the ball rotated and heated up"
#  ?[b]:(U(0,b) & ball(b) & ?[r]:(arg1(r)=b & rotate(r) & past(r) & ?[s]:(slowly(s) & arg1(s)=r)) & ?[h]:(?[s]:(slowly(s) & arg1(s)=h) & arg1(h)=b & heat_up(h) & past(h)))
#
#  "Emma and Noah met"
#  ?[X]:(X=^[x]:(x=emma | x=noah) & ?[m]:(arg1(m)=X & collective_meet(m) & past(m)))
#
#  "Emma and Noah lifted the stone"
#  ?[X]:(X=^[x]:(x=emma | x=noah) & ?[s]:(U(0,s) & stone(s) & ?[l]:(lift(l) & past(l) & arg2(l)=s & arg1(l)=X)))
# Here, "Emma and Noah" has a *collective* interpretation, which also occurs in
# many other sentences in English.
#
#  "i think there is a unicorn"
#  ?[t]:(arg1(t)=me & think(t) & present(t) & arg2(t)=possibility(?[e]:(exists(e) & present(e) & ?[u]:(U(0,u) & unicorn(u) & arg1(e)=u))))
# This is why we need the `true` predicate, since it provides a uniform way to
# handle modality, and to talk about objects and events that may not actually
# exist or be true, but may exist as thoughts or suppositions (the Platonic
# universe). All events have the property that if they are true, then all of
# its arguments are true, with a handful of specified exceptions, including
# `think`, `capable_of`, `want`, `purpose`, etc.
#
#  "i can swim"
#  "i am capable of swimming"
#  ?[c]:(arg1(c)=me & capable_of(c) & present(c) & arg2(c)=possibility(?[s]:(arg1(s)=me & swim(s))))
#
#  "i could swim"
#  "i was capable of swimming"
#  ?[c]:(arg1(c)=me & capable_of(c) & past(c) & arg2(c)=possibility(?[s]:(arg1(s)=me & swim(s))))
#
#  "she made a big cake, and hung up some balloons"
#  {?[s]:(U(0,s) & female_ref(0,s) & ?[B]:(subset(B,^[b]:(U(2,b) & balloon(b))) & ?[m]:(arg1(m)=s & make(m) & past(m) & ?[c]:(U(1,c) & cake(c) & ?[b]:(is_big(b) & arg1(b)=c) & arg2(m)=c)) & ![b]:(B(b) => ?[h]:(arg1(h)=s & hang(h) & past(h) & arg2(h)=b))))}
#
#  "the doctor watched everyone sleep"
#  {?[d]:(U(0,d) & doctor(d) & ?[X]:(X=^[x]:(U(1,x) & person/animate(x)) & ![x]:(X(x) => ?[w]:(arg1(w)=d & watch(w) & past(w) & arg2(w)=x))))}
# NOTE: We model pragmatic domain restriction implicitly. In this example,
# `^[x]:U(0,x)` contains the doctor but `^[x]:U(1,x)` contains everyone being
# monitored by the doctor but does not contain the doctor.
#
#  "John can play the guitar, and Mary, the violin"
#  {?[c]:(arg1(c)=john & capable_of(c) & present(c) & ?[p]:(arg1(c)=john & play(p) & ?[g]:(U(0,g) & guitar(g) & arg2(p)=g) & arg2(c)=p)) & ?[e]:(arg1(e)=mary & empty_ref(0,e) & ?[v]:(U(1,v) & violin(v) & arg2(e)=v))}
#
#  "John can play his guitar. Mary, too"
#  {?[c]:(arg1(c)=john & capable_of(c) & present(c) & ?[p]:(arg1(c)=john & play(p) & ?[g]:(U(0,g) & guitar(g) & arg2(p)=g) & arg2(c)=p)) & ?[e]:(arg1(e)=mary & empty_ref(0,e) & too(e))}
#
#  "she walked and sat under every tree and near every rock"
#  {?[s]:(U(0,s) & female_ref(s) & ?[T]:(T=^[x]:(U(1,x) & tree(x)) & ?[R]:(R=^[y]:(U(2,y) & rock(y)) & ![x]:(T(x) => ![y]:(R(y) => ?[w]:(arg1(w)=s & walk(w) & past(w) & ?[u]:(under(u) & arg1(u)=w & arg2(u)=x) & ?[n]:(near(n) & arg1(n)=w & arg2(n)=y)) & ?[a]:(arg1(a)=s & sit(a) & past(a) & ?[u]:(under(u) & arg1(u)=a & arg2(u)=x) & ?[n]:(near(n) & arg1(n)=a & arg2(n)=y)))))))}
#
#  "John wants and is able to swim and dance"
#  "John wants to and is able to swim and dance"
#  {?[s]:(swim(s) & ?[d]:(dance(d) & ?[X]:(X=^[x]:(x=s | x=d) & ![x]:(X(x) => ?[w]:(arg1(w)=john & want(w) & present(w) & arg2(w)=x) & ?[c]:(arg1(c)=john & capable_of(c) & present(c) & arg2(c)=x)))))}
#
#  "the house is Kim's"
#  {?[h]:(U(0,h) & house(h) & ?[o]:(arg1(o)=h & inverse(own)(o) & present(o) & arg2(o)=kim))}
#
#  "the pencils are the students'"
#  {?[X]:(X=^[x]:(U(0,x) & pencil(x)) & ?[Y]:(Y=^[y]:(Y(1,y) & student(y)) & ![x,y]:(X(x) & Y(y) => ?[o]:(arg1(o)=x & inverse(own)(o) & present(o) & arg2(o)=y))))}
#
#  "flower seller has carnations"
#  {?[C]:(subset(C,^[x]:(U(0,x) & carnation(x))) & ?[x]:(?[s]:(?[f]:(U(1,f) & flower(f) & arg2(s)=f) sell(s) & arg1(s)=x) & U(2,x) & ![c]:(C(c) => ?[o]:(arg1(o)=x & own(o) & present(o) & arg2(o)=c))))}
#
#  "Sirius is brighter"
#  {?[g]:(arg1(g)=sirius & greater(brightness)(g) & present(g))}
#
#  "Sirius is brighter than Vega"
#  {?[g]:(arg1(g)=sirius & greater(brightness)(g) & present(g) & arg2(g)=vega)}
# where we can add an axiom such as ![x,y,f]:(?[g]:(greater(f)(g) & arg1(g)=x & arg2(g)=y) & ~is_real_number(y) & ?[b]:(f(b) & arg1(b)=y) = ?[g]:(greater(f)(g) & arg1(g)=x & ?[b]:(brightness(b) & arg1(b)=y & arg2(g)=arg2(b))))
# as well as equivalent axioms for things like height, shortness, size, length, etc.
#
#  "i see a brighter star than Vega"
#  "i see a star brighter than Vega"
#  {?[s]:(arg1(s)=me & see(s) & present(s) & ?[x]:(U(0,x) & star(x) & ?[g]:(greater(brightness)(g) & arg1(g)=x & arg2(g)=vega) & arg2(s)=x))}
#
#  "Sirius is brighter than we thought"
#  ?[X]:(X=us & ![x]:(X(x) => ?[g]:(arg1(g)=sirius & greater(brightness)(g) & ?[t]:(arg1(t)=x & think(t) & past(t) & arg2(t)=arg2(g)))))
#
#  "Sirius is the brightest star"
#  {?[s]:(arg1(s)=sirius & same(s) & present(s) & ?[X]:(X=^[x]:(U(0,x) & star(x)) & ?[g]:(greatest(brightness)(g) & arg2(s)=arg1(g) & arg2(g)=X)))}
#
#  "Sirius is the brightest"
#  {?[s]:(arg1(s)=sirius & same(s) & present(s) & ?[g]:(greatest(brightness)(g) & arg2(s)=arg1(g)))}
#
#  "John swam extremely quickly"
#  {?[s]:(arg1(s)=john & swim(s) & past(s) & ?[q]:(?[e]:(extreme(e) & arg1(e)=q) & quick(q) & arg1(q)=s))}
#
#  "John arrived 10 minutes late"
#  {?[a]:(arg1(s)=john & arrive(a) & past(a) & ?[l]:(arg2(l)=(10*minute) & late(l) & arg1(l)=a))}


# This is the root nonterminal for declarative sentences.
S nonterminal {} {1.0} {1.0} {} 10 1.0 {}
S -> S':singular
S -> S':plural

# S {... & (~)?[y1]:(f(y1) & g(y1)) & ... & (~)?[yn]:(f(yn) & g(yn))}
#  -> ADVP_R {... & f'}
#     (COMMA)
#     S {... & (~)?[y1]:g(y1) & ... & (~)?[yn]:g(yn)}
# where f(y) = (~)?[z]:(h(z) & arg2(z)=y) and f' = (~)?[z]:h(z)
#    or f(y) = (~)?[z1]:(h1(z1) & arg2(z1)=y) & ... & (~)?[zn]:(hn(zn) & arg2(zn)=y) and f' = (~)?[z1]:h1(z1) & ... & (~)?[zn]:hn(zn)
#    or f(y) = (~)?[z1]:(h1(z1) & arg2(z1)=y) | ... | (~)?[zn]:(hn(zn) & arg2(zn)=y) and f' = (~)?[z1]:h1(z1) | ... | (~)?[zn]:hn(zn)
S -> ADVP_R:try_remove_comma,try_remove_nullable_subject COMMA S:try_remove_comma
S -> ADVP_R:try_remove_comma,try_remove_nullable_subject S:try_remove_comma

# S {?[X]:(h(X) & ![x]:(X(x) => (true(x) => g(x))))}
#  -> PP {^[P]:?[X]:(h(X) & ![x]:(X(x) => (true(x) => P(x))))}
#     (COMMA)
#     S {g(x)}
# S {... & (~)?[y1]:(f(y1) & g(y1)) & ... & (~)?[yn]:(f(yn) & g(yn))}
#  -> PP {^[P]:(... & f')}
#     (COMMA)
#     S {... & (~)?[y1]:g(y1) & ... & (~)?[yn]:g(yn)}
# S {... & ![x]:(h(x) => (~)?[y1]:(f(y1,x) & g(y1)) & ... & (~)?[yn]:(f(yn,x) & g(yn)))}
#  -> PP {^[P]:(... & ![x]:(h(x) => f'(x)))}
#     (COMMA)
#     S {... & (~)?[y1]:g(y1) & ... & (~)?[yn]:g(yn)}
# where f(y) = (~)?[z]:(h(z) & arg2(z)=y) and f' = (~)?[z]:(h(z) & P(z))
#    or f(y) = (~)?[z1]:(h1(z1) & arg2(z1)=y) & ... & (~)?[zn]:(hn(zn) & arg2(zn)=y) and f' = (~)?[z1]:(h1(z1) & P(z1)) & ... & (~)?[zn]:(hn(zn) & P(zn))
#    or f(y) = (~)?[z1]:(h1(z1) & arg2(z1)=y) | ... | (~)?[zn]:(hn(zn) & arg2(zn)=y) and f' = (~)?[z1]:(h1(z1) & P(z1)) | ... | (~)?[zn]:(hn(zn) & P(zn))
S -> PP:try_remove_comma,try_remove_nullable_subject S:try_remove_comma
S -> PP:try_remove_comma,try_remove_nullable_subject COMMA S:try_remove_comma

# S {... & (~)?[y1]:(f(y1) & p(y1) & f1(y1)) & ... & (~)?[yn]:(f(yn) & p(yn) & fn(yn))}
#  -> ADJP_R/PP {^[P]:(... & ?[y]:(p(y) & f(y) & P(y)))}
#     S' {... & (~)?[y1]:(p(y1) & f1(y1)) & ... & (~)?[yn]:(p(yn) & fn(yn))}
# where f(y) = (~)?[z]:(h(z) & arg2(z)=y)
#    or f(y) = (~)?[z1]:(h1(z1) & arg2(z1)=y) & ... & (~)?[zn]:(hn(zn) & arg2(zn)=y)
#    or f(y) = (~)?[z1]:(h1(z1) & arg2(z1)=y) | ... | (~)?[zn]:(hn(zn) & arg2(zn)=y)
# This rule removes the predicate `p` from the event corresponding to the verb
# (and so the verb is semantically empty) such as in "flawed was the argument"
# and "in the tree was the cat". (called preposing)
S -> PP:try_remove_comma,try_remove_nullable_subject S':try_remove_comma,add_nullable_subject
S -> ADJP_R:try_remove_comma,try_remove_nullable_subject S':try_remove_comma,add_nullable_subject

# S {?[X]:(f(X) & ![x]:(X(x) => (true(x) => g(x))))}
#  -> S {g(x)}
#     (COMMA)
#     PP {?[X]:(f(X) & ![x]:(X(x) => (true(x) => P(x))))}
# NOTE: We don't allow other adjuncts here to avoid the spurious ambiguity
# where the PP could also attach at VP.
S -> S:try_remove_comma PP:try_remove_comma,try_remove_nullable_subject
S -> S:try_remove_comma COMMA PP:try_remove_comma,try_remove_nullable_subject

# S {A => B} -> IF S {A} (COMMA) (THEN) S {B}
S -> IF S:try_remove_comma S:try_remove_comma
S -> IF S:try_remove_comma COMMA S:try_remove_comma
S -> IF S:try_remove_comma THEN S:try_remove_comma
S -> IF S:try_remove_comma COMMA THEN S:try_remove_comma

# S {A => B} -> S {B} (COMMA) IF S {A}
S -> S:try_remove_comma IF S:try_remove_comma
S -> S:try_remove_comma COMMA IF S:try_remove_comma

# S {A1 & ... & An} -> S {A1} COMMA S {A2 & ... & An}
# S {A1 | ... | An} -> S {A1} COMMA S {A2 | ... | An}
# S {~A1 & ... & ~An} -> S {~A1} COMMA S {~A2 & ... & ~An}
# In the NOR rule, the negation can appear in front of the scope ?[y], or in
# front of any parent scope.
S -> S:try_remove_comma COMMA S:add_comma

# S {A1 & A2} -> S {A1} (COMMA) AND S {A2}
S -> S:try_remove_comma COMMA AND S:try_remove_comma
S -> S:try_remove_comma AND S:try_remove_comma

# S {A1 | A2} -> S {A1} (COMMA) OR S {A2}
S -> S:try_remove_comma COMMA OR S:try_remove_comma
S -> S:try_remove_comma OR S:try_remove_comma

# S {A1 | A2} -> S {A1} (COMMA) NOR S {A2}
S -> S:try_remove_comma COMMA NOR VP_R:add_req_aux,try_remove_comma
S -> S:try_remove_comma NOR VP_R:add_req_aux,try_remove_comma

# S {... & ?[y1]:(g1(y1) & ?[r]:(arg1(r)=y1 & reason(r) & ?[z]:(h(z) & arg2(r)=z))) & ... & ?[yn]:(gn(yn) & ?[r]:(arg1(r)=yn & reason(r) & ?[z]:(h(z) & arg2(r)=z)))}
#  -> S {... & ?[y1]:g1(y1) & ... & ?[yn]:gn(yn)}
#     (COMMA) BECAUSE/FOR S {f(...)}
S -> S:try_remove_comma COMMA BECAUSE S:try_remove_comma
S -> S:try_remove_comma BECAUSE S:try_remove_comma
S -> S:try_remove_comma COMMA FOR S:try_remove_comma
S -> S:try_remove_comma FOR S:try_remove_comma

# S {... & ?[y1]:(?[r]:(arg1(r)=y1 & reason(r) & ?[z]:(h(z) & arg2(r)=z)) & g1(y1)) & ... & ?[yn]:(?[r]:(arg1(r)=yn & reason(r) & ?[z]:(h(z) & arg2(r)=z)) & gn(yn))}
#  -> BECAUSE/FOR S {?[z]:h(z)}
#     (COMMA) S {?[y1]:g1(y1) & ... & ?[yn]:gn(yn)}
S -> BECAUSE S:try_remove_comma COMMA S:try_remove_comma
S -> BECAUSE S:try_remove_comma S:try_remove_comma
S -> FOR S:try_remove_comma COMMA S:try_remove_comma
S -> FOR S:try_remove_comma S:try_remove_comma


S' nonterminal {has_not} {1.0, 1.0} {1.0, 1.0} {} 10 1.0 {}

# S' {(~)?[x]:f(x)} -> THERE IS DP {^[P]:?[X]:(X=^[x]:f(x) & (~)?[x]:(X(x) & P(x)))}
# NOTE: This above rule is only really useful if we choose to represent "there
# is a cat" as something like ?[x]:(U(0,x) & cat(x)).
S' -> THERE IS DP:try_remove_nullable_subject

# S' {... & (~)?[y1]:(... & arg1(y1)=a & ...) & ... & (~)?[yn]:(... & arg1(yn)=a & ...}
#  -> DP {^[P]:?[X]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x)))}
#     VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
# S' {... & (~)?[x]:(f(x) & (~)?[y1]:(... & arg1(y1)=x & ...) & ... & (~)?[yn]:(... & arg1(yn)=x & ...))} if x is not a set variable
#  -> DP {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)?[x]:(X(x) & P(x))))}
#     VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
# S' {... & (~)![x]:(f(x) => ... & (~)?[y1]:(... & arg1(y1)=x & ...) & ... & (~)?[yn]:(... & arg1(yn)=x & ...))}
#  -> DP {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)![x]:(X(x) => P(x))))}
#     VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
# S' {... & ?[X]:(f(X) & (~)![x]:(X(x) => ... & (~)?[y1]:(... & arg1(y1)=x & ...) & ... & (~)?[yn]:(... & arg1(yn)=x & ...)))}
#  -> DP {^[P]:(... & ?[X]:(f(X) & (~)![x]:(X(x) => P(x))))}
#     VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
# S' {... & ?[X]:(f(X) & (~)?[y1]:(... & arg1(y1)=X & ...) & ... & (~)?[yn]:(... & arg1(yn)=X & ...))} if X is a set variable
#  -> DP {^[P]:(... & ?[X]:(f(X) & ![x]:(X(x) => P(x))))}
#     VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
# NOTE: The above three rules, during the inverse transformation, the scope of
# X and x can be positioned anywhere above the scope of y. However, to avoid
# producing semantically-equivalent logical forms, for each equivalence class
# of semantically-equivalent inverse logical forms, we only output a single
# logical form (for example, by choosing the logical form in the equivalence
# class in which the scope of X and x are maximal). Also, the above rule can be
# extended to other kinds of quantification over X, such as existential or weak
# universal quantifier. Also, note that f(X) and f(x) cannot depend on any
# variables other than those declared within f(X) and f(x). But note that in
# the example "a cat and dog are sleeping", f(X) includes the definition for
# "cat" and "dog". In the above three rules, the scope of y is the right-most
# and top-most scope of an event variable (a object with arguments).
S' -> DP:try_remove_nullable_subject VP_R:try_remove_nullable_subject

# NOTE: The above note also applies to these rules.
# S' {... & ~?[x]:(f(x) & ?[y1]:(... & arg1(y1)=x & ...) & ... & ?[yn]:(... & arg1(yn)=x & ...))}
#  -> DP {^[P]:(... & ?[X]:(X=^[x]:f(x) & ?[x]:(X(x) & P(x))))}
#     VP_R {... & ~?[y1]:(...) & ... & ~?[yn]:(...)}
# S' {... & ~![x]:(f(x) => ... & ?[y1]:(... & arg1(y1)=x & ...) & ... & ?[yn]:(... & arg1(yn)=x & ...))}
#  -> DP {^[P]:(... & ?[X]:(X=^[x]:f(x) & ![x]:(X(x) => P(x))))}
#     VP_R {... & ~?[y1]:(...) & ... & ~?[yn]:(...)}
# S' {... & ?[X]:(f(X) & ~![x]:(X(x) => ... & ?[y1]:(... & arg1(y1)=x & ...) & ... & ?[yn]:(... & arg1(yn)=x & ...)))}
#  -> DP {^[P]:(... & ?[X]:(f(X) & ![x]:(X(x) => P(x))))}
#     VP_R {... & ~?[y1]:(...) & ... & ~?[yn]:(...)}
S' -> DP:try_remove_nullable_subject VP_R:try_remove_nullable_subject

S' -> VP_R:remove_nullable_subject


VP_R nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# VP_R {... & (~)?[y1]:(g1(y1) & f(y1)) & ... & (~)?[yn]:(gn(yn) & f(yn))}
#  -> VP_R {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
#     ADVP_R/PP {^[P]:(... & f')}
# where f(y) = (~)?[z]:(h(z) & arg1/arg2(z)=y) and f' = (~)?[z]:(h(z) & P(z))
#    or f(y) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=y) & ... & (~)?[zn]:(hn(zn) & arg1/arg2(zn)=y) and f' = (~)?[z1]:(h1(z1) & P(z1)) & ... & (~)?[zn]:(hn(zn) & P(zn))
#    or f(y) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=y) | ... | (~)?[zn]:(hn(zn) & arg1/arg2(zn)=y) and f' = (~)?[z1]:(h1(z1) & P(z1)) | ... | (~)?[zn]:(hn(zn) & P(zn))
# Note that f(y) may also contain variables which are universally-quantified,
# above the scope of zi, either within the scope of yi (e.g. "it flew faster
# than every bird") or above it ("i have been to every restaurant"). In this
# case, the universal quantifiers are also moved into f'.
# NOTE: This rule also works if the yi's are ORed.
#
# An example of a sentence with coordination in both the verb and adverb is:
#  "she walked and sat under every tree and near every rock"
VP_R -> VP_R:try_remove_comma PP:try_remove_comma # for arg1
VP_R -> VP_R:try_remove_comma ADVP_R:try_remove_comma # for arg1
VP_R -> VP_R:try_remove_comma COMMA PP:try_remove_comma # for arg1
VP_R -> VP_R:try_remove_comma COMMA ADVP_R:try_remove_comma # for arg1
VP_R -> VP_R:try_remove_comma PP:try_remove_comma # for arg2
VP_R -> VP_R:try_remove_comma ADVP_R:try_remove_comma # for arg2
VP_R -> VP_R:try_remove_comma COMMA PP:try_remove_comma # for arg2
VP_R -> VP_R:try_remove_comma COMMA ADVP_R:try_remove_comma # for arg2

# VP_R {... & (~)?[y1]:(p(y1) & f1(y1) & f(y1)) & ... & (~)?[yn]:(p(yn) & fn(yn) & f(yn))}
#  -> VP_R {... & (~)?[y1]:f1(y1) & ... & (~)?[yn]:fn(yn)}
#     ADJP_R/PP {^[P]:(... & ?[y]:(p(y) & f(y) & P(y)))}
# This rule removes the predicate `p` from the event corresponding to the verb
# (and so the verb is semantically empty) such as in "the cat is blue" and "the
# cat is in the tree". `fi` contains verb-specific terms such as `present` as
# well as any adjuncts of y whereas `f` contains everything else, such as the
# arguments.
VP_R -> VP_R:try_remove_comma PP:try_remove_comma
VP_R -> VP_R:try_remove_comma ADJP_R:try_remove_comma

# for prepositional verbs (i.e. "pay back", "look forward to", etc)
# VP_R {... & (~)?[y1]:(p(y1) & f1(y1) & f(y1)) & ... & (~)?[yn]:(p(yn) & fn(yn) & f(yn))}
#  -> VP_R {... & (~)?[y1]:(p(y1) & f1(y1)) & ... & (~)?[yn]:(p(yn) & fn(yn))}
#     PP {... & ?[y]:(p(y) & f(y))}
# where `p` is the predicate, `fi` contains verb-specific terms such as
# `present` as well as any adjuncts of y whereas `f` contains everything else,
# such as the arguments.
VP_R -> VP_R:try_remove_comma,add_preposition PP:try_remove_comma,add_preposition

# We need this rule for constructions like "she brought down the bed" and "she brought the bed down".
VP_R -> VP_R:try_remove_comma,add_particle PARTICLE_PLACEHOLDER

# VP_R {... & (~)?[y1]:(inverse(own)(y1) & arg2(y1)=a & ...) & ... & (~)?[yn]:(inverse(own)(yn) & arg2(yn)=a & ...}
#  -> VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
#     DP {^[P]:?[X]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x)))}
# VP_R {... & (~)?[x]:(f(x) & (~)?[y1]:(inverse(own)(y1) & arg2(y1)=x & ...) & ... & (~)?[yn]:(inverse(own)(yn) & arg2(yn)=x & ...))} if x is not a set variable
#  -> VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
#     DP {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)?[x]:(X(x) & P(x))))}
# VP_R {... & (~)![x]:(f(x) => ... & (~)?[y1]:(inverse(own)(y1) & arg2(y1)=x & ...) & ... & (~)?[yn]:(inverse(own)(yn) & arg2(yn)=x & ...))}
#  -> VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
#     DP {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)![x]:(X(x) => P(x))))}
# VP_R {... & ?[X]:(f(X) & (~)![x]:(X(x) => ... & (~)?[y1]:(inverse(own)(y1) & arg2(y1)=x & ...) & ... & (~)?[yn]:(inverse(own)(yn) & arg2(yn)=x & ...)))}
#  -> VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
#     DP {^[P]:(... & ?[X]:(f(X) & (~)![x]:(X(x) => P(x))))}
# VP_R {... & ?[X]:(f(X) & (~)?[y1]:(inverse(own)(y1) & arg2(y1)=X & ...) & ... & (~)?[yn]:(inverse(own)(yn) & arg2(yn)=X & ...))} if X is a set variable
#  -> VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
#     DP {^[P]:(... & ?[X]:(f(X) & ![x]:(X(x) => P(x))))}
# e.g. "the pencil is Emma's", "the pencils are the students'"
VP_R -> VP_R:try_remove_comma DP:add_genitive,singular,try_remove_comma
VP_R -> VP_R:try_remove_comma DP:add_genitive,plural,try_remove_comma

# VP_R {... & (~)?[y1]:(... & arg1/arg2/arg3(y1)=a & ...) & ... & (~)?[yn]:(... & arg1/arg2/arg3(yn)=a & ...)}
#  -> VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
#     DP/ADJP_R {^[P]:?[X]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x)))}
# VP_R {... & (~)?[x]:(f(x) & (~)?[y1]:(... & arg1/arg2/arg3(y1)=x & ...) & ... & (~)?[yn]:(... & arg1/arg2/arg3(yn)=x & ...))} if x is not a set variable
#  -> VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
#     DP/ADJP_R {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)?[x]:(X(x) & P(x))))}
# VP_R {... & (~)![x]:(f(x) => ... & (~)?[y1]:(... & arg1/arg2/arg3(y1)=x & ...) & ... & (~)?[yn]:(... & arg1/arg2/arg3(yn)=x & ...))}
#  -> VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
#     DP/ADJP_R {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)![x]:(X(x) => P(x))))}
# VP_R {... & ?[X]:(f(X) & (~)![x]:(X(x) => ... & (~)?[y1]:(... & arg1/arg2/arg3(y1)=x & ...) & ... & (~)?[yn]:(... & arg1/arg2/arg3(yn)=x & ...)))}
#  -> VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
#     DP/ADJP_R {^[P]:(... & ?[X]:(f(X) & (~)![x]:(X(x) => P(x))))}
# VP_R {... & ?[X]:(f(X) & (~)?[y1]:(... & arg1/arg2/arg3(y1)=X & ...) & ... & (~)?[yn]:(... & arg1/arg2/arg3(yn)=X & ...))} if X is a set variable
#  -> VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
#     DP/ADJP_R {^[P]:(... & ?[X]:(f(X) & ![x]:(X(x) => P(x))))}
# e.g. "it is not a cat nor is it a dog"
VP_R -> VP_R:try_remove_comma DP:try_remove_comma,require_no_inverse,remove_req_aux # for arg1 (subject-auxiliary inversion; e.g. "is it a boy?")
VP_R -> VP_R:try_remove_comma DP:try_remove_comma,require_no_inverse # for arg2
VP_R -> VP_R:try_remove_comma DP:try_remove_comma,require_no_inverse # for arg3 (NOTE: we could make this semantic and have only two args)
VP_R -> VP_R:try_remove_comma ADJP_R:try_remove_comma,require_no_inverse,remove_req_aux # for arg1 (subject-auxiliary inversion; e.g. "is he angry?")
VP_R -> VP_R:try_remove_comma ADJP_R:try_remove_comma,require_no_inverse # for arg2
VP_R -> VP_R:try_remove_comma ADJP_R:try_remove_comma,require_no_inverse # for arg3 (NOTE: we could make this semantic and have only two args)
VP_R -> VP_R:try_remove_comma BY DP:try_remove_comma,require_inverse # for arg2
VP_R -> VP_R:try_remove_comma BY DP:try_remove_comma,require_inverse # for arg3 (NOTE: we could make this semantic and have only two args)

# for gapping and stripping
# VP_R {... & (~)?[y]:(empty_ref(0,y) & f(y))}
#  -> ADVP_R/PP {... & f'}
# VP_R {... & ![x]:(h(x) => (~)?[y]:(empty_ref(0,y) & f(y,x)))}
#  -> ADVP_R/PP {... & ![x]:(h(x) => f'(x))}
# where f(y) = (~)?[z]:(h(z) & arg1/arg2(z)=y) and f' = (~)?[z]:h(z)
#    or f(y) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=y) & ... & (~)?[zn]:(hn(zn) & arg1/arg2(zn)=y) and f' = (~)?[z1]:h1(z1) & ... & (~)?[zn]:hn(zn)
#    or f(y) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=y) | ... | (~)?[zn]:(hn(zn) & arg1/arg2(zn)=y) and f' = (~)?[z1]:h1(z1) | ... | (~)?[zn]:hn(zn)
# Note that f(y) may also contain variables which are universally-quantified
# (above the scope of yi). In this case, the universal quantifiers are also
# moved into f'.
VP_R -> PP:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma # for arg1
VP_R -> ADVP_R:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma # for arg1
VP_R -> PP:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma # for arg2
VP_R -> ADVP_R:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma # for arg2

# for gapping and stripping
# VP_R {... & ?[y]:(empty_ref(y) & arg2/arg3(y)=a}
#  -> DP {^[P]:?[X]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x)))}
# VP_R {... & (~)?[x]:(f(x) & ?[y]:(empty_ref(y) & arg2/arg3(y)=x))} if x is not a set variable
#  -> DP {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)?[x]:(X(x) & P(x))))}
# VP_R {... & (~)![x]:(f(x) => ... & ?[y]:(empty_ref(y) & arg2/arg3(y)=x))}
#  -> DP {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)![x]:(X(x) => P(x))))}
# VP_R {... & ?[X]:(f(X) & (~)![x]:(X(x) => ... & ?[y]:(empty_ref(y) & arg2/arg3(y)=x)))}
#  -> DP {^[P]:(... & ?[X]:(f(X) & (~)![x]:(X(x) => P(x))))}
# VP_R {... & ?[X]:(f(X) & ?[y]:(empty_ref(y) & arg2/arg3(y)=X))} if X is a set variable
#  -> DP {^[P]:(... & ?[X]:(f(X) & ![x]:(X(x) => P(x))))}
VP_R -> DP:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma # for arg2
VP_R -> DP:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma # for arg3
VP_R -> BY DP:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_inverse,try_remove_comma # for arg2
VP_R -> BY DP:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_inverse,try_remove_comma # for arg3

# VP_R {A1 & ... & An} -> VP_R {A1} COMMA VP_R {A2 & ... & An}
# VP_R {A1 | ... | An} -> VP_R {A1} COMMA VP_R {A2 | ... | An}
VP_R -> VP_R:try_remove_comma COMMA VP_R:add_comma

# VP_R {A1 & A2} -> VP_R {A1} (COMMA) AND VP_R {A2}
VP_R -> VP_R:try_remove_comma COMMA AND VP_R:try_remove_comma
VP_R -> VP_R:try_remove_comma AND VP_R:try_remove_comma

# VP_R {A1 | A2} -> VP_R {A1} (COMMA) OR VP_R {A2}
VP_R -> VP_R:try_remove_comma COMMA OR VP_R:try_remove_comma
VP_R -> VP_R:try_remove_comma OR VP_R:try_remove_comma

# VP_R {~A1 & ~A2} -> VP_R {A1} (COMMA) NOR VP_R {A2}
VP_R -> VP_R:try_remove_comma COMMA NOR VP_R:try_remove_comma,add_req_aux
VP_R -> VP_R:try_remove_comma NOR VP_R:try_remove_comma,add_req_aux

# VP_R {... & (~)?[y1]:(g1(y1) & f(y1)) & ... & (~)?[yn]:(gn(yn) & f(yn))}
#  -> VP_R {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
#     S {... & f'}
# where f(y) = (~)?[z]:(h(z) & arg2(y)=z) and f' = (~)?[z]:h(z)
# VP_R {... & ?[X]:(X=^[x]:(x=z1 | ... | x=zm) & ... & ![x]:(X(x) => (~)?[y1]:(g1(y1) & arg2(y1)=x) & ... & (~)?[yn]:(gn(yn) & arg2(yn)=x)))}
#  -> VP_R {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
#     S {... & (?[z1]:(...) & ... & ?[zm]:(...))}
# VP_R {... & ?[X]:(X=^[x]:(x=z1 | ... | x=zm) & ... & ?[x]:(X(x) & (~)?[y1]:(g1(y1) & arg2(y1)=x) & ... & (~)?[yn]:(gn(yn) & arg2(yn)=x)))}
#  -> VP_R {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
#     S {... & (?[z1]:(...) | ... | ?[zm]:(...))}
# where f(y) = (~)?[z]:(h(z) & arg2(y)=z) and f' = (~)?[z]:h(z)
# NOTE: z could also be universally quantified above the scope of yi
VP_R -> VP_R:try_remove_comma S:try_remove_comma,add_to_infinitive,add_nullable_subject
VP_R -> VP_R:try_remove_comma S:try_remove_comma,add_infinitive,add_nullable_subject
# e.g. "i think Emma returned the books yesterday"
VP_R -> VP_R:try_remove_comma S:try_remove_comma # TODO: remove grammatical features from S

# TODO: we could require that here are no additional right adjuncts in the head scope
VP_R -> VP_L:try_remove_comma


VP_L nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# VP_L {... & (~)?[y1]:(f(y1) & g1(y1)) & ... & (~)?[yn]:(f(yn) & gn(yn))}
#  -> (COMMA) ADVP_R/PP {^[P]:(... & f')}
#     (COMMA) VP_L {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
# where f(y) = (~)?[z]:(h(z) & arg1/arg2(z)=y) and f' = (~)?[z]:(h(z) & P(z))
#    or f(y) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=y) & ... & (~)?[zn]:(hn(zn) & arg1/arg2(zn)=y) and f' = (~)?[z1]:(h1(z1) & P(z1)) & ... & (~)?[zn]:(hn(zn) & P(zn))
#    or f(y) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=y) | ... | (~)?[zn]:(hn(zn) & arg1/arg2(zn)=y) and f' = (~)?[z1]:(h1(z1) & P(z1)) | ... | (~)?[zn]:(hn(zn) & P(zn))
# Note that f(y) may also contain variables which are universally-quantified,
# above the scope of zi, either within the scope of yi (e.g. "it flew faster
# than every bird") or above it ("i have been at every restaurant"). In this
# case, the universal quantifiers are also moved into f'.
#
# An example of a sentence with coordination in both the verb and adverb is:
#  "she walked and sat under every tree and near every rock"
VP_L -> ADVP_L VP_L:require_no_req_aux
VP_L -> COMMA PP:require_no_req_aux COMMA VP_L

VP_L -> WILL VP_R:remove_future,add_infinitive,add_aux,remove_req_aux # future tense
VP_L -> HAVE VP_R:require_no_future,remove_perfect,add_past_participle,add_aux,remove_req_aux # perfect aspect
VP_L -> BE VP_R:require_no_future,require_no_perfect,remove_progressive,add_present_participle,add_aux,remove_req_aux # progressive aspect
VP_L -> DO VP_R:require_no_future,require_no_perfect,require_no_progressive,add_infinitive,add_aux,remove_req_aux # do-support
VP_L -> NOT VP_R:require_aux,remove_not,remove_req_aux
VP_L -> BE VP_R:require_no_future,require_no_perfect,require_no_progressive,remove_inverse,add_past_participle,add_aux,remove_req_aux # passive voice
VP_L -> TO VP_R:add_infinitive,remove_to_infinitive,require_no_future,require_no_req_aux
VP_L -> MODAL VP_R:add_infinitive,remove_req_aux

# VP_L {?[x]:p(x)} -> V {p}
VP_L -> V:require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,require_no_req_aux,require_no_empty_ref,require_finite

# VP_L {?[x]:T} -> BE
# This is the semantically empty "be"/"is"/"was"/"were" as in "the cat is blue" and "the cat is in the tree".
VP_L -> BE:require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,require_no_req_aux,require_no_empty_ref,require_finite

# for gapping and stripping
VP_L -> WILL:remove_future,remove_req_aux,require_only_empty_ref # future tense
VP_L -> HAVE:require_no_future,remove_perfect,remove_req_aux,require_only_empty_ref # perfect aspect
VP_L -> BE:require_no_future,require_no_perfect,remove_progressive,remove_req_aux,require_only_empty_ref # progressive aspect
VP_L -> DO:require_no_future,require_no_perfect,require_no_progressive,remove_req_aux,require_only_empty_ref # do-support
VP_L -> NOT:require_aux,remove_not,remove_req_aux,require_only_empty_ref
VP_L -> BE:require_no_future,require_no_perfect,require_no_progressive,remove_inverse,remove_req_aux # passive voice,require_only_empty_ref
VP_L -> MODAL:remove_req_aux,require_empty_ref

# VP_L {... & ?[y1]:(... & arg1(y1)=a & ...) & ... & ?[yn]:(... & arg1(yn)=a & ...}
#  -> DP {^[P]:?[X]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x)))}
#     VP_L {... & ?[y1]:(...) & ... & ?[yn]:(...)}
# VP_L {... & (~)?[x]:(f(x) & ?[y1]:(... & arg1(y1)=x & ...) & ... & ?[yn]:(... & arg1(yn)=x & ...))}
#  -> DP {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)?[x]:(X(x) & P(x))))}
#     VP_L {... & ?[y1]:(...) & ... & ?[yn]:(...)}
# VP_L {... & (~)![x]:(f(x) => ... & ?[y1]:(... & arg1(y1)=x & ...) & ... & ?[yn]:(... & arg1(yn)=x & ...))}
#  -> DP {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)![x]:(X(x) => P(x))))}
#     VP_L {... & ?[y1]:(...) & ... & ?[yn]:(...)}
# VP_L {... & ?[X]:(f(X) & (~)![x]:(X(x) => ... & ?[y1]:(... & arg1(y1)=x & ...) & ... & ?[yn]:(... & arg1(yn)=x & ...)))}
#  -> DP {^[P]:(... & ?[X]:(f(X) & (~)![x]:(X(x) => P(x))))}
#     VP_L {... & ?[y1]:(...) & ... & ?[yn]:(...)}
# e.g. "it is not a cat nor will it be a cat"
VP_L -> DP VP_L:require_no_req_aux # for subject-auxiliary inversion


# TODO: should this nonterminal change the universal/existential quantifiers into a single kind of quantifier, to improve generalization for the NP nonterminal and further downstream?
DP nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# DP {A} -> A DP' {A}
DP -> DP':try_remove_comma,remove_adv

# DP {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)![x]:(S(x) => ![y]:(x(y) => P(y)))))} if xi are set-valued
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)![x]:(S(x) => P(x))))} if xi are individuals
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)?[x]:(S(x) & ![y]:(x(y) => P(y)))))} if xi are set-valued
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)?[x]:(S(x) & P(x))))} if xi are individuals
#  -> DP {^[P]:(... & ?[x1]:(f1(x1) & (~)P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & (~)![x]:(x1(x) => P(x))))} if x1 is a set
#     COMMA
#     DP {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)![x]:(S(x) => ![y]:(x(y) => P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)![x]:(S(x) => P(x))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)?[x]:(S(x) & ?[y]:(x(y) => P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)?[x]:(S(x) & P(x))))}
# note: xi could also be constants, rather than existentially-quantified variables
# note: if xi is a set containing a singleton, S would look like ^[x]:(... | x=^[y]:y=singleton | ...)
DP -> DP:try_remove_comma,try_remove_genitive COMMA DP:add_comma,remove_adv

# DP {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => ![y]:(x(y) => P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => P(x))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & ?[y]:(x(y) => P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & P(x))))}
#  -> DP {^[P]:(... & ?[x1]:(f1(x1) & (~)P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & (~)![x]:(x1(x) => P(x))))} if x1 is a set
#     (COMMA) AND
#     DP {^[P]:(... & ?[x2]:(f2(x2) & (~)P(x2)))}
#     or {^[P]:(... & ?[x2]:(f2(x2) & (~)![x]:(x2(x) => P(x))))} if x2 is a set
# note: xi could also be constants, rather than existentially-quantified variables
DP -> DP:try_remove_comma,try_remove_genitive AND DP:try_remove_comma,remove_adv
DP -> DP:try_remove_comma,try_remove_genitive COMMA AND DP:try_remove_comma,remove_adv

# DP {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => ?[y]:(x(y) & P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => P(x))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & ?[y]:(x(y) => P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & P(x))))}
#  -> DP {^[P]:(... & ?[x1]:(f1(x1) & (~)P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & (~)![x]:(x1(x) => P(x))))} if x1 is a set
#     (COMMA) OR
#     DP {^[P]:(... & ?[x2]:(f2(x2) & (~)P(x2)))}
#     or {^[P]:(... & ?[x2]:(f2(x2) & (~)?[x]:(x2(x) & P(x))))} if x2 is a set
# note: xi could also be constants, rather than existentially-quantified variables
DP -> DP:try_remove_comma,try_remove_genitive OR DP:try_remove_comma,remove_adv
DP -> DP:try_remove_comma,try_remove_genitive COMMA OR DP:try_remove_comma,remove_adv

# DP {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ~![x]:(X(x) => P(x))))} -> NO NP_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# DP {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ~?[x]:(X(x) & P(x))))} -> NO NP_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ~?[x]:(X(x) & P(x))))}
# DP {^[P]:(... & ?[X]:(f(X) & ~![x]:(X(x) => P(x))))} -> NOT DP {^[P]:?[X]:(f(X) & ![x]:(X(x) => P(x)))}
# DP {^[P]:(... & ?[X]:(f(X) & ~?[x]:(X(x) & P(x))))} -> NOT DP {^[P]:?[X]:(f(X) & ?[x]:(X(x) & P(x)))}
# this depends on whether the head quantifier is negated
DP -> NO NP_R:try_remove_comma,remove_adv
DP -> NOT DP:try_remove_comma,remove_adv

# DP {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))} -> EACH NP_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# this depends on whether the set is defined as S=^[x]:f(x) rather than with functions like `subset` or `half`;
# it also depends on whether the head predicate of the left conjunct is `this`, `that`, [TODO: add features for possessive]
DP -> EACH NP_R:try_remove_comma,require_no_adv

# DP {A} -> A NP_R {A}
#   e.g. "A group of students walks down the street."
DP -> A NP_R:concord_singular,try_remove_comma,remove_adv

# DP {^[P]:(... & ?[X]:(F(subset(X,^[x]:f(x))) & ![x]:(X(x) => P(x))))} -> SOME NP_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# DP {^[P]:(... & ?[X]:(F(subset(X,^[x]:f(x))) & ?[x]:(X(x) & P(x))))} -> SOME NP_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & P(x))))}
# this depends on whether the set is defined using `subset` rather than with functions like `half` or as S=^[x]:f(x);
DP -> SOME NP_R:try_remove_comma,remove_adv

# DP {A} -> DEF_DP {A}
DP -> DEF_DP:try_remove_comma,remove_adv

# DP {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))} -> ALL DEF_DP {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# this depends on whether the set is defined as S=^[x]:f(x) rather than with functions like `subset` or `half`;
# it also depends on whether the head predicate of the left conjunct is `this`, `that`, [TODO: add features for possessive]
DP -> ALL DEF_DP:try_remove_comma,remove_adv
DP -> ALL DP':try_remove_comma,remove_adv

# DP {^[P]:(... & ?[X]:(F(half(X,^[x]:f(x))) & ![x]:(X(x) => P(x))))} -> HALF DEF_DP {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# DP {^[P]:(... & ?[X]:(F(half(X,^[x]:f(x))) & ![x]:(X(x) => P(x))))} -> HALF A NP_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# this depends on whether the set is defined using `half` rather than with functions like `subset` or as S=^[x]:f(x);
# it also depends on whether the head predicate of the left conjunct is `this`, `that`, [TODO: add features for possessive]
DP -> HALF DEF_DP:try_remove_comma,remove_adv
DP -> HALF A NP_R:try_remove_comma,remove_adv

# DP {^[P]:(... & ?[X]:(F(f(X,A)) & (~)![x]:(X(x) => P(x))))} -> ADV {f} DP {^[P]:(... & ?[X]:(F(X=A) & (~)![x]:(X(x) => P(x))))}
# DP {^[P]:(... & ?[X]:(F(f(X,A)) & (~)?[x]:(X(x) & P(x))))} -> ADV {f} DP {^[P]:(... & ?[X]:(F(X=A) & (~)?[x]:(X(x) & P(x))))}
# NOTE: If A is an existentially-quantified variable, we replace all
# occurrences of A with X (such as in the construction "almost half the cats").
# this depends on whether `f` is `half`, `subset`, or `almost`
DP -> ADV DP:try_remove_comma,add_adv

# DP {^[P]:(... & ?[X]:(X=^[x]:f(x) & ![x]:(X(x) => P(x))))} -> VP_R {... & f(x)} if X is not a union
# DP {^[P]:(... & ?[X]:(X=^[x]:f(x) & ?[x]:(X(x) & P(x))))} -> VP_R {... & f(x)} if X is not a union
# DP {^[P]:(... & ?[X]:(X=^[x]:(x=x1 | ... | x=xn) & ![x]:(X(x) => P(x))))} -> VP_R {... & ?[x1]:(...) & ... & ?[xn]:(...)} if X is a union
# DP {^[P]:(... & ?[X]:(X=^[x]:(x=x1 | ... | x=xn) & ?[x]:(X(x) & P(x))))} -> VP_R {... & ?[x1]:(...) & ... & ?[xn]:(...)} if X is a union
DP -> VP_R:add_present_participle


DEF_DP nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# DEF_DP {A} -> THE DP' {A}
DEF_DP -> THE DP'

# DP {^[P]:(... & ?[S]:(this(S) & F(S) & ![x]:(S(x) => P(x))))} -> THIS DP' {^[P]:(... & ?[S]:(F(S) & ![x]:(S(x) => P(x))))}
# DP {^[P]:(... & ?[S]:(this(S) & F(S) & ?[x]:(S(x) & P(x))))} -> THIS DP' {^[P]:(... & ?[S]:(F(S) & ?[x]:(S(x) & P(x))))}
# this depends on whether the head predicate of the left conjunct is `this`
DEF_DP -> THIS DP'

# DP {^[P]:(... & ?[S]:(that(S) & F(S) & ![x]:(S(x) => P(x))))} -> THIS DP' {^[P]:(... & ?[S]:(F(S) & ![x]:(S(x) => P(x))))}
# DP {^[P]:(... & ?[S]:(that(S) & F(S) & ?[x]:(S(x) & P(x))))} -> THIS DP' {^[P]:(... & ?[S]:(F(S) & ?[x]:(S(x) & P(x))))}
# this depends on whether the head predicate of the left conjunct is `that`
DEF_DP -> THAT DP'

# DEF_DP {^[P]:(... & ?[X]:(F(X=^[x]:(?[o]:(own(o) & arg2(o)=x & arg1(o)=a) & f(x))) & ![x]:(X(x) => P(x))))}
#  -> DP {^[P]:?[X]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x)))}
#     DP' {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# DEF_DP {^[P]:(... & ?[X]:(F(X=^[x]:(?[o]:(own(o) & arg2(o)=x & ?[y]:(g(y) & arg1(o)=y)) & f(x))) & ![x]:(X(x) => P(x))))}
#  -> DP {^[P]:(... & ?[X]:(X=^[x]:g(x) & ?[x]:(X(x) & P(x))))}
#     DP' {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# DEF_DP {^[P]:(... & ?[X]:(F(X=^[x]:(?[y]:(g(y) & ?[o]:(own(o) & arg2(o)=x & arg1(o)=y)) & f(x))) & ![x]:(X(x) => P(x))))}
#  -> DP {^[P]:(... & ?[X]:(X=^[x]:g(x) & ![x]:(X(x) => P(x))))}
#     DP' {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# DEF_DP {^[P]:(... & ?[X]:(F(X=^[x]:(![y]:(g(y) => ?[o]:(own(o) & arg2(o)=x & arg1(o)=y)) & f(x))) & ![x]:(X(x) => P(x))))}
#  -> DP {^[P]:(... & ?[X]:(X=^[x]:g(x) & ![x]:(X(x) => P(x))))}
#     DP' {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# NOTE: In the last two rules, if `g(y)` is just a set membership test `Y(y)`,
# then in the left child logical form, we replace `X=^[x]:g(x)` with the
# definition of `Y` (effectively renaming `Y` to `X`).
# NOTE: This rule also works if X is existentially-quantified.
DEF_DP -> DP:add_genitive,singular DP'
DEF_DP -> DP:add_genitive,plural DP'
# TODO: the above rule can also be used for `inverse(intended_for)` in addition to `own`

# DEF_DP {^[P]:(... & ?[S]:(F(S=^[x]:(arg1/arg2(x)=a & f(x))) & ![x]:(S(x) => P(x))))}
#  -> DP {^[P]:?[S]:(S=^[x]:(x=a) & ?[x]:(S(x) & P(x)))}
#     DP' {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
# DEF_DP {^[P]:(... & ?[S]:(F(S=^[x]:(?[y]:(g(y) & arg1/arg2(x)=y) & f(x))) & ![x]:(S(x) => P(x))))}
#  -> DP {^[P]:(... & ?[S]:(S=^[x]:g(x) & ?[x]:(S(x) & P(x))))}
#     DP' {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
# DEF_DP {^[P]:(... & ![y]:(g(y) => ... ?[S]:(F(S=^[x]:(arg1/arg2(x)=y & f(x))) & ![x]:(S(x) => P(x)))))}
#  -> DP {^[P]:(... & ?[S]:(S=^[x]:g(x) & ![x]:(S(x) => P(x))))}
#     DP' {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
# DEF_DP {^[P]:(... & ?[Y]:(G(Y) & ... & ![y]:(Y(y) => ?[S]:(F(S=^[x]:(arg1/arg2(x)=y & f(x))) & ![x]:(S(x) => P(x))))))}
#  -> DP {^[P]:(... & ?[S]:(G(S) & ![x]:(S(x) => P(x))))}
#     DP' {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
# NOTE: This rule also works if S is existentially-quantified.
#  e.g. "the arson's/termites' destruction of the barn(s)"
DEF_DP -> DP:add_genitive,singular DP' # for arg1
DEF_DP -> DP:add_genitive,singular DP' # for arg2
DEF_DP -> DP:add_genitive,plural DP' # for arg1
DEF_DP -> DP:add_genitive,plural DP' # for arg2

# DEF_DP {^[P]:(... ?[X]:(X=^[x]:(?[o]:(arg1(o)=a & own(o) & arg2(o)=x)) & ![x]:(X(x) => P(x))))}
#  -> DP {^[P]:(... ?[Y]:(Y=^[y]:(y=a) & ?[y]:(Y(y) & P(y))))}
# DEF_DP {^[P]:(... ?[y]:(f(y) & ... & ?[X]:(X=^[x]:(?[o]:(arg1(o)=y & own(o) & arg2(o)=x)) & ![x]:(X(x) => P(x)))))}
#  -> DP {^[P]:(... ?[Y]:(Y=^[y]:f(y) & ?[y]:(Y(y) => P(y))))}
# DEF_DP {^[P]:(... ?[Y]:(F(Y) & ... & ?[X]:(X=^[x]:(?[y]:(Y(y) & ?[o]:(arg1(o)=y & own(o) & arg2(o)=x))) & ![x]:(X(x) => P(x)))))}
#  -> DP {^[P]:(... ?[Y]:(F(Y) & ?[y]:(Y(y) & P(y))))}
# DEF_DP {^[P]:(... ?[Y]:(F(Y) & ... & ?[X]:(X=^[x]:(![y]:(Y(y) => ?[o]:(arg1(o)=y & own(o) & arg2(o)=x))) & ![x]:(X(x) => P(x)))))}
#  -> DP {^[P]:(... ?[Y]:(F(Y) & ![y]:(Y(y) => P(y))))}
# NOTE: This rule also works if X is existentially-quantified.
# e.g. "Jason's is better"
DEF_DP -> DP:require_no_genitive,add_genitive,singular



DP' nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# DP {^[P]:(... & ?[S]:(f(S) & g(S=^[x]:f(x)) & ...))} -> Q {f(S)} NP_R {^[P]:(... & ?[S]:(g(S=^[x]:f(x)) & ...))}
# this depends on whether the head predicate of the left conjunct f(S) is one that expresses information about the size of the set
DP' -> Q NP_R

# DP' {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))} -> NP_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# DP' {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & P(x))))} -> NP_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & P(x))))}
DP' -> NP_R


Q nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# Q {?[l]:(mod(f)(l) & ...)} -> ADV {mod} Q {?[l]:(f(l) & ...)} where f is the type predicate of `l`
#   [OR]
# Q {?[l]:(?[m]:(mod(m) & arg1(m)=l) & f(l) & ...)} -> ADV {mod} Q {?[l]:(f(l) & ...)} where f is the type predicate of `l`
#
# Q {?[a]:(mod(a) & arg1(a)=A & arg2(a)=B)} -> ADV {mod} Q {A=B}
#   [OR]
# Q {f(A,B) -> ADV {f} Q {A=B}
# The last two rules are for adverbs like "almost", "nearly", "more than", etc.
Q -> ADVP_L Q

# Q {size(x)=n} -> NUMBER {n}
Q -> NUMBER

Q -> MUCH
Q -> MANY
Q -> MORE
Q -> MOST
Q -> FEW
Q -> FEWER
Q -> FEWEST
Q -> LESS
Q -> LEAST


# this noun phrase nonterminal is for right-side modifiers
NP_R nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# NP_R {A} -> NP_L {A}
NP_R -> NP_L:try_remove_comma

# appositives
# NP_R {^[P]:(... & ?[S]:(F(S=^[x]:(... & x=a)) & ...))}
#  -> NP_R {^[P]:(... & ?[S]:(F(S=^[x]:(...)) & ...))}
#     DP {^[P]:?[Y]:(Y=^[y]:(y=a) & ?[y]:(Y(y) & P(y)))}
# NP_R {^[P]:(... & ?[S]:(F(S=^[x]:(... & ?[y]:(f(y) & x=y))) & ...))}
#  -> NP_R {^[P]:(... & ?[S]:(F(S=^[x]:(...)) & ...))}
#     DP {^[P]:?[Y]:(Y=^[y]:f(y) & ?[y]:(Y(y) & P(y)))}
# e.g. "Kim Jones, President of the Union, ...", "the year 2024"
NP_R -> NP_R:try_remove_comma,try_remove_genitive DP:try_remove_comma
NP_R -> NP_R:try_remove_comma,try_remove_genitive COMMA DP:try_remove_comma COMMA
NP_R -> NP_R:try_remove_comma,try_remove_genitive OF DP:try_remove_comma

# NP_R {^[P]:(... & ?[S]:(F(S=^[x]:(arg1/arg2(x)=a & f(x))) & ![x]:(S(x) => P(x))))}
#  -> NP_R {^[P]:?[S]:(S=^[x]:(x=a) & ?[x]:(S(x) & P(x))}
#     PP {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
# NP_R {^[P]:(... & ?[S]:(F(S=^[x]:(?[y]:(g(y) & arg1/arg2(x)=y) & f(x))) & ![x]:(S(x) => P(x))))}
#  -> NP_R {^[P]:(... & ?[S]:(S=^[x]:g(x) & ?[x]:(S(x) & P(x))))}
#     PP {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
# NP_R {^[P]:(... & ![y]:(g(y) => ... ?[S]:(F(S=^[x]:(arg1/arg2(x)=y & f(x))) & ![x]:(S(x) => P(x)))))}
#  -> NP_R {^[P]:(... & ?[S]:(S=^[x]:g(x) & ![x]:(S(x) => P(x))))}
#     PP {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
# NP_R {^[P]:(... & ?[Y]:(G(Y) & ... & ![y]:(Y(y) => ?[S]:(F(S=^[x]:(arg1/arg2(x)=y & f(x))) & ![x]:(S(x) => P(x))))))}
#  -> NP_R {^[P]:(... & ?[S]:(G(S) & ![x]:(S(x) => P(x))))}
#     PP {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
# NOTE: This rule also works if S is existentially-quantified.
#  e.g. "destruction of the barn(s)", "destruction of the barn(s) by the termites"
NP_R -> NP_R:try_remove_comma,try_remove_genitive PP:try_remove_comma

# NP_R {^[P]:(... & ?[X]:(F(X=^[x]:(... & f(x))) & ![x]:(X(x) => P(x))))}
#  -> NP_R {^[P]:(... & ?[X]:(... & ![x]:(X(x) => P(x))))}
#     ADJP_R/PP {^[P]:(... & f')}
# where f(x) = (~)?[z]:(h(z) & arg1/arg2(z)=x) and f' = (~)?[z]:(h(z) & P(z))
#    or f(x) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=x) & ... & (~)?[zn]:(hn(zn) & arg1/arg2(zn)=x) and f' = (~)?[z1]:(h1(z1) & P(z1)) & ... & (~)?[zn]:(hn(zn) & P(zn))
#    or f(x) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=x) | ... | (~)?[zn]:(hn(zn) & arg1/arg2(zn)=x) and f' = (~)?[z1]:(h1(z1) & P(z1)) | ... | (~)?[zn]:(hn(zn) & P(zn))
# Note that f(x) may also contain variables which are universally-quantified,
# above the scope of zi, either within the scope of xi (e.g. "i like the house
# next to the trees") or above it ("a student from each class spoke to her").
# In this case, the universal quantifiers are also moved into f'.
# NOTE: This rule also works if X is existentially-quantified.
NP_R -> NP_R:try_remove_comma,try_remove_genitive PP:try_remove_comma
NP_R -> NP_R:try_remove_comma,try_remove_genitive ADJP_R:try_remove_comma

# {^[P]:(... & ?[X]:(F(X=^[x]:(... & ?[g]:(greater/less(f)(g) & arg1(g)=x & arg2(g)=a) & ...)) & ![x]:(X(x) => P(x))))}
#  -> ADJP_R {?[g]:greater/less(f)(g)}
#     NP_R {^[P]:(... & ?[X]:(F(X=^[x]:(...)) & ![x]:(X(x) => P(x))))}
#     THAN DP {^[P]:?[Y]:(Y=^[y]:(y=a) & ?[y]:(Y(y) & P(y)))}
# {^[P]:(... & ?[X]:(F(X=^[x]:(... & ?[g]:(greater/less(f)(g) & arg1(g)=x & ?[y]:(h(y) & arg2(g)=y)) & ...)) & ![x]:(X(x) => P(x))))}
#  -> ADJP_R {?[g]:greater/less(f)(g)}
#     NP_R {^[P]:(... & ?[X]:(F(X=^[x]:(...)) & ![x]:(X(x) => P(x))))}
#     THAN DP {^[P]:?[Y]:(Y=^[y]:h(y) & ?[y]:(Y(y) & P(y)))}
# {^[P]:(... & ?[X]:(F(X=^[x]:(... & ![y]:(h(y) => ?[g]:(greater/less(f)(g) & arg1(g)=x & arg2(g)=y)) & ...)) & ![x]:(X(x) => P(x))))}
#  -> ADJP_R {?[g]:greater/less(f)(g)}
#     NP_R {^[P]:(... & ?[X]:(F(X=^[x]:(...)) & ![x]:(X(x) => P(x))))}
#     THAN DP {^[P]:?[Y]:(Y=^[y]:h(y) & ![y]:(Y(y) => P(y)))}
# {^[P]:(... & ?[Y]:(h(Y) & ... ?[X]:(F(X=^[x]:(... & ![y]:(Y(y) => ?[g]:(greater/less(f)(g) & arg1(g)=x & arg2(g)=y)) & ...)) & ![x]:(X(x) => P(x)))))}
#  -> ADJP_R {?[g]:greater/less(f)(g)}
#     NP_R {^[P]:(... & ?[X]:(F(X=^[x]:(...)) & ![x]:(X(x) => P(x))))}
#     THAN DP {^[P]:?[Y]:(h(Y) & ![y]:(Y(y) => P(y)))}
# NOTE: This rule also works if X is existentially-quantified.
# e.g. "brighter star than Vega"
NP_R -> ADJP_R:try_remove_comma,try_remove_genitive NP_R:try_remove_comma,try_remove_genitive THAN DP:try_remove_comma

# NP_R {^[P]:(... & ?[X]:(F(X=^[x]:(... & ?[g1]:(... & arg3(g1)=x) & ... & ?[gn]:(... & arg3(gn)=x))) & ...))}
#  -> NP_R {^[P]:(... & ?[X]:(F(X=^[x]:(...)) & ...))}
#     S {?[g1]:(...) & ... & ?[gn]:(...)}
# e.g. "the book I gave Kim"
NP_R -> NP_R:try_remove_comma,try_remove_genitive S:try_remove_comma # TODO: remove grammatical features from S

# NP_R {^[P]:(... & ?[X]:(F(X=^[x]:(... & ?[g1]:(... & arg1(g1)=x) & ... & ?[gn]:(... & arg1(gn)=x))) & ...))}
#  -> NP_R {^[P]:(... & ?[X]:(F(X=^[x]:(...)) & ...))}
#     VP_R {?[g1]:(...) & ... & ?[gn]:(...)}
# e.g. "the cat sleeping on the bed"
NP_R -> NP_R:try_remove_comma,try_remove_genitive VP_R:keep_present_participle,try_remove_comma

# NP_R {^[P]:(... & ?[X]:(F(X=^[x]:(... & ?[g1]:(p1(g1) & ... & arg2(g1)=x) & ... & ?[gn]:(pn(gn) & ... & arg2(gn)=x))) & ...))}
#  -> NP_R {^[P]:(... & ?[X]:(F(X=^[x]:(...)) & ...))}
#     VP_R {?[g1]:(inverse(p1)(g1) & ...) & ... & ?[gn]:(inverse(pn)(gn) & ...)}
# e.g. "the letter written by me"
NP_R -> NP_R:try_remove_comma,try_remove_genitive VP_R:invert_predicate,keep_past_participle,try_remove_comma

# NP_R {^[P]:(... & ?[X]:(F(X=^[x]:(... & ?[g1]:(... & arg1(g1)=x) & ... & ?[gn]:(... & arg1(gn)=x))) & ...))}
#  -> NP_R {^[P]:(... & ?[X]:(F(X=^[x]:(...)) & ...))}
#     VP_R {?[g1]:(...) & ... & ?[gn]:(...)}
# e.g. "the person to see the comet"
NP_R -> NP_R:try_remove_comma,try_remove_genitive VP_R:add_to_infinitive,try_remove_comma

# TODO: implement these
NP_R -> NP_R:try_remove_comma,try_remove_genitive REL:try_remove_comma
NP_R -> NP_R:try_remove_comma,try_remove_genitive COMMA REL:try_remove_comma COMMA

# NP_R {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)![x]:(S(x) => ![y]:(x(y) => P(y)))))} if xi are set-valued
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)![x]:(S(x) => P(x))))} if xi are individuals
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)?[x]:(S(x) & ![y]:(x(y) => P(y)))))} if xi are set-valued
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)?[x]:(S(x) & P(x))))} if xi are individuals
#  -> NP_R {^[P]:(... & ?[x1]:(f1(x1) & (~)P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & (~)![x]:(x1(x) => P(x))))} if x1 is a set
#     COMMA
#     NP_R {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)![x]:(S(x) => ![y]:(x(y) => P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)![x]:(S(x) => P(x))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)?[x]:(S(x) & ?[y]:(x(y) => P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)?[x]:(S(x) & P(x))))}
# note: xi could also be constants, rather than existentially-quantified variables
# note: if xi is a set containing a singleton, S would look like ^[x]:(... | x=^[y]:y=singleton | ...)
NP_R -> NP_R:try_remove_comma,try_remove_genitive COMMA NP_R:add_comma

# NP_R {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => ![y]:(x(y) => P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => P(x))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & ?[y]:(x(y) => P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & P(x))))}
#  -> NP_R {^[P]:(... & ?[x1]:(f1(x1) & (~)P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & (~)![x]:(x1(x) => P(x))))} if x1 is a set
#     (COMMA) AND
#     NP_R {^[P]:(... & ?[x2]:(f2(x2) & (~)P(x2)))}
#     or {^[P]:(... & ?[x2]:(f2(x2) & (~)![x]:(x2(x) => P(x))))} if x2 is a set
# note: xi could also be constants, rather than existentially-quantified variables
NP_R -> NP_R:try_remove_comma,try_remove_genitive AND NP_R:try_remove_comma
NP_R -> NP_R:try_remove_comma,try_remove_genitive COMMA AND NP_R:try_remove_comma

# NP_R {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => ?[y]:(x(y) & P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => P(x))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & ?[y]:(x(y) => P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & P(x))))}
#  -> NP_R {^[P]:(... & ?[x1]:(f1(x1) & (~)P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & (~)![x]:(x1(x) => P(x))))} if x1 is a set
#     (COMMA) OR
#     NP_R {^[P]:(... & ?[x2]:(f2(x2) & (~)P(x2)))}
#     or {^[P]:(... & ?[x2]:(f2(x2) & (~)?[x]:(x2(x) & P(x))))} if x2 is a set
# note: xi could also be constants, rather than existentially-quantified variables
NP_R -> NP_R:try_remove_comma,try_remove_genitive OR NP_R:try_remove_comma
NP_R -> NP_R:try_remove_comma,try_remove_genitive COMMA OR NP_R:try_remove_comma


# this noun phrase nonterminal is for left-side modifiers
NP_L nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# NP_L {^[P]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x))))} -> N {a}
# NP_L {^[P]:(X=^[x]:(U(0,x) & p(x)) & ?[x]:(X(x) & P(x))))} -> N {p}
# NP_L {^[P]:(X=^[x]:(U(0,x) & p(x)) & ![x]:(X(x) => P(x))))} -> N {p}
# This depends on whether `p` is an event (i.e. typically has arguments, even
# if it doesnt in this particular logical form).
NP_L -> N

# NP_L {^[P]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x))))} -> V {a}
# NP_L {^[P]:(X=^[x]:(U(0,x) & p(x)) & ?[x]:(X(x) & P(x))))} -> V {p}
# NP_L {^[P]:(X=^[x]:(U(0,x) & p(x)) & ![x]:(X(x) => P(x))))} -> V {p}
# This depends on whether `p` is an event (i.e. typically has arguments, even
# if it doesnt in this particular logical form).
NP_L -> V:add_tion

# NP_L {^[P]:(X=^[x]:(?[y]:(p(y) & arg1(p)=x)) & ?[x]:(X(x) & P(x))))} -> V {p}
# NP_L {^[P]:(X=^[x]:(?[y]:(p(y) & arg1(p)=x)) & ![x]:(X(x) => P(x))))} -> V {p}
NP_L -> V:add_er # this adds "ers" if the concord is plural, as well as any duplicated consonants if appropriate (i.e. "programmers")

# NP_L {^[P]:(... & ?[X]:(F(X=^[x]:(... & f(x))) & ... & ![x]:(X(x) => P(x))))}
#  -> ADJP_L {^[P]:(... & f')}
#     NP_L {^[P]:(... & ?[X]:(F(X=^[x]:(...) & ... & ![x]:(X(x) => P(x))))}
# where f(x) = (~)?[z]:(h(z) & arg1/arg2(z)=x) and f' = (~)?[z]:(h(z) & P(z))
#    or f(x) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=x) & ... & (~)?[zn]:(hn(zn) & arg1/arg2(zn)=x) and f' = (~)?[z1]:(h1(z1) & P(z1)) & ... & (~)?[zn]:(hn(zn) & P(zn))
#    or f(x) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=x) | ... | (~)?[zn]:(hn(zn) & arg1/arg2(zn)=x) and f' = (~)?[z1]:(h1(z1) & P(z1)) | ... | (~)?[zn]:(hn(zn) & P(zn))
# NOTE: This rule also works if X is existentially-quantified or used collectively.
NP_L -> ADJP_L:try_remove_genitive NP_L

# NP_L {^[P]:(... & ?[X]:(F(X=^[x]:(... & f(x))) & ... & ![x]:(X(x) => P(x))))}
#  -> ADJP_L {^[P]:(... & f')}
#     NP_L {^[P]:(... & ?[X]:(F(X=^[x]:(...) & ... & ![x]:(X(x) => P(x))))}
# where f(x) = (~)?[z]:(h(z) & arg1/arg2(z)=x) and f' = (~)?[z]:(h(z) & P(z))
#    or f(x) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=x) & ... & (~)?[zn]:(hn(zn) & arg1/arg2(zn)=x) and f' = (~)?[z1]:(h1(z1) & P(z1)) & ... & (~)?[zn]:(hn(zn) & P(zn))
#    or f(x) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=x) | ... | (~)?[zn]:(hn(zn) & arg1/arg2(zn)=x) and f' = (~)?[z1]:(h1(z1) & P(z1)) | ... | (~)?[zn]:(hn(zn) & P(zn))
# NOTE: This rule also works if X is existentially-quantified or used collectively.
NP_L -> ADJP_L:try_remove_genitive NP_L

# NP_L {^[P]:(... & ?[X]:(F(X) & ?[g1]:(... & P(arg1(g1)) & ... & greatest/least(f)(g1) & ... & arg2(g1)=X) & ... & ?[gn]:(... & P(arg1(gn)) & ... & greatest/least(f)(gn) & ... & arg2(gn)=X)))}
#  -> ADJP_L {^[P]:(?[g1]:(greatest/least(f)(g1) & P(g1)) & ... & ?[gn]:(greatest/least(f)(gn) & P(gn)))}
#     NP_L {^[P]:(... & ?[X]:(F(X) & ?[x]:(X(x) & P(x))))}
# e.g. "closest and brightest star"
NP_L -> ADJP_L:try_remove_genitive NP_L

# NP_L {^[P]:(... & ?[X]:(F(X=^[x]:(?[s]:(arg2(s)=a & ... & arg1(s)=x) & U(0,x)))) & ...)}
#  -> NP_L {^[P]:?[Y]:(Y=^[y]:(y=a) & ?[y]:(Y(y) & P(y)))}
#     NP_L {^[P]:(... & ?[X]:(F(X=^[x]:(?[s]:(... & arg1(s)=x) & U(0,x)))) & ...)}
# NP_L {^[P]:(... & ?[X]:(F(X=^[x]:(?[s]:(?[y]:(f(y) & arg2(s)=y) & ... & arg1(s)=x) & U(0,x)))) & ...)}
#  -> NP_L {^[P]:?[Y]:(Y=^[y]:f(y) & ?[y]:(Y(y) & P(y)))}
#     NP_L {^[P]:(... & ?[X]:(F(X=^[x]:(?[s]:(... & arg1(s)=x) & U(0,x)))) & ...)}
# e.g. "potion seller"
NP_L -> NP_L:try_remove_genitive NP_L

# NP_L {^[P]:(... & ?[X]:(F(X=^[x]:(?[c]:(consists_of(c) & arg1(c)=x & arg2(c)=a) & ...)) & ...))}
#  -> NP_L {^[P]:?[Y]:(Y=^[y]:(y=a) & ?[y]:(Y(y) & P(y)))}
#     NP_L {^[P]:(... & ?[X]:(F(X=^[x]:(...)) & ...))}
# NP_L {^[P]:(... & ?[X]:(F(X=^[x]:(?[c]:(consists_of(c) & ?[y]:(f(y) & arg1(c)=y) & arg2(c)=a) & ...)) & ...))}
#  -> NP_L {^[P]:?[Y]:(Y=^[y]:f(y) & ?[y]:(Y(y) & P(y)))}
#     NP_L {^[P]:(... & ?[X]:(F(X=^[x]:(...)) & ...))}
# e.g. "apple pie"
# TODO: what about "California Senator"
NP_L -> NP_L:try_remove_genitive NP_L # for `consists_of` (or maybe `contains`?)
NP_L -> NP_L:try_remove_genitive NP_L # for `purpose`
NP_L -> NP_L:try_remove_genitive NP_L # for `located`

# NP_L {^[P]:(... & ?[X]:(F(X=^[x]:(?[m1]:(g1(m1) & arg1/arg2(m1)=x) & ... & ?[mn]:(gn(mn) & arg1/arg2(mn)=x) & ...)) & ...))}
#  -> VP_L {?[m1]:g1(m1) & ... & ?[mn]:gn(mn)}
#     NP_L {^[P]:(... & ?[X]:(F(X=^[x]:(...)) & ...))}
# e.g. "recently published article", "melting marshmellows"
NP_L -> VP_L:try_remove_genitive,add_present_participle NP_L
NP_L -> VP_L:try_remove_genitive,add_past_participle NP_L

# NP_L {^[P]:(... & ?[X]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x))))} -> ENTITY_NAME {a}
# this depends on whether `a` is a constant vs a predicate, or a more complex formula
#NP_L -> ENTITY_NAME

# NP_L {^[P]:(... & ?[X]:(X=^[x]:(first_name(x)=n1) & ?[x]:(X(x) & P(x))))} -> NAME {first_name(x)=n1}
# NP_L {^[P]:(... & ?[X]:(X=^[x]:(first_name(x)=n1 & last_name(x)=n2) & ?[x]:(X(x) & P(x))))} -> NAME {first_name(x)=n1 & last_name(x)=n2}
# NP_L {^[P]:(... & ?[X]:(X=^[x]:(nickname(x,n1)) & ?[x]:(X(x) & P(x))))} -> NAME {nickname(x,n1)}
NP_L -> NAME


#ENTITY_NAME nonterminal {} {1.0} {1.0} {} 10 1.0 {}
#ENTITY_NAME -> STRING:get_nickname
#ENTITY_NAME -> STRING:get_first_name
#ENTITY_NAME -> STRING:get_first_name STRING:get_last_name

NAME nonterminal {} {1.0} {1.0} {} 10 1.0 {}
# NAME {nickname(x,s)} -> STRING {s}
NAME -> STRING:select_nickname
# NAME {first_name(x)=s} -> STRING {s}
NAME -> STRING:select_first_name
# NAME {first_name(x)=s1 & last_name(x)=s2} -> STRING {s1} STRING {s2}
NAME -> STRING:select_first_name STRING:select_last_name


PP nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# PP {^[P]:(... & ?[x]:(p(x) & arg1/arg2(x)=a & P(x)))}
#  -> P {p}
#     DP {^[P]:?[Y]:(Y=^[y]:(y=a) & ?[y]:(Y(y) & P(y)))}
# PP {^[P]:(... & ?[x]:(p(x) & arg1/arg2(x)=possibility(A) & P(x)))}
#  -> P {p}
#     DP {^[P]:A'} where p is something that expresses possibility like `capable_of`, and A' has a `P(z)` term added to the head scope
# PP {^[P]:(... & ?[x]:(p(x) & ?[y]:(f(y) & arg1/arg2(x)=y) & P(x)))}
#  -> P {p}
#     DP {^[P]:?[Y]:(Y=^[y]:f(y) & ?[y]:(Y(y) & P(y)))}
# PP {^[P]:(... & ![y]:(f(y) => ?[x]:(p(x) & arg1/arg2(x)=y & P(x))))}
#  -> P {p}
#     DP {^[P]:?[Y]:(Y=^[y]:f(y) & ![y]:(Y(y) => P(y)))}
# PP {^[P]:(... & ?[Y]:(F(Y) & ... & ![y]:(Y(y) => ?[x]:(p(x) & arg1/arg2(x)=y & P(x)))))}
#  -> P {p}
#     DP {^[P]:?[Y]:(F(Y) & ![y]:(Y(y) => P(y)))}
# e.g. "house(s) next to the tree(s)"
PP -> P:require_no_preposition DP:try_remove_comma
# e.g. "friend of Mary's", "eyes of Mary's"
PP -> P:require_no_preposition DP:add_genitive,try_remove_comma
# for prepositional verbs (i.e. "pay back", "look forward to", etc)
PP -> P_PLACEHOLDER:require_preposition DP:try_remove_comma

# PP {^[P]:(... & ?[x]:(p(x) & ?[y]:(f(y) & arg1/arg2(x)=y) & P(x)))}
#  -> P {p}
#     S {... & ?[y]:f(y)}
# e.g. "before the meeting ended"
PP -> P:require_no_preposition S:try_remove_comma

# PP {^[P]:(... & ~?[x]:(f(x) & P(x)))}
#  -> NOT PP {^[P]:(... & ?[x]:(f(x) & P(x)))}
PP -> NOT PP:try_remove_preposition,try_remove_comma

# PP {^[P]:(... & ((~)?[x1]:f1(x1) & ... & (~)?[xn]:fn(xn)))}
#  -> PP {^[P]:(... & (~)?[x1]:f1(x1))}
#     COMMA
#     PP {^[P]:(... & ((~)?[x2]:f2(x2) & ... & (~)?[xn]:fn(xn)))}
# PP {^[P]:(... & ((~)?[x1]:f1(x1) | ... | (~)?[xn]:fn(xn)))}
#  -> PP {^[P]:(... & (~)?[x1]:f1(x1))}
#     COMMA
#     PP {^[P]:(... & ((~)?[x2]:f2(x2) | ... | (~)?[xn]:fn(xn)))}
PP -> PP:try_remove_preposition,try_remove_comma COMMA PP:try_remove_preposition,add_comma

# PP {^[P]:(... & ((~)?[x1]:f1(x1) & ... & (~)?[xn]:fn(xn)))}
#  -> PP {^[P]:(... & (~)?[x1]:f1(x1))}
#     (COMMA) AND
#     PP {^[P]:(... & ((~)?[x2]:f2(x2) & ... & (~)?[xn]:fn(xn)))}
PP -> PP:try_remove_preposition,try_remove_comma AND PP:try_remove_preposition,try_remove_comma
PP -> PP:try_remove_preposition,try_remove_comma COMMA AND PP:try_remove_preposition,try_remove_comma

# PP {^[P]:(... & ((~)?[x1]:f1(x1) | ... | (~)?[xn]:fn(xn)))}
#  -> PP {^[P]:(... & (~)?[x1]:f1(x1))}
#     (COMMA) OR
#     PP {^[P]:(... & ((~)?[x2]:f2(x2) | ... | (~)?[xn]:fn(xn)))}
PP -> PP:try_remove_preposition,try_remove_comma OR PP:try_remove_preposition,try_remove_comma
PP -> PP:try_remove_preposition,try_remove_comma COMMA OR PP:try_remove_preposition,try_remove_comma


ADJP_R nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# ADJP_R {^[P]:(... & ?[g1]:(... & p1(g1) & ... & f1(g1)) & ... & ?[gn]:(... & pn(gn) & ... & fn(gn)))}
#  -> ADJP_R {^[P]:(... & ?[g1]:(...) & ... & ?[gn]:(...))}
#     PP {^[P]:(... & ?[g1]:(p1(g1) & f1') & ... ?[gn]:(pn(gn) & fn'))}
# where fi(g) = ?[x]:(... & arg2(g)=x) and fi' = ?[x]:(...)
# NOTE: `x` could also be universally-quantified, in which case it is passed to the PP.
# e.g. "afraid of dogs", "capable of swimming"
ADJP_R -> ADJP_R:try_remove_comma PP:try_remove_comma

# e.g. "glad that you arrived", "uncertain whether or not she arrived", "amazed what an entrance she made"
# TODO: implement this
ADJP_R -> ADJP_R REL?

# ADJP_R {^[P]:(... & ?[g1]:(... & f1(g1)) & ... & ?[gn]:(... & fn(gn)))}
#  -> ADJP_R {^[P]:(... & ?[g1]:(...) & ... & ?[gn]:(...))}
#     DP {^[P]:(f1' & ... & fn')}
# where fi(g) = ?[x]:(h(x) & arg2(g)=x) and fi' = ?[x]:(h(x) & P(x))
# e.g. "worth three dollars"
ADJP_R -> ADJP_R:try_remove_comma DP:try_remove_comma

# ADJP_R {^[P]:?[g1]:(... & ?[h]:(f(h) & arg2(g1)=h)) & ... & ?[gn]:(... & ?[h]:(f(h) & arg2(gn)=h))}
#  -> ADJP_R {^[P]:?[g1]:(...) & ... & ?[gn]:(...)}
#     VP_R {?[g1]:(...) & ... & ?[gn]:(...)}
# e.g. "happy to help"
ADJP_R -> ADJP_R:try_remove_comma VP_R:try_remove_comma,add_to_infinitive

# ADJP_R {^[P]:(A1 & ... & An)} -> ADJP_R {^[P]:A1} COMMA ADJP_R {^[P]:(A2 & ... & An)}
# ADJP_R {^[P]:(A1 | ... | An)} -> ADJP_R {^[P]:A1} COMMA ADJP_R {^[P]:(A2 | ... | An)}
ADJP_R -> ADJP_R:try_remove_comma COMMA ADJP_R:add_comma

# ADJP_R {^[P]:(A1 & ... & An)} -> ADJP_R {^[P]:A1} (COMMA) AND ADJP_R {^[P]:(A2 & ... & An)}
ADJP_R -> ADJP_R:try_remove_comma AND ADJP_R:try_remove_comma
ADJP_R -> ADJP_R:try_remove_comma COMMA AND ADJP_R:try_remove_comma

# ADJP_R {^[P]:(A1 | ... | An)} -> ADJP_R {^[P]:A1} (COMMA) OR ADJP_R {^[P]:(A2 | ... | An)}
ADJP_R -> ADJP_R:try_remove_comma OR ADJP_R:try_remove_comma
ADJP_R -> ADJP_R:try_remove_comma COMMA OR ADJP_R:try_remove_comma

# ADJP_R {A} -> ADJP_L {A}
ADJP_R -> ADJP_L:try_remove_comma


ADJP_L nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# ADJP_L {^[P]:?[g]:(f(g) & P(g))} -> ADJ {f}
ADJP_L -> ADJ

# ADJP_L {^[P]:?[g]:(greatest/least(f)(g) & P(g))} -> ADJ {f}
ADJP_L -> ADJ:add_superlative

# ADJP_L {^[P]:?[g]:(greatest/least(f)(g) & P(g))} -> ADJP_L {^[P]:?[g]:(f(g) & P(g))}
ADJP_L -> MOST ADJP_L # for `greatest` only
ADJP_L -> LEAST ADJP_L # for `least` only

# ADJP_L {^[P]:?[g]:(greater/less(f)(g) & P(g))} -> ADJ {f}
ADJP_L -> ADJ:add_comparative

# ADJP_L {^[P]:?[g]:(greater/less(f)(g) & P(g))} -> ADJP_L {^[P]:?[g]:(f(g) & P(g))}
ADJP_L -> MORE ADJP_L # for `greater` only
ADJP_L -> LESS ADJP_L # for `less` only

# ADJP_L {^[P]:(... & ~?[g1]:f1(g1) & ... & ~?[gn]:fn(gn))}
#  -> NOT ADJP_L {^[P]:(... & ?[g1]:f1(g1) & ... & ?[gn]:fn(gn))}
# e.g. "very tall"
ADJP_L -> NOT ADJP_L

# ADJP_L {^[P]:(... & (~)?[g1]:((~)?[x]:(... & arg1(x)=g1) & ... & P(g1)) & ... & (~)?[gn]:((~)?[x]:(... & arg1(x)=gn) & ... & P(gn)))}
#  -> ADVP_L {^[P]:(... & (~)?[x]:(... & P(x)))}
#     ADJP_L {^[P]:(... & (~)?[g1]:(... & P(g1)) & ... & (~)?[gn]:(... & P(gn)))}
# e.g. "very tall"
ADJP_L -> ADVP_L ADJP_L

# ADJP_L {^[P]:(... & (~)?[g1]:(... & f1(g1)) & ... & (~)?[gn]:(... & fn(gn)))}
#  -> DP {^[P]:(f1' & ... & fn')}
#     ADJP_L {^[P]:(... & (~)?[g1]:(...) & ... & (~)?[gn]:(...))}
# where fi(g) = ?[x]:(h(x) & arg2(g)=x) and fi' = ?[x]:(h(x) & P(x))
# e.g. "500 feet tall"
ADJP_L -> DP ADJP_L


ADVP_R nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# ADVP_R {^[P]:(... & (~)?[g1]:(... & p1(g1) & ... & f1(g1)) & ... & (~)?[gn]:(... & pn(gn) & ... & fn(gn)))}
#  -> ADVP_R {^[P]:(... & (~)?[g1]:(...) & ... & (~)?[gn]:(...))}
#     PP {^[P]:(... & (~)?[g1]:(p1(g1) & f1') & ... & (~)?[gn]:(pn(gn) & fn'))}
# where fi(g) = ?[x]:(... & arg2(g)=x) and fi' = ?[x]:(...)
# NOTE: `x` could also be universally-quantified, in which case it is passed to the PP.
# e.g. "differently than him", "equally as effective"
ADVP_R -> ADVP_R:try_remove_comma PP:try_remove_comma

# e.g. "so softly that no one heard"
# TODO: implement this
ADVP_R -> ADVP_R REL?

# ADVP_R {^[P]:(A1 & ... & An)} -> ADVP_R {^[P]:A1} COMMA ADVP_R {^[P]:(A2 & ... & An)}
# ADVP_R {^[P]:(A1 | ... | An)} -> ADVP_R {^[P]:A1} COMMA ADVP_R {^[P]:(A2 | ... | An)}
ADVP_R -> ADVP_R:try_remove_comma COMMA ADVP_R:add_comma

# ADVP_R {^[P]:(A1 & ... & An)} -> ADVP_R {^[P]:A1} (COMMA) AND ADVP_R {^[P]:(A2 & ... & An)}
ADVP_R -> ADVP_R:try_remove_comma AND ADVP_R:try_remove_comma
ADVP_R -> ADVP_R:try_remove_comma COMMA AND ADVP_R:try_remove_comma

# ADVP_R {^[P]:(A1 | ... | An)} -> ADVP_R {^[P]:A1} (COMMA) OR ADVP_R {^[P]:(A2 | ... | An)}
ADVP_R -> ADVP_R:try_remove_comma OR ADVP_R:try_remove_comma
ADVP_R -> ADVP_R:try_remove_comma COMMA OR ADVP_R:try_remove_comma

ADVP_R -> ADVP_L:try_remove_comma


ADVP_L nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# ADVP_L {^[P]:?[g]:(f(g) & P(g))} -> ADV {f}
ADVP_L -> ADV

# ADVP_L {^[P]:?[g]:(f(g) & P(g))} -> ADJ {f}
ADVP_L -> ADJ:add_ly

# ADVP_L {^[P]:?[g]:(greatest/least(f)(g) & P(g))} -> ADV {f}
# e.g. "soonest", "most seriously"
ADVP_L -> ADV:add_superlative

# ADVP_L {^[P]:?[g]:(greatest/least(f)(g) & P(g))} -> ADVP_L {^[P]:?[g]:(f(g) & P(g))}
ADVP_L -> MOST ADVP_L:try_remove_comma # for `greatest` only
ADVP_L -> LEAST ADVP_L:try_remove_comma # for `least` only

# ADVP_L {^[P]:?[g]:(greater/less(f)(g) & P(g))} -> ADV {f}
# e.g. "sooner", "more seriously"
ADVP_L -> ADV:add_comparative

# ADVP_L {^[P]:?[g]:(greater/less(f)(g) & P(g))} -> ADVP_L {^[P]:?[g]:(f(g) & P(g))}
ADVP_L -> MORE ADVP_L:try_remove_comma # for `greater` only
ADVP_L -> LESS ADVP_L:try_remove_comma # for `less` only

# ADVP_L {^[P]:(... & ~?[g1]:f(g1) & ... & ~?[gn]:f(gn))}
#  -> NOT ADVP_L {^[P]:(... & ?[g1]:f(g1) & ... & ?[gn]:f(gn))}
# e.g. "very slowly"
ADVP_L -> NOT ADVP_L

# ADVP_L {^[P]:(... & (~)?[g1]:((~)?[x]:(... & arg1(x)=g1) & ... & P(g1)) & ... & (~)?[gn]:((~)?[x]:(... & arg1(x)=gn) & ... & P(gn)))}
#  -> ADVP_L {^[P]:(... & (~)?[x]:(... & P(x)))}
#     ADVP_L {^[P]:(... & (~)?[g1]:(... & P(g1)) & ... & (~)?[gn]:(... & P(gn)))}
# e.g. "very slowly"
ADVP_L -> ADVP_L ADVP_L

# ADVP_L {^[P]:(... & ?[g1]:(... & f1(g1)) & ... & ?[gn]:(... & fn(gn)))}
#  -> DP {^[P]:(f1' & ... & fn')}
#     ADVP_L {^[P]:(... & ?[g1]:(...) & ... & ?[gn]:(...))}
# where fi(g) = ?[x]:(h(x) & arg2(g)=x) and fi' = ?[x]:(h(x) & P(x))
# e.g. "12 minutes late"
ADVP_L -> DP ADVP_L


ALL nonterminal {} {1.0} {1.0} {} 10 1.0 {}
ALL -> "every"
ALL -> "each"
ALL -> "all"
