# We use neo-Davidsonian/event semantics to represent meaning in logical form.
# Thus, all verbs, nouns, adjectives, adverbs, etc are expressed as quantified
# variables. The "head" of any logical form is the right-most scope (not
# necessarily the deepest). For example:
#
#  "cats are mammals"
#  ![x]:(U(0,x) & cat(x) => ?[t]:(type(t) & present(t) & arg2(t)=mammal & arg1(t)=x & true(t)))
# where `present` is relative to the deictic origo, so it could be defined as
# something like ![x]:(present(x) = time(x)(T)) where time(x) returns the set
# of times at which the event x is true, and T is the current time in the
# discourse model (deictic origo). Also, `U` is the current universe of
# discourse. `U` can either contain the entire universe, as a default,
# U=^[x]:T, or it could change dynamically according to the discourse model.
# The first argument to `U` is an index that increases by one each time `U`
# function is invoked (and so its semantics can differ even within a sentence).
# We also might add an axiom like:
#     ![t,x,y]:((type(t) & arg1(t)=x & arg2(t)=y & true(t)) = y(x))
#
# Generally, every event that corresponds to a verb is modified with
# information about the time at which the event occurs. We can do this with the
# following axioms:
#   ![x,t]:(progressive(x,t) = ?[r]:(r>0 & ![s]:(s>(t-r) & s<(t+r) => time(x)(t))))
#   ![x,t]:(perfect(x,t) = ![r]:(time(x)(r) => r<t))
#   ![x,t]:(perfect_progressive(x,t) = (perfect(x,t) & ?[r]:(r>0 & ![s]:(s>(t-r) & s<t => time(x)(t)))))
#   ![x]:(present(x) = time(x)(T))
#   ![x]:(present_progressive(x) = progressive(x,T))
#   ![x]:(present_perfect(x) = perfect(x,T))
#   ![x]:(present_perfect_progressive(x) = perfect_progressive(x,T))
#   ![x]:(past(x) = ?[t]:(t<T & time(x)(t)))
#   ![x]:(past_progressive(x) = ?[t]:(t<T & progressive(x,t)))
#   ![x]:(past_perfect(x) = ?[t]:(t<T & perfect(x,t)))
#   ![x]:(past_perfect_progressive(x) = ?[t]:(t<T & perfect_progressive(x,t)))
#   ![x]:(future(x) = ?[t]:(t>T & time(x)(t)))
#   ![x]:(future_progressive(x) = ?[t]:(t>T & progressive(x,t)))
#   ![x]:(future_perfect(x) = ?[t]:(t>T & perfect(x,t)))
#   ![x]:(future_perfect_progressive(x) = ?[t]:(t>T & perfect_progressive(x,t)))
# TODO: add time information to the below logical forms too
#
#  "4 cats sleep"
#  ?[X]:(subset(X,^[x]:(U(0,x) & cat(x))) & size(X)=4 & ![x]:(X(x) => ?[s]:(sleep(s) & present(s) & arg1(s)=x & true(s))))
#
#  "4 cats slept"
#  ?[X]:(subset(X,^[x]:(U(0,x) & cat(x))) & size(X)=4 & ![x]:(X(x) => ?[s]:(sleep(s) & past(s) & arg1(s)=x & true(s))))
#
#  "4 cats will have been sleeping"
#  ?[X]:(subset(X,^[x]:(U(0,x) & cat(x))) & size(X)=4 & ![x]:(X(x) => ?[s]:(sleep(s) & future_perfect_progressive(s) & arg1(s)=x & true(s))))
#
#  "there is a cat"
#  ?[x]:(U(0,x) & cat(x))
#    [OR]
#  ?[c]:(U(0,x) & cat(x) & ?[l]:(position(l) & present(l) & arg2(l)=L & arg1(l)=x & true(l)))
# where L is the current discourse location (location of deictic origo).
#
#  "3 teachers grade 6 exams"
#  ?[X]:(subset(X,^[x]:(U(0,x) & teacher(x))) & size(X)=3 & ?[Y]:(subset(Y,^[y]:(U(1,y) & exam(y))) & size(Y)=6 & ![x,y]:(X(x) & Y(y) => ?[g]:(grade(g) & present(g) & arg2(g)=y & arg1(g)=x & true(g)))))
#  ?[X]:(subset(X,^[x]:(U(0,x) & teacher(x))) & size(X)=3 & ?[Y]:(subset(Y,^[y]:(U(1,y) & exam(y))) & size(Y)=6 & !W[x,y]:(X(x) & Y(y) => ?[g]:(grade(g) & present(g) & arg2(g)=y & arg1(g)=x & true(g)))))
#  ?[X]:(subset(X,^[x]:(U(0,x) & teacher(x))) & size(X)=3 & ![x]:(X(x) => ?[Y]:(subset(Y,^[y]:(U(1,y) & exam(y))) & size(Y)=6 & ![y]:(Y(y) => ?[g]:(grade(g) & present(g) & arg2(g)=y & arg1(g)=x & true(g))))))
# where !W is the weak universal quantifier, which is defined as:
# !W[x1,...,xn]:(X1(x1) & ... & Xn(xn) => f(x1,...,xn)) =
#     ![x1]:(X1(x1) => ?[x2,...,xn]:(X2(x2) & ... & Xn(xn) & f(x1,...,xn)))
#   & ![x2]:(X2(x2) => ?[x1,x3,...,xn]:(X1(x1) & X3(x3) & ... & Xn(xn) & f(x1,...,xn)))
#   & ![x3]:(X3(x3) => ?[x1,...,x2,x4,...,xn]:(X1(x1) & ... & X2(x2) & X4(x4) & ... & Xn(xn) & f(x1,...,xn)))
#   & ![x4]:(X4(x4) => ?[x1,...,x3,x5,...,xn]:(X1(x1) & ... & X3(x3) & X5(x5) & ... & Xn(xn) & f(x1,...,xn)))
#   & ... & ![xn]:(Xn(xn) => ?[x1,...,x(n-1)]:(X1(x1) & ... & X(n-1)(x(n-1)) & f(x1,...,xn)))
#
#  "a dog likes every cat"
#  ?[d]:(U(0,d) & dog(d) & ![c]:(U(1,c) & cat(c) => ?[l]:(like(l) & present(l) & arg2(l)=c & arg1(l)=d & true(l))))
#  ![c]:(U(0,c) & cat(c) => ?[d]:(U(1,d) & dog(d) & ?[l]:(like(l) & present(l) & arg2(l)=c & arg1(l)=d & true(l))))
#
#  "a dog is liked by every cat"
#  ?[d]:(U(0,d) & dog(d) & ![c]:(U(1,c) & cat(c) => ?[l]:(inverse(like)(l) & present(l) & arg2(l)=c & arg1(l)=d & true(l))))
#  ![c]:(U(0,c) & cat(c) => ?[d]:(U(1,d) & dog(d) & ?[l]:(inverse(like)(l) & present(l) & arg2(l)=c & arg1(l)=d & true(l))))
# where we can have an axiom like:
#    ![e,t,x,y]:((inverse(t)(e) & arg1(e)=x & arg2(e)=y) = (t(e) & arg1(e)=y & arg2(e)=x))
# In fact, the passive voice is always realized in semantics using the
# `inverse` function.
#
#  "Noah entertained and was reviewed"
#  ?[X]:(?[e]:(entertain(e) & past(e) & ?[r]:(inverse(review)(r) & past(r) & X=^[x]:(x=e | x=r))) & ^[x]:(X(x) => arg1(x)=noah & true(x)))
#
#  "not every cat is a tabby"
#  "not all cats are tabbies"
#  ~![c]:(U(0,c) & cat(c) => ?[t]:(type(t) & present(t) & arg2(t)=tabby & arg1(t)=c & true(t)))
#
#  "every cat isn't a tabby"
#  "all cats aren't tabbies"
#  ~![c]:(U(0,c) & cat(c) => ?[t]:(type(t) & present(t) & arg2(t)=tabby & arg1(t)=c & true(t)))
#  ![c]:(U(0,c) & cat(c) => ~?[t]:(type(t) & present(t) & arg2(t)=tabby & arg1(t)=c & true(t)))
#
#  "a cat and dog are sleeping"
#  ?[X]:(?[c]:(U(0,c) & cat(c) & ?[d]:(U(1,d) & dog(d) & X=^[x]:(x=c | x=d))) & ![x]:(X(x) => ?[s]:(sleep(s) & present(s) & arg1(s)=x & true(s))))
#
#  "4 cats, 2 dogs, and a bird are sleeping"
#  ?[X]:(?[C]:(subset(C,^[x]:(U(0,x) & cat(x))) & size(C)=4 & ?[D]:(subset(D,^[x]:(U(1,x) & dog(x))) & size(D)=2 & ?[b]:(U(2,b) & bird(b) & X=^[x]:(x=C | x=D | x=^[y]:y=b)))) & ![Y]:(X(Y) => ![x]:(Y(x) => ?[s]:(sleep(s) & present(s) & arg1(s)=x & true(s)))))
#
#  "a man and his dog were walking in the park"
#  ?[X]:(?[m]:(U(0,m) & man(m) & ?[h]:(U(1,h) & male_ref(0,h) & ?[d]:(U(2,d) & dog(d) & ?[o]:(own(o) & arg1(o)=h & arg2(o)=d) & X=^[x]:(x=m | x=d)))) & ![x]:(X(x) => ?[w]:(walk(w) & past_progressive(w) & ?[p]:(U(3,p) & park(p) & arg2(w)=p) & arg1(w)=x & true(w))))
# where `male_ref` is defined in the pragmatics model. We could supervise the
# pragmatics model by specifying that h and m refer to the same object. We
# similarly define `female_ref` for grammatically female anaphora and `ref` for
# anaphora whose grammatical gender is either neutral or unspecified. The first
# argument of `male_ref` is an index parameter so that multiple uses of "he" in
# the same sentence can potentially refer to different objects (just as the
# first argument of `U`).
#
#  "10 girls and boys are in class"
#  ?[X]:(?[G]:(G=^[x]:(U(0,x) & girl(x)) & ?[B]:(B=^[x]:(U(1,x) & boy(x)) & X=^[x]:(x=G | x=B))) & ![Y]:(X(Y) => size(Y)=10) & ![Y]:(X(Y) => ![x]:(Y(x) => ?[p]:(position(p) & ?[c]:(U(2,c) & class(c) & arg2(p)=c) & arg1(p)=x & true(p)))))
#  ?[X]:(?[G]:(G=^[x]:(U(0,x) & girl(x)) & ?[B]:(B=^[x]:(U(1,x) & boy(x)) & X=^[x]:(x=G | x=B))) & sum(X,^[Y]:size(Y))=10 & ![Y]:(X(Y) => ![x]:(Y(x) => ?[p]:(position(p) & present(p) & ?[c]:(U(2,c) & class(c) & arg2(p)=c) & arg1(p)=x & true(p)))))
#
#  "Jane is the only doctor"
#  ?[o]:(only(o) & present(o) & arg2(o)=^[x]:(U(0,x) & doctor(x)) & arg1(o)=jane) [or maybe we should do] ?[o]:(only(o) & present(o) & ?[D]:(D=^[x]:(U(1,x) & doctor(x)) & arg2(o)=D) & arg1(o)=jane & true(o))
#
#  "i did not get much money"
#  ?[m]:(U(0,m) & money(m) & ?[l]:(large_amount(l) & arg1(l)=m) & ~?[r]:(receive(r) & past(r) & arg2(r)=m & arg1(r)=me & true(r)))
#
#  "i don't like Ralph's destroying the barn"
#  "i don't like Ralph's destruction of the barn"
#  ?[d]:(destroy(d) & progressive(d) & ?[b]:(U(0,b) & barn(b) & arg2(d)=b) & arg1(d)=ralph & ~?[l]:(like(l) & present(l) & arg2(l)=d & arg1(l)=me & true(l)))
# note: we could require constant arguments (e.g. `ralph` and `me`) to be part of U in the discourse model
#
#  "i don't like the destruction of the barns by the teenagers"
#  ![x]:(U(0,x) & teenager(x) => ![y]:(U(1,y) & barn(y) => ?[d]:(destroy(d) & arg2(d)=y & arg1(d)=x & ~?[l]:(like(l) & arg2(l)=d & arg1(l)=me & true(l)))))
#    [OR]
#  ?[X]:(X=^[x]:(U(0,x) & teenager(x)) & ?[Y]:(Y=^[y]:(U(1,y) & barn(y)) & ![x]:(X(x) => ![y]:(Y(y) => ?[d]:(destroy(d) & arg2(d)=y & arg1(d)=x & ~?[l]:(like(l) & arg2(l)=d & arg1(l)=me & true(l)))))))
#
#  "the cat's purring is soothing"
#  ?[p]:(purr(p) & progressive(p) & ?[c]:(U(0,c) & cat(c) & arg1(p)=c) & ?[s]:(sooth(s) & progressive(s) & arg1(s)=p & true(s)))
#
#  "Joan's pen is good"
#  ?[p]:(U(0,p) & pen(p) & ?[o]:(own(o) & arg2(o)=p & arg1(o)=joan) & ?[g]:(good(g) & present(g) & arg1(g)=p & true(g)))
#
#  "Joan's pens are good"
#  ![x]:(U(0,x) & pen(x) & ?[o]:(own(o) & arg2(o)=x & arg1(o)=joan) => ?[g]:(good(g) & present(g) & arg1(g)=x & true(g)))
#    [OR]
#  ?[X]:(X=^[p]:(U(0,p) & pen(p) & ?[o]:(own(o) & arg2(o)=p & arg1(o)=joan)) & ![x]:(X(x) => ?[g]:(good(g) & present(g) & arg1(g)=x & true(g))))
#
#  "the students' pens are good"
#  ?[X]:(?[Y]:(Y=^[y]:(U(0,y) & student(y)) & X=^[x]:(U(1,x) & pen(x) & ?[y]:(Y(y) & ?[o]:(own(o) & arg2(o)=x & arg1(o)=y)))) & ![x]:(X(x) => ?[g]:(good(g) & present(g) & arg1(g)=x & true(g))))
#
#  "i saw the trees by all the cats"
#  ?[X]:(X=^[x]:(U(0,x) & cat(x)) & ?[Y]:(Y=^[y]:(U(1,y) & tree(y) & ![x]:(X(x) => ?[n]:(near(n) & arg2(n)=y & arg1(n)=x))) & ![y]:(Y(y) => ?[s]:(see(s) & past(s) & arg2(s)=y & arg1(s)=me & true(s)))))
#    [OR]
#  ![y]:(U(0,y) & tree(y) & ![x]:(U(1,x) & cat(x) => ?[n]:(near(n) & arg2(n)=y & arg1(n)=x)) => ?[s]:(see(s) & past(s) & arg2(s)=y & arg1(s)=me & true(s)))
#
# TODO: move the below rules into the grammar
# S' {?[x]:f(x)} -> THERE IS DP {^[P]:?[x]:(f(x) & P(x))}
# NOTE: This above rule is only really useful if we choose to represent "there
# is a cat" as something like ?[x]:(U(0,x) & cat(x)).
# S' {... & ?[y]:(... & g(y)=a & ...)} -> DP {a} VP_R {... & ?[y]:(... & g(y)=x & ...)}
# S' {... & (~)![x]:(f(x) => ... & ?[y]:(... & g(y)=x & ...))} -> DP {^[P]:(~)![x]:(f(x) => P(x))} VP_R {... & ?[y]:(... & g(y)=x & ...)}
# S' {... & ?[X]:(f(X) & (~)![x]:(X(x) => ... & ?[y]:(... & g(y)=x & ...)))} -> DP {^[P]:?[X]:(f(X) & (~)![x]:(X(x) => P(x))} VP_R {... & ?[y]:(... & g(y)=x & ...)}
# where g is arg1 or arg2.
# NOTE: The above two rules, during the inverse transformation, the scope of X
# and x can be positioned anywhere above the scope of y. However, to avoid
# overgenerating semantically-equivalent logical forms, for each equivalence
# class of semantically-equivalent inverse logical forms, we only output a
# single logical form (for example, by choosing the logical form in the
# equivalence class in which the scope of X and x are maximal). Also, the above
# rule can be extended to other kinds of quantification over X, such as
# existential or weak universal quantifier. Also, note that f(X) and f(x)
# cannot depend on any variables other than those declared within f(X) and
# f(x). But note that in the example "a cat and dog are sleeping", f(X)
# includes the definition for "cat" and "dog". In the above two rules, g(x) is
# the right-most conjunct in that scope that has no unbound variables.
# S' {... & (~)![x]:(f(x) => ... & ?[y]:(... & g(x) & ...))} -> DP {^[P]:![x]:(f(x) => P(x))} VP_R {... & (~)?[y]:(... & g(x) & ...)}
# S' {... & ?[X]:(f(X) & (~)![x]:(X(x) => ... & ?[y]:(... & g(x) & ...)))} -> DP {^[P]:?[X]:(f(X) & ![x]:(X(x) => P(x))} VP_R {... & (~)?[y]:(... & g(x) & ...)}
# NOTE: The previous note also applies to the above two rules.
#  "he works a lot to earn money for school"
#  ?[h]:(U(0,h) & male_ref(0,h) & ?[w]:(arg1(w)=h & work(w) & present(w) & ?[p]:(purpose(p) & ?[e]:(earn(e) & ?[m]:(U(1,m) & money(m) & arg2(e)=m) & arg2(p)=e) & arg1(p)=w) & true(w)))
#
#  "the ladder collapsed because it was old"
#  ?[l]:(U(0,l) & ladder(l) & ?[c]:(collapse(c) & past(c) & ?[r]:(reason(r) & ?[i]:(U(0,i) & ref(0,i) & ?[o]:(old(o) & past(o) & arg1(o)=i & arg2(r)=o)) & arg1(r)=c) & arg1(c)=l & true(c)))
#
#  "Mr. Bibby wrote the letter with a pencil"
#  ?[p]:(U(0,p) & pencil(p) & ?[l]:(U(1,l) & letter(l) & ?[w]:(write(w) & arg2(w)=l & arg1(w)=bibby & true(w))))
#
#  "the students wrote the letters with the pencils"
#  ?[S]:(S=^[s]:(U(0,s) & student(s)) & ?[L]:(L=^[l]:(U(1,l) & letter(l)) & ?[P]:(P=^[p]:(U(2,p) & pencil(p)) & !W[s,l,p]:(S(s) & L(l) & P(p) => ?[w]:(wrote(w) & past(w) & arg2(w)=l & ?[x]:(with(x) & arg2(x)=p & arg1(x)=w) & arg1(w)=s & true(w)))))))
#
#  "she sat on the table"
#  ?[x]:(U(0,x) & female_ref(0,x) & ?[s]:(arg1(s)=x & sit(s) & past(s) & ?[o]:(on_top_of(o) & ?[t]:(U(1,t) & table(t) & arg2(o)=t) & arg1(o)=s) & true(s)))
#
#  "the birds hear each other"
#  ![X]:(X=^[x]:(U(0,x) & bird(x)) & ![x,y]:(X(x) & Y(x) & ~(x=y) => ?[h]:(hear(h) & arg2(h)=y & arg1(h)=x & true(h))))
#
#  "some relative of each villager and some relative of each townsman hate each other"
#  ?[a]:(U(0,a) & ![x]:(U(1,x) & villager(x) => ?[r]:(related_to(r) & arg2(r)=x & arg1(r)=a)) & ?[b]:(U(2,b) & ![x]:(U(3,x) & townsman(x) => ?[r]:(related_to(r) & arg2(r)=x & arg1(r)=b)) & ?[X]:(X=^[x]:(x=a | x=b) & ![x,y]:(X(x) & Y(x) & ~(x=y) => ?[h]:(hate(h) & arg2(h)=y & arg1(h)=x & true(h))))))
#
#  "in either case, i am going"
#  ?[X]:(subset(X,^[x]:(U(0,x) & case(x))) & size(X)=2 & ![x]:(X(x) => (true(x) => ?[g]:(go(g) & progressive(g) & arg1(g)=me & true(g)))))
#
#  "if it rains, the grass will be wet"
#  "the grass, if it rains, will be wet"
#  ?[i]:(U(0,i) & ref(0,i) & ?[r]:(rain(r) & present(r) & arg1(r)=i & true(r))) => ?[g]:(U(1,g) & grass(g) & ?[w]:(wet(w) & future(w) & arg1(w)=g & true(w)))
#
#  "he ran with difficulty"
#  ?[h]:(U(0,h) & male_ref(0,h) & ?[r]:(arg1(r)=h & run(r) & past(r) & ?[d]:(difficult(d) & arg1(d)=r) & true(r)))
#
#  "he stood in silence"
#  ?[h]:(U(0,h) & male_ref(0,h) & ?[s]:(arg1(s)=h & stand(s) & past(s) & ?[x]:(silently(x) & arg1(x)=s) & true(s)))
# where we could define ![x]:(silently(x) = ?[s]:(is_silent(s) & arg1(s)=arg1(x) & ![t]:(time(x)(t) => time(s)(t))))
#
#  "she helped me with my homework"
#  ?[s]:(U(0,s) & female_ref(0,s) & ?[h]:(arg1(h)=s & help(h) & past(h) & arg2(h)=me & ?[x]:(U(1,x) & homework(x) & ?[o]:(own(o) & arg2(o)=x & arg1(o)=me) & ?[w]:(with(w) & arg2(w)=x & arg1(w)=h)) & true(h)))
#
#  "he stayed for two weeks"
#  ?[h]:(U(0,h) & male_ref(0,h) & ?[s]:(arg1(s)=h & stay(s) & past(s) & ?[d]:(duration(d) & arg2(d)=(2*week) & arg1(d)=s) & true(s)))
#
#  "it is under the bush"
#  ?[i]:(U(0,i) & ref(0,i) & ?[u]:(arg1(u)=i & is_under(u) & present(u) & ?[b]:(U(1,b) & bush(b) & arg2(u)=b) & true(u)))
#
#  "the party is at seven o'clock"
#  ?[p]:(U(0,p) & party(p) & start_time(p)=(7:00pm) & true(p))
#    [OR]
#  ?[p]:(U(0,p) & party(p) & ?[s]:(start_time(s) & arg2(s)=(7:00pm) & arg1(s)=p & true(s)))
# where we could define ![x,t]:((start_time(x)=t) = ![s]:(time(x)(s) => t<=s))
# TODO: how do we represent date/time constants?
#
#  "she will leave after she has had breakfast"
#  ?[s]:(U(0,s) & female_ref(0,s) & ?[l]:(arg1(l)=s & leave(l) & future(l) & ?[a]:(after(a) & ?[r]:(U(1,r) & female_ref(1,r) & ?[e]:(eat(e) & ?[b]:(U(2,b) & breakfast(b) & arg2(e)=b) & arg1(e)=r & arg2(a)=e)) & arg1(a)=l) & true(l)))
# where we could define ![a,x,y]:((after(a) & arg1(a)=x & arg2(a)=y) = ~?[s,t]:(time(x)(s) & time(y)(t) & s<t))
#
#  "the ball rotated quickly and heated up slowly"
#  ?[b]:(U(0,b) & ball(b) & ?[r]:(rotate(r) & past(r) & ?[q]:(quickly(q) & arg1(q)=r) & ?[h]:(heat_up(h) & past(h) & ?[s]:(slowly(s) & arg1(s)=h) & ?[X]:(X=^[x]:(x=r | x=h) & ![x]:(X(x) => arg1(x)=b & true(x))))))
#
#  "the ball rotated and heated up slowly"
#  ?[b]:(U(0,b) & ball(b) & ?[r]:(rotate(r) & past(r) & ?[h]:(heat_up(h) & past(h) & ?[X]:(X=^[x]:(x=r | x=h) & ![x]:(X(x) => ?[s]:(slowly(s) & arg1(s)=x) & arg1(x)=b & true(x))))))
#
#  "Emma and Noah met"
#  ?[X]:(X=^[x]:(x=emma | x=noah) & ?[m]:(collective_meet(m) & past(m) & arg1(m)=X & true(m)))
#
#  "Emma and Noah lifted the stone"
#  ?[X]:(X=^[x]:(x=emma | x=noah) & ?[s]:(U(0,s) & stone(s) & ?[l]:(lift(l) & past(l) & arg2(l)=s & arg1(l)=X & true(l))))
# Here, "Emma and Noah" has a *collective* interpretation, which also occurs in
# many other sentences in English.
#
#  "i think there is a unicorn"
#  ?[t]:(think(t) & present(t) & ?[e]:(exists(e) & present(e) & ?[u]:(U(0,u) & unicorn(u) & arg1(e)=u) & arg2(t)=e) & arg1(t)=me & true(t))
# This is why we need the `true` predicate, since it provides a uniform way to
# handle modality, and to talk about objects and events that may not actually
# exist or be true, but may exist as thoughts or suppositions (the Platonic
# universe). All events have the property that they are true if and only if
# both of its arguments are also true, with a handful of specified exceptions,
# including `think`, `capable_of`, `want`, etc. So for indicative sentences, we
# only need to mark one node (such as the root) as `true`, and the rest follows
# by transitivity.
#
#  "i can swim"
#  "i am capable of swimming"
#  ?[c]:(capable_of(c) & present(c) & ?[s]:(swim(s) & arg2(c)=s) & arg1(c)=me & true(c))
#
#  "i could swim"
#  "i was capable of swimming"
#  ?[c]:(capable_of(c) & past(c) & ?[s]:(swim(s) & arg2(c)=s) & arg1(c)=me & true(c))
#
#  "she made a big cake, and hung up some balloons"
#  {?[s]:(U(0,s) & female_ref(0,s) & ?[m]:(arg1(m)=s & make(m) & past(m) & ?[c]:(U(1,c) & cake(c) & ?[b]:(is_big(b) & arg1(b)=c) & arg2(m)=c) & true(m)) & ?[B]:(subset(B,^[b]:(U(2,b) & balloon(b))) & ![b]:(B(b) => ?[h]:(arg1(h)=s & hang(h) & past(h) & arg2(h)=b & true(h)))))}


# This is the root nonterminal for declarative sentences.
S nonterminal {} {1.0} {1.0} {} 10 1.0 {}
S -> S':singular
S -> S':plural

S -> ADVP (COMMA) S
S -> S (COMMA) ADVP
S -> S COMMA S
S -> S COMMA AND S
S -> S AND S
S -> S COMMA OR S
S -> S OR S

# S {f(because(A,B))} -> S {f(A)} (COMMA) BECAUSE/FOR S {B} where A is the head
S -> S COMMA BECAUSE S
S -> S BECAUSE S
S -> S COMMA FOR S
S -> S FOR S


S' nonterminal {has_not} {1.0, 1.0} {1.0, 1.0} {} 10 1.0 {}

# S' {g(a)} -> DP {a} VP_R {g(x)}
# S' {~g(a)} -> DP {a} VP_R {~g(x)}
# S' {![x]:(f(x) => g(h(x)))} -> DP {![x]:(f(x) => h(x))} VP_R {g(x)}
# S' {~![x]:(f(x) => g(h(x)))} -> DP {~![x]:(f(x) => h(x))} VP_R {g(x)}
# note: h is optional here (it could be the identity ^[x]:x)
# S' {?[X1]:(F1(X1,^[x]:f1(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & ![x1]:(X1(x1) => ... => ![xn]:(Xn(xn) => g(h1(x1),h2(x2,...,xn)))...))...)}
#  -> DP {?[X1]:(F1(X1,^[x]:f1(x)) & ![x1]:(X1(x1) => h1(x1)))}
#     VP_R {?[X2]:(F2(X2,^[x]:f2(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & ![x2]:(X2(x2) => ... => ![xn]:(Xn(xn) => g(x1,h2(x2,...,xn)))...))...)}
# S' {?[X1]:(F1(X1,^[x]:f1(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & ~![x1]:(X1(x1) => ... => ![xn]:(Xn(xn) => g(h1(x1),h2(x2,...,xn)))...))...)}
#  -> DP {?[X1]:(F1(X1,^[x]:f1(x)) & ~![x1]:(X1(x1) => h1(x1)))}
#     VP_R {?[X2]:(F2(X2,^[x]:f2(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & ![x2]:(X2(x2) => ... => ![xn]:(Xn(xn) => g(x1,h2(x2,...,xn)))...))...)}
# S' {?[X1]:(F1(X1,^[x]:f1(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & ?[x1]:(X1(x1) & ... => ![xn]:(Xn(xn) => g(h1(x1),h2(x2,...,xn)))...))...)}
#  -> DP {?[X1]:(F1(X1,^[x]:f1(x)) & ?[x1]:(X1(x1) & h1(x1)))}
#     VP_R {?[X2]:(F2(X2,^[x]:f2(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & ![x2]:(X2(x2) => ... => ![xn]:(Xn(xn) => g(x1,h2(x2,...,xn)))...))...)}
# S' {?[X1]:(F1(X1,^[x]:f1(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & ~?[x1]:(X1(x1) & ... => ![xn]:(Xn(xn) => g(h1(x1),h2(x2,...,xn)))...))...)}
#  -> DP {?[X1]:(F1(X1,^[x]:f1(x)) & ~?[x1]:(X1(x1) & h1(x)))}
#     VP_R {?[X2]:(F2(X2,^[x]:f2(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & ![x2]:(X2(x2) => ... => ![xn]:(Xn(xn) => g(x1,h2(x2,...,xn)))...))...)}
# where F1,...,Fn are set-defining functions like subset or =
# note: h1 and h2 are optional (they could be the identity ^[x]:x)
# TODO: add a version of these two rules for weak universal quantification
S' -> DP:remove_set_universal VP_R:select_set_consequent
# S' {~![x]:(f(x) => g(h(x)))} -> DP {![x]:(f(x) => h(x))} VP_R {~g(x)}
# note: h is optional here (it could be the identity ^[x]:x)
# S' {?[x]:(f(x) & g(h(x)))} -> DP {?[x]:(f(x) & h(x))} VP_R:{g(x)}
# S' {?[X1]:(F1(X1,^[x]:f1(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & ~![x1]:(X1(x1) => ... => ![xn]:(Xn(xn) => g(h1(x1),h2(x2,...,xn)))...))...)}
#  -> DP {?[X1]:(F1(X1,^[x]:f1(x)) & ![x1]:(X1(x1) => h1(x1)))}
#     VP_R {?[X2]:(F2(X2,^[x]:f2(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & ~![x2]:(X2(x2) => ... => ![xn]:(Xn(xn) => g(x1,h2(x2,...,xn)))...))...)}
# S' {?[X1]:(F1(X1,^[x]:f1(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & ~?[x1]:(X1(x1) & ... => ![xn]:(Xn(xn) => g(h1(x1),h2(x2,...,xn)))...))...)}
#  -> DP {?[X1]:(F1(X1,^[x]:f1(x)) & ?[x1]:(X1(x1) & h1(x1)))}
#     VP_R {?[X2]:(F2(X2,^[x]:f2(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & ~![x2]:(X2(x2) => ... => ![xn]:(Xn(xn) => g(x1,h2(x2,...,xn)))...))...)}
S' -> DP:not_remove_set_universal VP_R:select_set_consequent

# S' {?[x]:f(x)} -> THERE IS DP {?[x]:f(x)}
# S' {~?[x]:f(x)} -> THERE IS DP {~?[x]:f(x)}
S' -> THERE:null IS:null DP:identity


VP_R nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# VP_R {?[X1]:(F1(X1) & ... & ?[Xn]:(Fn(Xn) & (~)![x1,...,xn]:(X1(x1) & ... & Xn(xn) => g(h(x2,...,xn), x1)))...)}
#  -> VP_R {?[X2]:(F2(X2) & ... & ?[Xn]:(Fn(Xn) & (~)![x2,...,xn]:(X2(x2) & ... & Xn(xn) => h(x2,...,xn)))...)} # all sets and variables that are not required by h are removed
#     PP {?[X1]:(F1(X1) & ![x1]:(X1(x1) => g(z,x1)))} # any other sets and variables required by g are also kept
# note: x1,...,xn could also be individuals rather than sets
# this rule should not be selected if there are any sets/variables that are shared by both g and h
VP_R -> VP_R PP

# VP_R {?[X1]:(F1(X1) & ... & ?[Xn]:(Fn(Xn) & (~)![x1,...,xn]:(X1(x1) & ... & Xn(xn) => g(h1(x1,...,xm),hn(xn))))...)}
#  -> VP_R {?[X1]:(F1(X1) & ... & ?[Xm]:(Fm(Xm) & (~)![x1,...,xm]:(X1(x1) & ... & Xm(xm) => g(h1(x1,...,xm),xn)))...)} # all sets and variables that are not required by hn(xn) are removed
#     PP {?[Xn]:(Fn(Xn) & ![xn]:(Xn(xn) => g(x1,...,xm,hn(xn)))))} # any other sets and variables required by g are also kept
# note: x1,...,xn could also be individuals rather than sets
# this rule should not be selected if there are any sets/variables that are shared by both g and h
VP_R -> VP_R PP

# VP_R {(~)f1(x1,...,xk) & ... & (~)fn(x1,...,xk)}
#  -> VP_R {(~)f1(x1,...,xk)}
#     COMMA
#     VP_R {(~)f2(x1,...,xk) & ... & (~)fn(x1,...,xk)}
# VP_R {?[X1,...,Xj]:(... & ![x1,...,xj]:(X1(x1) & ... & Xj(xj) => (~)f1(x1,...xj) & ... & (~)fn(x1,...xj)))}
#  -> VP_R {?[X1,...,Xj]:(... & ![x1,...,xj]:(X1(x1) & ... & Xj(xj) => (~)f1(x1,...xj)))} # the sets and variables unused by f1 are removed
#     COMMA
#     VP_R {?[X1,...,Xj]:(... & ![x1,...,xj]:(X1(x1) & ... & Xj(xj) => (~)f2(x1,...xj) & ... & (~)fn(x1,...xj)))} # the sets and variables unused by f2,...,fn are removed
# VP_R {(~)f1(x1,...,xk) | ... | (~)fn(x1,...,xk)}
#  -> VP_R {(~)f1(x1,...,xk)}
#     COMMA
#     VP_R {(~)f2(x1,...,xk) | ... | (~)fn(x1,...,xk)}
# VP_R {?[X1,...,Xj]:(... & ![x1,...,xj]:(X1(x1) & ... & Xj(xj) => (~)f1(x1,...xj) | ... | (~)fn(x1,...xj)))}
#  -> VP_R {?[X1,...,Xj]:(... & ![x1,...,xj]:(X1(x1) & ... & Xj(xj) => (~)f1(x1,...xj)))} # the sets and variables unused by f1 are removed
#     COMMA
#     VP_R {?[X1,...,Xj]:(... & ![x1,...,xj]:(X1(x1) & ... & Xj(xj) => (~)f2(x1,...xj) | ... | (~)fn(x1,...xj)))} # the sets and variables unused by f2,...,fn are removed
VP_R -> VP_R COMMA:null VP_R

# VP_R {(~)f1(x1,...,xk) & (~)f2(x1,...,xk)}
#  -> VP_R {(~)f1(x1,...,xk)}
#     (COMMA) AND
#     VP_R {(~)f2(x1,...,xk)}
# VP_R {?[X1,...,Xj]:(... & ![x1,...,xj]:(X1(x1) & ... & Xj(xj) => (~)f1(x1,...xj) & (~)f2(x1,...xj)))}
#  -> VP_R {?[X1,...,Xj]:(... & ![x1,...,xj]:(X1(x1) & ... & Xj(xj) => (~)f1(x1,...xj)))} # the sets and variables unused by f1 are removed
#     (COMMA) AND
#     VP_R {?[X1,...,Xj]:(... & ![x1,...,xj]:(X1(x1) & ... & Xj(xj) => (~)f2(x1,...xj)))} # the sets and variables unused by f2 are removed
VP_R -> VP_R AND VP_R
VP_R -> VP_R COMMA:null AND VP_R

# VP_R {(~)f1(x1,...,xk) | (~)f2(x1,...,xk)}
#  -> VP_R {(~)f1(x1,...,xk)}
#     (COMMA) OR
#     VP_R {(~)f2(x1,...,xk)}
# VP_R {?[X1,...,Xj]:(... & ![x1,...,xj]:(X1(x1) & ... & Xj(xj) => (~)f1(x1,...xj) | (~)f2(x1,...xj)))}
#  -> VP_R {?[X1,...,Xj]:(... & ![x1,...,xj]:(X1(x1) & ... & Xj(xj) => (~)f1(x1,...xj)))} # the sets and variables unused by f1 are removed
#     (COMMA) OR
#     VP_R {?[X1,...,Xj]:(... & ![x1,...,xj]:(X1(x1) & ... & Xj(xj) => (~)f2(x1,...xj)))} # the sets and variables unused by f2 are removed
VP_R -> VP_R OR VP_R
VP_R -> VP_R COMMA:null OR VP_R

# VP_R {~f1(x1,...,xk) & ~f2(x1,...,xk)}
#  -> VP_R {~f1(x1,...,xk)}
#     (COMMA) NOR
#     VP_R {f2(x1,...,xk)}
# VP_R {?[X1,...,Xj]:(... & ![x1,...,xj]:(X1(x1) & ... & Xj(xj) => ~f1(x1,...xj) & ~f2(x1,...xj)))}
#  -> VP_R {?[X1,...,Xj]:(... & ![x1,...,xj]:(X1(x1) & ... & Xj(xj) => ~f1(x1,...xj)))} # the sets and variables unused by f1 are removed
#     (COMMA) NOR
#     VP_R {?[X1,...,Xj]:(... & ![x1,...,xj]:(X1(x1) & ... & Xj(xj) => f2(x1,...xj)))} # the sets and variables unused by f2 are removed
# this depends on whether f1 and f2 are negated
VP_R -> VP_R NOR VP_R # TODO: the second VP_R requires an auxiliary
VP_R -> VP_R COMMA:null NOR VP_R # TODO: the second VP_R requires an auxiliary

VP_R -> VP_R DP
VP_R -> VP_R ADVP
VP_R -> VP_L


VP_L nonterminal {} {1.0} {1.0} {} 10 1.0 {}
VP_L -> ADVP VP_L
VP_L -> COMMA PP COMMA VP_L
VP_L -> WILL VP_R:remove_future,add_infinitive,add_aux # future tense
VP_L -> HAVE VP_R:reuire_no_future,remove_perfect,add_past_participle,add_aux # perfect aspect
VP_L -> BE VP_R:require_no_future,require_no_perfect,remove_progressive,add_present_participle,add_aux # progressive aspect
VP_L -> DO VP_R:require_no_future,require_no_perfect,require_no_progressive,add_infinitive,add_aux # do-support
VP_L -> NOT VP_R:require_aux,remove_not
VP_L -> BE VP_R:require_no_future,require_no_perfect,require_no_progressive,remove_inverse,add_past_participle,add_aux # passive voice
VP_L -> MODAL VP_R:add_infinitive
VP_L -> V:require_no_future,require_no_perfect,require_no_progressive,require_no_inverse


# TODO: should this nonterminal change the universal/existential quantifiers into a single kind of quantifier, to improve generalization for the NP nonterminal and further downstream?
DP nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# DP {A} -> A NP {A}
DP -> DP'

# DP {?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)![x]:(S(x) => ![y]:(x(y) => h(y))))} if xi are set-valued
# or {?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)![x]:(S(x) => h(x)))} if xi are individuals
# or {?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)?[x]:(S(x) & ?[y]:(x(y) & h(y))))} if xi are set-valued
# or {?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)?[x]:(S(x) & h(x)))} if xi are individuals
#  -> DP {?[x1]:(f1(x1) & (~)h(x1))} or {?[x1]:(f1(x1) & (~)![x]:(x1(x) => h(x)))} if x1 is a set
#     COMMA
#     DP {?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)![x]:(S(x) => ![y]:(x(y) => h(y))))}
#     or {?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)![x]:(S(x) => h(x)))}
#     or {?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)?[x]:(S(x) & ?[y]:(x(y) & h(y))))}
#     or {?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)?[x]:(S(x) & h(x)))}
# note: xi could also be constants, rather than existentially-quantified variables
# note: if xi is a set containing a singleton, S would look like ^[x]:(... | x=^[y]:y=singleton | ...)
DP -> DP COMMA:null DP:comma

# DP {?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => ![y]:(x(y) => h(y))))}
# or {?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => h(x)))}
#  -> DP {?[x1]:(f1(x1) & (~)h(x1))} or {?[x1]:(f1(x1) & (~)![x]:(x1(x) => h(x)))} if x1 is a set
#     (COMMA) AND
#     DP {?[x2]:(f2(x2) & (~)h(x2))} or {?[x2]:(f2(x2) & (~)![x]:(x2(x) => h(x)))} if x2 is a set
# note: xi could also be constants, rather than existentially-quantified variables
DP -> DP AND:null DP
DP -> DP COMMA:null AND:null DP

# DP {?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & ?[y]:(x(y) & h(y))))}
# or {?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & h(x)))}
#  -> DP {?[x1]:(f1(x1) & (~)h(x1))} or {?[x1]:(f1(x1) & (~)?[x]:(x1(x) & h(x)))} if x1 is a set
#     (COMMA) OR
#     DP {?[x2]:(f2(x2) & (~)h(x2))} or {?[x2]:(f2(x2) & (~)?[x]:(x2(x) & h(x)))} if x2 is a set
# note: xi could also be constants, rather than existentially-quantified variables
DP -> DP OR:null DP
DP -> DP COMMA:null OR:null DP

# DP {~![x]:(f(x) -> h(x))} -> NO NP {![x]:(f(x) -> h(x))}
# DP {~?[x]:(f(x) & h(x))} -> NO NP {?[x]:(f(x) & h(x))}
# DP {![X]:(f(X) & ~![x]:(X(x) => h(x)))} -> NO NP {![X]:(f(X) & ![x]:(X(x) => h(x)))}
# DP {![X]:(f(X) & ~?[x]:(X(x) & h(x)))} -> NO NP {![X]:(f(X) & ?[x]:(X(x) & h(x)))}
# this depends on whether the head quantifier is negated
DP -> NO NP
DP -> NOT DP

# DP {a} -> NAME {a}
# this depends on whether `a` is a constant vs a predicate, or a more complex formula
DP -> NAME

# DP {A & h(a,c)} => ADV {h(x,c)} DP {A & a}
# DP {A & h(c,a)} => ADV {h(c,x)} DP {A & a}
# where e.g. h could be multiply and c could be 2, which can be expressed as "twice the ..."
DP -> ADV DP:adv

# DP {![X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => h(x)))} -> EACH NP {![X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => h(x)))}
# DP {![X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & h(x)))} -> EACH NP {![X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & h(x)))}
# this depends on whether the set is defined as S=^[x]:f(x) rather than with functions like `subset` or `half`;
# it also depends on whether the head predicate of the left conjunct is `this`, `that`, [TODO: add features for possessive]
DP -> EACH:no_adv NP

# DP {A} -> A NP {A}
#   e.g. "A group of students walks down the street."
DP -> A:null NP:concord_singular

# DP {![X]:(F(subset(X,^[x]:f(x))) & ![x]:(X(x) => h(x)))} -> SOME NP {![X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => h(x)))}
# DP {![X]:(F(subset(X,^[x]:f(x))) & ?[x]:(X(x) & h(x)))} -> SOME NP {![X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & h(x)))}
# this depends on whether the set is defined using `subset` rather than with functions like `half` or as S=^[x]:f(x);
DP -> SOME NP

# DP {A} -> DEF_DP {A}
DP -> DEF_DP

# DP {![X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => h(x)))} -> ALL DEF_NP {![X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => h(x)))}
# DP {![X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & h(x)))} -> ALL DEF_NP {![X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & h(x)))}
# this depends on whether the set is defined as S=^[x]:f(x) rather than with functions like `subset` or `half`;
# it also depends on whether the head predicate of the left conjunct is `this`, `that`, [TODO: add features for possessive]
DP -> ALL DEF_DP
DP -> ALL DP'

# DP {![X]:(F(half(X,^[x]:f(x))) & ![x]:(X(x) => h(x)))} -> HALF DEF_NP {![X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => h(x)))}
# DP {![X]:(F(half(X,^[x]:f(x))) & ?[x]:(X(x) & h(x)))} -> HALF DEF_NP {![X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & h(x)))}
# this depends on whether the set is defined using `half` rather than with functions like `subset` or as S=^[x]:f(x);
# it also depends on whether the head predicate of the left conjunct is `this`, `that`, [TODO: add features for possessive]
DP -> HALF DEF_DP
DP -> HALF A NP


DEF_DP nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# DEF_DP {A} -> THE NP {A}
DEF_DP -> THE DP'

# DP {![x]:(this(x) & f(x) => h(x))} -> THIS NP {![x]:(f(x) => h(x))}
# DP {?[x]:(this(x) & h(x))} -> THIS NP {?[x]:h(x)}
# DP {?[S]:(this(S) & F(S) & ![x]:(S(x) => h(x)))} -> THIS NP {?[S]:(F(S) & ![x]:(S(x) => h(x)))}
# DP {?[S]:(this(S) & F(S) & ?[x]:(S(x) & h(x)))} -> THIS NP {?[S]:(F(S) & ?[x]:(S(x) & h(x)))}
# this depends on whether the head predicate of the left conjunct is `this`
DEF_DP -> THIS DP'

# DP {![x]:(that(x) & f(x) => h(x))} -> THIS NP {![x]:(f(x) => h(x))}
# DP {?[x]:(that(x) & h(x))} -> THIS NP {?[x]:h(x)}
# DP {?[S]:(that(S) & F(S) & ![x]:(S(x) => h(x)))} -> THIS NP {?[S]:(F(S) & ![x]:(S(x) => h(x)))}
# DP {?[S]:(that(S) & F(S) & ?[x]:(S(x) & h(x)))} -> THIS NP {?[S]:(F(S) & ?[x]:(S(x) & h(x)))}
# this depends on whether the head predicate of the left conjunct is `that`
DEF_DP -> THAT DP'

# DEF_DP {?[x]:(belongs(x,a) & f(x))} -> DP {a} DP' {?[x]:f(x)}
# DEF_DP {?[x]:(?[y]:(g(y) & belongs(x,h(y))) & f(x))} -> DP {?[y]:(g(y) & h(y))} DP' {?[x]:f(x)}
# DEF_DP {?[S]:(![x]:(S(x) => belongs(x,a)) & f(S))} -> DP {a} DP' {?[S]:f(S)}
# DEF_DP {?[S]:(?[y]:(g(y) & ![x]:(S(x) => belongs(x,h(y)))) & f(S))} -> DP {?[y]:(g(y) & h(y))} DP' {?[S]:f(S)}
# DEF_DP {?[S]:(?[T]:(g(T) & ![x]:(S(x) => ![y]:(T(y) => belongs(x,h(y))))) & f(S))} -> DP {?[T]:(g(T) & ![y]:(T(y) => h(y)))} DP' {?[S]:f(S)}
# TODO: this is wrong; as written, this is stating for every x in S={x:f(x)} and every y in T={y:g(y)}, y owns x. but we want T to be the set {y:g(y) & some x owns y}
# note: in the above, the head predicate could also be `intended` rather than `belongs`
DEF_DP -> DP:poss DP'

# DEF_DP {?[x]:(f(x) & h(x))} -> DP {?[x]:(f(x) & x)} DP' {h(x)}
# DEF_DP {![x]:(f(x) => h(x))} -> DP {![x]:(f(x) => x)} DP' {h(x)}
# DEF_DP {?[S]:(f(S) & ![x]:(S(x) => h(x)))} -> DP {?[S]:(f(S) & ![x]:(S(x) => x))} DP' {h(x)}
# DEF_DP {?[S]:(f(S) & ?[x]:(S(x) & h(x)))} -> DP {?[S]:(f(S) & ?[x]:(S(x) & x))} DP' {h(x)}
# this depends on whether there is a predicate inside the Q, and its arguments (which argument is `x` in?) and arity
DEF_DP -> DP:poss DP'

# DEF_DP {?[x]:(f(x) & h(a,x))} -> DP {a} DP' {?[x]:(f(x) & h(y,x))}
# DEF_DP {?[x]:(f(x) & h(x,a))} -> DP {a} DP' {?[x]:(f(x) & h(x,y))}
# DEF_DP {![x]:(f(x) => h(a,x))} -> DP {a} DP' {![x]:(f(x) => h(y,x))}
# DEF_DP {![x]:(f(x) => h(x,a))} -> DP {a} DP' {![x]:(f(x) => h(x,y))}
# DEF_DP {?[x]:(f(x) & ?[y]:(g(y) & h(y,x)))} -> DP {?[y]:(g(y) & y)} DP' {?[x]:(f(x) & h(y,x))}
# DEF_DP {?[x]:(f(x) & ?[y]:(g(y) & h(x,y)))} -> DP {?[y]:(g(y) & y)} DP' {?[x]:(f(x) & h(x,y))}
# DEF_DP {![x]:(f(x) => ?[y]:(g(y) & h(y,x)))} -> DP {?[y]:(g(y) & y)} DP' {![x]:(f(x) => h(y,x))}
# DEF_DP {![x]:(f(x) => ?[y]:(g(y) & h(x,y)))} -> DP {?[y]:(g(y) & y)} DP' {![x]:(f(x) => h(x,y))}
# DEF_DP {?[x]:(f(x) & ![y]:(g(y) => h(y,x)))} -> DP {![y]:(g(y) => y)} DP' {?[x]:(f(x) & h(y,x))}
# DEF_DP {?[x]:(f(x) & ![y]:(g(y) => h(x,y)))} -> DP {![y]:(g(y) => y)} DP' {?[x]:(f(x) & h(x,y))}
# DEF_DP {![x]:(f(x) => ![y]:(g(y) => h(y,x)))} -> DP {![y]:(g(y) => y)} DP' {![x]:(f(x) => h(y,x))}
# DEF_DP {![x]:(f(x) => ![y]:(g(y) => h(x,y)))} -> DP {![y]:(g(y) => y)} DP' {![x]:(f(x) => h(x,y))}
# DEF_DP {?[S]:(f(S) & ![x]:(S(x) => h(a,x)))} -> DP {a} DP' {?[S]:(f(S) & ![x]:(S(x) => h(y,x)))}
# DEF_DP {?[S]:(f(S) & ![x]:(S(x) => h(x,y)))} -> DP {a} DP' {?[S]:(f(S) & ![x]:(S(x) => h(x,y)))}
# DEF_DP {?[S]:(f(S) & ?[x]:(S(x) & h(a,x)))} -> DP {a} DP' {?[S]:(f(S) & ?[x]:(S(x) & h(y,x)))}
# DEF_DP {?[S]:(f(S) & ?[x]:(S(x) & h(x,y)))} -> DP {a} DP' {?[S]:(f(S) & ?[x]:(S(x) & h(x,y)))}
# ...there are many more (where in the last four examples, `a` could be an existentially or universally-quantified variable, or a variable quantified over a set)
# this depends on whether there is a predicate in the head, and its arguments (which argument is `x` in?) and arity
DEF_DP -> DP:poss DP'


DP' nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# DP {?[S]:(f(S) & F(S) & ![x]:(S(x) => h(x)))} -> Q {f(S)} NP {?[S]:(F(S) & ![x]:(S(x) => h(x)))}
# this depends on whether the head predicate of the left conjunct is one that expresses information about the size of the set
DP' -> Q NP

# DEF_DP {A} -> THE NP {A}
DP' -> NP


Q nonterminal {} {1.0} {1.0} {} 10 1.0 {}
Q -> NUMBER
Q -> MUCH
Q -> MANY
Q -> MORE
Q -> MOST
Q -> FEW
Q -> FEWER
Q -> FEWEST
Q -> LESS
Q -> LEAST


# TODO: add appositives
# this noun phrase nonterminal is for right-side modifiers
NP nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# NP {A} -> NP' {A}
NP -> NP'

# NP {?[x]:(f(x) & h(x))} -> NP {h(x)} PP {?[x]:(f(x) & x)}
# NP {?[X1]:(F1(X1) & ... & ?[Xn]:(Fn(Xn) & (~)![x1]:(X1(x1) => ... ![xn]:(Xn(xn) => g(h1(x1),h2(x2,...,xn))))))}
#  -> NP {?[X2]:(F2(X2) & ... & ?[Xn]:(Fn(Xn) & (~)![x2]:(X2(x2) => ... ![xn]:(Xn(xn) => g(x1,h2(x2,...,xn))))))}
#     PP {?[X1]:(F1(X1) & ![x1]:(X1(x1) => h1(x1)))}
# NP {?[X1]:(F1(X1) & ... & ?[Xn]:(Fn(Xn) & (~)?[x1]:(X1(x1) => ... ![xn]:(Xn(xn) => g(h1(x1),h2(x2,...,xn))))))}
#  -> NP {?[X2]:(F2(X2) & ... & ?[Xn]:(Fn(Xn) & (~)![x2]:(X2(x2) => ... ![xn]:(Xn(xn) => g(x1,h2(x2,...,xn))))))}
#     PP {?[X1]:(F1(X1) & ?[x1]:(X1(x1) => h1(x1)))}
#  e.g. "destruction of the barn(s)", "destruction of the barn(s) by the termites"
NP -> NP PP

# NP {?[S]:(?[T]:(F(T) & G(S,^[x]:(u(x) & v(x,T)))) & ![x]:(S(x) => h(x)))} -> NP {?[S]:(G(S,^[x]:u(x)) & ![x]:(S(x) => h(x)))} PP {?[T]:(F(T) & v(x,T))}
#  e.g. "tree(s) by all the cats"
# note: S and T could be existentially or universally-quantified individuals rather than set-valued, as well; they could also be constants
NP -> NP PP

NP -> NP REL
NP -> NP COMMA:null REL COMMA:null
NP -> NP VP_R:keep_present_participle
NP -> NP VP_R:flip_predicate_keep_past_participle

# NP {?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)![x]:(S(x) => ![y]:(x(y) => h(y))))} if xi are set-valued
# or {?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)![x]:(S(x) => h(x)))} if xi are individuals
# or {?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)?[x]:(S(x) & ?[y]:(x(y) & h(y))))} if xi are set-valued
# or {?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)?[x]:(S(x) & h(x)))} if xi are individuals
#  -> NP {?[x1]:(f1(x1) & (~)h(x1))} or {?[x1]:(f1(x1) & (~)![x]:(x1(x) => h(x)))} if x1 is a set
#     COMMA
#     NP {?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)![x]:(S(x) => ![y]:(x(y) => h(y))))}
#     or {?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)![x]:(S(x) => h(x)))}
#     or {?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)?[x]:(S(x) & ?[y]:(x(y) & h(y))))}
#     or {?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)?[x]:(S(x) & h(x)))}
# note: xi could also be constants, rather than existentially-quantified variables
# note: if xi is a set containing a singleton, S would look like ^[x]:(... | x=^[y]:y=singleton | ...)
NP -> NP COMMA:null NP:comma

# NP {?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => ![y]:(x(y) => h(y))))}
# or {?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => h(x)))}
#  -> NP {?[x1]:(f1(x1) & (~)h(x1))} or {?[x1]:(f1(x1) & (~)![x]:(x1(x) => h(x)))} if x1 is a set
#     (COMMA) AND
#     NP {?[x2]:(f2(x2) & (~)h(x2))} or {?[x2]:(f2(x2) & (~)![x]:(x2(x) => h(x)))} if x2 is a set
# note: xi could also be constants, rather than existentially-quantified variables
NP -> NP AND:null NP
NP -> NP COMMA:null AND:null NP

# NP {?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & ?[y]:(x(y) & h(y))))}
# or {?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & h(x)))}
#  -> NP {?[x1]:(f1(x1) & (~)h(x1))} or {?[x1]:(f1(x1) & (~)?[x]:(x1(x) & h(x)))} if x1 is a set
#     (COMMA) AND
#     NP {?[x2]:(f2(x2) & (~)h(x2))} or {?[x2]:(f2(x2) & (~)?[x]:(x2(x) & h(x)))} if x2 is a set
# note: xi could also be constants, rather than existentially-quantified variables
NP -> NP OR:null NP
NP -> NP COMMA:null OR:null NP


# this noun phrase nonterminal is for left-side modifiers
NP' nonterminal {} {1.0} {1.0} {} 10 1.0 {}
NP' -> N
NP' -> ADJP NP'


PP nonterminal {} {1.0} {1.0} {} 10 1.0 {}
PP -> P DP
PP -> PP COMMA:null PP
PP -> PP AND PP
PP -> PP COMMA:null AND PP
PP -> PP OR PP
PP -> PP COMMA:null OR PP


ALL nonterminal {} {1.0} {1.0} {} 10 1.0 {}
ALL -> "every"
ALL -> "each"
ALL -> "all"
