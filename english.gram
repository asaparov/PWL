# english.gram
# Author: asaparov
#
# Examples of sentences as well as broad strokes of the grammar were found in:
#   Huddleston, R. D. & Pullum, G. K. (2002). The Cambridge Grammar of the English Language Cambridge University Press.
#
# We use neo-Davidsonian/event semantics to represent meaning in logical form.
# Thus, all verbs, nouns, adjectives, adverbs, etc are expressed as quantified
# variables. The "head" of any logical form is the right-most scope (not
# necessarily the deepest) that is an event (excluding `capable_of` events with
# an event argument). For example:
#
# We also chose to order the terms in the logical forms to match the order of
# the words/complements/arguments in the sentence as close as possible. This is
# so that, for each nonterminal, when selecting which production rule to
# expand, we only want to inspect one term (or a constant number of terms) in
# the logical form in order to make the decision. However, if the order of `n`
# terms in the head scope of the logical form is canonical, then we would need
# to inspect all `n` terms to capture the correct distribution.
#
#  "cats are mammals."
#  ![x]:(U(0,x) & cat(x) => ?[s]:(arg1(s)=x & same(s) & present(s) & ?[m]:(U(1,m) & mammal(m) & arg2(s)=m)))
# where `present` is relative to the deictic origo, so it could be defined as
# something like ![x]:(present(x) = time(x)(T)) where time(x) returns the set
# of times at which the event x is true, and T is the current time in the
# discourse model (deictic origo). Also, `U` is the current universe of
# discourse. `U` can either contain the entire universe, as a default,
# U=^[x]:T, or it could change dynamically according to the discourse model.
# The first argument to `U` is an index that increases by one each time `U`
# function is invoked (and so its semantics can differ even within a sentence).
#
# Generally, every event that corresponds to a verb is modified with
# information about the time at which the event occurs. We can do this with the
# following axioms:
#   ![x,t]:(progressive(x,t) = ?[r]:(r>0 & ![s]:(s>(t-r) & s<(t+r) => time(x)(t))))
#   ![x,t]:(perfect(x,t) = ![r]:(time(x)(r) => r<t))
#   ![x,t]:(perfect_progressive(x,t) = (perfect(x,t) & ?[r]:(r>0 & ![s]:(s>(t-r) & s<t => time(x)(t)))))
#   ![x]:(present(x) = time(x)(T))
#   ![x]:(present_progressive(x) = progressive(x,T))
#   ![x]:(present_perfect(x) = perfect(x,T))
#   ![x]:(present_perfect_progressive(x) = perfect_progressive(x,T))
#   ![x]:(past(x) = ?[t]:(t<T & time(x)(t)))
#   ![x]:(past_progressive(x) = ?[t]:(t<T & progressive(x,t)))
#   ![x]:(past_perfect(x) = ?[t]:(t<T & perfect(x,t)))
#   ![x]:(past_perfect_progressive(x) = ?[t]:(t<T & perfect_progressive(x,t)))
#   ![x]:(future(x) = ?[t]:(t>T & time(x)(t)))
#   ![x]:(future_progressive(x) = ?[t]:(t>T & progressive(x,t)))
#   ![x]:(future_perfect(x) = ?[t]:(t>T & perfect(x,t)))
#   ![x]:(future_perfect_progressive(x) = ?[t]:(t>T & perfect_progressive(x,t)))
#
#  "4 cats sleep."
#  ?[X]:(subset(X,^[x]:(U(0,x) & cat(x))) & size(X)=4 & ![x]:(X(x) => ?[s]:(arg1(s)=x & sleep(s) & present(s))))
#
#  "4 cats slept."
#  ?[X]:(subset(X,^[x]:(U(0,x) & cat(x))) & size(X)=4 & ![x]:(X(x) => ?[s]:(arg1(s)=x & sleep(s) & past(s))))
#
#  "4 cats will have been sleeping."
#  ?[X]:(subset(X,^[x]:(U(0,x) & cat(x))) & size(X)=4 & ![x]:(X(x) => ?[s]:(arg1(s)=x & sleep(s) & future_perfect_progressive(s))))
#
#  "there is a cat."
#  ?[x]:(U(0,x) & cat(x))
#    [OR]
#  ?[c]:(U(0,x) & cat(x) & ?[l]:(arg1(l)=x & location(l) & present(l) & arg2(l)=L))
# where L is the current discourse location (location of deictic origo).
#
#  "3 teachers grade 6 exams."
#  ?[X]:(subset(X,^[x]:(U(0,x) & teacher(x))) & size(X)=3 & ?[Y]:(subset(Y,^[y]:(U(1,y) & exam(y))) & size(Y)=6 & ![x,y]:(X(x) & Y(y) => ?[g]:(arg1(g)=x & grade(g) & present(g) & arg2(g)=y))))
#  ?[X]:(subset(X,^[x]:(U(0,x) & teacher(x))) & size(X)=3 & ?[Y]:(subset(Y,^[y]:(U(1,y) & exam(y))) & size(Y)=6 & !W[x,y]:(X(x) & Y(y) => ?[g]:(arg1(g)=x & grade(g) & present(g) & arg2(g)=y))))
#  ?[X]:(subset(X,^[x]:(U(0,x) & teacher(x))) & size(X)=3 & ![x]:(X(x) => ?[Y]:(subset(Y,^[y]:(U(1,y) & exam(y))) & size(Y)=6 & ![y]:(Y(y) => ?[g]:(arg1(g)=x & grade(g) & present(g) & arg2(g)=y)))))
# where !W is the weak universal quantifier, which is defined as:
# !W[x1,...,xn]:(X1(x1) & ... & Xn(xn) => f(x1,...,xn)) =
#     ![x1]:(X1(x1) => ?[x2,...,xn]:(X2(x2) & ... & Xn(xn) & f(x1,...,xn)))
#   & ![x2]:(X2(x2) => ?[x1,x3,...,xn]:(X1(x1) & X3(x3) & ... & Xn(xn) & f(x1,...,xn)))
#   & ![x3]:(X3(x3) => ?[x1,...,x2,x4,...,xn]:(X1(x1) & ... & X2(x2) & X4(x4) & ... & Xn(xn) & f(x1,...,xn)))
#   & ![x4]:(X4(x4) => ?[x1,...,x3,x5,...,xn]:(X1(x1) & ... & X3(x3) & X5(x5) & ... & Xn(xn) & f(x1,...,xn)))
#   & ... & ![xn]:(Xn(xn) => ?[x1,...,x(n-1)]:(X1(x1) & ... & X(n-1)(x(n-1)) & f(x1,...,xn)))
#
#  "a dog likes every cat."
#  ?[d]:(U(0,d) & dog(d) & ![c]:(U(1,c) & cat(c) => ?[l]:(arg1(l)=d & like(l) & present(l) & arg2(l)=c)))
#  ![c]:(U(0,c) & cat(c) => ?[d]:(U(1,d) & dog(d) & ?[l]:(arg1(l)=d & like(l) & present(l) & arg2(l)=c)))
#
#  "a dog is liked by every cat."
#  ?[d]:(U(0,d) & dog(d) & ![c]:(U(1,c) & cat(c) => ?[l]:(arg1(l)=d & inverse(like)(l) & present(l) & arg2(l)=c)))
#  ![c]:(U(0,c) & cat(c) => ?[d]:(U(1,d) & dog(d) & ?[l]:(arg1(l)=d & inverse(like)(l) & present(l) & arg2(l)=c)))
# where we can have an axiom like:
#    ![e,t,x,y]:((inverse(t)(e) & arg1(e)=x & arg2(e)=y) = (t(e) & arg1(e)=y & arg2(e)=x))
# In fact, the passive voice is always realized in semantics using the
# `inverse` function.
#
#  "Noah entertained and was reviewed."
#  ?[e]:(arg1(e)=noah & entertain(e) & past(e)) & ?[r]:(arg1(r)=noah & inverse(review)(r) & past(r))
# NOTE: We originally labeled this sentence with the following logical form:
#  ?[X]:(?[e]:(entertain(e) & past(e) & ?[r]:(inverse(review)(r) & past(r) & X=^[x]:(x=e | x=r))) & ^[x]:(X(x) => arg1(x)=noah))
# However, putting events into sets is problematic if one of the events is
# itself a set of events. See the later example "she made a big cake, and hung
# up some balloons".
#
#  "not every cat is a tabby."
#  "not all cats are tabbies."
#  ~![c]:(U(0,c) & cat(c) => ?[s]:(arg1(s)=c & same(s) & present(s) & ?[t]:(U(1,t) & tabby(t) & arg2(s)=t))
#
#  "every cat isn't a tabby."
#  "all cats aren't tabbies."
#  ~![c]:(U(0,c) & cat(c) => ?[s]:(arg1(s)=c & same(s) & present(s) & ?[t]:(U(1,t) & tabby(t) & arg2(s)=t))
#  ![c]:(U(0,c) & cat(c) => ~?[s]:(arg1(s)=c & same(s) & present(s) & ?[t]:(U(1,t) & tabby(t) & arg2(s)=t))
#
#  "a cat and dog are sleeping."
#  ?[X]:(?[c]:(U(0,c) & cat(c) & ?[d]:(U(1,d) & dog(d) & X=^[x]:(x=c | x=d))) & ![x]:(X(x) => ?[s]:(arg1(s)=x & sleep(s) & present(s))))
#
#  "4 cats, 2 dogs, and a bird are sleeping."
#  ?[X]:(?[C]:(subset(C,^[x]:(U(0,x) & cat(x))) & size(C)=4 & ?[D]:(subset(D,^[x]:(U(1,x) & dog(x))) & size(D)=2 & ?[b]:(U(2,b) & bird(b) & X=^[x]:(x=C | x=D | x=^[y]:y=b)))) & ![Y]:(X(Y) => ![x]:(Y(x) => ?[s]:(arg1(s)=x & sleep(s) & present(s)))))
#
#  "a man and his dog were walking in the park."
#  ?[X]:(?[m]:(U(0,m) & man(m) & ?[h]:(U(1,h) & male_ref(0,h) & ?[d]:(U(2,d) & dog(d) & ?[o]:(arg1(o)=h & own(o) & arg2(o)=d) & X=^[x]:(x=m | x=d)))) & ![x]:(X(x) => ?[w]:(arg1(w)=x & walk(w) & past_progressive(w) & ?[p]:(U(3,p) & park(p) & arg2(w)=p))))
# where `male_ref` is defined in the pragmatics model. We could supervise the
# pragmatics model by specifying that h and m refer to the same object. We
# similarly define `female_ref` for grammatically female anaphora and `ref` for
# anaphora whose grammatical gender is either neutral or unspecified. The first
# argument of `male_ref` is an index parameter so that multiple uses of "he" in
# the same sentence can potentially refer to different objects (just as the
# first argument of `U`).
#
#  "10 girls and boys are in class."
#  ?[X]:(?[G]:(G=^[x]:(U(0,x) & girl(x)) & ?[B]:(B=^[x]:(U(1,x) & boy(x)) & X=^[x]:(x=G | x=B))) & ![Y]:(X(Y) => size(Y)=10) & ![Y]:(X(Y) => ![x]:(Y(x) => ?[p]:(arg1(p)=x & location(p) & ?[c]:(U(2,c) & class(c) & arg2(p)=c)))))
#  ?[X]:(?[G]:(G=^[x]:(U(0,x) & girl(x)) & ?[B]:(B=^[x]:(U(1,x) & boy(x)) & X=^[x]:(x=G | x=B))) & sum(X,^[Y]:size(Y))=10 & ![Y]:(X(Y) => ![x]:(Y(x) => ?[p]:(arg1(p)=x & location(p) & present(p) & ?[c]:(U(2,c) & class(c) & arg2(p)=c)))))
#
#  "a cat is not currently but will be in the room."
#  ?[c]:(U(0,c) & cat(c) & ?[r]:(U(1,r) & room(r) & ?[l]:(arg1(l)=c & located(l) & present(l) & arg2(l)=r & ?[c]:(currently(c) & arg1(c)=l)) & ?[l]:(arg1(l)=c & located(l) & future(l) & arg2(l)=r)))
#
#  "Jane is the only doctor."
#  ?[o]:(arg1(o)=jane & only(o) & present(o) & arg2(o)=^[x]:(U(0,x) & doctor(x)))
#    [or maybe we should do]
#  ?[o]:(arg1(o)=jane & only(o) & present(o) & ?[D]:(D=^[x]:(U(1,x) & doctor(x)) & arg2(o)=D))
#
#  "i did not get much money."
#  ?[m]:(U(0,m) & money(m) & ?[l]:(large_amount(l) & arg1(l)=m) & ~?[r]:(arg1(r)=me & receive(r) & past(r) & arg2(r)=m))
#
#  "i did not get very much money."
#  ?[m]:(U(0,m) & money(m) & ?[l]:(very(large_amount)(l) & arg1(l)=m) & ~?[r]:(arg1(r)=me & receive(r) & past(r) & arg2(r)=m))
#    [OR]
#  ?[m]:(U(0,m) & money(m) & ?[l]:(?[v]:(very(v) & arg1(v)=l) & large_amount(l) & arg1(l)=m) & ~?[r]:(arg1(r)=me & receive(r) & past(r) & arg2(r)=m))
#
#  "i don't like Ralph's destroying the barn."
#  "i don't like Ralph's destruction of the barn."
#  ?[d]:(arg1(d)=ralph & destroy(d) & progressive(d) & ?[b]:(U(0,b) & barn(b) & arg2(d)=b) & ~?[l]:(arg1(l)=me & like(l) & present(l) & arg2(l)=d))
# NOTE: We could require constant arguments (e.g. `ralph` and `me`) to be part
# of U in the discourse model.
#
#  "i don't like the destruction of the barns by the teenagers."
#  ![x]:(U(0,x) & teenager(x) => ![y]:(U(1,y) & barn(y) => ?[d]:(arg1(d)=x & destroy(d) & arg2(d)=y & ~?[l]:(like(l) & arg2(l)=d & arg1(l)=me))))
#    [OR]
#  ?[X]:(X=^[x]:(U(0,x) & teenager(x)) & ?[Y]:(Y=^[y]:(U(1,y) & barn(y)) & ![x]:(X(x) => ![y]:(Y(y) => ?[d]:(arg1(d)=x & destroy(d) & arg2(d)=y & ~?[l]:(arg1(l)=me & like(l) & arg2(l)=d))))))
#
#  "the cat's purring is soothing."
#  ?[p]:(?[c]:(U(0,c) & cat(c) & arg1(p)=c) & purr(p) & progressive(p) & ?[s]:(arg1(s)=p & sooth(s) & progressive(s)))
#
#  "Joan's pen is good."
#  ?[p]:(U(0,p) & pen(p) & ?[o]:(arg1(o)=joan & own(o) & arg2(o)=p) & ?[g]:(arg1(g)=p & good(g) & present(g)))
#
#  "Joan's pens are good."
#  ![x]:(U(0,x) & pen(x) & ?[o]:(arg1(o)=joan & own(o) & arg2(o)=x) => ?[g]:(arg1(g)=x & good(g) & present(g)))
#    [OR]
#  ?[X]:(X=^[p]:(U(0,p) & pen(p) & ?[o]:(arg1(o)=joan & own(o) & arg2(o)=p)) & ![x]:(X(x) => ?[g]:(arg1(g)=x & good(g) & present(g))))
#
#  "the students' pens are good."
#  ?[X]:(?[Y]:(Y=^[y]:(U(0,y) & student(y)) & X=^[x]:(U(1,x) & pen(x) & ?[y]:(Y(y) & ?[o]:(own(o) & arg2(o)=x & arg1(o)=y)))) & ![x]:(X(x) => ?[g]:(arg1(g)=x & good(g) & present(g))))
#
#  "i saw the trees by all the cats."
#  ?[X]:(X=^[x]:(U(0,x) & cat(x)) & ?[Y]:(Y=^[y]:(U(1,y) & tree(y) & ![x]:(X(x) => ?[n]:(near(n) & arg2(n)=y & arg1(n)=x))) & ![y]:(Y(y) => ?[s]:(arg1(s)=me & see(s) & past(s) & arg2(s)=y))))
#    [OR]
#  ![y]:(U(0,y) & tree(y) & ![x]:(U(1,x) & cat(x) => ?[n]:(near(n) & arg2(n)=y & arg1(n)=x)) => ?[s]:(arg1(s)=me & see(s) & past(s) & arg2(s)=y))
#
#  "he works a lot to earn money for school."
#  ?[h]:(U(0,h) & male_ref(0,h) & ?[w]:(arg1(w)=h & work(w) & present(w) & ?[l]:(large_duration(l) & arg1(l)=w) & ?[p]:(purpose(p) & ?[e]:(earn(e) & ?[m]:(U(1,m) & money(m) & arg2(e)=m) & arg2(p)=e) & arg1(p)=w)))
#
#  "the ladder collapsed because it was old."
#  ?[l]:(U(0,l) & ladder(l) & ?[c]:(arg1(c)=l & collapse(c) & past(c) & ?[r]:(reason(r) & ?[i]:(U(0,i) & ref(0,i) & ?[o]:(old(o) & past(o) & arg1(o)=i & arg2(r)=o)) & arg1(r)=c)))
#
#  "Mr. Bibby wrote the letter with a pencil."
#  ?[p]:(U(0,p) & pencil(p) & ?[l]:(U(1,l) & letter(l) & ?[w]:(arg1(x)=w & write(w) & arg2(w)=l & arg1(w)=bibby & ?[x]:(with(x) & arg2(x)=p))))
#
#  "the students wrote the letters with the pencils."
#  ?[S]:(S=^[s]:(U(0,s) & student(s)) & ?[L]:(L=^[l]:(U(1,l) & letter(l)) & ?[P]:(P=^[p]:(U(2,p) & pencil(p)) & !W[s,l,p]:(S(s) & L(l) & P(p) => ?[w]:(arg1(w)=s & wrote(w) & past(w) & arg2(w)=l & ?[x]:(with(x) & arg2(x)=p & arg1(x)=w))))))
#
#  "she sat on the table."
#  ?[x]:(U(0,x) & female_ref(0,x) & ?[s]:(arg1(s)=x & sit(s) & past(s) & ?[o]:(on_top_of(o) & ?[t]:(U(1,t) & table(t) & arg2(o)=t) & arg1(o)=s)))
#
#  "the birds hear each other."
#  ?[X]:(X=^[x]:(U(0,x) & bird(x)) & ![x,y]:(X(x) & Y(x) & ~(x=y) => ?[h]:(arg1(h)=x & hear(h) & arg2(h)=y)))
#
#  "some relative of each villager and some relative of each townsman hate each other."
#  ?[a]:(U(0,a) & ![x]:(U(1,x) & villager(x) => ?[r]:(related_to(r) & arg2(r)=x & arg1(r)=a)) & ?[b]:(U(2,b) & ![x]:(U(3,x) & townsman(x) => ?[r]:(related_to(r) & arg2(r)=x & arg1(r)=b)) & ?[X]:(X=^[x]:(x=a | x=b) & ![x,y]:(X(x) & Y(x) & ~(x=y) => ?[h]:(arg1(h)=x & hate(h) & arg2(h)=y)))))
#
#  "in either case, i am going."
#  ?[X]:(subset(X,^[x]:(U(0,x) & case(x))) & size(X)=2 & ![x]:(X(x) => (true(x) => ?[g]:(arg1(g)=me & go(g) & progressive(g)))))
#
#  "if it rains, the grass will be wet."
#  "the grass, if it rains, will be wet."
#  ?[i]:(U(0,i) & ref(0,i) & ?[r]:(rain(r) & present(r) & arg1(r)=i)) => ?[g]:(U(1,g) & grass(g) & ?[w]:(wet(w) & future(w) & arg1(w)=g))
#
#  "he ran with difficulty."
#  ?[h]:(U(0,h) & male_ref(0,h) & ?[r]:(arg1(r)=h & run(r) & past(r) & ?[d]:(difficult(d) & arg1(d)=r)))
#
#  "he stood in silence."
#  ?[h]:(U(0,h) & male_ref(0,h) & ?[s]:(arg1(s)=h & stand(s) & past(s) & ?[x]:(silently(x) & arg1(x)=s)))
# where we could define ![x]:(silently(x) = ?[s]:(is_silent(s) & arg1(s)=arg1(x) & ![t]:(time(x)(t) => time(s)(t))))
#
#  "she helped me with my homework."
#  ?[s]:(U(0,s) & female_ref(0,s) & ?[h]:(arg1(h)=s & help(h) & past(h) & arg2(h)=me & ?[o]:(own(o) & arg2(o)=x & arg1(o)=me) & ?[w]:(with(w) & ?[x]:(U(1,x) & homework(x) & arg2(w)=x & arg1(w)=h))))
#
#  "he stayed for two weeks."
#  ?[h]:(U(0,h) & male_ref(0,h) & ?[s]:(arg1(s)=h & stay(s) & past(s) & ?[d]:(duration(d) & arg2(d)=(2*week) & arg1(d)=s)))
#
#  "it is under the bush."
#  ?[i]:(U(0,i) & ref(0,i) & ?[u]:(arg1(u)=i & is_under(u) & present(u) & ?[b]:(U(1,b) & bush(b) & arg2(u)=b)))
#
#  "the party is at seven o'clock."
#  ?[p]:(U(0,p) & party(p) & ?[s]:(arg1(s)=p & start_time(s) & present(s) & arg2(s)=(7:00pm)))
# where we could define ![x,t]:((start_time(x)=t) = ![s]:(time(x)(s) => t<=s)),
# or perhaps `start_time` and `end_time` should be the elementary event time
# predicates rather than `time`.
# TODO: how do we represent date/time constants?
#
#  "she will leave after she has had breakfast."
#  ?[s]:(U(0,s) & female_ref(0,s) & ?[l]:(arg1(l)=s & leave(l) & future(l) & ?[a]:(arg1(a)=l & after(a) & ?[r]:(U(1,r) & female_ref(1,r) & ?[e]:(eat(e) & ?[b]:(U(2,b) & breakfast(b) & arg2(e)=b) & arg1(e)=r & arg2(a)=e)))))
# where we could define ![a,x,y]:((after(a) & arg1(a)=x & arg2(a)=y) = ~?[s,t]:(time(x)(s) & time(y)(t) & s<t))
#
#  "the ball rotated quickly and heated up slowly."
#  ?[b]:(U(0,b) & ball(b) & ?[r]:(arg1(r)=b & rotate(r) & past(r) & ?[q]:(quick(q) & arg1(q)=r)) & ?[h]:(arg1(h)=b & heat_up(h) & past(h) & ?[s]:(slowly(s) & arg1(s)=h)))
# NOTE: We originally labeled this sentence with the following logical form:
#  ?[b]:(U(0,b) & ball(b) & ?[r]:(rotate(r) & past(r) & ?[q]:(quick(q) & arg1(q)=r) & ?[h]:(heat_up(h) & past(h) & ?[s]:(slowly(s) & arg1(s)=h) & ?[X]:(X=^[x]:(x=r | x=h) & ![x]:(X(x) => arg1(x)=b)))))
# However, putting events into sets is problematic if one of the events is
# itself a set of events. See the later example "she made a big cake, and hung
# up some balloons".
#
#  "the ball rotated and heated up slowly."
#  ?[b]:(U(0,b) & ball(b) & ?[r]:(arg1(r)=b & rotate(r) & past(r) & ?[s]:(slowly(s) & arg1(s)=r)) & ?[h]:(arg1(h)=b & heat_up(h) & past(h) & ?[s]:(slowly(s) & arg1(s)=h)))
# NOTE: We originally labeled this sentence with the following logical form:
#  ?[b]:(U(0,b) & ball(b) & ?[r]:(rotate(r) & past(r) & ?[h]:(heat_up(h) & past(h) & ?[X]:(X=^[x]:(x=r | x=h) & ![x]:(X(x) => ?[s]:(slowly(s) & arg1(s)=x) & arg1(x)=b)))))
# However, putting events into sets is problematic if one of the events is
# itself a set of events. See the later example "she made a big cake, and hung
# up some balloons".
#
#  "slowly, the ball rotated and heated up."
#  ?[b]:(U(0,b) & ball(b) & ?[r]:(arg1(r)=b & rotate(r) & past(r) & ?[s]:(slowly(s) & arg1(s)=r)) & ?[h]:(?[s]:(slowly(s) & arg1(s)=h) & arg1(h)=b & heat_up(h) & past(h)))
#
#  "Emma and Noah met."
#  ?[X]:(X=^[x]:(x=emma | x=noah) & ?[m]:(arg1(m)=X & collective_meet(m) & past(m)))
#
#  "Emma and Noah lifted the stone."
#  ?[X]:(X=^[x]:(x=emma | x=noah) & ?[s]:(U(0,s) & stone(s) & ?[l]:(lift(l) & past(l) & arg2(l)=s & arg1(l)=X)))
# Here, "Emma and Noah" has a *collective* interpretation, which also occurs in
# many other sentences in English.
#
#  "i think there is a unicorn."
#  ?[t]:(arg1(t)=me & think(t) & present(t) & arg2(t)=possibility(?[e]:(exists(e) & present(e) & ?[u]:(U(0,u) & unicorn(u) & arg1(e)=u))))
# This is why we need the `true` predicate, since it provides a uniform way to
# handle modality, and to talk about objects and events that may not actually
# exist or be true, but may exist as thoughts or suppositions (the Platonic
# universe). All events have the property that if they are true, then all of
# its arguments are true, with a handful of specified exceptions, including
# `think`, `capable_of`, `want`, `purpose`, etc.
#
#  "i can swim."
#  "i am capable of swimming."
#  ?[c]:(arg1(c)=me & capable_of(c) & present(c) & arg2(c)=possibility(?[s]:(arg1(s)=me & swim(s))))
#
#  "i could swim."
#  "i was capable of swimming."
#  ?[c]:(arg1(c)=me & capable_of(c) & past(c) & arg2(c)=possibility(?[s]:(arg1(s)=me & swim(s))))
#
#  "she made a big cake, and hung up some balloons."
#  ?[s]:(U(0,s) & female_ref(0,s) & ?[B]:(subset(B,^[b]:(U(2,b) & balloon(b))) & ?[m]:(arg1(m)=s & make(m) & past(m) & ?[c]:(U(1,c) & cake(c) & ?[b]:(is_big(b) & arg1(b)=c) & arg2(m)=c)) & ![b]:(B(b) => ?[h]:(arg1(h)=s & hang(h) & past(h) & arg2(h)=b))))
#
#  "the doctor watched everyone sleep."
#  ?[d]:(U(0,d) & doctor(d) & ?[X]:(X=^[x]:(U(1,x) & animate/anthropomorphic(x)) & ![x]:(X(x) => ?[w]:(arg1(w)=d & watch(w) & past(w) & arg2(w)=x))))
# NOTE: We model pragmatic domain restriction implicitly. In this example,
# `^[x]:U(0,x)` contains the doctor but `^[x]:U(1,x)` contains everyone being
# monitored by the doctor but does not contain the doctor.
#
#  "John can play the guitar, and Mary, the violin."
#  ?[c]:(arg1(c)=john & capable_of(c) & present(c) & arg2(c)=possibility(?[p]:(play(p) & ?[g]:(U(0,g) & guitar(g) & arg2(p)=g)))) & ?[e]:(arg1(e)=mary & empty_ref(0,e) & ?[v]:(U(1,v) & violin(v) & arg2(e)=v))
#
#  "John can play his guitar. Mary, too."
#  ?[c]:(arg1(c)=john & capable_of(c) & present(c) & arg2(c)=possibility(?[p]:(play(p) & ?[g]:(U(0,g) & guitar(g) & arg2(p)=g)))) & ?[e]:(arg1(e)=mary & empty_ref(0,e) & too(e))
#
#  "she walked and sat under every tree and near every rock."
#  ?[s]:(U(0,s) & female_ref(s) & ?[T]:(T=^[x]:(U(1,x) & tree(x)) & ?[R]:(R=^[y]:(U(2,y) & rock(y)) & ![x]:(T(x) => ![y]:(R(y) => ?[w]:(arg1(w)=s & walk(w) & past(w) & ?[u]:(under(u) & arg1(u)=w & arg2(u)=x) & ?[n]:(near(n) & arg1(n)=w & arg2(n)=y)) & ?[a]:(arg1(a)=s & sit(a) & past(a) & ?[u]:(under(u) & arg1(u)=a & arg2(u)=x) & ?[n]:(near(n) & arg1(n)=a & arg2(n)=y)))))))
#
#  "John wants and is able to swim and dance."
#  "John wants to and is able to swim and dance."
#  ?[w]:(arg1(w)=john & want(w) & present(w) & arg2(w)=possibility(?[s]:swim(s) & ?[d]:dance(d))) & ?[c]:(arg1(c)=john & capable_of(c) & present(c) & arg2(c)=possibility(?[s]:swim(s) & ?[d]:dance(d)))
#
#  "the house is Kim's."
#  ?[h]:(U(0,h) & house(h) & ?[o]:(arg1(o)=h & inverse(own)(o) & present(o) & arg2(o)=kim))
#
#  "the pencils are the students'."
#  ?[X]:(X=^[x]:(U(0,x) & pencil(x)) & ?[Y]:(Y=^[y]:(Y(1,y) & student(y)) & ![x,y]:(X(x) & Y(y) => ?[o]:(arg1(o)=x & inverse(own)(o) & present(o) & arg2(o)=y))))
#
#  "flower seller has carnations."
#  ?[C]:(subset(C,^[x]:(U(0,x) & carnation(x))) & ?[x]:(?[s]:(?[f]:(U(1,f) & flower(f) & arg2(s)=f) sell(s) & arg1(s)=x) & U(2,x) & ![c]:(C(c) => ?[o]:(arg1(o)=x & own(o) & present(o) & arg2(o)=c))))
#
#  "John swam extremely quickly."
#  ?[s]:(arg1(s)=john & swim(s) & past(s) & ?[q]:(?[e]:(extreme(e) & arg1(e)=q) & quick(q) & arg1(q)=s))
#
#  "John arrived 10 minutes late."
#  ?[a]:(arg1(s)=john & arrive(a) & past(a) & ?[l]:(arg2(l)=(10*minute) & late(l) & arg1(l)=a))
#
#  "they ran away from the house and from the tree."
#  ?[T]:(U(0,T) & plural_ref(T) & ![x]:(T(x) => ?[r]:(arg1(r) & run(r) & past(r) & ?[a]:(away(a) & arg1(a)=r & ?[h]:(U(1,h) & house(h) & arg2(a)=h)) & ?[a]:(away(a) & arg1(a)=r & ?[t]:(U(2,t) & tree(t) & arg2(a)=t)))))
#
#  "they ran away from the house and the tree."
#  ?[T]:(U(0,T) & plural_ref(T) & ![x]:(T(x) => ?[r]:(arg1(r) & run(r) & past(r) & ?[X]:(?[h]:(U(1,h) & house(h) & ?[t]:(U(2,t) & tree(t) & Y=^[y]:(y=h | y=t))) & ![y]:(Y(y) => ?[a]:(away(a) & arg1(a)=r & arg2(a)=y))))))
#
#  "that Constance is smart is not surprising."
#  ~?[x]:(arg1(x)=possibility(?[s]:(arg1(s)=constance & smart(s) & present(s))) & surprise(x) & present_progressive(x))
#
#  "that all cats are mammals is not surprising."
#  ~?[x]:(arg1(x)=possibility(![x]:(U(0,x) & cat(x) => ?[s]:(arg1(s)=x & same(s) & present(s) & ?[m]:(U(1,m) & mammal(m) & arg2(s)=m)))) & surprise(x) & present_progressive(x))
#
#  "i am glad that you arrived."
#  ?[h]:(arg1(h)=me & happy(h) & present(h) & ?[a]:(arg1(a)=you & arrive(a) & past(a) & arg2(h)=a))
#
#  "i will buy what she wants."
#  "i will buy whatever she wants."
#  ?[b]:(arg1(b)=me & buy(b) & future(b) & ?[x]:(?[w]:(?[h]:(U(0,h) & female_ref(h) & arg1(w)=h) & want(w) & arg2(w)=x) & arg2(b)=x))
#
#  "are you generous?"
#  "you are generous?"
#  ^[x]:(x=?[g]:(arg1(g)=you & generous(g) & present(g)))
#
#  "how generous are you?"
#  ^[x]:?[g]:(?[d]:(degree(d) & arg1(d)=g & arg2(d)=x) & arg1(g)=you & generous(g) & present(g))
#
#  "did they see her?"
#  ^[x]:x=?[T]:(U(0,T) & plural_ref(T) & ?[h]:(U(1,h) & female_ref(h) & ?[t]:(T(t) & ?[s]:(arg1(s)=t & see(s) & past(s) & arg2(s)=h))))
#
#  "did they all see her?"
#  ^[x]:x=?[T]:(U(0,T) & plural_ref(T) & ?[h]:(U(1,h) & female_ref(h) & ![t]:(T(t) => ?[s]:(arg1(s)=t & see(s) & past(s) & arg2(s)=h))))
#
#  "which store did Jason run to?"
#  "to which store did Jason run?"
#  "Jason ran to which store?"
#  "what store did Jason run to?"
#  "to what store did Jason run?"
#  "Jason ran to what store?"
#  ^[x]:(?[S]:(S=^[s]:(U(s,0) & store(s)) & S(x) & ?[r]:(arg1(r)=jason & run(r) & past(r) & arg2(r)=x)))
#
#  "which stores did Jason run to?"
#  "to which stores did Jason run?"
#  "Jason ran to which stores?"
#  "what stores did Jason run to?"
#  "to what stores did Jason run?"
#  "Jason ran to what stores?"
#  ^[X]:(subset(X,^[s]:(U(s,0) & store(s))) & ![x]:(X(x) => ?[r]:(arg1(r)=jason & run(r) & past(r) & arg2(r)=x)))
#
#  "is it red or blue?"
#  ^[x]:?[i]:(U(0,i) & ref(i) & true(x) & (x=possibility(?[r]:(arg1(r)=i & red(r) & present(r))) | x=possibility(?[b]:(arg1(b)=i & blue(b) & present(b)))))
#
#  "how big is the earth?"
#  ^[x]:?[b]:(?[d]:(degree(d) & arg1(d)=b & arg2(d)=x) arg1(b)=earth & big(b))
#
#  "Kim knows whether the earth is big."
#  ?[k]:(arg1(k)=kim & know(k) & present(k) & arg2(k)=^[x]:x=?[b]:(arg1(b)=earth & big(b) & present(b)))
#
#  "Kim knows how big the earth is."
#  ?[k]:(arg1(k)=kim & know(k) & present(k) & arg2(k)=^[x]:?[b]:(?[d]:(degree(d) & arg1(d)=b & arg2(d)=x) arg1(b)=earth & big(b)))
#
#  "how to make an omelet?"
#  ^[x]:?[m]:(?[y]:(manner(y) & arg1(y)=m & arg2(y)=x) & make(m) & ?[o]:(U(0,o) & omelet(o) & arg2(m)=o))
#
#  "Jason knows how to make an omelet."
#  ?[k]:(arg1(k)=jason & know(k) & present(k) & arg2(k)=^[x]:?[m]:(?[y]:(manner(y) & arg1(y)=m & arg2(y)=x) & make(m) & ?[o]:(U(0,o) & omelet(o) & arg2(m)=o)))
#
#  "whether running or swimming, Emma is quick."
#  (?[r]:(arg1(r)=emma & run(r) & present_progressive(r)) | ?[s]:(arg1(s)=emma & swim(s) & present_progressive(s))) => ?[q]:(arg1(q)=emma & quick(q))
#
#  "Noah was intrigued by what strange people inhabited this place."
#  TODO: label this and ensure the grammar can handle it
#
#  "the necklace which Emma gave to her is in the safe."
#  "the necklace, which Emma gave to her, is in the safe."
#  ?[l]:(?[n]:(U(0,n) & necklace(n) & ?[g]:(arg1(g)=emma & give(g) & past(g) & ?[h]:(U(1,n) & female_ref(h) & arg3(g)=h) & arg2(g)=n) & arg1(l)=n) & location(l) & present(l) & ?[s]:(U(2,s) & safe(s) & arg2(l)=s))
#
#  "Jason, who is my brother, is here."
#  ?[l]:(?[j]:(j=jason & ?[b]:(arg1(b)=me & brother_of(b) & present(b) & arg2(b)=j) & arg1(l)=j) location(l) & present(l) & arg2(l)=here)
#
#  "a person walked into the room who looked like Emma."
#  ?[p]:(U(0,p) & person(p) & ?[w]:(arg1(w)=p & walk(w) & past(w) & ?[r]:(U(1,r) & room(r) & arg2(w)=r)) & ?[v]:(arg1(v)=p & visually_similar(v) & arg2(v)=emma))
#
#  "Sirius is brighter."
#  ?[g]:(arg1(g)=sirius & greater(brightness)(g) & present(g))
#
#  "Sirius is brighter than Vega."
#  ?[g]:(arg1(g)=sirius & greater(brightness)(g) & present(g) & arg2(g)=vega)
# where we can add an axiom such as ![x,y,f]:(?[g]:(greater(f)(g) & arg1(g)=x & arg2(g)=y) & ~is_real_number(y) & ?[b]:(f(b) & arg1(b)=y) = ?[g]:(greater(f)(g) & arg1(g)=x & ?[b]:(brightness(b) & arg1(b)=y & arg2(g)=arg2(b))))
# as well as equivalent axioms for things like height, shortness, size, length, etc.
#
#  "i see a brighter star than Vega."
#  ?[s]:(arg1(s)=me & see(s) & present(s) & ?[x,r]:(?[g]:(greater(brightness)(g) & arg1(g)=x & arg2(g)=r) & U(0,x) & star(x) & r=vega & arg2(s)=x))
#
#  "i see a star brighter than Vega."
#  ?[s]:(arg1(s)=me & see(s) & present(s) & ?[x]:(U(0,x) & star(x) & ?[g]:(greater(brightness)(g) & arg1(g)=x & arg2(g)=vega) & arg2(s)=x))
#
#  "Sirius is brighter than we thought."
#  ?[X]:(X=us & ![x]:(X(x) => ?[g]:(arg1(g)=sirius & greater(brightness)(g) & ?[t]:(arg1(t)=x & think(t) & past(t) & arg2(t)=arg2(g)))))
#
#  "Sirius is the brightest star."
#  ?[s]:(arg1(s)=sirius & same(s) & present(s) & ?[X]:(?[g]:(greatest(brightness)(g) & arg2(s)=arg1(g) & arg2(g)=X) & X=^[x]:(U(0,x) & star(x))))
#
#  "Sirius is the brightest."
#  ?[s]:(arg1(s)=sirius & same(s) & present(s) & ?[g]:(greatest(brightness)(g) & arg2(s)=arg1(g)))
#
#  "a brighter star could be seen with the telescope than without it"
#  ?[x,r]:(?[g]:(greater(brightness)(g) & arg1(g)=x & arg2(g)=r) & U(0,x) & star(x) & ?[c]:(capable_of(c) & arg2(c)=possibility(?[s]:(arg1(s)=x & inverse(see)(s) & ?[w]:(with(w) & ?[t]:(U(2,t) & telescope(t) & arg1(w)=t)) & ?[y]:(arg1(y)=r & ~?[w]:(with(w) & ?[t]:(U(1,t) & telescope(t) & arg1(w)=t)))))))
#
#  "brighter stars could be seen with the telescope than without it"
#  ?[X,R]:(subset(X,^[x]:(![r]:(R(r) => ?[g]:(greater(brightness)(g) & arg1(g)=x & arg2(g)=r)) & U(0,x) & star(x))) & ![x]:(X(x) => ?[c]:(capable_of(c) & arg2(c)=possibility(?[s]:(arg1(s)=x & inverse(see)(s) & ?[w]:(with(w) & ?[t]:(U(2,t) & telescope(t) & arg1(w)=t)) & R=^[r]:?[y]:(arg1(y)=r & ~?[w]:(with(w) & ?[t]:(U(1,t) & telescope(t) & arg1(w)=t))))))))
#
#  "last time i went to campus, i took the bus"
#  ?[t]:(?[l]:(last_time(l) & arg1(l)=t & arg2(l)=^[g]:(arg1(g)=me & go(g) & past(g) & ?[c]:(U(0,c) & campus(c) & arg2(g)=c))) & arg1(t)=me & take(t) & past(t) & ?[b]:(U(1,b) & bus(b) & arg2(t)=b))
#    [OR]
#  ?[t]:(?[l]:(last_time(l) & arg1(l)=t & ?[S]:(S=^[g]:(arg1(g)=me & go(g) & past(g) & ?[c]:(U(0,c) & campus(c) & arg2(g)=c)) & arg2(l)=S)) & arg1(t)=me & take(t) & past(t) & ?[b]:(U(1,b) & bus(b) & arg2(t)=b))
# where we could have an axiom like ![x,S]:(?[l]:(last_time(l) & arg1(l)=x & arg2(l)=S) = ~?[y]:(S(y) & start_time(y)>end_time(x) & start_time(y)<now))
#
#  "last time, i took the bus"
#  ?[t]:(?[l]:(last_time(l) & arg1(l)=t) & arg1(t)=me & take(t) & past(t) & ?[b]:(U(0,b) & bus(b) & arg2(t)=b))
#
#  "i took the same bus as i took yesterday."
#  ?[t]:(arg1(t)=me & take(t) & past(t) & ?[b,r]:(?[s]:(same(s) & arg1(s)=b & arg2(s)=r) & U(0,b) & bus(b) & ?[y]:(arg1(y)=me & take(y) & past(y) & arg2(y)=r & ?[z]:(yesterday(z) & arg1(z)=y)) & arg2(t)=b))
#
#  "i took the same bus as i took last time."
#  ?[t]:(arg1(t)=me & take(t) & past(t) & ?[b,r]:(?[s]:(same(s) & arg1(s)=b & arg2(s)=r) & U(0,b) & bus(b) & ?[y]:(arg1(y)=me & take(y) & past(y) & arg2(y)=r & ?[z]:(last_time(z) & arg1(z)=y)) & arg2(t)=b))
#
#  "i took the same bus as last time."
#  ?[t]:(arg1(t)=me & take(t) & past(t) & ?[b,r]:(?[s]:(same(s) & arg1(s)=b & arg2(s)=r) & U(0,b) & bus(b) & ?[y]:(arg2(y)=r & ?[z]:(last_time(z) & arg1(z)=y)) & arg2(t)=b))
#
#  "Sirius is as bright as Vega."
#  ?[g]:(arg1(g)=sirius & greater_than_or_equal(brightness)(g) & present(g) & arg2(g)=vega)
#
#  "last time i had a party, 7 people came"
#  ?[P]:(subset(P,^[p]:(U(0,p) & person(p))) & size(P)=7 & ![p]:(P(p) => ?[g]:(?[l]:(last_time(l) & arg1(l)=g & arg2(l)=^[h]:(arg1(h)=me & have(h) & past(h) & ?[p]:(U(1,p) & party(p) & arg2(h)=p))) & arg1(g)=p & go(g) & past(g))))
#
#  "more people came to the party than people came last time i had a party."
#  ?[P,R]:(size(P)>size(R) & subset(P,^[p]:(U(0,p) & person(p))) & ![p]:(P(p) => ?[g]:(arg1(g)=p & go(g) & past(g) & R=^[r]:(U(1,r) & person(r) & ?[g]:(arg1(g)=r & go(g) & past(g) & ?[l]:(last_time(l) & arg1(l)=g & arg2(l)=^[h]:(arg1(h)=me & have(h) & ?[p]:(U(2,p) & party(p) & arg2(h)=p))))))))
#
#  "more people came than people came last time."
#  ?[P,R]:(size(P)>size(R) & subset(P,^[p]:(U(0,p) & person(p))) & ![p]:(P(p) => ?[g]:(arg1(g)=p & go(g) & past(g) & R=^[r]:(U(1,r) & person(r) & ?[g]:(arg1(g)=r & go(g) & past(g) & ?[l]:(last_time(l) & arg1(l)=g))))))
#
#  "more people came than last time."
#  ?[P,R]:(size(P)>size(R) & subset(P,^[p]:(U(0,p) & person(p))) & ![p]:(P(p) => ?[g]:(arg1(g)=p & go(g) & past(g) & R=^[r]:(?[g]:(arg1(g)=r & ?[l]:(last_time(l) & arg1(l)=g))))))
#
#  "more girls but fewer boys came than last time."
#  ?[P,R]:(?[G,R1]:(size(G)>size(R1) & subset(G,^[g]:(U(0,g) & girl(g))) & ?[B,R2]:(size(B)<size(R2) & subset(B,^[b]:(U(1,b) & boy(b))) & P=^[s]:(s=G | s=B) & R=^[s]:(s=R1 | s=R2))) & ![s]:(P(s) => ![p]:(s(p) => ?[g]:(arg1(g)=p & go(g) & past(g) & ![Ri]:(R(Ri) => Ri=^[r]:(?[g]:(arg1(g)=r & ?[l]:(last_time(l) & arg1(l)=g))))))))
#
#  "a taller person came than last time."
#  ?[x,r]:(?[g]:(greater(height)(g) & arg1(g)=x & arg2(g)=r) & U(0,x) & person(x) & ?[g]:(arg1(g)=x & go(g) & past(g) & ?[g]:(arg1(g)=r & ?[l]:(last_time(l) & arg1(l)=g))))
#
#  "taller people came than last time."
#  ?[X,R]:(subset(X,^[x]:(![r]:(R(r) => ?[g]:(greater(height)(g) & arg1(g)=x & arg2(g)=r)) & U(0,x) & person(x))) & ?[g]:(arg1(g)=x & go(g) & past(g) & R=^[r]:(?[g]:(arg1(g)=r & ?[l]:(last_time(l) & arg1(l)=g)))))
#
#  "she is older than i am."
#  ?[g]:(?[h]:(U(0,h) & female_ref(h) & arg1(g)=h) & greater(age)(g) & ?[y]:(arg1(y)=me & arg2(g)=y))
# where `y` could have type `age_of`.
#
#  "she wrote more plays than i wrote novels."
#  ?[h]:(U(0,h) & female_ref(h) & ?[P,N]:(size(P)>size(N) & subset(P,^[p]:(U(1,p) & play(p))) & ![p]:(P(p) => ?[w]:(arg1(w)=h & write(w) & past(w) & arg2(w)=p & N=^[n]:(U(2,n) & novel(n) & ?[w]:(arg1(w)=me & write(w) & past(w) & arg2(w)=n))))))
#
#  "we spend more time in France than in Germany."
#  ?[X]:(X=us & ![x]:(X(x) => ?[s]:(arg1(s)=x & spend_time(s) & present(s) & ?[g]:(greater(time)(g) & arg1(g)=s & ?[l]:(located(l) & arg1(l)=s & arg2(l)=france) & ?[y]:(?[l]:(located(l) & arg1(l)=y & arg2(l)=germany) & arg2(g)=y)))))
# TODO: implement this in the grammar
#
#  "he plays better drunk than sober."
#  ?[p]:(?[h]:(U(0,h) & male_ref(h) & arg1(p)=h) & play(p) & present(p) & ?[g]:(greater(skill)(g) & arg1(g)=p & ?[d]:(drunk(d) & arg1(d)=p) & ?[y]:(?[s]:(sober(s) & arg1(s)=y) arg2(g)=y)))
#
#  "it is better to try and fail than to not try at all."
#  ?[b]:(better(b) & arg1(b)=possibility(?[t]:try(t) & ?[f]:fail(f)) & arg2(b)=possibility(~?[t]:try(t)))
#
#  "it is better that he tried and failed than not try at all."
#  ?[b]:(better(b) & arg1(b)=possibility(?[t]:(try(t) & past(t)) & ?[f]:(fail(f) & past(f))) & arg2(b)=possibility(~?[t]:try(t)))
#
#  "the flower is more red than pink."
#  ?[f]:(U(0,f) & flower(f) & ?[g]:(greater(degree)(g) & ?[r]:(arg1(r)=f & red(r) & arg1(g)=r & ?[p]:(pink(p) & arg2(g)=p))))
#
#  "i saw four times as many cats as i saw dogs."
#  ?[C,D]:(size(C)=4*size(D) & C=^[x]:(U(0,x) & cat(c)) & ![x]:(C(x) => ?[s]:(arg1(s)=me & see(s) & past(s) & arg2(s)=x & D=^[y]:(?[z]:(arg1(z)=me & see(z) & past(z) & U(1,y) & dog(y) & arg2(z)=y)))))
#
#  "i saw four times as many cats as dogs."
#  ?[C,D]:(size(C)=4*size(D) & C=^[x]:(U(0,x) & cat(c)) & ![x]:(C(x) => ?[s]:(arg1(s)=me & see(s) & past(s) & arg2(s)=x & D=^[y]:(?[z]:(U(1,y) & dog(y) & arg2(z)=y)))))
#
#  "i earn four times as much as Ned earns."
#  ?[X,R]:(size(X)=4*size(R) & ![x]:(X(x) => ?[e]:(arg1(e)=me & earn(e) & present(e) & arg2(e)=x & R=^[r]:(?[y]:(arg1(y)=ned & earn(y) & present(y) & arg2(y)=r)))))
#
#  "they work harder the more we pay them."
#  ?[t]:(U(0,t) & plural_ref(t) & ![x]:(t(x) => ?[p]:(?[i]:(increase(quantity)(i) & arg1(i)=p) & arg1(p)=we & pay(p) & present(p) & arg2(p)=x))) => ?[t]:(U(1,t) & plural_ref(t) & ![x]:(t(x) => ?[w]:(arg1(w)=x & work(w) & present(w) & ?[i]:(increase(effort)(i) & arg1(i)=w))))
#
#  "they work harder if we pay them more."
#  ?[t]:(U(0,t) & plural_ref(t) & ![x]:(t(x) => ?[p]:(arg1(p)=we & pay(p) & present(p) & arg2(p)=x & ?[i]:(increase(quantity)(i) & arg1(i)=p)))) => ?[t]:(U(1,t) & plural_ref(t) & ![x]:(t(x) => ?[w]:(arg1(w)=x & work(w) & present(w) & ?[i]:(increase(effort)(i) & arg1(i)=w))))
#
#  "the more we pay them, the harder they work."
#  ?[t]:(U(0,t) & plural_ref(t) & ![x]:(t(x) => ?[p]:(?[i]:(increase(quantity)(i) & arg1(i)=p) & arg1(p)=we & pay(p) & present(p) & arg2(p)=x))) => ?[t]:(U(1,t) & plural_ref(t) & ![x]:(t(x) => ?[w]:(?[i]:(increase(effort)(i) & arg1(i)=w) & arg1(w)=x & work(w) & present(w))))
#
#  "the more money we pay them, the harder they work."
#  ?[t]:(U(0,t) & plural_ref(t) & ![x]:(t(x) => ?[p]:(?[i]:(increase(quantity)(i) & ?[m]:(U(1,m) & money(m) & arg1(i)=m & arg3(p)=m)) & arg1(p)=we & pay(p) & present(p) & arg2(p)=x))) => ?[t]:(U(2,t) & plural_ref(t) & ![x]:(t(x) => ?[w]:(?[i]:(increase(effort)(i) & arg1(i)=w) & arg1(w)=x & work(w) & present(w))))
#
#  "he is richer."
#  ?[h]:(U(0,h) & male_ref(h) & ?[i]:(arg1(i)=h & increase(wealth)(i) & present(i)))
#
#  "he became richer."
#  ?[h]:(U(0,h) & male_ref(h) & ?[i]:(arg1(i)=h & increase(wealth)(i) & past(i)))
#
#  "it is a difficult book to understand."
#  ?[i]:(U(0,i) & ref(i) & ?[s]:(arg1(s)=i & same(s) & present(s) & ?[b]:(?[d]:(difficult(d) & arg1(d)=b & arg2(d)=possibility(?[u]:(arg2(u)=b & understand(u)))) & U(1,b) & book(b) & arg2(s)=b)))


S nonterminal {} {1.0} {1.0} {} 10 1.0 {}

S -> S' PERIOD

# for closed interrogatives that are essentially declarative with a question mark
# S {^[x]:x=A} -> S' {A}
# S {^[x]:(... & true(x) & (x=possibility(A1) | ... | x=possibility(An)))} -> S' {... & (A1 | ... | An)}
S -> S' QUESTION

# for all other interrogatives
# S {^[x]:A} -> S' {^[x]:A}
S -> S' QUESTION


# This is the root nonterminal for declarative sentences.
S' nonterminal {} {1.0} {1.0} {} 10 1.0 {}
S' -> S'':singular,try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,require_no_for
S' -> S'':plural,try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,require_no_for

# for subordinate clauses
S' -> THAT S':try_remove_comma,try_remove_correlated,remove_that
S' -> WHETHER S':try_remove_comma,try_remove_correlated,remove_whether
S' -> WHETHER OR NOT S':try_remove_comma,try_remove_correlated,remove_whether
S' -> IF S':try_remove_comma,try_remove_correlated,remove_if
S' -> BECAUSE S':try_remove_comma,try_remove_correlated,remove_because
S' -> FOR S':try_remove_comma,try_remove_correlated,remove_for

# (non-predicative) preposed VP complements/adjuncts
# S' {... & (~)?[y1]:(f(y1) & g1(y1)) & ... & (~)?[yn]:(f(yn) & gn(yn))}
#  -> V_ADJUNCT {... & ?[y1]:(p1(y1) & f(y1)) & ... & ?[yn]:(pn(yn) & f(yn))}
#     (COMMA) S' {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
S' -> V_ADJUNCT:try_remove_comma,try_remove_nullable_subject,require_no_that,require_no_whether,require_no_if,require_no_because,require_no_for S':try_remove_comma,try_remove_correlated
S' -> V_ADJUNCT:try_remove_comma,try_remove_nullable_subject,require_no_that,require_no_whether,require_no_if,require_no_because,require_no_for COMMA S':try_remove_comma,try_remove_correlated

# (predicative) preposed VP complements/adjuncts
# S' {... & (~)?[y1]:(f(y1) & p(y1) & f1(y1)) & ... & (~)?[yn]:(f(yn) & p(yn) & fn(yn))}
#  -> V_ADJUNCT {... & ?[y]:(p(y) & f(y))}
#     (COMMA) S' {... & (~)?[y1]:f1(y1) & ... & (~)?[yn]:fn(yn)}
# This rule removes the predicate `p` from the event corresponding to the verb
# (and so the verb is semantically empty) such as in "blue, the cat is" and "in
# the tree, the cat is". `fi` contains verb-specific terms such as `present` as
# well as any adjuncts or other arguments of y whereas `f` contains everything
# else, such as the argument.
S' -> V_ADJUNCT:try_remove_comma,try_remove_nullable_subject,require_no_that,require_no_whether,require_no_if,require_no_because,require_no_for S':try_remove_comma,try_remove_correlated
S' -> V_ADJUNCT:try_remove_comma,try_remove_nullable_subject,require_no_that,require_no_whether,require_no_if,require_no_because,require_no_for COMMA S':try_remove_comma,try_remove_correlated

# S' {?[X]:(f(X) & ![x]:(X(x) => (true(x) => g(x))))}
#  -> S' {g(x)}
#     (COMMA)
#     PP {?[X]:(f(X) & ![x]:(X(x) => (true(x) => P(x))))}
# NOTE: We don't allow other adjuncts here to avoid the spurious ambiguity
# where the PP could also attach at VP.
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,require_no_for PP:try_remove_comma,try_remove_nullable_subject,try_remove_correlated
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,require_no_for COMMA PP:try_remove_comma,try_remove_nullable_subject,try_remove_correlated

# S' {A => B} -> IF/WHETHER S' {A} (COMMA) (THEN) S' {B}
# S' {^[x]:x=(A => B)} -> IF/WHETHER S' {A} (COMMA) (THEN) S' {^[x]:x=B}
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,require_no_for,add_if S':try_remove_comma,try_remove_correlated
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,require_no_for,add_if COMMA S':try_remove_comma,try_remove_correlated
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,require_no_for,add_if THEN S':try_remove_comma,try_remove_correlated
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,require_no_for,add_if COMMA THEN S':try_remove_comma,try_remove_correlated
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,require_no_for,add_whether S':try_remove_comma,try_remove_correlated
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,require_no_for,add_whether COMMA S':try_remove_comma,try_remove_correlated
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,require_no_for,add_if,add_subjunctive S':try_remove_comma,try_remove_correlated
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,require_no_for,add_if,add_subjunctive COMMA S':try_remove_comma,try_remove_correlated
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,require_no_for,add_if,add_subjunctive THEN S':try_remove_comma,try_remove_correlated
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,require_no_for,add_if,add_subjunctive COMMA THEN S':try_remove_comma,try_remove_correlated
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,require_no_for,add_whether,add_subjunctive S':try_remove_comma,try_remove_correlated
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,require_no_for,add_whether,add_subjunctive COMMA S':try_remove_comma,try_remove_correlated

# (not preposed) correlative comparative constructions
# S' {... & ?[y]:(?[i]:f(i) & g(y)) => B}
#  -> S' {B}
#     THE ADJP_L/ADVP_L {^[P]:(... & ?[i]:(f(i) & P(i)))}
#     S' {... & ?[y]:g(y)}
# S' {... & ?[i]:(p(i) & f(y)) => B}
#  -> S' {B}
#     THE ADJP_L/ADVP_L {^[P]:(... & ?[i]:(p(i) & P(i)))}
#     S' {... & ?[i]:f(i)}
# e.g. "they work harder the more (money) we pay them.", "he becomes more cynical the older he gets."
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,require_no_for THE ADJP_L:try_remove_comma,try_remove_correlated S':try_remove_comma,try_remove_correlated
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,require_no_for THE ADVP_L:try_remove_comma,try_remove_correlated S':try_remove_comma,try_remove_correlated

# (preposed) correlative comparative constructions
# S' {... & ?[y]:(?[i]:f1(i) & g1(y)) => ... & ?[y]:(?[i]:f2(i) & g2(y))}
#  -> THE ADJP_L/ADVP_L {^[P]:(... & ?[i]:(f1(i) & P(i)))}
#     S' {... & ?[y]:g1(y)}
#     COMMA THE ADJP_L/ADVP_L {^[P]:(... & ?[i]:(f2(i) & P(i)))}
#     S' {... & ?[y]:g2(y)}
# S' {... & ?[i]:(p1(i) & f1(y)) => ... & ?[y]:(?[i]:f2(i) & g2(y))}
#  -> THE ADJP_L/ADVP_L {^[P]:(... & ?[i]:(p1(i) & P(i)))}
#     S' {... & ?[y]:f1(y)}
#     COMMA THE ADJP_L/ADVP_L {^[P]:(... & ?[i]:(f2(i) & P(i)))}
#     S' {... & ?[y]:g2(y)}
# NOTE: The consequent could also be predicative in the same way as the antecedent.
# e.g. "the more (money) we pay them, the harder they work.", "the older he gets, the more cynical he becomes."
S' -> THE ADJP_L:try_remove_comma,try_remove_correlated S':try_remove_comma,try_remove_correlated,require_no_that,require_no_whether,require_no_if,require_no_because,require_no_for COMMA THE ADJP_L:try_remove_comma,try_remove_correlated S':try_remove_comma,try_remove_correlated
S' -> THE ADJP_L:try_remove_comma,try_remove_correlated S':try_remove_comma,try_remove_correlated,require_no_that,require_no_whether,require_no_if,require_no_because,require_no_for COMMA THE ADVP_L:try_remove_comma,try_remove_correlated S':try_remove_comma,try_remove_correlated
S' -> THE ADVP_L:try_remove_comma,try_remove_correlated S':try_remove_comma,try_remove_correlated,require_no_that,require_no_whether,require_no_if,require_no_because,require_no_for COMMA THE ADJP_L:try_remove_comma,try_remove_correlated S':try_remove_comma,try_remove_correlated
S' -> THE ADVP_L:try_remove_comma,try_remove_correlated S':try_remove_comma,try_remove_correlated,require_no_that,require_no_whether,require_no_if,require_no_because,require_no_for COMMA THE ADVP_L:try_remove_comma,try_remove_correlated S':try_remove_comma,try_remove_correlated

# for correlated coordination
# NOTE: For the following rules, the coordination doesn't have to be at head
# scope, it can be the left-most coordination that is a descendant of the head
# scope as well, so long as there is no negation between the coordination and
# the root. However, we need some measure of "distance" between the
# coordination and the head scope to be a feature to decide between the rules
# at this nonterminal (e.g. "both" moves left much less often than "either").
# S' {A1 | ... | An} -> EITHER S' {A1 | ... | An}
S' -> S':add_either,add_correlated_by_either
S' -> EITHER:require_not_correlated,require_no_coordination S':add_correlated_by_either
# S' {A1 & A2} -> BOTH S' {A1 & A2}
S' -> S':add_both,add_correlated_by_both
S' -> BOTH:require_not_correlated,require_no_coordination S':add_correlated_by_both

# S' {A1 & ... & An} -> S' {A1} COMMA S' {A2 & ... & An}
# S' {A1 | ... | An} -> S' {A1} COMMA S' {A2 | ... | An}
# S' {~A1 & ... & ~An} -> S' {~A1} COMMA S' {~A2 & ... & ~An}
# In the NOR rule, the negation can appear in front of the scope ?[yi], or in
# front of any parent scope of ?[yi] (within Ai).
S' -> S':try_remove_comma,try_remove_coordination COMMA S':add_comma,add_coordination # for n > 2
S' -> S':try_remove_comma,try_remove_coordination COMMA S':try_remove_comma,try_remove_coordination # for n == 2

# S' {A1 & ... & An} -> S' {A1} (COMMA) AND S' {A2 & ... & An}
S' -> S':try_remove_comma,try_remove_coordination COMMA AND S':add_coordination # for n > 2
S' -> S':try_remove_comma,try_remove_coordination AND S':add_coordination # for n > 2
S' -> S':try_remove_comma,try_remove_coordination COMMA AND S':try_remove_comma,try_remove_coordination # for n == 2
S' -> S':try_remove_comma,try_remove_coordination AND S':try_remove_comma,try_remove_coordination # for n == 2

# S' {A1 | ... | An} -> S' {A1} (COMMA) OR S' {A2 | ... | An}
S' -> S':try_remove_comma,try_remove_coordination COMMA OR S':add_coordination # for n > 2
S' -> S':try_remove_comma,try_remove_coordination OR S':add_coordination # for n > 2
S' -> S':try_remove_comma,try_remove_coordination COMMA OR S':try_remove_comma,try_remove_coordination # for n == 2
S' -> S':try_remove_comma,try_remove_coordination OR S':try_remove_comma,try_remove_coordination # for n == 2

# S' {A1 | ... | An} -> S' {~A1} (COMMA) NOR S' {A2}
S' -> S':try_remove_comma,try_remove_coordination,require_not_correlated_by_either COMMA NOR VP_R:add_req_aux,add_coordination # for n > 2
S' -> S':try_remove_comma,try_remove_coordination,require_not_correlated_by_either NOR VP_R:add_req_aux,add_coordination # for n > 2
S' -> S':try_remove_comma,try_remove_coordination,require_not_correlated_by_either COMMA NOR VP_R:add_req_aux,try_remove_comma,try_remove_coordination # for n == 2
S' -> S':try_remove_comma,try_remove_coordination,require_not_correlated_by_either NOR VP_R:add_req_aux,try_remove_comma,try_remove_coordination # for n == 2


S'' nonterminal {has_not} {1.0, 1.0} {1.0, 1.0} {} 10 1.0 {}

# S'' {(~)?[x]:f(x)} -> THERE IS NP {^[P]:?[X]:(X=^[x]:f(x) & (~)?[x]:(X(x) & P(x)))}
# NOTE: This above rule is only really useful if we choose to represent "there
# is a cat" as something like ?[x]:(U(0,x) & cat(x)).
S'' -> THERE IS NP:try_remove_nullable_subject,require_no_lambda,try_remove_correlated

# S'' {... & (~)?[y1]:(... & arg1/arg2(y1)=a & ...) & ... & (~)?[yn]:(... & arg1/arg2(yn)=a & ...}
#  -> NP {^[P]:?[X]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x)))}
#     VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
# S'' {... & (~)?[x]:(f(x) & (~)?[y1]:(... & arg1/arg2(y1)=x & ...) & ... & (~)?[yn]:(... & arg1/arg2(yn)=x & ...))} if x is not a set variable
#  -> NP {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)?[x]:(X(x) & P(x))))}
#     VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
# S'' {... & (~)![x]:(f(x) => ... & (~)?[y1]:(... & arg1/arg2(y1)=x & ...) & ... & (~)?[yn]:(... & arg1/arg2(yn)=x & ...))}
#  -> NP {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)![x]:(X(x) => P(x))))}
#     VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
# S'' {... & ?[X]:(f(X) & (~)![x]:(X(x) => ... & (~)?[y1]:(... & arg1/arg2(y1)=x & ...) & ... & (~)?[yn]:(... & arg1/arg2(yn)=x & ...)))}
#  -> NP {^[P]:(... & ?[X]:(f(X) & (~)![x]:(X(x) => P(x))))}
#     VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
# S'' {... & ?[X]:(f(X) & (~)?[y1]:(... & arg1/arg2(y1)=X & ...) & ... & (~)?[yn]:(... & arg1/arg2(yn)=X & ...))} if X is a set variable
#  -> NP {^[P]:(... & ?[X]:(f(X) & ![x]:(X(x) => P(x))))}
#     VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
# NOTE: The above three rules, during the inverse transformation, the scope of
# X and x can be positioned anywhere above the scope of y. However, to avoid
# producing semantically-equivalent logical forms, for each equivalence class
# of semantically-equivalent inverse logical forms, we only output a single
# logical form (for example, by choosing the logical form in the equivalence
# class in which the scope of X and x are maximal). Also, the above rule can be
# extended to other kinds of quantification over X, such as existential or weak
# universal quantifier. Also, note that f(X) and f(x) cannot depend on any
# variables other than those declared within f(X) and f(x). But note that in
# the example "a cat and dog are sleeping", f(X) includes the definition for
# "cat" and "dog". In the above three rules, the scope of y is the right-most
# and top-most scope of an event variable (a object with arguments).
# NOTE: This rule also handles open interrogatives but only when the unknown
# variable is in the logical form for the NP. In the logical forms of some
# interrogatives, X may be declared as a lambda variable.
# NOTE: The `arg2` version of the rule is for preposing.
# NOTE: In comparative constructions where sizes of sets are compared, this
# requires that the quantified variables are used in the same way in both
# consequents. That is, in:
#   ?[X]:(... & ?[R]:(f(size(X),size(R)) & ... & ![r]:(R(r) => ?[y]:(arg1/arg2/arg3(y)=r & ...))) & ... & ![x]:(X(x) => ?[y]:(arg1/arg2/arg3(y)=x & ...)))
# This rule requires that `arg1(y)=r` and `arg1(y)=x` appear in both
# consequents (or `arg2(y)=r` and `arg2(y)=x`, etc).
S'' -> NP:try_remove_nullable_subject,require_no_subordinate VP_R:try_remove_nullable_subject,try_remove_correlated

# NOTE: The above note also applies to these rules.
# S'' {... & ~?[x]:(f(x) & ?[y1]:(... & arg1/arg2(y1)=x & ...) & ... & ?[yn]:(... & arg1/arg2(yn)=x & ...))}
#  -> NP {^[P]:(... & ?[X]:(X=^[x]:f(x) & ?[x]:(X(x) & P(x))))}
#     VP_R {... & ~?[y1]:(...) & ... & ~?[yn]:(...)}
# S'' {... & ~![x]:(f(x) => ... & ?[y1]:(... & arg1/arg2(y1)=x & ...) & ... & ?[yn]:(... & arg1/arg2(yn)=x & ...))}
#  -> NP {^[P]:(... & ?[X]:(X=^[x]:f(x) & ![x]:(X(x) => P(x))))}
#     VP_R {... & ~?[y1]:(...) & ... & ~?[yn]:(...)}
# S'' {... & ?[X]:(f(X) & ~![x]:(X(x) => ... & ?[y1]:(... & arg1/arg2(y1)=x & ...) & ... & ?[yn]:(... & arg1/arg2(yn)=x & ...)))}
#  -> NP {^[P]:(... & ?[X]:(f(X) & ![x]:(X(x) => P(x))))}
#     VP_R {... & ~?[y1]:(...) & ... & ~?[yn]:(...)}
# NOTE: This rule also handles open interrogatives but only when the unknown
# variable is in the logical form for the NP. In the logical forms of some
# interrogatives, X may be declared as a lambda variable.
# NOTE: The `arg2` version of the rule is for preposing.
# NOTE: In comparative constructions where sizes of sets are compared, this
# requires that the quantified variables are used in the same way in both
# consequents. That is, in:
#   ?[X]:(... & ?[R]:(f(size(X),size(R)) & ... & ![r]:(R(r) => ?[y]:(arg1/arg2/arg3(y)=r & ...))) & ... & ![x]:(X(x) => ?[y]:(arg1/arg2/arg3(y)=x & ...)))
# This rule requires that `arg1(y)=r` and `arg1(y)=x` appear in both
# consequents (or `arg2(y)=r` and `arg2(y)=x`, etc).
S'' -> NP:try_remove_nullable_subject,require_no_subordinate VP_R:try_remove_nullable_subject,try_remove_correlated

# the subject is an open interrogative finite subordinate clause
# S'' {... & (~)?[y1]:(f(y1) & g1(y1)) & ... & (~)?[yn]:(f(yn) & gn(yn))}
#  -> S' {... & f'}
#     VP_R {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
# where f(y) = arg1(y)=^[x]:A and f' = ^[x]:A
# e.g. "what books she has are in the attic"
S'' -> S':try_remove_nullable_subject,require_no_subordinate,add_req_no_aux,add_subordinate VP_R:try_remove_nullable_subject,try_remove_correlated

# open interrogative clauses with movement
# S'' {^[x]:(... ?[X]:(... & X(x) & ... & ?[r]:(... & arg1/arg2/arg3(r)=x)))} note that X is not quantified here; `X(x)` kind of plays the role of a quantifier
#  -> NP {^[P,x]:(... & ?[X]:(... & X(x) & P(x)))}
#     VP_R {... & ?[r]:(...)}
# S'' {^[X]:(... & ![x]:(X(x) => ?[r]:(... & arg1/arg2/arg3(r)=x)))}
#  -> NP {^[P,X]:(... & ![X]:(X(x) => P(x)))}
#     VP_R {... & ?[r]:(...)}
# S'' {^[x]:(... & ?[r]:(... & arg1/arg2/arg3(r)=x))}
#  -> NP {^[P,x]:(... & ?[X]:(^[x]:U(x,0) & ... & X(x) & P(x)))}
#     VP_R {... & ?[r]:(...)}
# NOTE: `r` does not have to be the head of the logical form.
# NOTE: `r` can also be any scope that is an ancestor of x.
# e.g. "which store did Jason run to?", "what store did Jason run to?", "who is she speaking with?"
S'' -> NP:try_remove_nullable_subject,try_remove_subordinate VP_R:try_remove_nullable_subject,try_add_req_aux,try_remove_subordinate,try_remove_correlated # requires do-support unless subordinate
S'' -> NP:try_remove_nullable_subject,try_remove_subordinate VP_R:try_remove_nullable_subject,try_add_req_aux,try_remove_subordinate,try_remove_correlated,add_to_infinitive # requires do-support unless subordinate

# open interrogative clauses with movement
# S'' {^[x]:(... ?[X]:(... & X(x) & ... & ?[r]:(p(r) & f(r) & arg1/arg2/arg3(r)=x)))} note that X is not quantified here; `X(x)` kind of plays the role of a quantifier
#  -> PP {^[x]:(... ?[X]:(... & X(x) & ... & ?[r]:(p(r) & arg1/arg2/arg3(r)=x)))}
#     VP_R {... & ?[r]:(p(r) & f(r))}
# S'' {^[X]:(... & ![x]:(X(x) => ?[r]:(p(r) & f(r) & arg1/arg2/arg3(r)=x)))}
#  -> PP {^[X]:(... ![x]:(X(x) => ?[r]:(p(r) & arg1/arg2/arg3(r)=x)))}
#     VP_R {... & ?[r]:(p(r) & f(r))}
# S'' {^[x]:(... & ?[r]:(p(r) & f(r) & arg1/arg2/arg3(r)=x))}
#  -> PP {^[x]:(... & ?[r]:(p(r) & arg1/arg2/arg3(r)=x))}
#     VP_R {... & ?[r]:(p(r) & f(r))}
# where `f(r)` contains the verb-specific terms for the event `r`.
# NOTE: `r` does not have to be the head of the logical form.
# e.g. "to which store did Jason run?", "with whom is she speaking?"
S'' -> PP:try_remove_nullable_subject,try_remove_subordinate,add_preposition VP_R:try_remove_nullable_subject,try_add_req_aux,try_remove_subordinate,add_preposition,try_remove_correlated # requires do-support unless subordinate
S'' -> PP:try_remove_nullable_subject,try_remove_subordinate,add_preposition VP_R:try_remove_nullable_subject,try_add_req_aux,try_remove_subordinate,add_preposition,try_remove_correlated,add_to_infinitive # requires do-support unless subordinate

# open interrogative clauses with movement
# S'' {^[x]:(... ?[r]:(?[d]:(degree(d) & arg1(d)=r & arg2(d)=x) & p(r) & f(r)))}
#  -> ADJP_R {^[P,x]:?[r]:(?[d]:(degree(d) & arg1(d)=r & arg2(d)=x) & p(r))}
#     VP_R {^[x]:(... ?[r]:f(r))}
# NOTE: `r` does not have to be the head of the logical form.
# This rule removes the predicate `p` from the event corresponding to the verb
# (and so the verb is semantically empty).
# e.g. "how big is the earth?"
S'' -> ADJP:try_remove_nullable_subject,try_remove_subordinate VP_R:try_remove_nullable_subject,try_add_req_aux,try_remove_subordinate,try_remove_correlated # requires do-support unless subordinate
S'' -> ADJP:try_remove_nullable_subject,try_remove_subordinate VP_R:try_remove_nullable_subject,try_add_req_aux,try_remove_subordinate,try_remove_correlated,add_to_infinitive # requires do-support unless subordinate

# subject-less infinitival closed interrogative clauses
# S'' {^[x]:x=A} -> VP_R {A}
# S'' {^[x]:(... & true(x) & (x=possibility(A1) | ... | x=possibility(An)))} -> VP_R {... & (A1 | ... | An)}
S'' -> VP_R:remove_subordinate,require_no_arg1,require_to_infinitive

# subject-less infinitival open interrogative clauses
# S'' {^[x]:A} -> VP_R {^[x]:A}
S'' -> VP_R:try_remove_subordinate,require_no_arg1,add_to_infinitive

# closed interrogative clauses, which require subject-auxiliary inversion
# (excluding closed interrogative clauses we handle at the nonterminal S)
# S'' {^[x]:x=A} -> VP_R {A}
# S'' {^[x]:(... & true(x) & (x=possibility(A1) | ... | x=possibility(An)))} -> VP_R {... & (A1 | ... | An)}
S'' -> VP_R:try_add_req_aux # requires do-support unless subordinate

# S'' {... & ?[x]:(arg1(x)=possibility(A) & ...)} -> THAT S' {A} VP_R {... & ?[x]:(...)}
# e.g. "that Constance is smart is not surprising"
S'' -> S':remove_nullable_subject,add_that VP_R:remove_nullable_subject
# e.g. "that it be signed is a requirement"
S'' -> S':remove_nullable_subject,add_that,add_subjunctive VP_R:remove_nullable_subject,try_remove_correlated

# comparative constructions
# S'' {... & ?[x,r]:(?[g1]:(p(f1)(g1) & arg1(g1)=x & arg2(g1)=r) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x & arg2(gn)=r) & ... & ?[y]:(... & arg1(y)=x & ... & h(r) & ...))}
#  -> NP {^[P]:(... & ?[X]:(X=^[x]:(?[g1]:(p(f1)(g1) & arg1(g1)=x) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x) & ...) & ?[x]:(X(x) & P(x))))}
#     VP_R {... & ?[r]:(?[gn]:(p(fn)(gn) & arg2(gn)=r) & ... & ?[y]:(... & h(r) & ...))}
# where h(r) could either be `r=a` if r is a constant or it can define a new object like `U(i,r) & p(r) & ...`.
# S'' {... & ?[X,R]:(... & f(size(X),size(R)) & ... & F(X=^[x]:(![r]:(R(r) => ?[g1]:(p(f1)(g1) & arg1(g1)=x & arg2(g1)=r) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x & arg2(gn)=r)) & ...)) & ... & ![x]:(X(x) => ?[y]:(... & arg1(y)=x & ... & R=^[r]:(...) & ...)))}
#  -> NP {^[P]:(... & ?[X]:(... & f(size(X)) & ... & F(X=^[x]:(?[g1]:(p(f1)(g1) & arg1(g1)=x) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x))) & ... & ![x]:(X(x) => P(x))))}
#     VP_R {... & ?[R]:(f(size(R)) & ... & ![r]:(R(r) => ?[gn]:(p(fn)(gn) & arg2(gn)=r)) & ... & ?[y]:(... R=^[r]:(...) & ...))}
# S'' {... & ?[X,R]:(?[X1,R1]:(... & f(size(X1),size(R1)) & ... & F(X1=^[x]:(![r]:(R1(r) => ?[g1]:(p(f1)(g1) & arg1(g1)=x & arg2(g1)=r) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x & arg2(gn)=r)) & ...)) & ?[X2,R2]:(... & f(size(X2),size(R2)) & ... & F(X2=^[x]:(...)) & ... & X=^[S]:(S=X1 | ... | S=Xn) & R=^[S]:(S=R1 | ... | S=Rn))) & ... & ![S]:(X(S) => ![x]:(S(x) => ?[y]:(... & arg1(y)=x & ... & ![Ri]:(R(Ri) => Ri=^[r]:(...)) & ...))))}
#  -> NP {^[P]:(... & ?[X]:(... & f(size(X)) & ... & F(X=^[x]:(?[g1]:(p(f1)(g1) & arg1(g1)=x) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x))) & ... & ![x]:(X(x) => P(x))))}
#     VP_R {... & ?[Rn]:(f(size(Rn)) & ... & ![r]:(Rn(r) => ?[gn]:(p(fn)(gn) & arg2(gn)=r)) & ... & ?[y]:(... Rn=^[r]:(...) & ...))}
# NOTE: The predicate could also be a simple `p` rather than `p(f)`. The terms
# `f(size(X),size(R))` and `?[gi]:(...)` are optional (but there must be at
# least one). The term `f(size(X),size(R))` handles comparative constructions
# where sizes of sets are compared.
# e.g. "a brighter star could be seen with the telescope than without it", "more people came than last time", "more girls but fewer boys came to the event than last time"
S'' -> NP:try_remove_nullable_subject,require_no_subordinate VP_R:try_remove_nullable_subject,try_remove_correlated

# S'' {A} -> VP_R {A}
S'' -> VP_R:remove_nullable_subject


VP_R nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# VP_R {... & (~)?[y1]:(g1(y1) & f(y1)) & ... & (~)?[yn]:(gn(yn) & f(yn))}
#  -> VP_R {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
#     V_ADJUNCT {... & ?[y1]:(p1(y1) & f(y1)) & ... & ?[yn]:(pn(yn) & f(yn))}
VP_R -> VP_R:try_remove_comma V_ADJUNCT:try_remove_comma,try_remove_correlated
VP_R -> VP_R:try_remove_comma,add_preposition V_ADJUNCT:try_remove_comma,try_remove_correlated,add_preposition

# VP_R {... & (~)?[y1]:(p(y1) & f1(y1) & f(y1)) & ... & (~)?[yn]:(p(yn) & fn(yn) & f(yn))}
#  -> VP_R {... & (~)?[y1]:f1(y1) & ... & (~)?[yn]:fn(yn)}
#     V_ADJUNCT {... & ?[y]:(p(y) & f(y))}
# This rule removes the predicate `p` from the event corresponding to the verb
# (and so the verb is semantically empty) such as in "the cat is blue" and "the
# cat is in the tree". `fi` contains verb-specific terms such as `present` as
# well as any adjuncts or other arguments of y whereas `f` contains everything
# else, such as the argument.
VP_R -> VP_R:try_remove_comma V_ADJUNCT:try_remove_comma,try_remove_correlated

# for (conditional) closed interrogative finite subordinate clauses
# VP_R {A => B} -> VP_R {B} (COMMA) IF/WHETHER S' {A} (COMMA)
# VP_R {^[x]:x=(A => B)} -> VP_R {^[x]:x=B} (COMMA) IF/WHETHER S' {A} (COMMA)
VP_R -> VP_R:try_remove_comma S':try_remove_comma,try_remove_correlated,add_req_no_aux,add_whether
VP_R -> VP_R:try_remove_comma S':try_remove_comma,try_remove_correlated,add_req_no_aux,add_if
VP_R -> VP_R:try_remove_comma COMMA S':try_remove_comma,try_remove_correlated,add_req_no_aux,add_whether COMMA
VP_R -> VP_R:try_remove_comma COMMA S':try_remove_comma,try_remove_correlated,add_req_no_aux,add_if COMMA
VP_R -> VP_R:try_remove_comma S':try_remove_comma,try_remove_correlated,add_req_no_aux,add_whether,add_subjunctive
VP_R -> VP_R:try_remove_comma S':try_remove_comma,try_remove_correlated,add_req_no_aux,add_if,add_subjunctive
VP_R -> VP_R:try_remove_comma COMMA S':try_remove_comma,try_remove_correlated,add_req_no_aux,add_whether,add_subjunctive COMMA
VP_R -> VP_R:try_remove_comma COMMA S':try_remove_comma,try_remove_correlated,add_req_no_aux,add_if,add_subjunctive COMMA

# We need this rule for constructions like "she brought down the bed" and "she brought the bed down".
VP_R -> VP_R:try_remove_comma,add_particle PARTICLE_PLACEHOLDER

# postposed prepositional phrases
# VP_R {... & ?[x]:(... ?[y1]:(... & arg1/arg2/arg3(y1)=x & ...) & ... & ?[yn]:(... & arg1/arg2/arg3(yn)=x & ...) & ... & f(x))}
#  -> VP_R {... & ?[x]:(... ?[y1]:(... & arg1/arg2/arg3(y1)=x & ...) & ... & ?[yn]:(... & arg1/arg2/arg3(yn)=x & ...) & ...)}
#     PP {^[P]:(... & f')}
# where f(x) = (~)?[z]:(h(z) & arg1/arg2(z)=x) and f' = (~)?[z]:(h(z) & P(z))
#    or f(x) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=x) & ... & (~)?[zn]:(hn(zn) & arg1/arg2(zn)=x) and f' = (~)?[z1]:(h1(z1) & P(z1)) & ... & (~)?[zn]:(hn(zn) & P(zn))
#    or f(x) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=x) | ... | (~)?[zn]:(hn(zn) & arg1/arg2(zn)=x) and f' = (~)?[z1]:(h1(z1) & P(z1)) | ... | (~)?[zn]:(hn(zn) & P(zn))
# Note that f(x) may also contain variables which are universally-quantified,
# above the scope of zi, either within the scope of xi (e.g. "i lent the book
# to her with every fact about chemistry") or above it ("i lent a book to her
# from each student").
# In this case, the universal quantifiers are also moved into f'.
# NOTE: This rule also works if X is existentially-quantified.
# e.g. "i lent the book to Kim with all the information she needs"
VP_R -> VP_R:try_remove_comma PP:try_remove_comma,try_remove_correlated

# postposed subordinate clauses
# VP_R {... & ?[x]:(f(x) & ... ?[y1]:(... & arg1/arg2/arg3(y1)=x & ...) & ... & ?[yn]:(... & arg1/arg2/arg3(yn)=x & ...) & ... & ?[g1]:(... & arg1/arg2/arg3(g1)=x) & ... & ?[gn]:(... & arg1/arg2/arg3(gn)=x))}
#  -> VP_R {... & ?[x]:(f(x) & ... ?[y1]:(... & arg1/arg2/arg3(y1)=x & ...) & ... & ?[yn]:(... & arg1/arg2/arg3(yn)=x & ...) & ... & ?[g1]:(... & arg1/arg2/arg3(g1)=x) & ...)}
#     (COMMA) (THAT) S' {?[g1]:(...) & ... & ?[gn]:(...)} (COMMA)
# e.g. "Kim lent a book to Ed that contained all the information he needed"
VP_R -> VP_R:try_remove_comma S':try_remove_comma,add_that,add_nullable_subject,try_remove_correlated # TODO: remove grammatical features from S'
VP_R -> VP_R:try_remove_comma COMMA S':try_remove_comma,add_that,add_nullable_subject,try_remove_correlated COMMA # TODO: remove grammatical features from S'

# postposed open interrogative finite subordinate clause (relative clauses)
# VP_R {... & ?[x]:(f(x) & ... ?[y1]:(... & arg1/arg2/arg3(y1)=x & ...) & ... & ?[yn]:(... & arg1/arg2/arg3(yn)=x & ...) & ... & A(x))}
#  -> VP_R {... & ?[x]:(f(x) & ... ?[y1]:(... & arg1/arg2/arg3(y1)=x & ...) & ... & ?[yn]:(... & arg1/arg2/arg3(yn)=x & ...) & ...)}
#     S' {^[x]:A(x)}
# NOTE: The above `x` could also be universally quantified.
# VP_R {... & ?[S]:(F(S) & ... & ![x]:(S(x) => ?[y1]:(... & arg1/arg2/arg3(y1)=x & ...) & ... & ?[yn]:(... & arg1/arg2/arg3(yn)=x & ...)) & ... & ![x]:(S(x) => A(x)))}
#  -> VP_R {... & ?[S]:(F(S) & ... & ![x]:(S(x) => ?[y1]:(... & arg1/arg2/arg3(y1)=x & ...) & ... & ?[yn]:(... & arg1/arg2/arg3(yn)=x & ...)) & ...)}
#     (COMMA) S' {^[x]:A(x)} (COMMA)
# NOTE: The first form of this rule requires no commas (the child S' is an
# integrated relative clause), whereas the second form may or may not have
# commas (the child S' is a supplementary relative clause).
# e.g. "a person walked into the room who looked like Emma"
VP_R -> VP_R:try_remove_comma S':try_remove_comma,add_req_no_aux,add_subordinate,try_remove_correlated
VP_R -> VP_R:try_remove_comma COMMA S':try_remove_comma,add_req_no_aux,add_subordinate,try_remove_correlated COMMA

# comparative constructions
# VP_R {... & ?[x,r]:(?[g1]:(p(f1)(g1) & arg1(g1)=x & arg2(g1)=r) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x & arg2(gn)=r) & ... & ?[y]:(... & arg1(y)=x & ... & h(r) & ...))}
#  -> VP_R {... & ?[x]:(?[g1]:(p(f1)(g1) & arg1(g1)=x) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x) & ... & ?[y]:(... & arg1(y)=x & ... ))}
#     COMP {p}
#     V_ADJUNCT {h'}
# VP_R {... & ?[X,R]:(... & f(size(X),size(R)) & ... & F(X=^[x]:(![r]:(R(r) => ?[g1]:(p(f1)(g1) & arg1(g1)=x & arg2(g1)=r) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x & arg2(gn)=r)) & ...)) & ... & ![x]:(X(x) => ?[y]:(... & arg1(y)=x & ... & R=^[r]:h(r) & ...)))}
#  -> VP_R {... & ?[X]:(... & f(size(X)) & ... & F(X=^[x]:(?[g1]:(p(f1)(g1) & arg1(g1)=x) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x) & ...)) & ... & ![x]:(X(x) => ?[y]:(... & arg1(y)=x & ...)))}
#     COMP {p} (or `f`, whichever comes last)
#     V_ADJUNCT {h'}
# VP_R {... & ?[X,R]:(?[X1,R1]:(... & f(size(X1),size(R1)) & ... & F(X1=^[x]:(![r]:(R(r) => ?[g1]:(p(f1)(g1) & arg1(g1)=x & arg2(g1)=r) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x & arg2(gn)=r)) & ...)) & ?[X2,R2]:(... & f(size(X2),size(R2)) & ... & F(X2=^[x]:(...)) & ... & X=^[S]:(S=X1 | ... | S=Xn) & R=^[S]:(S=R1 | ... | S=Rn))) & ... & ![S]:(X(S) => ![x]:(S(x) => ?[y]:(... & arg1(y)=x & ... & ![Ri]:(R(Ri) => Ri=^[r]:h(r)) & ...))))}
#  -> VP_R {... & ?[X]:(?[X1]:(... & f(size(X1)) & ... & F(X1=^[x]:(?[g1]:(p(f1)(g1) & arg1(g1)=x) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x) & ...)) & ?[X2]:(... & f(size(X2)) & ... & F(X2=^[x]:(...)) & ... & X=^[S]:(S=X1 | ... | S=Xn))) & ... & ![S]:(X(S) => ![x]:(S(x) => ?[y]:(... & arg1(y)=x & ...))))}
#     COMP {p} (or `f`, whichever comes last)
#     V_ADJUNCT {h'}
# where h(r) = r=a and h' = ?[gn]:(arg2(gn)=a)
#    or h(r) = U(i,r) & p(r) & ?[x]:(arg1/arg2(x)=r & ...) and h' = ?[gn]:(?[r]:(U(i,r) & p(r) & ?[x]:(arg1/arg2(x)=r & ...)))
#    or h(r) = ?[x]:(arg1/arg2(x)=r & ...) & h' = ?[x]:(...)
# NOTE: The predicate could also be a simple `p` rather than `p(f)`. The terms
# `f(size(X),size(R))` and `?[gi]:(...)` are optional (but there must be at
# least one). The term `f(size(X),size(R))` handles comparative constructions
# where sizes of sets are compared.
# e.g. "you can see a brighter star with the telescope than without it", "i saw more people at the party than last time", "there were more girls but fewer boys at the event than last time"
VP_R -> VP_R:try_remove_comma COMP V_ADJUNCT:try_remove_comma,try_remove_correlated

# comparative constructions
# VP_R {... & ?[r]:(?[gn]:(p(fn)(gn) & arg2(gn)=r) & ... & ?[y]:(... & h(r) & ...))}
#  -> VP_R {... & ?[y]:(...)}
#     COMP {p}
#     V_ADJUNCT {h'}
# VP_R {... & ?[R]:(f(size(R)) & ... & ![r]:(R(r) => ?[gn]:(p(fn)(gn) & arg2(gn)=r)) & ... & ?[y]:(... R=^[r]:h(r) & ...))}
#  -> VP_R {... & ?[y]:(...)}
#     COMP {p}
#     V_ADJUNCT {h'}
# where h(r) = r=a and h' = ?[gn]:(arg2(gn)=a)
#    or h(r) = U(i,r) & p(r) & ?[x]:(arg1/arg2(x)=r & ...) and h' = ?[gn]:(?[r]:(U(i,r) & p(r) & ?[x]:(arg1/arg2(x)=r & ...)))
#    or h(r) = ?[x]:(arg1/arg2(x)=r & ...) & h' = ?[x]:(...)
# NOTE: The predicate could also be a simple `p` rather than `p(f)`. The terms
# `f(size(R))` and `?[gi]:(...)` are optional (but there must be at least one).
# The term `f(size(R))` handles comparative constructions where sizes of sets
# are compared.
# e.g. "a brighter star could be seen with the telescope than without it", "more people came than last time", "more girls but fewer boys came to the event than last time"
VP_R -> VP_R:try_remove_comma COMP V_ADJUNCT:try_remove_comma,try_remove_correlated

# for gapping and stripping
# VP_R {... & (~)?[y]:(empty_ref(0,y) & f(y))}
#  -> ADVP_R/PP {... & f'}
# VP_R {... & ![x]:(h(x) => (~)?[y]:(empty_ref(0,y) & f(y,x)))}
#  -> ADVP_R/PP {... & ![x]:(h(x) => f'(x))}
# where f(y) = (~)?[z]:(h(z) & arg1/arg2(z)=y) and f' = (~)?[z]:h(z)
#    or f(y) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=y) & ... & (~)?[zn]:(hn(zn) & arg1/arg2(zn)=y) and f' = (~)?[z1]:h1(z1) & ... & (~)?[zn]:hn(zn)
#    or f(y) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=y) | ... | (~)?[zn]:(hn(zn) & arg1/arg2(zn)=y) and f' = (~)?[z1]:h1(z1) | ... | (~)?[zn]:hn(zn)
# Note that f(y) may also contain variables which are universally-quantified
# (above the scope of yi). In this case, the universal quantifiers are also
# moved into f'.
VP_R -> PP:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma # for arg1
VP_R -> ADVP_R:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma # for arg1
VP_R -> COMMA PP:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma # for arg1
VP_R -> COMMA ADVP_R:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma # for arg1
VP_R -> PP:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma # for arg2
VP_R -> ADVP_R:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma # for arg2
VP_R -> COMMA PP:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma # for arg2
VP_R -> COMMA ADVP_R:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma # for arg2

# for gapping and stripping
# VP_R {... & ?[y]:(empty_ref(y) & arg2/arg3(y)=a}
#  -> NP {^[P]:?[X]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x)))}
# VP_R {... & (~)?[x]:(f(x) & ?[y]:(empty_ref(y) & arg2/arg3(y)=x))} if x is not a set variable
#  -> NP {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)?[x]:(X(x) & P(x))))}
# VP_R {... & (~)![x]:(f(x) => ... & ?[y]:(empty_ref(y) & arg2/arg3(y)=x))}
#  -> NP {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)![x]:(X(x) => P(x))))}
# VP_R {... & ?[X]:(f(X) & (~)![x]:(X(x) => ... & ?[y]:(empty_ref(y) & arg2/arg3(y)=x)))}
#  -> NP {^[P]:(... & ?[X]:(f(X) & (~)![x]:(X(x) => P(x))))}
# VP_R {... & ?[X]:(f(X) & ?[y]:(empty_ref(y) & arg2/arg3(y)=X))} if X is a set variable
#  -> NP {^[P]:(... & ?[X]:(f(X) & ![x]:(X(x) => P(x))))}
VP_R -> NP:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma # for arg2
VP_R -> NP:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma # for arg3
VP_R -> COMMA NP:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma # for arg2
VP_R -> COMMA NP:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma # for arg3
VP_R -> BY NP:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_inverse,try_remove_comma,try_remove_correlated # for arg2
VP_R -> BY NP:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_inverse,try_remove_comma,try_remove_correlated # for arg3

# for gapping and stripping
# VP_R {... & (~)?[y]:(empty_ref(y) & f(y))}
#  -> S' {... & f'}
# where f(y) = (~)?[z]:(h(z) & arg2(y)=z) and f' = (~)?[z]:h(z)
#    or f(y) = arg2(y)=possibility(A) and f' = A
# VP_R {... & ?[X]:(X=^[x]:(x=z1 | ... | x=zm) & ... & ![x]:(X(x) => (~)?[y]:(empty_ref(y) & arg2(y)=x)))}
#  -> S' {... & (?[z1]:(...) & ... & ?[zm]:(...))}
# VP_R {... & ?[X]:(X=^[x]:(x=z1 | ... | x=zm) & ... & ?[x]:(X(x) & (~)?[y]:(empty_ref(y) & arg2(y)=x)))}
#  -> S' {... & (?[z1]:(...) | ... | ?[zm]:(...))}
# where f(y) = (~)?[z]:(h(z) & arg2(y)=z) and f' = (~)?[z]:h(z)
# NOTE: z could also be universally quantified above the scope of yi
# e.g. "Mary wants to run, and John, swim"
VP_R -> S':require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma,add_to_infinitive,add_nullable_subject
VP_R -> COMMA S':require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma,add_to_infinitive,add_nullable_subject

# for correlated coordination
# NOTE: For the following rules, the coordination doesn't have to be at head
# scope, it can be the left-most coordination that is a descendant of the head
# scope as well, so long as there is no negation between the coordination and
# the root. However, we need some measure of "distance" between the
# coordination and the head scope to be a feature to decide between the rules
# at this nonterminal (e.g. "both" moves left much less often than "either").
# VP_R {A1 | ... | An} -> EITHER VP_R {A1 | ... | An}
# VP_R {... ?[y]:(... & arg2(y)=possibility(A1 | ... | An))} -> EITHER VP_R {... ?[y]:(... & arg2(y)=possibility(A1 | ... | An))}
VP_R -> EITHER:require_not_correlated,require_no_coordination VP_R:add_correlated_by_either
# VP_R {A1 & A2} -> BOTH VP_R {A1 & A2}
# VP_R {... ?[y]:(... & arg2(y)=possibility(A1 & A2))} -> BOTH VP_R {... ?[y]:(... & arg2(y)=possibility(A1 & A2))}
VP_R -> BOTH:require_not_correlated,require_no_coordination VP_R:add_correlated_by_both
# VP_R {~A1 & ... & ~An} -> NEITHER VP_R {A1 | ... | An}
# VP_R {... ?[y]:(... & arg2(y)=possibility(~A1 & ... & ~An))} -> NEITHER VP_R {... ?[y]:(... & arg2(y)=possibility(~A1 & ... & ~An))}
VP_R -> NEITHER:require_not_correlated,require_no_coordination VP_R:add_correlated_by_neither

# VP_R {A1 & ... & An} -> VP_R {A1} COMMA VP_R {A2 & ... & An}
# VP_R {A1 | ... | An} -> VP_R {A1} COMMA VP_R {A2 | ... | An}
VP_R -> VP_R:try_remove_comma,try_remove_coordination COMMA VP_R:add_comma,add_coordination # for n > 2
VP_R -> VP_R:try_remove_comma,try_remove_coordination COMMA VP_R:try_remove_comma,try_remove_coordination # for n == 2

# VP_R {A1 & ... & An} -> VP_R {A1} (COMMA) AND VP_R {A2 & ... & An}
VP_R -> VP_R:try_remove_comma,try_remove_coordination COMMA AND VP_R:add_coordination # for n > 2
VP_R -> VP_R:try_remove_comma,try_remove_coordination AND VP_R:add_coordination # for n > 2
VP_R -> VP_R:try_remove_comma,try_remove_coordination COMMA AND VP_R:try_remove_comma,try_remove_coordination # for n == 2
VP_R -> VP_R:try_remove_comma,try_remove_coordination AND VP_R:try_remove_comma,try_remove_coordination # for n == 2

# VP_R {A1 | ... | An} -> VP_R {A1} (COMMA) OR VP_R {A2 | ... | An}
VP_R -> VP_R:try_remove_comma,try_remove_coordination COMMA OR VP_R:add_coordination # for n > 2
VP_R -> VP_R:try_remove_comma,try_remove_coordination OR VP_R:add_coordination # for n > 2
VP_R -> VP_R:try_remove_comma,try_remove_coordination COMMA OR VP_R:try_remove_comma,try_remove_coordination # for n == 2
VP_R -> VP_R:try_remove_comma,try_remove_coordination OR VP_R:try_remove_comma,try_remove_coordination # for n == 2

# VP_R {A1 | ... | An} -> VP_R {A1} (COMMA) NOR VP_R {A2 | ... | An}
VP_R -> VP_R:try_remove_comma,try_remove_coordination,require_not_correlated_by_either COMMA NOR VP_R:add_req_aux,add_coordination # for n > 2
VP_R -> VP_R:try_remove_comma,try_remove_coordination,require_not_correlated_by_either NOR VP_R:add_req_aux,add_coordination # for n > 2
VP_R -> VP_R:try_remove_comma,try_remove_coordination,require_not_correlated_by_either COMMA NOR VP_R:try_remove_comma,try_remove_coordination,add_req_aux # for n == 2
VP_R -> VP_R:try_remove_comma,try_remove_coordination,require_not_correlated_by_either NOR VP_R:try_remove_comma,try_remove_coordination,add_req_aux # for n == 2

# TODO: we could require that here are no additional right adjuncts in the head scope
VP_R -> VP_L:try_remove_comma


V_ADJUNCT nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# V_ADJUNCT {... & ?[y1]:(... & f(y1)) & ... & ?[yn]:(... & f(yn))}
#  -> ADJP_R/PP {^[P]:(... & f')}
# where f(y) = (~)?[z]:(h(z) & arg1/arg2(z)=y) and f' = (~)?[z]:(h(z) & P(z))
#    or f(y) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=y) & ... & (~)?[zn]:(hn(zn) & arg1/arg2(zn)=y) and f' = (~)?[z1]:(h1(z1) & P(z1)) & ... & (~)?[zn]:(hn(zn) & P(zn))
#    or f(y) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=y) | ... | (~)?[zn]:(hn(zn) & arg1/arg2(zn)=y) and f' = (~)?[z1]:(h1(z1) & P(z1)) | ... | (~)?[zn]:(hn(zn) & P(zn))
# Note that f(y) may also contain variables which are universally-quantified,
# above the scope of zi, either within the scope of yi (e.g. "it flew faster
# than every bird") or above it ("i have been to every restaurant"). In this
# case, the universal quantifiers are also moved into f'.
# NOTE: This rule also works if the yi's are ORed.
#
# An example of a sentence with coordination in both the verb and adverb is:
#  "she walked and sat under every tree and near every rock"
V_ADJUNCT -> PP:try_remove_comma # for arg1
V_ADJUNCT -> ADJP_R:try_remove_comma,require_no_preposition # for arg1
V_ADJUNCT -> COMMA PP:try_remove_comma,require_no_preposition # for arg1
V_ADJUNCT -> COMMA ADJP_R:try_remove_comma,require_no_preposition # for arg1
V_ADJUNCT -> PP:try_remove_comma # for arg2
V_ADJUNCT -> ADJP_R:try_remove_comma,require_no_preposition # for arg2
V_ADJUNCT -> COMMA PP:try_remove_comma,require_no_preposition # for arg2
V_ADJUNCT -> COMMA ADJP_R:try_remove_comma,require_no_preposition # for arg2

# predicative complements
# V_ADJUNCT {A} -> PP/ADJP_R/ADVP_R {A}
# e.g. "Sirius is brighter than Vega", "the cat is in the house"
V_ADJUNCT -> PP:try_remove_comma,require_no_preposition
V_ADJUNCT -> ADJP_R:try_remove_comma,require_no_preposition
V_ADJUNCT -> ADVP_R:try_remove_comma,require_no_preposition

# for prepositional verbs (i.e. "look forward to", etc)
# V_ADJUNCT {... & ?[y]:(p(y) & f(y))}
#  -> PP {^[P]:(... & ?[y]:(p(y) & f(y)))}
# where `p` is the predicate, `fi` contains verb-specific terms such as
# `present` as well as any adjuncts of y whereas `f` contains everything else,
# such as the arguments.
V_ADJUNCT -> PP:try_remove_comma

# V_ADJUNCT {... & ?[y1]:(inverse(own)(y1) & arg2(y1)=a) & ... & ?[yn]:(inverse(own)(yn) & arg2(yn)=a)}
#  -> NP {^[P]:?[X]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x)))}
# V_ADJUNCT {... & (~)?[x]:(f(x) & ?[y1]:(inverse(own)(y1) & arg2(y1)=x) & ... & ?[yn]:(inverse(own)(yn) & arg2(yn)=x))} if x is not a set variable
#  -> NP {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)?[x]:(X(x) & P(x))))}
# V_ADJUNCT {... & (~)![x]:(f(x) => ?[y1]:(inverse(own)(y1) & arg2(y1)=x) & ... & ?[yn]:(inverse(own)(yn) & arg2(yn)=x))}
#  -> NP {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)![x]:(X(x) => P(x))))}
# V_ADJUNCT {... & ?[X]:(f(X) & (~)![x]:(X(x) => ?[y1]:(inverse(own)(y1) & arg2(y1)=x) & ... & ?[yn]:(inverse(own)(yn) & arg2(yn)=x)))}
#  -> NP {^[P]:(... & ?[X]:(f(X) & (~)![x]:(X(x) => P(x))))}
# V_ADJUNCT {... & ?[X]:(f(X) & ?[y1]:(inverse(own)(y1) & arg2(y1)=X) & ... & ?[yn]:(inverse(own)(yn) & arg2(yn)=X))} if X is a set variable
#  -> NP {^[P]:(... & ?[X]:(f(X) & ![x]:(X(x) => P(x))))}
# e.g. "the pencil is Emma's", "the pencils are the students'"
V_ADJUNCT -> NP:try_remove_comma,require_no_preposition,add_genitive,singular
V_ADJUNCT -> NP:try_remove_comma,require_no_preposition,add_genitive,plural

# V_ADJUNCT {... & ?[y1]:(... & arg1/arg2/arg3(y1)=a) & ... & ?[yn]:(... & arg1/arg2/arg3(yn)=a)}
#  -> NP/ADJP_R {^[P]:?[X]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x)))}
# V_ADJUNCT {... & (~)?[x]:(f(x) & ?[y1]:(... & arg1/arg2/arg3(y1)=x) & ... & ?[yn]:(... & arg1/arg2/arg3(yn)=x))} if x is not a set variable
#  -> NP/ADJP_R {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)?[x]:(X(x) & P(x))))}
# V_ADJUNCT {... & (~)![x]:(f(x) => ?[y1]:(... & arg1/arg2/arg3(y1)=x) & ... & ?[yn]:(... & arg1/arg2/arg3(yn)=x))}
#  -> NP/ADJP_R {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)![x]:(X(x) => P(x))))}
# V_ADJUNCT {... & ?[X]:(f(X) & (~)![x]:(X(x) => ?[y1]:(... & arg1/arg2/arg3(y1)=x) & ... & ?[yn]:(... & arg1/arg2/arg3(yn)=x)))}
#  -> NP/ADJP_R {^[P]:(... & ?[X]:(f(X) & (~)![x]:(X(x) => P(x))))}
# V_ADJUNCT {... & ?[X]:(f(X) & ?[y1]:(... & arg1/arg2/arg3(y1)=X) & ... & ?[yn]:(... & arg1/arg2/arg3(yn)=X))} if X is a set variable
#  -> NP/ADJP_R {^[P]:(... & ?[X]:(f(X) & ![x]:(X(x) => P(x))))}
# e.g. "it is not a cat nor is it a dog"
V_ADJUNCT -> NP:try_remove_comma,require_no_preposition,require_no_inverse,remove_req_aux # for arg1 (subject-auxiliary inversion; e.g. "is it a boy?")
V_ADJUNCT -> NP:try_remove_comma,require_no_preposition,require_no_inverse # for arg2
V_ADJUNCT -> NP:try_remove_comma,require_no_preposition,require_no_inverse # for arg3 (NOTE: we could make this semantic and have only two args)
V_ADJUNCT -> ADJP_R:try_remove_comma,require_no_preposition,require_no_inverse,remove_req_aux # for arg1 (subject-auxiliary inversion; e.g. "is he angry?")
V_ADJUNCT -> ADJP_R:try_remove_comma,require_no_preposition,require_no_inverse # for arg2
V_ADJUNCT -> ADJP_R:try_remove_comma,require_no_preposition,require_no_inverse # for arg3 (NOTE: we could make this semantic and have only two args)
V_ADJUNCT -> BY NP:try_remove_comma,require_no_preposition,require_inverse,try_remove_correlated # for arg2
V_ADJUNCT -> BY NP:try_remove_comma,require_no_preposition,require_inverse,try_remove_correlated # for arg3 (NOTE: we could make this semantic and have only two args)

# V_ADJUNCT {... & ?[y1]:(... & f(y1)) & ... & ?[yn]:(... & f(yn))}
#  -> (COMMA) (THAT) S' {... & f'}
# where f(y) = (~)?[z]:(h(z) & arg1/arg2(y)=z) and f' = (~)?[z]:h(z)
#    or f(y) = arg1/arg2(y)=possibility(A) and f' = A
# V_ADJUNCT {... & ?[X]:(X=^[x]:(x=z1 | ... | x=zm) & ![x]:(X(x) => ?[y1]:(... & arg1/arg2(y1)=x) & ... & ?[yn]:(... & arg1/arg2(yn)=x)))}
#  -> (COMMA) (THAT) S' {... & (?[z1]:(...) & ... & ?[zm]:(...))}
# V_ADJUNCT {... & ?[X]:(X=^[x]:(x=z1 | ... | x=zm) & ?[x]:(X(x) & ?[y1]:(... & arg1/arg2(y1)=x) & ... & ?[yn]:(... & arg1/arg2(yn)=x)))}
#  -> (COMMA) (THAT) S' {... & (?[z1]:(...) | ... | ?[zm]:(...))}
# where f(y) = (~)?[z]:(h(z) & arg1/arg2(y)=z) and f' = (~)?[z]:h(z)
#    or f(y) = ?[p]:(purpose(p) & arg1(p)=y & arg2(p)=possibility(A)) and f' = A (for purpose constructions with to-infinitival clauses)
# NOTE: z could also be universally quantified above the scope of yi
# NOTE: The arg1 version is for postposing/it-cleft constructions such as "it
# didn't worry him that she was early".
# e.g. "he wants to fly"
V_ADJUNCT -> S':try_remove_comma,require_no_preposition,add_to_infinitive,add_nullable_subject
# e.g. "he wants for Jason to fly"
V_ADJUNCT -> S':try_remove_comma,require_no_preposition,add_to_infinitive,add_for
# e.g. "i bought it to give to Martha"
V_ADJUNCT -> S':try_remove_comma,require_no_preposition,add_to_infinitive,add_for # for `purpose` predicates
# e.g. "he insists she be here", "he insists that she be here"
V_ADJUNCT -> S':try_remove_comma,require_no_preposition,add_subjunctive,add_nullable_subject
V_ADJUNCT -> COMMA S':try_remove_comma,require_no_preposition,add_subjunctive,add_nullable_subject
V_ADJUNCT -> S':try_remove_comma,require_no_preposition,add_subjunctive,add_nullable_subject,add_that
# e.g. "i think Emma returned the books yesterday", "i think that Emma returned the books yesterday"
V_ADJUNCT -> S':try_remove_comma,require_no_preposition # TODO: remove grammatical features from S'
V_ADJUNCT -> S':try_remove_comma,require_no_preposition,add_that # TODO: remove grammatical features from S'
# e.g. "he didn't like it that the barn was destroyed"
V_ADJUNCT -> IT S':try_remove_comma,require_no_preposition,add_that # TODO: remove grammatical features from S'
# e.g. "we must stop him coming back tomorrow"
# NOTE: The following rule requires a subject to avoid spurious ambiguity with
# gerund noun phrases (i.e. "i opposed destroying the barn").
V_ADJUNCT -> S':try_remove_comma,require_no_preposition,add_present_participle # TODO: remove grammatical features from S'

# V_ADJUNCT {... & ?[y1]:(... & ?[r]:(arg1(r)=y1 & reason(r) & ?[z]:(h(z) & arg2(r)=z))) & ... & ?[yn]:(... & ?[r]:(arg1(r)=yn & reason(r) & ?[z]:(h(z) & arg2(r)=z)))}
#  -> (COMMA) BECAUSE/FOR S' {?[z]:h(z)}
V_ADJUNCT -> COMMA S':try_remove_comma,add_because
V_ADJUNCT -> S':try_remove_comma,add_because
V_ADJUNCT -> COMMA FOR S':try_remove_comma,try_remove_correlated
V_ADJUNCT -> FOR S':try_remove_comma,try_remove_correlated

# (non-conditional) closed interrogative finite subordinate clause
# V_ADJUNCT {... & ?[y1]:(... & f(y1)) & ... & ?[yn]:(... & f(yn))}
#  -> (COMMA) IF/WHETHER S' {... & f'} (COMMA)
# where f(y) = arg2(y)=^[x]:A and f' = ^[x]:A
V_ADJUNCT -> S':try_remove_comma,require_no_preposition,add_req_no_aux,add_whether
V_ADJUNCT -> S':try_remove_comma,require_no_preposition,add_req_no_aux,add_if
V_ADJUNCT -> COMMA S':try_remove_comma,require_no_preposition,add_req_no_aux,add_whether COMMA
V_ADJUNCT -> COMMA S':try_remove_comma,require_no_preposition,add_req_no_aux,add_if COMMA
V_ADJUNCT -> S':try_remove_comma,require_no_preposition,add_req_no_aux,add_whether,add_subjunctive
V_ADJUNCT -> S':try_remove_comma,require_no_preposition,add_req_no_aux,add_if,add_subjunctive
V_ADJUNCT -> COMMA S':try_remove_comma,require_no_preposition,add_req_no_aux,add_whether,add_subjunctive COMMA
V_ADJUNCT -> COMMA S':try_remove_comma,require_no_preposition,add_req_no_aux,add_if,add_subjunctive COMMA

# open interrogative finite subordinate clause
# V_ADJUNCT {... & ?[y1]:(p(y1) & f(y1)) & ... & ?[yn]:(p(yn) & f(yn))}
#  -> S' {... & f'}
# where f(y) = arg1/arg2(y)=^[x]:A and f' = ^[x]:A
# NOTE: The `arg1` form is for subject-auxiliary inversion.
V_ADJUNCT -> S':try_remove_comma,require_no_preposition,add_req_no_aux,add_subordinate

# for correlated coordination
# NOTE: For the following rules, the coordination doesn't have to be at head
# scope, it can be the left-most coordination that is a descendant of the head
# scope as well, so long as there is no negation between the coordination and
# the root. However, we need some measure of "distance" between the
# coordination and the head scope to be a feature to decide between the rules
# at this nonterminal (e.g. "both" moves left much less often than "either").
# V_ADJUNCT {A1 | ... | An} -> EITHER V_ADJUNCT {A1 | ... | An}
V_ADJUNCT -> EITHER:require_not_correlated,require_no_coordination V_ADJUNCT:add_correlated_by_either
# V_ADJUNCT {A1 & A2} -> BOTH V_ADJUNCT {A1 & A2}
V_ADJUNCT -> BOTH:require_not_correlated,require_no_coordination V_ADJUNCT:add_correlated_by_both
# V_ADJUNCT {~A1 & ... & ~An} -> NEITHER V_ADJUNCT {A1 | ... | An}
V_ADJUNCT -> NEITHER:require_not_correlated,require_no_coordination V_ADJUNCT:add_correlated_by_neither

# V_ADJUNCT {A1 & ... & An} -> V_ADJUNCT {A1} COMMA V_ADJUNCT {A2 & ... & An}
# V_ADJUNCT {A1 | ... | An} -> V_ADJUNCT {A1} COMMA V_ADJUNCT {A2 | ... | An}
V_ADJUNCT -> V_ADJUNCT:try_remove_comma,try_remove_coordination COMMA V_ADJUNCT:add_comma,add_coordination # for n > 2
V_ADJUNCT -> V_ADJUNCT:try_remove_comma,try_remove_coordination COMMA V_ADJUNCT:try_remove_comma,try_remove_coordination # for n == 2

# V_ADJUNCT {A1 & ... & An} -> V_ADJUNCT {A1} (COMMA) AND V_ADJUNCT {A2 & ... & An}
V_ADJUNCT -> V_ADJUNCT:try_remove_comma,try_remove_coordination COMMA AND V_ADJUNCT:add_coordination # for n > 2
V_ADJUNCT -> V_ADJUNCT:try_remove_comma,try_remove_coordination AND V_ADJUNCT:add_coordination # for n > 2
V_ADJUNCT -> V_ADJUNCT:try_remove_comma,try_remove_coordination COMMA AND V_ADJUNCT:try_remove_comma,try_remove_coordination # for n == 2
V_ADJUNCT -> V_ADJUNCT:try_remove_comma,try_remove_coordination AND V_ADJUNCT:try_remove_comma,try_remove_coordination # for n == 2

# V_ADJUNCT {A1 | ... | An} -> V_ADJUNCT {A1} (COMMA) OR V_ADJUNCT {A2 | ... | An}
V_ADJUNCT -> V_ADJUNCT:try_remove_comma,try_remove_coordination COMMA OR V_ADJUNCT:add_coordination # for n > 2
V_ADJUNCT -> V_ADJUNCT:try_remove_comma,try_remove_coordination OR V_ADJUNCT:add_coordination # for n > 2
V_ADJUNCT -> V_ADJUNCT:try_remove_comma,try_remove_coordination COMMA OR V_ADJUNCT:try_remove_comma,try_remove_coordination # for n == 2
V_ADJUNCT -> V_ADJUNCT:try_remove_comma,try_remove_coordination OR V_ADJUNCT:try_remove_comma,try_remove_coordination # for n == 2

# V_ADJUNCT {A1 | ... | A2} -> V_ADJUNCT {A1} (COMMA) NOR V_ADJUNCT {A2 | ... | An}
V_ADJUNCT -> V_ADJUNCT:try_remove_comma,try_remove_coordination,require_not_correlated_by_either COMMA NOR V_ADJUNCT:add_req_aux,add_coordination # for n > 2
V_ADJUNCT -> V_ADJUNCT:try_remove_comma,try_remove_coordination,require_not_correlated_by_either NOR V_ADJUNCT:add_req_aux,add_coordination # for n > 2
V_ADJUNCT -> V_ADJUNCT:try_remove_comma,try_remove_coordination,require_not_correlated_by_either COMMA NOR V_ADJUNCT:try_remove_comma,try_remove_coordination,add_req_aux # for n == 2
V_ADJUNCT -> V_ADJUNCT:try_remove_comma,try_remove_coordination,require_not_correlated_by_either NOR V_ADJUNCT:try_remove_comma,try_remove_coordination,add_req_aux # for n == 2


VP_L nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# VP_L {... & (~)?[y1]:(f(y1) & g1(y1)) & ... & (~)?[yn]:(f(yn) & gn(yn))}
#  -> (COMMA) ADVP_R/PP {^[P]:(... & f')}
#     (COMMA) VP_L {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
# where f(y) = (~)?[z]:(h(z) & arg1/arg2(z)=y) and f' = (~)?[z]:(h(z) & P(z))
#    or f(y) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=y) & ... & (~)?[zn]:(hn(zn) & arg1/arg2(zn)=y) and f' = (~)?[z1]:(h1(z1) & P(z1)) & ... & (~)?[zn]:(hn(zn) & P(zn))
#    or f(y) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=y) | ... | (~)?[zn]:(hn(zn) & arg1/arg2(zn)=y) and f' = (~)?[z1]:(h1(z1) & P(z1)) | ... | (~)?[zn]:(hn(zn) & P(zn))
# Note that f(y) may also contain variables which are universally-quantified,
# above the scope of zi, either within the scope of yi (e.g. "it flew faster
# than every bird") or above it ("i have been at every restaurant"). In this
# case, the universal quantifiers are also moved into f'.
#
# An example of a sentence with coordination in both the verb and adverb is:
#  "she walked and sat under every tree and near every rock"
VP_L -> ADVP_L VP_L:require_no_req_aux,try_remove_correlated
VP_L -> COMMA PP:require_no_req_aux COMMA VP_L:try_remove_correlated

VP_L -> WILL VP_R:try_remove_correlated,remove_future,add_infinitive,add_aux,remove_req_aux,require_no_subjunctive # future "tense"
VP_L -> HAVE VP_R:try_remove_correlated,require_no_future,remove_perfect,add_past_participle,add_aux,remove_req_aux,require_no_subjunctive # perfect aspect
VP_L -> BE VP_R:try_remove_correlated,require_no_future,require_no_perfect,remove_progressive,add_present_participle,add_aux,remove_req_aux # progressive aspect
VP_L -> DO VP_R:try_remove_correlated,require_no_future,require_no_perfect,require_no_progressive,add_infinitive,add_aux,remove_req_aux,require_no_req_no_aux,require_no_subjunctive # do-support
VP_L -> NOT VP_R:try_remove_correlated,require_aux_or_subjunctive_or_infinitive_or_to_infinitive,remove_not,remove_req_aux
VP_L -> BE VP_R:try_remove_correlated,require_no_future,require_no_perfect,require_no_progressive,remove_inverse,add_past_participle,add_aux,remove_req_aux # passive voice
VP_L -> GET VP_R:try_remove_correlated,require_no_future,require_no_perfect,require_no_progressive,remove_inverse,add_past_participle,add_aux,remove_req_aux # passive voice
VP_L -> TO VP_R:try_remove_correlated,add_infinitive,remove_to_infinitive,require_no_future,require_no_req_aux
VP_L -> MODAL VP_R:try_remove_correlated,add_infinitive,remove_req_aux,require_no_subjunctive

# VP_L {?[x]:p(x)} -> V {p}
# NOTE: If subjunctive, and the resulting inflected verb has the same form as
# that without the subjunctive mood, this rule fails. This is to avoid spurious
# ambiguity where the verb can be interpreted as either being in the
# subjunctive mood or not (e.g. "it's vital that we keep them informed.").
VP_L -> V:require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,require_no_req_aux,require_no_empty_ref,require_no_to_infinitive

# VP_L {?[x]:T} -> BE
# This is the semantically empty "be"/"is"/"was"/"were" as in "the cat is blue" and "the cat is in the tree".
# NOTE: If subjunctive, and the resulting inflected verb has the same form as
# that without the subjunctive mood, this rule fails. This is to avoid spurious
# ambiguity where the verb can be interpreted as either being in the
# subjunctive mood or not (e.g. "it's vital that we keep them informed.").
VP_L -> BE:require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,require_no_req_aux,require_no_empty_ref,require_no_to_infinitive

# for gapping and stripping
VP_L -> WILL:remove_future,remove_req_aux,require_only_empty_ref,require_no_subjunctive # future "tense"
VP_L -> HAVE:require_no_future,remove_perfect,remove_req_aux,require_only_empty_ref,require_no_subjunctive # perfect aspect
VP_L -> BE:require_no_future,require_no_perfect,remove_progressive,remove_req_aux,require_only_empty_ref # progressive aspect
VP_L -> DO:require_no_future,require_no_perfect,require_no_progressive,remove_req_aux,require_only_empty_ref,require_no_subjunctive # do-support
VP_L -> NOT:require_aux_or_subjunctive,remove_not,remove_req_aux,require_only_empty_ref
VP_L -> BE:require_no_future,require_no_perfect,require_no_progressive,remove_inverse,remove_req_aux # passive voice,require_only_empty_ref
VP_L -> MODAL:remove_req_aux,require_empty_ref,require_no_subjunctive

# VP_L {... & ?[y1]:(... & arg1(y1)=a & ...) & ... & ?[yn]:(... & arg1(yn)=a & ...}
#  -> NP {^[P]:?[X]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x)))}
#     VP_L {... & ?[y1]:(...) & ... & ?[yn]:(...)}
# VP_L {... & (~)?[x]:(f(x) & ?[y1]:(... & arg1(y1)=x & ...) & ... & ?[yn]:(... & arg1(yn)=x & ...))}
#  -> NP {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)?[x]:(X(x) & P(x))))}
#     VP_L {... & ?[y1]:(...) & ... & ?[yn]:(...)}
# VP_L {... & (~)![x]:(f(x) => ... & ?[y1]:(... & arg1(y1)=x & ...) & ... & ?[yn]:(... & arg1(yn)=x & ...))}
#  -> NP {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)![x]:(X(x) => P(x))))}
#     VP_L {... & ?[y1]:(...) & ... & ?[yn]:(...)}
# VP_L {... & ?[X]:(f(X) & (~)![x]:(X(x) => ... & ?[y1]:(... & arg1(y1)=x & ...) & ... & ?[yn]:(... & arg1(yn)=x & ...)))}
#  -> NP {^[P]:(... & ?[X]:(f(X) & (~)![x]:(X(x) => P(x))))}
#     VP_L {... & ?[y1]:(...) & ... & ?[yn]:(...)}
# e.g. "it is not a cat nor will it be a cat", "what did they do?"
VP_L -> NP VP_L:require_no_req_aux,try_remove_correlated # for subject-auxiliary inversion

# VP_L {^[x]:(... & ?[y1]:(?[l]:(location(l) & arg1(l)=y1 & arg2(l)=x) & ...) & ... & ?[yn]:(?[l]:(location(l) & arg1(l)=y1 & arg2(l)=x) & ...))}
#  -> WHERE VP_L {... & ?[y1]:(...) & ... & ?[yn]:(...)}
VP_L -> WHERE VP_L:try_remove_correlated

# VP_L {^[x]:(... & ?[y1]:(?[t]:(time(t) & arg1(t)=y1 & arg2(t)=x) & ...) & ... & ?[yn]:(?[t]:(time(t) & arg1(t)=y1 & arg2(t)=x) & ...))}
#  -> WHEN VP_L {... & ?[y1]:(...) & ... & ?[yn]:(...)}
VP_L -> WHEN VP_L:try_remove_correlated

# VP_L {^[x]:(... & ?[y1]:(?[m]:(manner(m) & arg1(m)=y1 & arg2(m)=x) & ...) & ... & ?[yn]:(?[m]:(manner(m) & arg1(m)=y1 & arg2(m)=x) & ...))}
#  -> HOW VP_L {... & ?[y1]:(...) & ... & ?[yn]:(...)}
VP_L -> HOW VP_L:try_remove_correlated

# VP_L {^[x]:(... & ?[y1]:(?[r]:(reason(r) & arg1(r)=y1 & arg2(r)=x) & ...) & ... & ?[yn]:(?[r]:(reason(r) & arg1(r)=y1 & arg2(r)=x) & ...))}
#  -> WHY VP_L {... & ?[y1]:(...) & ... & ?[yn]:(...)}
VP_L -> WHY VP_L:try_remove_correlated


# TODO: should this nonterminal change the universal/existential quantifiers into a single kind of quantifier, to improve generalization for the NP nonterminal and further downstream?
NP nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# NP {A} -> A NP' {A}
NP -> NP':try_remove_comma,remove_adv

# NP {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ~![x]:(X(x) => P(x))))} -> NO NOMINAL_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# NP {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ~?[x]:(X(x) & P(x))))} -> NO NOMINAL_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ~?[x]:(X(x) & P(x))))}
# NP {^[P]:(... & ?[X]:(f(X) & ~![x]:(X(x) => P(x))))} -> NOT NP {^[P]:?[X]:(f(X) & ![x]:(X(x) => P(x)))}
# NP {^[P]:(... & ?[X]:(f(X) & ~?[x]:(X(x) & P(x))))} -> NOT NP {^[P]:?[X]:(f(X) & ?[x]:(X(x) & P(x)))}
# this depends on whether the head quantifier is negated
NP -> NO NOMINAL_R:try_remove_comma,remove_adv,try_remove_correlated
NP -> NOT NP:try_remove_comma,remove_adv,try_remove_correlated

# NP {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))} -> EACH NOMINAL_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# this depends on whether the set is defined as S=^[x]:f(x) rather than with functions like `subset` or `half`;
# it also depends on whether the head predicate of the left conjunct is `this`, `that`, [TODO: add features for possessive]
NP -> EACH NOMINAL_R:try_remove_comma,require_no_adv,try_remove_correlated

# NP {A} -> A NOMINAL_R {A}
#   e.g. "A group of students walks down the street."
NP -> A NOMINAL_R:concord_singular,try_remove_comma,remove_adv,try_remove_correlated

# NP {^[P]:(... & ?[X]:(F(subset(X,^[x]:f(x))) & ![x]:(X(x) => P(x))))} -> SOME NOMINAL_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# NP {^[P]:(... & ?[X]:(F(subset(X,^[x]:f(x))) & ?[x]:(X(x) & P(x))))} -> SOME NOMINAL_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & P(x))))}
# this depends on whether the set is defined using `subset` rather than with functions like `half` or as S=^[x]:f(x);
NP -> SOME NOMINAL_R:try_remove_comma,remove_adv,try_remove_correlated

# NP {A} -> DEF_NP {A}
NP -> DEF_NP:try_remove_comma,remove_adv

# NP {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))} -> ALL DEF_NP {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# this depends on whether the set is defined as S=^[x]:f(x) rather than with functions like `subset` or `half`;
# it also depends on whether the head predicate of the left conjunct is `this`, `that`, [TODO: add features for possessive]
NP -> ALL DEF_NP:try_remove_comma,remove_adv,try_remove_correlated
NP -> ALL NP':try_remove_comma,remove_adv,try_remove_correlated

# NP {^[P]:(... & ?[X]:(F(half(X,^[x]:f(x))) & ![x]:(X(x) => P(x))))} -> HALF DEF_NP {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# NP {^[P]:(... & ?[X]:(F(half(X,^[x]:f(x))) & ![x]:(X(x) => P(x))))} -> HALF A NOMINAL_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# this depends on whether the set is defined using `half` rather than with functions like `subset` or as S=^[x]:f(x);
# it also depends on whether the head predicate of the left conjunct is `this`, `that`, [TODO: add features for possessive]
NP -> HALF DEF_NP:try_remove_comma,remove_adv,try_remove_correlated
NP -> HALF A NOMINAL_R:try_remove_comma,remove_adv,try_remove_correlated

# NP {^[P]:(... & ?[X]:(F(f(X,A)) & (~)![x]:(X(x) => P(x))))} -> ADV {f} NP {^[P]:(... & ?[X]:(F(X=A) & (~)![x]:(X(x) => P(x))))}
# NP {^[P]:(... & ?[X]:(F(f(X,A)) & (~)?[x]:(X(x) & P(x))))} -> ADV {f} NP {^[P]:(... & ?[X]:(F(X=A) & (~)?[x]:(X(x) & P(x))))}
# NOTE: If A is an existentially-quantified variable, we replace all
# occurrences of A with X (such as in the construction "almost half the cats").
# this depends on whether `f` is `half`, `subset`, or `almost`
NP -> ADV NP:try_remove_comma,add_adv,try_remove_correlated

# NP {^[P,x]:(... & ?[X]:(X=^[x]:f(x) & ... & X(x) & P(x)))}
#  -> WHICH/WHAT NOMINAL_R {^[P]:(... & ?[X]:(X=^[x]:f(x) & ... & ?[x]:(X(x) & P(x))))}
NP -> WHICH NOMINAL_R:try_remove_comma,remove_adv,try_remove_correlated
NP -> WHAT NOMINAL_R:try_remove_comma,remove_adv,try_remove_correlated

# NP {^[P]:(... & ?[X]:(X=^[x]:f(x) & ... & ?[x]:(X(x) & P(x))))} -> WHATEVER/WHICHEVER
# NP {^[P]:(... & ?[X]:(X=^[x]:f(x) & ... & ![x]:(X(x) => P(x))))} -> WHATEVER/WHICHEVER
NP -> WHICHEVER NOMINAL_R:try_remove_comma,remove_adv,try_remove_correlated
NP -> WHATEVER NOMINAL_R:try_remove_comma,remove_adv,try_remove_correlated

# for correlated coordination
# NOTE: For the following rules, the coordination doesn't have to be at head
# scope, it can be the left-most coordination that is a descendant of the head
# scope as well, so long as there is no negation between the coordination and
# the root. However, we need some measure of "distance" between the
# coordination and the head scope to be a feature to decide between the rules
# at this nonterminal (e.g. "both" moves left much less often than "either").
# NP {A} -> EITHER NP {A}
# where A = ^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & (~)![x]:(S(x) => ![y]:(x(y) => P(y)))))
#    or A = ^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & (~)![x]:(S(x) => P(x))))
#    or A = ^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & (~)?[x]:(S(x) & ?[y]:(x(y) & P(y)))))
#    or A = ^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & (~)?[x]:(S(x) & P(x))))
NP -> EITHER:require_not_correlated,require_no_coordination NP:add_correlated_by_either
# NP {A} -> BOTH NP {A}
# where A = ^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => ![y]:(x(y) => P(y)))))
#    or A = ^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => P(x))))
#    or A = ^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & ?[y]:(x(y) & P(y)))))
#    or A = ^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & P(x))))
NP -> BOTH:require_not_correlated,require_no_coordination NP:add_correlated_by_both
# NP {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ~?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
#  -> NEITHER NP {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
# NP {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ~?[x]:(S(x) & P(x))))}
#  -> NEITHER NP {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & P(x))))}
NP -> NEITHER:require_not_correlated,require_no_coordination NP:add_correlated_by_neither

# NP {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)![x]:(S(x) => ![y]:(x(y) => P(y)))))} if xi are set-valued
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)![x]:(S(x) => P(x))))} if xi are individuals
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)?[x]:(S(x) & ![y]:(x(y) => P(y)))))} if xi are set-valued
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)?[x]:(S(x) & P(x))))} if xi are individuals
#  -> NP {^[P]:(... & ?[x1]:(f1(x1) & (~)P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & (~)![x]:(x1(x) => P(x))))} if x1 is a set
#     COMMA
#     NP {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)![x]:(S(x) => ![y]:(x(y) => P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)![x]:(S(x) => P(x))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)?[x]:(S(x) & P(x))))}
# NOTE: xi could also be constants, rather than existentially-quantified variables
# NOTE: if xi is a set containing a singleton, S would look like ^[x]:(... | x=^[y]:y=singleton | ...)
NP -> NP:try_remove_comma,try_remove_coordination,try_remove_genitive COMMA NP:add_comma,remove_adv,add_coordination # for n > 2
NP -> NP:try_remove_comma,try_remove_coordination,try_remove_genitive COMMA NP:try_remove_comma,try_remove_coordination,remove_adv # for n == 2

# NP {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & (~)![x]:(S(x) => ![y]:(x(y) => P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & (~)![x]:(S(x) => P(x))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & (~)?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & (~)?[x]:(S(x) & P(x))))}
#  -> NP {^[P]:(... & ?[x1]:(f1(x1) & (~)P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & (~)![x]:(x1(x) => P(x))))} if x1 is a set
#     (COMMA) AND
#     [if n > 2] NP {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & (~)![x]:(S(x) => ![y]:(x(y) => P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & (~)![x]:(S(x) => P(x))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & (~)?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & (~)?[x]:(S(x) & P(x))))}
#     [if n == 2] NP {^[P]:(... & ?[x2]:(f2(x2) & (~)P(x2)))}
#     or {^[P]:(... & ?[x2]:(f2(x2) & (~)![x]:(x2(x) => P(x))))} if x2 is a set
# NOTE: xi could also be constants, rather than existentially-quantified variables
NP -> NP:try_remove_comma,try_remove_coordination,try_remove_genitive AND NP:remove_adv,add_coordination # for n > 2
NP -> NP:try_remove_comma,try_remove_coordination,try_remove_genitive COMMA AND NP:remove_adv,add_coordination # for n > 2
NP -> NP:try_remove_comma,try_remove_coordination,try_remove_genitive AND NP:try_remove_comma,try_remove_coordination,remove_adv # for n == 2
NP -> NP:try_remove_comma,try_remove_coordination,try_remove_genitive COMMA AND NP:try_remove_comma,try_remove_coordination,remove_adv # for n == 2

# NP {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & (~)![x]:(S(x) => ?[y]:(x(y) & P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & (~)![x]:(S(x) => P(x))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & (~)?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & (~)?[x]:(S(x) & P(x))))}
#  -> NP {^[P]:(... & ?[x1]:(f1(x1) & (~)P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & (~)![x]:(x1(x) => P(x))))} if x1 is a set
#     (COMMA) OR
#     [if n > 2] NP {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & (~)![x]:(S(x) => ?[y]:(x(y) & P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & (~)![x]:(S(x) => P(x))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & (~)?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & (~)?[x]:(S(x) & P(x))))}
#     [if n == 2] NP {^[P]:(... & ?[x2]:(f2(x2) & (~)P(x2)))}
#     or {^[P]:(... & ?[x2]:(f2(x2) & (~)?[x]:(x2(x) & P(x))))} if x2 is a set
# NOTE: xi could also be constants, rather than existentially-quantified variables
NP -> NP:try_remove_comma,try_remove_coordination,try_remove_genitive OR NP:remove_adv,add_coordination # for n > 2
NP -> NP:try_remove_comma,try_remove_coordination,try_remove_genitive COMMA OR NP:remove_adv,add_coordination # for n > 2
NP -> NP:try_remove_comma,try_remove_coordination,try_remove_genitive OR NP:try_remove_comma,try_remove_coordination,remove_adv # for n == 2
NP -> NP:try_remove_comma,try_remove_coordination,try_remove_genitive COMMA OR NP:try_remove_comma,try_remove_coordination,remove_adv # for n == 2

# NP {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & P(x))))}
#  -> NP {^[P]:(... & ?[x1]:(f1(x1) & P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & ![x]:(x1(x) => P(x))))} if x1 is a set
#     (COMMA) OR
#     [if n > 2] NP {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ?[x]:(S(x) & P(x))))}
#     [if n == 2] NP {^[P]:(... & ?[x2]:(f2(x2) & P(x2)))}
#     or {^[P]:(... & ?[x2]:(f2(x2) & ?[x]:(x2(x) & P(x))))} if x2 is a set
# NOTE: xi could also be constants, rather than existentially-quantified variables
NP -> NP:try_remove_comma,try_remove_coordination,try_remove_genitive,require_not_correlated_by_either NOR NP:remove_adv,add_coordination # for n > 2
NP -> NP:try_remove_comma,try_remove_coordination,try_remove_genitive,require_not_correlated_by_either COMMA NOR NP:remove_adv,add_coordination # for n > 2
NP -> NP:try_remove_comma,try_remove_coordination,try_remove_genitive,require_not_correlated_by_either NOR NP:try_remove_comma,try_remove_coordination,remove_adv # for n == 2
NP -> NP:try_remove_comma,try_remove_coordination,try_remove_genitive,require_not_correlated_by_either COMMA NOR NP:try_remove_comma,try_remove_coordination,remove_adv # for n == 2


DEF_NP nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# DEF_NP {A} -> THE NP' {A}
DEF_NP -> THE NP':try_remove_correlated

# NP {^[P]:(... & ?[S]:(this(S) & F(S) & ![x]:(S(x) => P(x))))} -> THIS NP' {^[P]:(... & ?[S]:(F(S) & ![x]:(S(x) => P(x))))}
# NP {^[P]:(... & ?[S]:(this(S) & F(S) & ?[x]:(S(x) & P(x))))} -> THIS NP' {^[P]:(... & ?[S]:(F(S) & ?[x]:(S(x) & P(x))))}
# this depends on whether the head predicate of the left conjunct is `this`
DEF_NP -> THIS NP':try_remove_correlated

# NP {^[P]:(... & ?[S]:(that(S) & F(S) & ![x]:(S(x) => P(x))))} -> THIS NP' {^[P]:(... & ?[S]:(F(S) & ![x]:(S(x) => P(x))))}
# NP {^[P]:(... & ?[S]:(that(S) & F(S) & ?[x]:(S(x) & P(x))))} -> THIS NP' {^[P]:(... & ?[S]:(F(S) & ?[x]:(S(x) & P(x))))}
# this depends on whether the head predicate of the left conjunct is `that`
DEF_NP -> THAT NP':try_remove_correlated

# DEF_NP {^[P]:(... & ?[X]:(F(X=^[x]:(?[o]:(own(o) & arg2(o)=x & arg1(o)=a) & f(x))) & ![x]:(X(x) => P(x))))}
#  -> NP {^[P]:?[X]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x)))}
#     NP' {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# DEF_NP {^[P]:(... & ?[X]:(F(X=^[x]:(?[o]:(own(o) & arg2(o)=x & ?[y]:(g(y) & arg1(o)=y)) & f(x))) & ![x]:(X(x) => P(x))))}
#  -> NP {^[P]:(... & ?[X]:(X=^[x]:g(x) & ?[x]:(X(x) & P(x))))}
#     NP' {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# DEF_NP {^[P]:(... & ?[X]:(F(X=^[x]:(?[y]:(g(y) & ?[o]:(own(o) & arg2(o)=x & arg1(o)=y)) & f(x))) & ![x]:(X(x) => P(x))))}
#  -> NP {^[P]:(... & ?[X]:(X=^[x]:g(x) & ![x]:(X(x) => P(x))))}
#     NP' {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# DEF_NP {^[P]:(... & ?[X]:(F(X=^[x]:(![y]:(g(y) => ?[o]:(own(o) & arg2(o)=x & arg1(o)=y)) & f(x))) & ![x]:(X(x) => P(x))))}
#  -> NP {^[P]:(... & ?[X]:(X=^[x]:g(x) & ![x]:(X(x) => P(x))))}
#     NP' {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# NOTE: In the last two rules, if `g(y)` is just a set membership test `Y(y)`,
# then in the left child logical form, we replace `X=^[x]:g(x)` with the
# definition of `Y` (effectively renaming `Y` to `X`).
# NOTE: This rule also works if X is existentially-quantified.
DEF_NP -> NP:add_genitive,singular NP':try_remove_correlated
DEF_NP -> NP:add_genitive,plural NP':try_remove_correlated
# TODO: the above rule can also be used for `inverse(intended_for)` in addition to `own`

# DEF_NP {^[P]:(... & ?[S]:(F(S=^[x]:(arg1/arg2(x)=a & f(x))) & ![x]:(S(x) => P(x))))}
#  -> NP {^[P]:?[S]:(S=^[x]:(x=a) & ?[x]:(S(x) & P(x)))}
#     NP' {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
# DEF_NP {^[P]:(... & ?[S]:(F(S=^[x]:(?[y]:(g(y) & arg1/arg2(x)=y) & f(x))) & ![x]:(S(x) => P(x))))}
#  -> NP {^[P]:(... & ?[S]:(S=^[x]:g(x) & ?[x]:(S(x) & P(x))))}
#     NP' {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
# DEF_NP {^[P]:(... & ![y]:(g(y) => ... ?[S]:(F(S=^[x]:(arg1/arg2(x)=y & f(x))) & ![x]:(S(x) => P(x)))))}
#  -> NP {^[P]:(... & ?[S]:(S=^[x]:g(x) & ![x]:(S(x) => P(x))))}
#     NP' {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
# DEF_NP {^[P]:(... & ?[Y]:(G(Y) & ... & ![y]:(Y(y) => ?[S]:(F(S=^[x]:(arg1/arg2(x)=y & f(x))) & ![x]:(S(x) => P(x))))))}
#  -> NP {^[P]:(... & ?[S]:(G(S) & ![x]:(S(x) => P(x))))}
#     NP' {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
# NOTE: This rule also works if S is existentially-quantified.
#  e.g. "the arson's/termites' destruction of the barn(s)"
DEF_NP -> NP:add_genitive,singular NP':try_remove_correlated # for arg1
DEF_NP -> NP:add_genitive,singular NP':try_remove_correlated # for arg2
DEF_NP -> NP:add_genitive,plural NP':try_remove_correlated # for arg1
DEF_NP -> NP:add_genitive,plural NP':try_remove_correlated # for arg2

# DEF_NP {^[P]:(... ?[X]:(X=^[x]:(?[o]:(arg1(o)=a & own(o) & arg2(o)=x)) & ![x]:(X(x) => P(x))))}
#  -> NP {^[P]:(... ?[Y]:(Y=^[y]:(y=a) & ?[y]:(Y(y) & P(y))))}
# DEF_NP {^[P]:(... ?[y]:(f(y) & ... & ?[X]:(X=^[x]:(?[o]:(arg1(o)=y & own(o) & arg2(o)=x)) & ![x]:(X(x) => P(x)))))}
#  -> NP {^[P]:(... ?[Y]:(Y=^[y]:f(y) & ?[y]:(Y(y) => P(y))))}
# DEF_NP {^[P]:(... ?[Y]:(F(Y) & ... & ?[X]:(X=^[x]:(?[y]:(Y(y) & ?[o]:(arg1(o)=y & own(o) & arg2(o)=x))) & ![x]:(X(x) => P(x)))))}
#  -> NP {^[P]:(... ?[Y]:(F(Y) & ?[y]:(Y(y) & P(y))))}
# DEF_NP {^[P]:(... ?[Y]:(F(Y) & ... & ?[X]:(X=^[x]:(![y]:(Y(y) => ?[o]:(arg1(o)=y & own(o) & arg2(o)=x))) & ![x]:(X(x) => P(x)))))}
#  -> NP {^[P]:(... ?[Y]:(F(Y) & ![y]:(Y(y) => P(y))))}
# NOTE: This rule also works if X is existentially-quantified.
# e.g. "Jason's is better"
DEF_NP -> NP:require_no_genitive,add_genitive,singular



NP' nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# NP {^[P]:(... & ?[S]:(f(S) & g(S=^[x]:f(x)) & ...))} -> Q {f(S)} NOMINAL_R {^[P]:(... & ?[S]:(g(S=^[x]:f(x)) & ...))}
# this depends on whether the head predicate of the left conjunct f(S) is one that expresses information about the size of the set
NP' -> Q NOMINAL_R:try_remove_correlated

# NP' {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))} -> NOMINAL_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# NP' {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & P(x))))} -> NOMINAL_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & P(x))))}
NP' -> NOMINAL_R


Q nonterminal {} {1.0} {1.0} {} 10 1.0 {}
# TODO: to decide between the following rules, we need information about the countability of the noun

# Q {?[l]:(mod(f)(l) & ...)} -> ADV {mod} Q {?[l]:(f(l) & ...)} where f is the type predicate of `l`
#   [OR]
# Q {?[l]:(?[m]:(mod(m) & arg1(m)=l) & f(l) & ...)} -> ADV {mod} Q {?[l]:(f(l) & ...)} where f is the type predicate of `l`
#
# Q {?[a]:(mod(a) & arg1(a)=A & arg2(a)=B)} -> ADV {mod} Q {A=B}
#   [OR]
# Q {f(A,B) -> ADV {f} Q {A=B}
# The last two rules are for adverbs like "almost", "nearly", "more than", etc.
Q -> ADVP_L Q:try_remove_correlated

# Q {size(x)=n} -> NUMBER {n}
Q -> NUMBER

# comparative constructions where sizes of sets are compared
# Q {?[R]:size(X)>size(R)} -> MORE
# e.g. "more people came than last time"
Q -> MORE

# comparative constructions where sizes of sets are compared
# Q {?[R]:size(X)<size(R)} -> LESS/FEWER
# e.g. "more people came than last time"
Q -> FEWER
Q -> LESS

# Q {?[R]:size(X)=k*size(R)} -> NUMBER {k} TIMES (AS MUCH/MANY)
# e.g. "four times as many/much"
Q -> NUMBER TIMES
Q -> NUMBER TIMES AS MUCH
Q -> NUMBER TIMES AS MANY

Q -> MUCH
Q -> MANY
Q -> MOST
Q -> FEW
Q -> FEWEST
Q -> LEAST


# this noun phrase nonterminal is for right-side modifiers
NOMINAL_R nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# NOMINAL_R {A} -> NOMINAL_L {A}
NOMINAL_R -> NOMINAL_L:try_remove_comma

# appositives
# NOMINAL_R {^[P]:(... & ?[S]:(F(S=^[x]:(... & x=a)) & ...))}
#  -> NOMINAL_R {^[P]:(... & ?[S]:(F(S=^[x]:(...)) & ...))}
#     NP {^[P]:?[Y]:(Y=^[y]:(y=a) & ?[y]:(Y(y) & P(y)))}
# NOMINAL_R {^[P]:(... & ?[S]:(F(S=^[x]:(... & ?[y]:(f(y) & x=y))) & ...))}
#  -> NOMINAL_R {^[P]:(... & ?[S]:(F(S=^[x]:(...)) & ...))}
#     NP {^[P]:?[Y]:(Y=^[y]:f(y) & ?[y]:(Y(y) & P(y)))}
# e.g. "Kim Jones, President of the Union, ...", "the year 2024"
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_genitive NP:try_remove_comma,try_remove_correlated
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_genitive COMMA NP:try_remove_comma,try_remove_correlated COMMA
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_genitive OF NP:try_remove_comma,try_remove_correlated

# NOMINAL_R {^[P]:(... & ?[S]:(F(S=^[x]:(arg1/arg2(x)=a & f(x))) & ![x]:(S(x) => P(x))))}
#  -> NOMINAL_R {^[P]:?[S]:(S=^[x]:(x=a) & ?[x]:(S(x) & P(x))}
#     PP {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
# NOMINAL_R {^[P]:(... & ?[S]:(F(S=^[x]:(?[y]:(g(y) & arg1/arg2(x)=y) & f(x))) & ![x]:(S(x) => P(x))))}
#  -> NOMINAL_R {^[P]:(... & ?[S]:(S=^[x]:g(x) & ?[x]:(S(x) & P(x))))}
#     PP {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
# NOMINAL_R {^[P]:(... & ![y]:(g(y) => ... ?[S]:(F(S=^[x]:(arg1/arg2(x)=y & f(x))) & ![x]:(S(x) => P(x)))))}
#  -> NOMINAL_R {^[P]:(... & ?[S]:(S=^[x]:g(x) & ![x]:(S(x) => P(x))))}
#     PP {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
# NOMINAL_R {^[P]:(... & ?[Y]:(G(Y) & ... & ![y]:(Y(y) => ?[S]:(F(S=^[x]:(arg1/arg2(x)=y & f(x))) & ![x]:(S(x) => P(x))))))}
#  -> NOMINAL_R {^[P]:(... & ?[S]:(G(S) & ![x]:(S(x) => P(x))))}
#     PP {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
# NOTE: This rule also works if S is existentially-quantified.
#  e.g. "destruction of the barn(s)", "destruction of the barn(s) by the termites"
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_genitive PP:try_remove_comma,try_remove_correlated

# NOMINAL_R {^[P]:(... & ?[X]:(F(X=^[x]:(... & f(x))) & ![x]:(X(x) => P(x))))}
#  -> NOMINAL_R {^[P]:(... & ?[X]:(... & ![x]:(X(x) => P(x))))}
#     ADJP_R/PP {^[P]:(... & f')}
# where f(x) = (~)?[z]:(h(z) & arg1/arg2(z)=x) and f' = (~)?[z]:(h(z) & P(z))
#    or f(x) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=x) & ... & (~)?[zn]:(hn(zn) & arg1/arg2(zn)=x) and f' = (~)?[z1]:(h1(z1) & P(z1)) & ... & (~)?[zn]:(hn(zn) & P(zn))
#    or f(x) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=x) | ... | (~)?[zn]:(hn(zn) & arg1/arg2(zn)=x) and f' = (~)?[z1]:(h1(z1) & P(z1)) | ... | (~)?[zn]:(hn(zn) & P(zn))
# Note that f(x) may also contain variables which are universally-quantified,
# above the scope of zi, either within the scope of xi (e.g. "i like the house
# next to the trees") or above it ("a student from each class spoke to her").
# In this case, the universal quantifiers are also moved into f'.
# NOTE: This rule also works if X is existentially-quantified.
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_genitive PP:try_remove_comma,try_remove_correlated
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_genitive ADJP_R:try_remove_comma,try_remove_correlated

# comparative constructions
# NOMINAL_R {^[P]:(... & ?[X,r]:(... & F(X=^[x]:(?[g1]:(p(f1)(g1) & arg1(g1)=x & arg2(g1)=r) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x & arg2(gn)=r) & ... & h(r) & ...)) & ...))}
#  -> NOMINAL_R {^[P]:(... & ?[X]:(... & F(X=^[x]:(?[g1]:(p(f1)(g1) & arg1(g1)=x) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x) & ...)) & ...))}
#     COMP {p}
#     V_ADJUNCT {h'}
# NOMINAL_R {^[P]:(... & ?[X,R]:(... & f(size(X),size(R)) & ... & F(X=^[x]:(![r]:(R(r) => ?[g1]:(p(f1)(g1) & arg1(g1)=x & arg2(g1)=r) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x & arg2(gn)=r)) & ...)) & ... & R=^[r]:h(r) & ...))}
#  -> NOMINAL_R {^[P]:(... & ?[X]:(... & f(size(X)) & ... & F(X=^[x]:(?[g1]:(p(f1)(g1) & arg1(g1)=x) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x) & ...)) & ...))}
#     COMP {p} (or `f`, whichever comes last)
#     V_ADJUNCT {h'}
# NOMINAL_R {^[P]:(... & ?[X,R]:(?[X1,R1]:(... & f(size(X1),size(R1)) & ... & F(X1=^[x]:(![r]:(R(r) => ?[g1]:(p(f1)(g1) & arg1(g1)=x & arg2(g1)=r) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x & arg2(gn)=r)) & ...)) & ?[X2,R2]:(... & f(size(X2),size(R2)) & ... & F(X2=^[x]:(...)) & ... & X=^[S]:(S=X1 | ... | S=Xn) & R=^[S]:(S=R1 | ... | S=Rn))) & ... & ![Ri]:(R(Ri) => Ri=^[r]:h(r)) & ...))}
#  -> NOMINAL_R {^[P]:(... & ?[X]:(?[X1]:(... & f(size(X1)) & ... & F(X1=^[x]:(?[g1]:(p(f1)(g1) & arg1(g1)=x) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x) & ...)) & ?[X2]:(... & f(size(X2)) & ... & F(X2=^[x]:(...)) & ... & X=^[S]:(S=X1 | ... | S=Xn))) & ...))}
#     COMP {p} (or `f`, whichever comes last)
#     V_ADJUNCT {h'}
# where h(r) = r=a and h' = ?[gn]:(arg2(gn)=a)
#    or h(r) = U(i,r) & p(r) & ?[x]:(arg1/arg2(x)=r & ...) and h' = ?[gn]:(?[r]:(U(i,r) & p(r) & ?[x]:(arg1/arg2(x)=r & ...)))
#    or h(r) = ?[x]:(arg1/arg2(x)=r & ...) & h' = ?[x]:(...)
# NOTE: The predicate could also be a simple `p` rather than `p(f)`. The terms
# `f(size(X),size(R))` and `?[gi]:(...)` are optional (but there must be at
# least one). The term `f(size(X),size(R))` handles comparative constructions
# where sizes of sets are compared.
# e.g. "brighter star than Vega", "more people than last time", "more girls but fewer boys than last time"
NOMINAL_R -> NOMINAL_R:try_remove_comma COMP V_ADJUNCT:try_remove_comma,try_remove_correlated

# NOMINAL_R {^[P]:(... & ?[X]:(F(X=^[x]:(... & ?[g1]:(... & arg1/arg2/arg3(g1)=x) & ... & ?[gn]:(... & arg1/arg2/arg3(gn)=x))) & ...))}
#  -> NOMINAL_R {^[P]:(... & ?[X]:(F(X=^[x]:(...)) & ...))}
#     (COMMA) (THAT) S' {?[g1]:(...) & ... & ?[gn]:(...)} (COMMA)
# e.g. "the book (that) I gave Kim"
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_genitive S':try_remove_comma,try_remove_correlated # TODO: remove grammatical features from S'
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_genitive S':try_remove_comma,try_remove_correlated,add_that,add_nullable_subject # TODO: remove grammatical features from S'
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_genitive COMMA S':try_remove_comma,try_remove_correlated,add_that,add_nullable_subject COMMA # TODO: remove grammatical features from S'

# NOMINAL_R {^[P]:(... & ?[S]:(F(S=^[x]:(?[y]:(g(y) & arg1/arg2(x)=y) & f(x))) & ![x]:(S(x) => P(x))))}
#  -> NOMINAL_R {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
#     (COMMA) (THAT) S' {... & ?[y]:g(y)} (COMMA)
# e.g. "the toys (that) you don't want"
# NOMINAL_R {^[P]:(... & ?[X]:(F(X=^[x]:(... & arg2(x)=^[g]:f(g))) & ...))}
#  -> NOMINAL_R {^[P]:(... & ?[l1]:(... & P(l1)) & ... & ?[ln]:(... & P(ln)))}
#     (THAT) S' {... & ?[g]:f(g)}
# e.g. "last time (that) i went to campus"
# NOTE: This second rule does not allow a comma.
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_genitive S':try_remove_comma,try_remove_correlated # TODO: remove grammatical features from S'
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_genitive S':try_remove_comma,try_remove_correlated,add_that,add_nullable_subject # TODO: remove grammatical features from S'
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_genitive COMMA S':try_remove_comma,try_remove_correlated,add_that,add_nullable_subject COMMA # TODO: remove grammatical features from S'
# e.g. "the demand that she be here"
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_genitive S':try_remove_comma,try_remove_correlated,add_that,add_subjunctive # TODO: remove grammatical features from S'
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_genitive COMMA S':try_remove_comma,try_remove_correlated,add_that,add_subjunctive COMMA # TODO: remove grammatical features from S'

# closed interrogative finite subordinate clause
# NOMINAL_R {^[P]:(... & ?[X]:(X=^[x]:(... & f(x)) & ... ))}
#  -> NOMINAL_R {^[P]:(... & ?[X]:(X=^[x]:(...) & ... ))}
#     IF/WHETHER S' {... & f'}
# where f(y) = arg2(y)=^[x]:A and f' = ^[x]:A
# e.g. "the question whether he arrived or not"
NOMINAL_R -> NOMINAL_R:try_remove_comma S':try_remove_comma,try_remove_correlated,add_req_no_aux,add_whether

# open interrogative finite subordinate clause (relative clauses)
# NOMINAL_R {^[P]:(... & ?[S]:(F(S=^[x]:(A(x) & f(x))) & ![x]:(S(x) => P(x))))}
#  -> NOMINAL_R {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
#     S' {^[x]:A(x)}
# NOMINAL_R {^[P]:(... & ?[S]:(F(S) & ![x]:(S(x) => A(x)) & ![x]:(S(x) => P(x))))}
#  -> NOMINAL_R {^[P]:(... & ?[S]:(F(S) & ![x]:(S(x) => P(x))))}
#     (COMMA) S' {^[x]:A(x)} (COMMA)
# NOTE: The first form of this rule requires no commas (the child S' is an
# integrated relative clause), whereas the second form may or may not have
# commas (the child S' is a supplementary relative clause).
# e.g. "the toys which you don't want", "the people whose house we are renting", "the state through which the Allegheny runs", "a problem with which to challenge the students"
NOMINAL_R -> NOMINAL_R:try_remove_comma S':try_remove_comma,try_remove_correlated,add_req_no_aux,add_subordinate
NOMINAL_R -> NOMINAL_R:try_remove_comma COMMA S':try_remove_comma,try_remove_correlated,add_req_no_aux,add_subordinate COMMA

# relative clauses where the relative phrase is a complement of a preposition
# NOMINAL_R {^[P]:(... & ?[S]:(F(S=^[x]:(A(?[y]:(g(y) & arg2(y)=x)) & f(x))) & ![x]:(S(x) => P(x))))}
#  -> NOMINAL_R {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
#     (THAT) S' {A(?[y]:(g(y) & ?[x]:(empty_ref(x) & arg2(y)=x)))}
# NOMINAL_R {^[P]:(... & ?[S]:(F(S) & ![x]:(S(x) => A(?[y]:(g(y) & arg2(y)=x))) & ![x]:(S(x) => P(x))))}
#  -> NOMINAL_R {^[P]:(... & ?[S]:(F(S) & ![x]:(S(x) => P(x))))}
#     (COMMA) THAT S' {A(?[y]:(g(y) & ?[x]:(empty_ref(x) & arg2(y)=x)))} (COMMA)
# NOTE: The first form of this rule requires no commas (the child S' is an
# integrated relative clause), whereas the second form may or may not have
# commas (the child S' is a supplementary relative clause).
# e.g. "the knife (that) he was trying to cut it with"
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_genitive S':try_remove_comma,try_remove_correlated # TODO: remove grammatical features from S'
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_genitive S':try_remove_comma,try_remove_correlated,add_that,add_nullable_subject # TODO: remove grammatical features from S'
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_genitive COMMA S':try_remove_comma,try_remove_correlated,add_that,add_nullable_subject COMMA # TODO: remove grammatical features from S'

# NOMINAL_R {^[P]:(... & ?[X]:(F(X=^[x]:(... & ?[g1]:(... & arg1(g1)=x) & ... & ?[gn]:(... & arg1(gn)=x))) & ...))}
#  -> NOMINAL_R {^[P]:(... & ?[X]:(F(X=^[x]:(...)) & ...))}
#     VP_R {?[g1]:(...) & ... & ?[gn]:(...)}
# e.g. "the cat sleeping on the bed"
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_genitive VP_R:keep_present_participle,try_remove_comma,try_remove_correlated

# NOMINAL_R {^[P]:(... & ?[X]:(F(X=^[x]:(... & ?[g1]:(p1(g1) & ... & arg2(g1)=x) & ... & ?[gn]:(pn(gn) & ... & arg2(gn)=x))) & ...))}
#  -> NOMINAL_R {^[P]:(... & ?[X]:(F(X=^[x]:(...)) & ...))}
#     VP_R {?[g1]:(inverse(p1)(g1) & ...) & ... & ?[gn]:(inverse(pn)(gn) & ...)}
# e.g. "the letter written by me"
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_genitive VP_R:invert_predicate,keep_past_participle,try_remove_comma,try_remove_correlated

# NOMINAL_R {^[P]:(... & ?[X]:(F(X=^[x]:(... & ?[g1]:(... & arg1(g1)=x) & ... & ?[gn]:(... & arg1(gn)=x))) & ...))}
#  -> NOMINAL_R {^[P]:(... & ?[X]:(F(X=^[x]:(...)) & ...))}
#     VP_R {?[g1]:(...) & ... & ?[gn]:(...)}
# e.g. "the person to see the comet", "decision to go to Boston"
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_genitive VP_R:add_to_infinitive,try_remove_comma,try_remove_correlated

# NOMINAL_R {^[P]:(... & ?[X]:(X=^[x]:f(x) & ![x]:(X(x) => P(x))))} -> VP_R {... & f(x)} if X is not a union
# NOMINAL_R {^[P]:(... & ?[X]:(X=^[x]:f(x) & ?[x]:(X(x) & P(x))))} -> VP_R {... & f(x)} if X is not a union
# NOMINAL_R {^[P]:(... & ?[X]:(X=^[x]:(x=x1 | ... | x=xn) & ![x]:(X(x) => P(x))))} -> VP_R {... & ?[x1]:(...) & ... & ?[xn]:(...)} if X is a union
# NOMINAL_R {^[P]:(... & ?[X]:(X=^[x]:(x=x1 | ... | x=xn) & ?[x]:(X(x) & P(x))))} -> VP_R {... & ?[x1]:(...) & ... & ?[xn]:(...)} if X is a union
# e.g. "the heating of the food"
NOMINAL_R -> VP_R:add_present_participle,try_remove_comma,remove_adv

# postposed infinitival clause from ADJP_R
# NOMINAL_R {^[P]:(... & ?[X]:(F(X=^[x]:(?[d]:(f(d) & ... & h(d)) & ...)) & ...))}
#  -> NOMINAL_R {^[P]:(... & ?[X]:(F(X=^[x]:(?[d]:(f(d) & ...) & ...)) & ...))}
#     VP_R {... & h'}
# where h(d) = ?[y]:(g(y) & arg1/arg2(y)=d) and h' = ?[y]:g(y)
#    or h(d) = arg1/arg2(y)=possibility(A) and h' = A
# e.g. "a difficult book to understand"
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_genitive VP_R:try_remove_comma,add_to_infinitive,try_remove_correlated

# pronouns
# NOMINAL_R {A} -> PRO {A}
NOMINAL_R -> PRO:try_remove_comma,remove_adv

# noun phrases headed by quantifiers
# NOMINAL_R {A} -> Q {A}
NOMINAL_R -> Q:try_remove_comma,remove_adv

# for correlated coordination
# NOTE: For the following rules, the coordination doesn't have to be at head
# scope, it can be the left-most coordination that is a descendant of the head
# scope as well, so long as there is no negation between the coordination and
# the root. However, we need some measure of "distance" between the
# coordination and the head scope to be a feature to decide between the rules
# at this nonterminal (e.g. "both" moves left much less often than "either").
# NOMINAL_R {A} -> EITHER NOMINAL_R {A}
# where A = ^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & (~)![x]:(S(x) => ![y]:(x(y) => P(y)))))
#    or A = ^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & (~)![x]:(S(x) => P(x))))
#    or A = ^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & (~)?[x]:(S(x) & ?[y]:(x(y) & P(y)))))
#    or A = ^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & (~)?[x]:(S(x) & P(x))))
NOMINAL_R -> EITHER:require_not_correlated,require_no_coordination NOMINAL_R:add_correlated_by_either
# NOMINAL_R {A} -> BOTH NOMINAL_R {A}
# where A = ^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => ![y]:(x(y) => P(y)))))
#    or A = ^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => P(x))))
#    or A = ^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & ?[y]:(x(y) & P(y)))))
#    or A = ^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & P(x))))
NOMINAL_R -> BOTH:require_not_correlated,require_no_coordination NOMINAL_R:add_correlated_by_both
# NOMINAL_R {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ~?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
#  -> NEITHER NOMINAL_R {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
# NOMINAL_R {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ~?[x]:(S(x) & P(x))))}
#  -> NEITHER NOMINAL_R {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & P(x))))}
NOMINAL_R -> NEITHER:require_not_correlated,require_no_coordination NOMINAL_R:add_correlated_by_neither

# NOMINAL_R {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)![x]:(S(x) => ![y]:(x(y) => P(y)))))} if xi are set-valued
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)![x]:(S(x) => P(x))))} if xi are individuals
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)?[x]:(S(x) & ![y]:(x(y) => P(y)))))} if xi are set-valued
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)?[x]:(S(x) & P(x))))} if xi are individuals
#  -> NOMINAL_R {^[P]:(... & ?[x1]:(f1(x1) & (~)P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & (~)![x]:(x1(x) => P(x))))} if x1 is a set
#     COMMA
#     NOMINAL_R {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)![x]:(S(x) => ![y]:(x(y) => P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)![x]:(S(x) => P(x))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)?[x]:(S(x) & P(x))))}
# NOTE: xi could also be constants, rather than existentially-quantified variables
# NOTE: if xi is a set containing a singleton, S would look like ^[x]:(... | x=^[y]:y=singleton | ...)
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_coordination,try_remove_genitive COMMA NOMINAL_R:add_comma,remove_adv,add_coordination # for n > 2
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_coordination,try_remove_genitive COMMA NOMINAL_R:try_remove_comma,try_remove_coordination,remove_adv # for n == 2

# NOMINAL_R {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & (~)![x]:(S(x) => ![y]:(x(y) => P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & (~)![x]:(S(x) => P(x))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & (~)?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & (~)?[x]:(S(x) & P(x))))}
#  -> NOMINAL_R {^[P]:(... & ?[x1]:(f1(x1) & (~)P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & (~)![x]:(x1(x) => P(x))))} if x1 is a set
#     (COMMA) AND
#     [if n > 2] NOMINAL_R {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & (~)![x]:(S(x) => ![y]:(x(y) => P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & (~)![x]:(S(x) => P(x))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & (~)?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & (~)?[x]:(S(x) & P(x))))}
#     [if n == 2] NOMINAL_R {^[P]:(... & ?[x2]:(f2(x2) & (~)P(x2)))}
#     or {^[P]:(... & ?[x2]:(f2(x2) & (~)![x]:(x2(x) => P(x))))} if x2 is a set
# NOTE: xi could also be constants, rather than existentially-quantified variables
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_coordination,try_remove_genitive AND NOMINAL_R:remove_adv,add_coordination # for n > 2
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_coordination,try_remove_genitive COMMA AND NOMINAL_R:remove_adv,add_coordination # for n > 2
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_coordination,try_remove_genitive AND NOMINAL_R:try_remove_comma,try_remove_coordination,remove_adv # for n == 2
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_coordination,try_remove_genitive COMMA AND NOMINAL_R:try_remove_comma,try_remove_coordination,remove_adv # for n == 2

# NOMINAL_R {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & (~)![x]:(S(x) => ?[y]:(x(y) & P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & (~)![x]:(S(x) => P(x))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & (~)?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & (~)?[x]:(S(x) & P(x))))}
#  -> NOMINAL_R {^[P]:(... & ?[x1]:(f1(x1) & (~)P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & (~)![x]:(x1(x) => P(x))))} if x1 is a set
#     (COMMA) OR
#     [if n > 2] NOMINAL_R {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & (~)![x]:(S(x) => ?[y]:(x(y) & P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & (~)![x]:(S(x) => P(x))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & (~)?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & (~)?[x]:(S(x) & P(x))))}
#     [if n == 2] NOMINAL_R {^[P]:(... & ?[x2]:(f2(x2) & (~)P(x2)))}
#     or {^[P]:(... & ?[x2]:(f2(x2) & (~)?[x]:(x2(x) & P(x))))} if x2 is a set
# NOTE: xi could also be constants, rather than existentially-quantified variables
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_coordination,try_remove_genitive OR NOMINAL_R:remove_adv,add_coordination # for n > 2
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_coordination,try_remove_genitive COMMA OR NOMINAL_R:remove_adv,add_coordination # for n > 2
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_coordination,try_remove_genitive OR NOMINAL_R:try_remove_comma,try_remove_coordination,remove_adv # for n == 2
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_coordination,try_remove_genitive COMMA OR NOMINAL_R:try_remove_comma,try_remove_coordination,remove_adv # for n == 2

# NOMINAL_R {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & P(x))))}
#  -> NOMINAL_R {^[P]:(... & ?[x1]:(f1(x1) & P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & ![x]:(x1(x) => P(x))))} if x1 is a set
#     (COMMA) OR
#     [if n > 2] NOMINAL_R {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ?[x]:(S(x) & P(x))))}
#     [if n == 2] NOMINAL_R {^[P]:(... & ?[x2]:(f2(x2) & P(x2)))}
#     or {^[P]:(... & ?[x2]:(f2(x2) & ?[x]:(x2(x) & P(x))))} if x2 is a set
# NOTE: xi could also be constants, rather than existentially-quantified variables
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_coordination,try_remove_genitive,require_not_correlated_by_either NOR NOMINAL_R:remove_adv,add_coordination # for n > 2
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_coordination,try_remove_genitive,require_not_correlated_by_either COMMA NOR NOMINAL_R:remove_adv,add_coordination # for n > 2
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_coordination,try_remove_genitive,require_not_correlated_by_either NOR NOMINAL_R:try_remove_comma,try_remove_coordination,remove_adv # for n == 2
NOMINAL_R -> NOMINAL_R:try_remove_comma,try_remove_coordination,try_remove_genitive,require_not_correlated_by_either COMMA NOR NOMINAL_R:try_remove_comma,try_remove_coordination,remove_adv # for n == 2


# pronouns
PRO nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# PRO {^[P]:?[X]:(^[x]:(x=me) & ?[x]:(X(x) & P(x)))} -> I/ME
PRO -> I
PRO -> ME

# PRO {^[P]:?[X]:(^[x]:(x=you) & ?[x]:(X(x) & P(x)))} -> YOU
PRO -> YOU

# PRO {^[P]:?[X]:(^[x]:(U(0,x) & female_ref(x)) & ?[x]:(X(x) & P(x)))} -> SHE/HER
PRO -> SHE
PRO -> HER

# PRO {^[P]:?[X]:(^[x]:(U(0,x) & male_ref(x)) & ?[x]:(X(x) & P(x)))} -> HE/HIM
PRO -> HE
PRO -> HIM

# PRO {^[P]:?[X]:(^[x]:(U(0,x) & ref(x)) & ?[x]:(X(x) & P(x)))} -> IT
PRO -> IT

# PRO {^[P]:?[X]:(plural_ref(X) & ?[x]:(X(x) & P(x)))} -> THEY/THEM
PRO -> THEY
PRO -> THEM

# PRO {^[P,x]:?[X]:(X=^[x]:U(0,x) & X(x) & P(x))} -> WHICH/WHAT/WHICHEVER/WHATEVER
PRO -> WHICH
PRO -> WHAT
PRO -> WHICHEVER
PRO -> WHATEVER

# PRO {^[P,x]:?[X]:(X=^[x]:(U(0,x) & animate(x)) & X(x) & P(x))} -> WHO/WHOM/WHOEVER/WHOMEVER
PRO -> WHO
PRO -> WHOM
PRO -> WHOEVER
PRO -> WHOMEVER

# PRO {^[P,x]:?[X]:(X=^[x]:(U(0,x) & location(x)) & X(x) & P(x))} -> WHERE/WHEREVER
PRO -> WHERE
PRO -> WHEREVER


# this noun phrase nonterminal is for left-side modifiers
NOMINAL_L nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# NOMINAL_L {^[P]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x))))} -> N {a}
# NOMINAL_L {^[P]:(X=^[x]:(U(0,x) & p(x)) & ?[x]:(X(x) & P(x))))} -> N {p}
# NOMINAL_L {^[P]:(X=^[x]:(U(0,x) & p(x)) & ![x]:(X(x) => P(x))))} -> N {p}
# This depends on whether `p` is an event (i.e. typically has arguments, even
# if it doesnt in this particular logical form).
NOMINAL_L -> N

# NOMINAL_L {^[P]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x))))} -> V {a}
# NOMINAL_L {^[P]:(X=^[x]:(U(0,x) & p(x)) & ?[x]:(X(x) & P(x))))} -> V {p}
# NOMINAL_L {^[P]:(X=^[x]:(U(0,x) & p(x)) & ![x]:(X(x) => P(x))))} -> V {p}
# This depends on whether `p` is an event (i.e. typically has arguments, even
# if it doesnt in this particular logical form).
NOMINAL_L -> V:add_tion

# NOMINAL_L {^[P]:(X=^[x]:(?[y]:(p(y) & arg1(p)=x)) & ?[x]:(X(x) & P(x))))} -> V {p}
# NOMINAL_L {^[P]:(X=^[x]:(?[y]:(p(y) & arg1(p)=x)) & ![x]:(X(x) => P(x))))} -> V {p}
NOMINAL_L -> V:add_er # this adds "ers" if the concord is plural, as well as any duplicated consonants if appropriate (i.e. "programmers")

# NOMINAL_L {^[P]:(... & ?[X]:(F(X=^[x]:(... & f(x))) & ... & ![x]:(X(x) => P(x))))}
#  -> ADJP_R {^[P]:(... & f')}
#     NOMINAL_L {^[P]:(... & ?[X]:(F(X=^[x]:(...) & ... & ![x]:(X(x) => P(x))))}
# where f(x) = (~)?[z]:(h(z) & arg1/arg2(z)=x) and f' = (~)?[z]:(h(z) & P(z))
#    or f(x) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=x) & ... & (~)?[zn]:(hn(zn) & arg1/arg2(zn)=x) and f' = (~)?[z1]:(h1(z1) & P(z1)) & ... & (~)?[zn]:(hn(zn) & P(zn))
#    or f(x) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=x) | ... | (~)?[zn]:(hn(zn) & arg1/arg2(zn)=x) and f' = (~)?[z1]:(h1(z1) & P(z1)) | ... | (~)?[zn]:(hn(zn) & P(zn))
# NOTE: This rule also works if X is existentially-quantified or used collectively.
NOMINAL_L -> ADJP_R:try_remove_genitive NOMINAL_L:try_remove_correlated

# NOMINAL_L {^[P]:(... & ?[X]:(F(X=^[x]:(... & f(x))) & ... & ![x]:(X(x) => P(x))))}
#  -> ADJP_R {^[P]:(... & f')}
#     NOMINAL_L {^[P]:(... & ?[X]:(F(X=^[x]:(...) & ... & ![x]:(X(x) => P(x))))}
# where f(x) = (~)?[z]:(h(z) & arg1/arg2(z)=x) and f' = (~)?[z]:(h(z) & P(z))
#    or f(x) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=x) & ... & (~)?[zn]:(hn(zn) & arg1/arg2(zn)=x) and f' = (~)?[z1]:(h1(z1) & P(z1)) & ... & (~)?[zn]:(hn(zn) & P(zn))
#    or f(x) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=x) | ... | (~)?[zn]:(hn(zn) & arg1/arg2(zn)=x) and f' = (~)?[z1]:(h1(z1) & P(z1)) | ... | (~)?[zn]:(hn(zn) & P(zn))
# NOTE: This rule also works if X is existentially-quantified or used collectively.
NOMINAL_L -> ADJP_R:try_remove_genitive NOMINAL_L:try_remove_correlated

# NOMINAL_L {^[P]:(... & ?[X]:(F(X) & ?[g1]:(... & P(arg1(g1)) & ... & greatest/least(f)(g1) & ... & arg2(g1)=X) & ... & ?[gn]:(... & P(arg1(gn)) & ... & greatest/least(f)(gn) & ... & arg2(gn)=X)))}
#  -> ADJP_R {^[P]:(?[g1]:(greatest/least(f)(g1) & P(g1)) & ... & ?[gn]:(greatest/least(f)(gn) & P(gn)))}
#     NOMINAL_L {^[P]:(... & ?[X]:(F(X) & ?[x]:(X(x) & P(x))))}
# e.g. "closest and brightest star"
NOMINAL_L -> ADJP_R:try_remove_genitive NOMINAL_L:try_remove_correlated

# NOMINAL_L {^[P]:(... & ?[X]:(F(X=^[x]:(?[s]:(arg2(s)=a & ... & arg1(s)=x) & U(0,x)))) & ...)}
#  -> NOMINAL_L {^[P]:?[Y]:(Y=^[y]:(y=a) & ?[y]:(Y(y) & P(y)))}
#     NOMINAL_L {^[P]:(... & ?[X]:(F(X=^[x]:(?[s]:(... & arg1(s)=x) & U(0,x)))) & ...)}
# NOMINAL_L {^[P]:(... & ?[X]:(F(X=^[x]:(?[s]:(?[y]:(f(y) & arg2(s)=y) & ... & arg1(s)=x) & U(0,x)))) & ...)}
#  -> NOMINAL_L {^[P]:?[Y]:(Y=^[y]:f(y) & ?[y]:(Y(y) & P(y)))}
#     NOMINAL_L {^[P]:(... & ?[X]:(F(X=^[x]:(?[s]:(... & arg1(s)=x) & U(0,x)))) & ...)}
# e.g. "potion seller"
NOMINAL_L -> NOMINAL_L:try_remove_genitive NOMINAL_L:try_remove_correlated

# NOMINAL_L {^[P]:(... & ?[X]:(F(X=^[x]:(?[c]:(consists_of(c) & arg1(c)=x & arg2(c)=a) & ...)) & ...))}
#  -> NOMINAL_L {^[P]:?[Y]:(Y=^[y]:(y=a) & ?[y]:(Y(y) & P(y)))}
#     NOMINAL_L {^[P]:(... & ?[X]:(F(X=^[x]:(...)) & ...))}
# NOMINAL_L {^[P]:(... & ?[X]:(F(X=^[x]:(?[c]:(consists_of(c) & ?[y]:(f(y) & arg1(c)=y) & arg2(c)=a) & ...)) & ...))}
#  -> NOMINAL_L {^[P]:?[Y]:(Y=^[y]:f(y) & ?[y]:(Y(y) & P(y)))}
#     NOMINAL_L {^[P]:(... & ?[X]:(F(X=^[x]:(...)) & ...))}
# e.g. "apple pie"
# TODO: what about "California Senator"
NOMINAL_L -> NOMINAL_L:try_remove_genitive NOMINAL_L:try_remove_correlated # for `consists_of` (or maybe `contains`?)
NOMINAL_L -> NOMINAL_L:try_remove_genitive NOMINAL_L:try_remove_correlated # for `purpose`
NOMINAL_L -> NOMINAL_L:try_remove_genitive NOMINAL_L:try_remove_correlated # for `located`

# NOMINAL_L {^[P]:(... & ?[X]:(F(X=^[x]:(?[m1]:(g1(m1) & arg1/arg2(m1)=x) & ... & ?[mn]:(gn(mn) & arg1/arg2(mn)=x) & ...)) & ...))}
#  -> VP_L {?[m1]:g1(m1) & ... & ?[mn]:gn(mn)}
#     NOMINAL_L {^[P]:(... & ?[X]:(F(X=^[x]:(...)) & ...))}
# e.g. "recently published article", "melting marshmellows"
NOMINAL_L -> VP_L:try_remove_genitive,add_present_participle NOMINAL_L:try_remove_correlated
NOMINAL_L -> VP_L:try_remove_genitive,add_past_participle NOMINAL_L:try_remove_correlated

# NOMINAL_L {^[P]:(... & ?[X]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x))))} -> ENTITY_NAME {a}
# this depends on whether `a` is a constant vs a predicate, or a more complex formula
#NOMINAL_L -> ENTITY_NAME

# NOMINAL_L {^[P]:(... & ?[X]:(X=^[x]:(first_name(x)=n1) & ?[x]:(X(x) & P(x))))} -> NAME {first_name(x)=n1}
# NOMINAL_L {^[P]:(... & ?[X]:(X=^[x]:(first_name(x)=n1 & last_name(x)=n2) & ?[x]:(X(x) & P(x))))} -> NAME {first_name(x)=n1 & last_name(x)=n2}
# NOMINAL_L {^[P]:(... & ?[X]:(X=^[x]:(nickname(x,n1)) & ?[x]:(X(x) & P(x))))} -> NAME {nickname(x,n1)}
NOMINAL_L -> NAME


#ENTITY_NAME nonterminal {} {1.0} {1.0} {} 10 1.0 {}
#ENTITY_NAME -> STRING:get_nickname
#ENTITY_NAME -> STRING:get_first_name
#ENTITY_NAME -> STRING:get_first_name STRING:get_last_name

NAME nonterminal {} {1.0} {1.0} {} 10 1.0 {}
# NAME {nickname(x,s)} -> STRING {s}
NAME -> STRING:select_nickname
# NAME {first_name(x)=s} -> STRING {s}
NAME -> STRING:select_first_name
# NAME {first_name(x)=s1 & last_name(x)=s2} -> STRING {s1} STRING {s2}
NAME -> STRING:select_first_name STRING:select_last_name


PP nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# transitive prepositions
# PP {^[P]:(... & ?[x]:(p(x) & arg1/arg2/arg3(x)=a & P(x)))}
#  -> P {p}
#     NP {^[P]:?[Y]:(Y=^[y]:(y=a) & ?[y]:(Y(y) & P(y)))}
# PP {^[P]:(... & ?[x]:(p(x) & arg1/arg2/arg3(x)=possibility(A) & P(x)))}
#  -> P {p}
#     NP {^[P]:A'} where p is something that expresses possibility like `capable_of`, and A' has a `P(z)` term added to the head scope (it will also need to be changed into the set-centric form expected by NP)
# PP {^[P]:(... & ?[x]:(p(x) & ?[y]:(f(y) & arg1/arg2/arg3(x)=y) & P(x)))}
#  -> P {p}
#     NP {^[P]:?[Y]:(Y=^[y]:f(y) & ?[y]:(Y(y) & P(y)))}
# PP {^[P]:(... & ![y]:(f(y) => ?[x]:(p(x) & arg1/arg2/arg3(x)=y & P(x))))}
#  -> P {p}
#     NP {^[P]:?[Y]:(Y=^[y]:f(y) & ![y]:(Y(y) => P(y)))}
# PP {^[P]:(... & ?[Y]:(F(Y) & ... & ![y]:(Y(y) => ?[x]:(p(x) & arg1/arg2/arg3(x)=y & P(x)))))}
#  -> P {p}
#     NP {^[P]:?[Y]:(F(Y) & ![y]:(Y(y) => P(y)))}
# e.g. "house(s) next to the tree(s)"
PP -> P:require_no_preposition NP:try_remove_comma,try_remove_correlated
# e.g. "friend of Mary's", "eyes of Mary's"
PP -> P:require_no_preposition NP:add_genitive,try_remove_comma,try_remove_correlated
# for prepositional verbs (i.e. "look forward to", etc)
PP -> P_PLACEHOLDER:require_preposition NP:try_remove_comma,try_remove_correlated

# for (intransitive) prepositional verbs (i.e. "look forward to", etc)
# PP {^[P]:(... & ?[x]:(p(x) & P(x)))}
#  -> P {p}
PP -> P_PLACEHOLDER:require_preposition NP:try_remove_comma,try_remove_correlated

# PP {^[P]:(... & ?[x]:(p(x) & ?[y]:(f(y) & arg1/arg2(x)=y) & P(x)))}
#  -> P {p}
#     S' {... & ?[y]:f(y)}
# e.g. "before the meeting ended"
PP -> P:require_no_preposition S':try_remove_comma,try_remove_correlated

# closed interrogative finite subordinate clause
# PP {^[P]:(... & (~)?[y1]:(g1(y1) & f(y1)) & ... & (~)?[yn]:(gn(yn) & f(yn)))}
#  -> P {^[P]:(... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn))}
#     P S' {... & f'}
# where f(y) = arg2(y)=^[x]:A and f' = ^[x]:A
# e.g. "he is worried about whether or not the game ended"
PP -> P S':try_remove_comma,add_req_no_aux,add_whether,try_remove_correlated

# open interrogative finite subordinate clause
# PP {^[P]:(... & (~)?[y1]:(g1(y1) & f(y1)) & ... & (~)?[yn]:(gn(yn) & f(yn)))}
#  -> P {^[P]:(... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn))}
#     S' {... & f'}
# where f(y) = arg2(y)=^[x]:A and f' = ^[x]:A
# e.g. "he is worried about when she will arrive"
PP -> P S':try_remove_comma,add_req_no_aux,add_subordinate,try_remove_correlated

# prepositional phrase complements
# PP {^[P]:(... & ?[x]:(p(x) & f(x) & P(x)))}
#  -> P {p}
#     PP {^[P]:(... & ?[x]:(p(x) & f(x) & P(x)))}
# e.g. "apart from Jill", "away from me", "since before the war"
PP -> P:require_no_preposition PP:add_preposition,try_remove_correlated

# postpositions
# PP {^[P]:(... & ?[x]:(p(x) & arg1/arg2(x)=a & P(x)))}
#  -> NP {^[P]:?[Y]:(Y=^[y]:(y=a) & ?[y]:(Y(y) & P(y)))}
#     P {p}
# PP {^[P]:(... & ?[x]:(p(x) & arg1/arg2(x)=possibility(A) & P(x)))}
#  -> NP {^[P]:A'} where p is something that expresses possibility like `capable_of`, and A' has a `P(z)` term added to the head scope
#     P {p}
# PP {^[P]:(... & ?[x]:(p(x) & ?[y]:(f(y) & arg1/arg2(x)=y) & P(x)))}
#  -> NP {^[P]:?[Y]:(Y=^[y]:f(y) & ?[y]:(Y(y) & P(y)))}
#     P {p}
# PP {^[P]:(... & ![y]:(f(y) => ?[x]:(p(x) & arg1/arg2(x)=y & P(x))))}
#  -> NP {^[P]:?[Y]:(Y=^[y]:f(y) & ![y]:(Y(y) => P(y)))}
#     P {p}
# PP {^[P]:(... & ?[Y]:(F(Y) & ... & ![y]:(Y(y) => ?[x]:(p(x) & arg1/arg2(x)=y & P(x)))))}
#  -> NP {^[P]:?[Y]:(F(Y) & ![y]:(Y(y) => P(y)))}
#     P {p}
# e.g. "ten years ago"
PP -> NP:try_remove_comma POSTPOSITION:require_no_preposition

# PP {^[P]:(... & ~?[x]:(f(x) & P(x)))}
#  -> NOT PP {^[P]:(... & ?[x]:(f(x) & P(x)))}
PP -> NOT PP:try_remove_comma,try_remove_correlated

# PP {^[P]:(... & (~)?[x]:((~)?[v1]:g1(v1) & ... & (~)?[vn]:gn(vn) & f(x) & P(x)))}
#  -> ADVP_L {^[P]:((~)?[v1]:(g1(v1) ^ P(v1)) & ... & (~)?[vn]:(gn(vn) & P(vn)))}
#     PP {^[P]:(... & (~)?[x]:(f(x) & P(x)))}
PP -> ADVP_L:try_remove_comma PP:try_remove_comma,try_remove_correlated

# preposition stranding
# e.g. "what school did Jason run to?"
PP -> P:require_no_preposition,require_empty_ref

# for correlated coordination
# NOTE: For the following rules, the coordination doesn't have to be at head
# scope, it can be the left-most coordination that is a descendant of the head
# scope as well, so long as there is no negation between the coordination and
# the root. However, we need some measure of "distance" between the
# coordination and the head scope to be a feature to decide between the rules
# at this nonterminal (e.g. "both" moves left much less often than "either").
# PP {^[P]:(... & ((~)?[x1]:f1(x1) | ... | (~)?[xn]:fn(xn)))} -> EITHER PP {^[P]:(... & ((~)?[x1]:f1(x1) | ... | (~)?[xn]:fn(xn)))}
PP -> EITHER:require_not_correlated,require_no_coordination PP:add_correlated_by_either
# PP {^[P]:(... & ((~)?[x1]:f1(x1) & (~)?[x2]:f2(x2)))} -> BOTH PP {^[P]:(... & ((~)?[x1]:f1(x1) & (~)?[x2]:f2(x2)))}
PP -> BOTH:require_not_correlated,require_no_coordination PP:add_correlated_by_both
# PP {^[P]:(... & (~?[x1]:f1(x1) & ... & ~?[xn]:fn(xn)))} -> NEITHER PP {^[P]:(... & (?[x1]:f1(x1) | ... | ?[xn]:fn(xn)))}
PP -> NEITHER:require_not_correlated,require_no_coordination PP:add_correlated_by_neither

# PP {^[P]:(... & ((~)?[x1]:f1(x1) & ... & (~)?[xn]:fn(xn)))}
#  -> PP {^[P]:(... & (~)?[x1]:f1(x1))}
#     COMMA
#     PP {^[P]:(... & ((~)?[x2]:f2(x2) & ... & (~)?[xn]:fn(xn)))}
# PP {^[P]:(... & ((~)?[x1]:f1(x1) | ... | (~)?[xn]:fn(xn)))}
#  -> PP {^[P]:(... & (~)?[x1]:f1(x1))}
#     COMMA
#     PP {^[P]:(... & ((~)?[x2]:f2(x2) | ... | (~)?[xn]:fn(xn)))}
PP -> PP:try_remove_comma,try_remove_coordination COMMA PP:add_comma,add_coordination # for n > 2
PP -> PP:try_remove_comma,try_remove_coordination COMMA PP:try_remove_comma,try_remove_coordination # for n == 2

# PP {^[P]:(... & ((~)?[x1]:f1(x1) & ... & (~)?[xn]:fn(xn)))}
#  -> PP {^[P]:(... & (~)?[x1]:f1(x1))}
#     (COMMA) AND
#     PP {^[P]:(... & ((~)?[x2]:f2(x2) & ... & (~)?[xn]:fn(xn)))}
PP -> PP:try_remove_comma,try_remove_coordination AND PP:add_coordination # for n > 2
PP -> PP:try_remove_comma,try_remove_coordination COMMA AND PP:add_coordination # for n > 2
PP -> PP:try_remove_comma,try_remove_coordination AND PP:try_remove_comma,try_remove_coordination # for n == 2
PP -> PP:try_remove_comma,try_remove_coordination COMMA AND PP:try_remove_comma,try_remove_coordination # for n == 2

# PP {^[P]:(... & ((~)?[x1]:f1(x1) | ... | (~)?[xn]:fn(xn)))}
#  -> PP {^[P]:(... & (~)?[x1]:f1(x1))}
#     (COMMA) OR
#     PP {^[P]:(... & ((~)?[x2]:f2(x2) | ... | (~)?[xn]:fn(xn)))}
PP -> PP:try_remove_comma,try_remove_coordination OR PP:add_coordination # for n > 2
PP -> PP:try_remove_comma,try_remove_coordination COMMA OR PP:add_coordination # for n > 2
PP -> PP:try_remove_comma,try_remove_coordination OR PP:try_remove_comma,try_remove_coordination # for n == 2
PP -> PP:try_remove_comma,try_remove_coordination COMMA OR PP:try_remove_comma,try_remove_coordination # for n == 2

# PP {^[P]:(... & (?[x1]:f1(x1) | ... | ?[xn]:fn(xn)))}
#  -> PP {^[P]:(... & ?[x1]:f1(x1))}
#     (COMMA) NOR
#     PP {^[P]:(... & (?[x2]:f2(x2) | ... | ?[xn]:fn(xn)))}
PP -> PP:try_remove_comma,try_remove_coordination,require_not_correlated_by_either NOR PP:add_coordination # for n > 2
PP -> PP:try_remove_comma,try_remove_coordination,require_not_correlated_by_either COMMA NOR PP:add_coordination # for n > 2
PP -> PP:try_remove_comma,try_remove_coordination,require_not_correlated_by_either NOR PP:try_remove_comma,try_remove_coordination # for n == 2
PP -> PP:try_remove_comma,try_remove_coordination,require_not_correlated_by_either COMMA NOR PP:try_remove_comma,try_remove_coordination # for n == 2


ADJP_R nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# ADJP_R {^[P]:(... & ?[g1]:(... & p1(g1) & ... & f1(g1)) & ... & ?[gn]:(... & pn(gn) & ... & fn(gn)))}
#  -> ADJP_R {^[P]:(... & ?[g1]:(...) & ... & ?[gn]:(...))}
#     PP {^[P]:(... & ?[g1]:(p1(g1) & f1') & ... ?[gn]:(pn(gn) & fn'))}
# where fi(g) = ?[x]:(... & arg2(g)=x) and fi' = ?[x]:(...)
# NOTE: `x` could also be universally-quantified, in which case it is passed to the PP.
# e.g. "afraid of dogs", "capable of swimming"
ADJP_R -> ADJP_R:try_remove_comma PP:try_remove_comma,try_remove_correlated

# ADJP_R {^[P]:(... & ?[g1]:(... & f1(g1)) & ... & ?[gn]:(... & fn(gn)))}
#  -> ADJP_R {^[P]:(... & ?[g1]:(...) & ... & ?[gn]:(...))}
#     S' {^[P]:(f1' & ... & fn')}
# where fi(g) = ?[x]:(h(x) & arg2(g)=x) and fi' = ?[x]:(h(x) & P(x))
#    or fi(g) = arg2(g)=possibility(A) and fi' = A
# e.g. "glad that you arrived"
ADJP_R -> ADJP_R:try_remove_comma S':try_remove_comma,try_remove_correlated
ADJP_R -> ADJP_R:try_remove_comma S':try_remove_comma,try_remove_correlated,add_that

# closed interrogative finite subordinate clause
# ADJP_R {^[P]:(... & (~)?[y1]:(g1(y1) & f(y1)) & ... & (~)?[yn]:(gn(yn) & f(yn)))}
#  -> ADJP_R {^[P]:(... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn))}
#     IF/WHETHER S' {... & f'}
# where f(y) = arg2(y)=^[x]:A and f' = ^[x]:A
# e.g. "i'm not sure whether he arrived or not"
ADJP_R -> ADJP_R:try_remove_comma S':try_remove_comma,try_remove_correlated,add_req_no_aux,add_whether
ADJP_R -> ADJP_R:try_remove_comma S':try_remove_comma,try_remove_correlated,add_req_no_aux,add_if

# open interrogative finite subordinate clause
# ADJP_R {^[P]:(... & (~)?[y1]:(g1(y1) & f(y1)) & ... & (~)?[yn]:(gn(yn) & f(yn)))}
#  -> ADJP_R {^[P]:(... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn))}
#     S' {... & f'}
# where f(y) = arg2(y)=^[x]:A and f' = ^[x]:A
# e.g. "i'm not sure when she arrived"
ADJP_R -> ADJP_R:try_remove_comma S':try_remove_comma,try_remove_correlated,add_req_no_aux,add_subordinate

# ADJP_R {^[P]:(... & ?[g1]:(... & f1(g1)) & ... & ?[gn]:(... & fn(gn)))}
#  -> ADJP_R {^[P]:(... & ?[g1]:(...) & ... & ?[gn]:(...))}
#     NP {^[P]:(f1' & ... & fn')}
# where fi(g) = ?[x]:(h(x) & arg2(g)=x) and fi' = ?[x]:(h(x) & P(x))
# e.g. "worth three dollars"
ADJP_R -> ADJP_R:try_remove_comma NP:try_remove_comma,try_remove_correlated

# ADJP_R {^[P]:?[g1]:(... & h(g1)) & ... & ?[gn]:(... & h(gn))}
#  -> ADJP_R {^[P]:?[g1]:(...) & ... & ?[gn]:(...)}
#     VP_R/FOR S' {... & h'}
# where h(g) = ?[y]:(f(y) & arg2(g)=y) and h' = ?[y]:f(y)
#    or h(g) = arg2(g)=possibility(A) and h' = A
# e.g. "happy to help", "easy for me to sympathize", "too hot to drink", "too hot for you to drink"
ADJP_R -> ADJP_R:try_remove_comma VP_R:try_remove_comma,try_remove_correlated,add_to_infinitive
ADJP_R -> ADJP_R:try_remove_comma S':try_remove_comma,try_remove_correlated,add_to_infinitive,add_for

# ADJP_R {^[P]:?[g1]:(... & h(g1)) & ... & ?[gn]:(... & h(gn))}
#  -> ADJP_R {^[P]:?[g1]:(...) & ... & ?[gn]:(...)}
#     VP_R {... & h'}
# where h(g) = ?[y]:(f(y) & arg2(g)=y) and h' = ?[y]:f(y)
#    or h(g) = arg2(g)=possibility(A) and h' = A
# e.g. "busy preparing the report"
ADJP_R -> ADJP_R:try_remove_comma VP_R:try_remove_comma,try_remove_correlated,add_present_participle

# comparative constructions
# ADJP_R {^[P]:(... & ?[g1]:(p(f1)(g1) & ... & arg2(g1)=a) & ... & ?[gn]:(p(fn)(gn) & ... & arg2(gn)=a) & ...)}
#  -> ADJP_R {^[P]:(... & ?[g1]:(p(f1)(g1) & ...) & ... & ?[gn]:(p(fn)(gn) & ...) & ...)}
#     COMP {p}
#     V_ADJUNCT {?[gn]:(arg2(gn)=a)}
# ADJP_R {^[P]:(... & ?[r]:(... & ?[g1]:(p(f1)(g1) & ... & arg2(g1)=r) & ... & ?[gn]:(p(fn)(gn) & ... & arg2(gn)=r) & ... & h(r) & ...))}
#  -> ADJP_R {^[P]:(... & ?[g1]:(p(f1)(g1) & ...) & ... & ?[gn]:(p(fn)(gn) & ...) & ...)}
#     COMP {p}
#     V_ADJUNCT {h'}
# ADJP_R {^[P]:(... & ?[R]:(... & ![r]:(R(r) => ?[g1]:(p(f1)(g1) & ... & arg2(g1)=r) & ... & ?[gn]:(p(fn)(gn) & ... & arg2(gn)=r)) & ... & R=^[r]:h(r) & ...))}
#  -> ADJP_R {^[P]:(... & ?[g1]:(p(f1)(g1) & ...) & ... & ?[gn]:(p(fn)(gn) & ...) & ...)}
#     COMP {p} (or `f`, whichever comes last)
#     V_ADJUNCT {h'}
# where h(r) = r=a and h' = ?[gn]:(arg2(gn)=a)
#    or h(r) = U(i,r) & p(r) & ?[x]:(arg1/arg2(x)=r & ...) and h' = ?[gn]:(?[r]:(U(i,r) & p(r) & ?[x]:(arg1/arg2(x)=r & ...)))
#    or h(r) = ?[x]:(arg1/arg2(x)=r & ...) & h' = ?[x]:(...)
# NOTE: The predicate could also be a simple `p` rather than `p(f)`.
# e.g. "more powerful than my car", "brighter than Vega"
ADJP_R -> ADJP_R:try_remove_comma COMP V_ADJUNCT:try_remove_comma,try_remove_correlated

# for correlated coordination
# NOTE: For the following rules, the coordination doesn't have to be at head
# scope, it can be the left-most coordination that is a descendant of the head
# scope as well, so long as there is no negation between the coordination and
# the root. However, we need some measure of "distance" between the
# coordination and the head scope to be a feature to decide between the rules
# at this nonterminal (e.g. "both" moves left much less often than "either").
# ADJP_R {^[P]:(A1 | ... | An)} -> EITHER ADJP_R {^[P]:(A1 | ... | An)}
ADJP_R -> EITHER:require_not_correlated,require_no_coordination ADJP_R:add_correlated_by_either
# ADJP_R {^[P]:(A1 & A2)} -> BOTH ADJP_R {^[P]:(A1 & A2)}
ADJP_R -> BOTH:require_not_correlated,require_no_coordination ADJP_R:add_correlated_by_both
# ADJP_R {^[P]:(~A1 & ... & ~An)} -> EITHER ADJP_R {^[P]:(A1 | ... | An)}
ADJP_R -> NEITHER:require_not_correlated,require_no_coordination ADJP_R:add_correlated_by_neither

# ADJP_R {^[P]:(A1 & ... & An)} -> ADJP_R {^[P]:A1} COMMA ADJP_R {^[P]:(A2 & ... & An)}
# ADJP_R {^[P]:(A1 | ... | An)} -> ADJP_R {^[P]:A1} COMMA ADJP_R {^[P]:(A2 | ... | An)}
ADJP_R -> ADJP_R:try_remove_comma,try_remove_coordination COMMA ADJP_R:add_comma,add_coordination # for n > 2
ADJP_R -> ADJP_R:try_remove_comma,try_remove_coordination COMMA ADJP_R:try_remove_comma,try_remove_coordination # for n == 2

# ADJP_R {^[P]:(A1 & ... & An)} -> ADJP_R {^[P]:A1} (COMMA) AND ADJP_R {^[P]:(A2 & ... & An)}
ADJP_R -> ADJP_R:try_remove_comma,try_remove_coordination AND ADJP_R:add_coordination # for n > 2
ADJP_R -> ADJP_R:try_remove_comma,try_remove_coordination COMMA AND ADJP_R:add_coordination # for n > 2
ADJP_R -> ADJP_R:try_remove_comma,try_remove_coordination AND ADJP_R:try_remove_comma,try_remove_coordination # for n == 2
ADJP_R -> ADJP_R:try_remove_comma,try_remove_coordination COMMA AND ADJP_R:try_remove_comma,try_remove_coordination # for n == 2

# ADJP_R {^[P]:(A1 | ... | An)} -> ADJP_R {^[P]:A1} (COMMA) OR ADJP_R {^[P]:(A2 | ... | An)}
ADJP_R -> ADJP_R:try_remove_comma,try_remove_coordination OR ADJP_R:add_coordination # for n > 2
ADJP_R -> ADJP_R:try_remove_comma,try_remove_coordination COMMA OR ADJP_R:add_coordination # for n > 2
ADJP_R -> ADJP_R:try_remove_comma,try_remove_coordination OR ADJP_R:try_remove_comma,try_remove_coordination # for n == 2
ADJP_R -> ADJP_R:try_remove_comma,try_remove_coordination COMMA OR ADJP_R:try_remove_comma,try_remove_coordination # for n == 2

# ADJP_R {^[P]:(A1 | ... | An)} -> ADJP_R {^[P]:A1} (COMMA) NOR ADJP_R {^[P]:(A2 | ... | An)}
ADJP_R -> ADJP_R:try_remove_comma,try_remove_coordination,require_not_correlated_by_either NOR ADJP_R:add_coordination # for n > 2
ADJP_R -> ADJP_R:try_remove_comma,try_remove_coordination,require_not_correlated_by_either COMMA NOR ADJP_R:add_coordination # for n > 2
ADJP_R -> ADJP_R:try_remove_comma,try_remove_coordination,require_not_correlated_by_either NOR ADJP_R:try_remove_comma,try_remove_coordination # for n == 2
ADJP_R -> ADJP_R:try_remove_comma,try_remove_coordination,require_not_correlated_by_either COMMA NOR ADJP_R:try_remove_comma,try_remove_coordination # for n == 2

# ADJP_R {^[P,x]:?[r]:(?[d]:(degree(d) & arg1(d)=r & arg2(d)=x) & ...)}
#  -> HOW ADJP_R {^[P]:?[r]:(...)}
ADJP_R -> HOW ADJP_R:try_remove_comma

# ADJP_R {A} -> ADJP_L {A}
ADJP_R -> ADJP_L:try_remove_comma


ADJP_L nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# ADJP_L {^[P]:?[g]:(f(g) & P(g))} -> ADJ {f}
ADJP_L -> ADJ

# ADJP_L {^[P]:?[g]:(greatest/least(f)(g) & P(g))} -> ADJ {f}
ADJP_L -> ADJ:add_superlative

# ADJP_L {^[P]:?[g]:(greatest/least(f)(g) & P(g))} -> ADJP_L {^[P]:?[g]:(f(g) & P(g))}
ADJP_L -> MOST ADJP_L:try_remove_correlated # for `greatest` only
ADJP_L -> LEAST ADJP_L:try_remove_correlated # for `least` only

# ADJP_L {^[P]:?[g]:(greater/less(f)(g) & P(g))} -> ADJ {f}
ADJP_L -> ADJ:add_comparative

# ADJP_L {^[P]:?[g]:(greater/less(f)(g) & P(g))} -> ADJP_L {^[P]:?[g]:(f(g) & P(g))}
ADJP_L -> MORE ADJP_L:try_remove_correlated # for `greater` only
ADJP_L -> LESS ADJP_L:try_remove_correlated # for `less` only

# ADJP_L {^[P]:(... & ~?[g1]:f1(g1) & ... & ~?[gn]:fn(gn))}
#  -> NOT ADJP_L {^[P]:(... & ?[g1]:f1(g1) & ... & ?[gn]:fn(gn))}
# e.g. "not tall"
ADJP_L -> NOT ADJP_L:try_remove_correlated

# ADJP_L {^[P]:(... & (~)?[g1]:((~)?[x]:(... & arg1(x)=g1) & ... & P(g1)) & ... & (~)?[gn]:((~)?[x]:(... & arg1(x)=gn) & ... & P(gn)))}
#  -> ADVP_L {^[P]:(... & (~)?[x]:(... & P(x)))}
#     ADJP_L {^[P]:(... & (~)?[g1]:(... & P(g1)) & ... & (~)?[gn]:(... & P(gn)))}
# e.g. "very tall"
ADJP_L -> ADVP_L ADJP_L:try_remove_correlated

# ADJP_L {^[P]:(... & (~)?[g1]:(... & f1(g1)) & ... & (~)?[gn]:(... & fn(gn)))}
#  -> NP {^[P]:(f1' & ... & fn')}
#     ADJP_L {^[P]:(... & (~)?[g1]:(...) & ... & (~)?[gn]:(...))}
# where fi(g) = ?[x]:(h(x) & arg2(g)=x) and fi' = ?[x]:(h(x) & P(x))
# e.g. "500 feet tall"
ADJP_L -> NP ADJP_L:try_remove_correlated


ADVP_R nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# ADVP_R {^[P]:(... & (~)?[g1]:(... & p1(g1) & ... & f1(g1)) & ... & (~)?[gn]:(... & pn(gn) & ... & fn(gn)))}
#  -> ADVP_R {^[P]:(... & (~)?[g1]:(...) & ... & (~)?[gn]:(...))}
#     PP {^[P]:(... & (~)?[g1]:(p1(g1) & f1') & ... & (~)?[gn]:(pn(gn) & fn'))}
# where fi(g) = ?[x]:(... & arg2(g)=x) and fi' = ?[x]:(...)
# NOTE: `x` could also be universally-quantified, in which case it is passed to the PP.
# e.g. "differently than him", "equally as effective"
ADVP_R -> ADVP_R:try_remove_comma PP:try_remove_comma,try_remove_correlated

# e.g. "so softly that no one heard", "much rather give it to charity"
# TODO: implement this
ADVP_R -> ADVP_R REL?

# comparative constructions
# ADVP_R {^[P]:(... & ?[r]:(... & ?[g1]:(p(f1)(g1) & ... & arg2(g1)=a) & ... & ?[gn]:(p(fn)(gn) & ... & arg2(gn)=a) & ...))}
#  -> ADVP_R {^[P]:(... & ?[g1]:(p(f1)(g1) & ...) & ... & ?[gn]:(p(fn)(gn) & ...) & ...)}
#     COMP {p}
#     V_ADJUNCT {?[gn]:(arg2(gn)=a)}
# ADVP_R {^[P]:(... & ?[r]:(... & ?[g1]:(p(f1)(g1) & ... & arg2(g1)=r) & ... & ?[gn]:(p(fn)(gn) & ... & arg2(gn)=r) & ... & h(r) & ...))}
#  -> ADVP_R {^[P]:(... & ?[g1]:(p(f1)(g1) & ...) & ... & ?[gn]:(p(fn)(gn) & ...) & ...)}
#     COMP {p}
#     V_ADJUNCT {h'}
# ADVP_R {^[P]:(... & ?[R]:(... & ![r]:(R(r) => ?[g1]:(p(f1)(g1) & ... & arg2(g1)=r) & ... & ?[gn]:(p(fn)(gn) & ... & arg2(gn)=r)) & ... & R=^[r]:h(r) & ...))}
#  -> ADVP_R {^[P]:(... & ?[g1]:(p(f1)(g1) & ...) & ... & ?[gn]:(p(fn)(gn) & ...) & ...)}
#     COMP {p} (or `f`, whichever comes last)
#     V_ADJUNCT {h'}
# where h(r) = r=a and h' = ?[gn]:(arg2(gn)=a)
#    or h(r) = U(i,r) & p(r) & ?[x]:(arg1/arg2(x)=r & ...) and h' = ?[gn]:(?[r]:(U(i,r) & p(r) & ?[x]:(arg1/arg2(x)=r & ...)))
#    or h(r) = ?[x]:(arg1/arg2(x)=r & ...) & h' = ?[x]:(...)
# NOTE: The predicate could also be a simple `p` rather than `p(f)`.
# e.g. "more persuasively than me"
ADVP_R -> ADVP_R:try_remove_comma COMP V_ADJUNCT:try_remove_comma,try_remove_correlated

# for correlated coordination
# NOTE: For the following rules, the coordination doesn't have to be at head
# scope, it can be the left-most coordination that is a descendant of the head
# scope as well, so long as there is no negation between the coordination and
# the root. However, we need some measure of "distance" between the
# coordination and the head scope to be a feature to decide between the rules
# at this nonterminal (e.g. "both" moves left much less often than "either").
# ADVP_R {^[P]:(A1 | ... | An)} -> EITHER ADVP_R {^[P]:(A1 | ... | An)}
ADVP_R -> EITHER:require_not_correlated,require_no_coordination ADVP_R:add_correlated_by_either
# ADVP_R {^[P]:(A1 & A2)} -> BOTH ADVP_R {^[P]:(A1 & A2)}
ADVP_R -> BOTH:require_not_correlated,require_no_coordination ADVP_R:add_correlated_by_both
# ADVP_R {^[P]:(~A1 & ... & ~An)} -> NEITHER ADVP_R {^[P]:(A1 | ... | An)}
ADVP_R -> NEITHER:require_not_correlated,require_no_coordination ADVP_R:add_correlated_by_neither

# ADVP_R {^[P]:(A1 & ... & An)} -> ADVP_R {^[P]:A1} COMMA ADVP_R {^[P]:(A2 & ... & An)}
# ADVP_R {^[P]:(A1 | ... | An)} -> ADVP_R {^[P]:A1} COMMA ADVP_R {^[P]:(A2 | ... | An)}
ADVP_R -> ADVP_R:try_remove_comma,try_remove_coordination COMMA ADVP_R:add_comma,add_coordination # for n > 2
ADVP_R -> ADVP_R:try_remove_comma,try_remove_coordination COMMA ADVP_R:try_remove_comma,try_remove_coordination # for n == 2

# ADVP_R {^[P]:(A1 & ... & An)} -> ADVP_R {^[P]:A1} (COMMA) AND ADVP_R {^[P]:(A2 & ... & An)}
ADVP_R -> ADVP_R:try_remove_comma,try_remove_coordination AND ADVP_R:add_coordination # for n > 2
ADVP_R -> ADVP_R:try_remove_comma,try_remove_coordination COMMA AND ADVP_R:add_coordination # for n > 2
ADVP_R -> ADVP_R:try_remove_comma,try_remove_coordination AND ADVP_R:try_remove_comma,try_remove_coordination # for n == 2
ADVP_R -> ADVP_R:try_remove_comma,try_remove_coordination COMMA AND ADVP_R:try_remove_comma,try_remove_coordination # for n == 2

# ADVP_R {^[P]:(A1 | ... | An)} -> ADVP_R {^[P]:A1} (COMMA) OR ADVP_R {^[P]:(A2 | ... | An)}
ADVP_R -> ADVP_R:try_remove_comma,try_remove_coordination OR ADVP_R:add_coordination # for n > 2
ADVP_R -> ADVP_R:try_remove_comma,try_remove_coordination COMMA OR ADVP_R:add_coordination # for n > 2
ADVP_R -> ADVP_R:try_remove_comma,try_remove_coordination OR ADVP_R:try_remove_comma,try_remove_coordination # for n == 2
ADVP_R -> ADVP_R:try_remove_comma,try_remove_coordination COMMA OR ADVP_R:try_remove_comma,try_remove_coordination # for n == 2

# ADVP_R {^[P]:(A1 | ... | An)} -> ADVP_R {^[P]:A1} (COMMA) NOR ADVP_R {^[P]:(A2 | ... | An)}
ADVP_R -> ADVP_R:try_remove_comma,try_remove_coordination,require_not_correlated_by_either NOR ADVP_R:add_coordination # for n > 2
ADVP_R -> ADVP_R:try_remove_comma,try_remove_coordination,require_not_correlated_by_either COMMA NOR ADVP_R:add_coordination # for n > 2
ADVP_R -> ADVP_R:try_remove_comma,try_remove_coordination,require_not_correlated_by_either NOR ADVP_R:try_remove_comma,try_remove_coordination # for n == 2
ADVP_R -> ADVP_R:try_remove_comma,try_remove_coordination,require_not_correlated_by_either COMMA NOR ADVP_R:try_remove_comma,try_remove_coordination # for n == 2

ADVP_R -> ADVP_L:try_remove_comma


ADVP_L nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# ADVP_L {^[P]:?[g]:(f(g) & P(g))} -> ADV {f}
ADVP_L -> ADV

# ADVP_L {^[P]:?[g]:(f(g) & P(g))} -> ADJ {f}
ADVP_L -> ADJ:add_ly

# ADVP_L {^[P]:?[g]:(greatest/least(f)(g) & P(g))} -> ADV {f}
# e.g. "soonest", "most seriously"
ADVP_L -> ADV:add_superlative

# ADVP_L {^[P]:?[g]:(greatest/least(f)(g) & P(g))} -> ADVP_L {^[P]:?[g]:(f(g) & P(g))}
ADVP_L -> MOST ADVP_L:try_remove_comma,try_remove_correlated # for `greatest` only
ADVP_L -> LEAST ADVP_L:try_remove_comma,try_remove_correlated # for `least` only

# ADVP_L {^[P]:?[g]:(greater/less(f)(g) & P(g))} -> ADV {f}
# e.g. "sooner", "more seriously"
ADVP_L -> ADV:add_comparative

# ADVP_L {^[P]:?[g]:(greater/less(f)(g) & P(g))} -> ADVP_L {^[P]:?[g]:(f(g) & P(g))}
ADVP_L -> MORE ADVP_L:try_remove_comma,try_remove_correlated # for `greater` only
ADVP_L -> LESS ADVP_L:try_remove_comma,try_remove_correlated # for `less` only

# ADVP_L {^[P]:(... & ~?[g1]:f(g1) & ... & ~?[gn]:f(gn))}
#  -> NOT ADVP_L {^[P]:(... & ?[g1]:f(g1) & ... & ?[gn]:f(gn))}
# e.g. "very slowly"
ADVP_L -> NOT ADVP_L:try_remove_correlated

# ADVP_L {^[P]:(... & (~)?[g1]:((~)?[x]:(... & arg1(x)=g1) & ... & P(g1)) & ... & (~)?[gn]:((~)?[x]:(... & arg1(x)=gn) & ... & P(gn)))}
#  -> ADVP_L {^[P]:(... & (~)?[x]:(... & P(x)))}
#     ADVP_L {^[P]:(... & (~)?[g1]:(... & P(g1)) & ... & (~)?[gn]:(... & P(gn)))}
# e.g. "very slowly"
ADVP_L -> ADVP_L ADVP_L:try_remove_correlated

# ADVP_L {^[P]:(... & ?[g1]:(... & f1(g1)) & ... & ?[gn]:(... & fn(gn)))}
#  -> NP {^[P]:(f1' & ... & fn')}
#     ADVP_L {^[P]:(... & ?[g1]:(...) & ... & ?[gn]:(...))}
# where fi(g) = ?[x]:(h(x) & arg2(g)=x) and fi' = ?[x]:(h(x) & P(x))
# e.g. "12 minutes late"
ADVP_L -> NP ADVP_L:try_remove_correlated


ALL nonterminal {} {1.0} {1.0} {} 10 1.0 {}
ALL -> "every"
ALL -> "each"
ALL -> "all"


COMP nonterminal {} {1.0} {1.0} {} 10 1.0 {}
COMP -> "as"
COMP -> "than"
# TODO: is "that" a comparator? as in a relative clause like "the same hotel that we stayed at last year", or could we model all comparative phrases as relative clauses (or other kinds of subordinate clauses)?
COMP -> "rather than"
COMP -> "from"
COMP -> "to"
