# We use neo-Davidsonian/event semantics to represent meaning in logical form.
# Thus, all verbs, nouns, adjectives, adverbs, etc are expressed as quantified
# variables. The "head" of any logical form is the right-most scope (not
# necessarily the deepest). For example:
#
#  "cats are mammals"
#  ![x]:(U(0,x) & cat(x) => ?[t]:(arg1(t)=x & type(t) & present(t) & arg2(t)=mammal))
# where `present` is relative to the deictic origo, so it could be defined as
# something like ![x]:(present(x) = time(x)(T)) where time(x) returns the set
# of times at which the event x is true, and T is the current time in the
# discourse model (deictic origo). Also, `U` is the current universe of
# discourse. `U` can either contain the entire universe, as a default,
# U=^[x]:T, or it could change dynamically according to the discourse model.
# The first argument to `U` is an index that increases by one each time `U`
# function is invoked (and so its semantics can differ even within a sentence).
# We also might add an axiom like:
#     ![t,x,y]:((type(t) & arg1(t)=x & arg2(t)=y) = y(x))
#
# Generally, every event that corresponds to a verb is modified with
# information about the time at which the event occurs. We can do this with the
# following axioms:
#   ![x,t]:(progressive(x,t) = ?[r]:(r>0 & ![s]:(s>(t-r) & s<(t+r) => time(x)(t))))
#   ![x,t]:(perfect(x,t) = ![r]:(time(x)(r) => r<t))
#   ![x,t]:(perfect_progressive(x,t) = (perfect(x,t) & ?[r]:(r>0 & ![s]:(s>(t-r) & s<t => time(x)(t)))))
#   ![x]:(present(x) = time(x)(T))
#   ![x]:(present_progressive(x) = progressive(x,T))
#   ![x]:(present_perfect(x) = perfect(x,T))
#   ![x]:(present_perfect_progressive(x) = perfect_progressive(x,T))
#   ![x]:(past(x) = ?[t]:(t<T & time(x)(t)))
#   ![x]:(past_progressive(x) = ?[t]:(t<T & progressive(x,t)))
#   ![x]:(past_perfect(x) = ?[t]:(t<T & perfect(x,t)))
#   ![x]:(past_perfect_progressive(x) = ?[t]:(t<T & perfect_progressive(x,t)))
#   ![x]:(future(x) = ?[t]:(t>T & time(x)(t)))
#   ![x]:(future_progressive(x) = ?[t]:(t>T & progressive(x,t)))
#   ![x]:(future_perfect(x) = ?[t]:(t>T & perfect(x,t)))
#   ![x]:(future_perfect_progressive(x) = ?[t]:(t>T & perfect_progressive(x,t)))
# TODO: add time information to the below logical forms too
#
#  "4 cats sleep"
#  ?[X]:(subset(X,^[x]:(U(0,x) & cat(x))) & size(X)=4 & ![x]:(X(x) => ?[s]:(arg1(s)=x & sleep(s) & present(s))))
#
#  "4 cats slept"
#  ?[X]:(subset(X,^[x]:(U(0,x) & cat(x))) & size(X)=4 & ![x]:(X(x) => ?[s]:(arg1(s)=x & sleep(s) & past(s))))
#
#  "4 cats will have been sleeping"
#  ?[X]:(subset(X,^[x]:(U(0,x) & cat(x))) & size(X)=4 & ![x]:(X(x) => ?[s]:(arg1(s)=x & sleep(s) & future_perfect_progressive(s))))
#
#  "there is a cat"
#  ?[x]:(U(0,x) & cat(x))
#    [OR]
#  ?[c]:(U(0,x) & cat(x) & ?[l]:(arg1(l)=x & position(l) & present(l) & arg2(l)=L))
# where L is the current discourse location (location of deictic origo).
#
#  "3 teachers grade 6 exams"
#  ?[X]:(subset(X,^[x]:(U(0,x) & teacher(x))) & size(X)=3 & ?[Y]:(subset(Y,^[y]:(U(1,y) & exam(y))) & size(Y)=6 & ![x,y]:(X(x) & Y(y) => ?[g]:(arg1(g)=x & grade(g) & present(g) & arg2(g)=y))))
#  ?[X]:(subset(X,^[x]:(U(0,x) & teacher(x))) & size(X)=3 & ?[Y]:(subset(Y,^[y]:(U(1,y) & exam(y))) & size(Y)=6 & !W[x,y]:(X(x) & Y(y) => ?[g]:(arg1(g)=x & grade(g) & present(g) & arg2(g)=y))))
#  ?[X]:(subset(X,^[x]:(U(0,x) & teacher(x))) & size(X)=3 & ![x]:(X(x) => ?[Y]:(subset(Y,^[y]:(U(1,y) & exam(y))) & size(Y)=6 & ![y]:(Y(y) => ?[g]:(arg1(g)=x & grade(g) & present(g) & arg2(g)=y)))))
# where !W is the weak universal quantifier, which is defined as:
# !W[x1,...,xn]:(X1(x1) & ... & Xn(xn) => f(x1,...,xn)) =
#     ![x1]:(X1(x1) => ?[x2,...,xn]:(X2(x2) & ... & Xn(xn) & f(x1,...,xn)))
#   & ![x2]:(X2(x2) => ?[x1,x3,...,xn]:(X1(x1) & X3(x3) & ... & Xn(xn) & f(x1,...,xn)))
#   & ![x3]:(X3(x3) => ?[x1,...,x2,x4,...,xn]:(X1(x1) & ... & X2(x2) & X4(x4) & ... & Xn(xn) & f(x1,...,xn)))
#   & ![x4]:(X4(x4) => ?[x1,...,x3,x5,...,xn]:(X1(x1) & ... & X3(x3) & X5(x5) & ... & Xn(xn) & f(x1,...,xn)))
#   & ... & ![xn]:(Xn(xn) => ?[x1,...,x(n-1)]:(X1(x1) & ... & X(n-1)(x(n-1)) & f(x1,...,xn)))
#
#  "a dog likes every cat"
#  ?[d]:(U(0,d) & dog(d) & ![c]:(U(1,c) & cat(c) => ?[l]:(arg1(l)=d & like(l) & present(l) & arg2(l)=c)))
#  ![c]:(U(0,c) & cat(c) => ?[d]:(U(1,d) & dog(d) & ?[l]:(arg1(l)=d & like(l) & present(l) & arg2(l)=c)))
#
#  "a dog is liked by every cat"
#  ?[d]:(U(0,d) & dog(d) & ![c]:(U(1,c) & cat(c) => ?[l]:(arg1(l)=d & inverse(like)(l) & present(l) & arg2(l)=c)))
#  ![c]:(U(0,c) & cat(c) => ?[d]:(U(1,d) & dog(d) & ?[l]:(arg1(l)=d & inverse(like)(l) & present(l) & arg2(l)=c)))
# where we can have an axiom like:
#    ![e,t,x,y]:((inverse(t)(e) & arg1(e)=x & arg2(e)=y) = (t(e) & arg1(e)=y & arg2(e)=x))
# In fact, the passive voice is always realized in semantics using the
# `inverse` function.
#
#  "Noah entertained and was reviewed"
#  ?[e]:(arg1(e)=noah & entertain(e) & past(e)) & ?[r]:(arg1(r)=noah & inverse(review)(r) & past(r))
# NOTE: We originally labeled this sentence with the following logical form:
#  ?[X]:(?[e]:(entertain(e) & past(e) & ?[r]:(inverse(review)(r) & past(r) & X=^[x]:(x=e | x=r))) & ^[x]:(X(x) => arg1(x)=noah))
# However, putting events into sets is problematic if one of the events is
# itself a set of events. See the later example "she made a big cake, and hung
# up some balloons".
#
#  "not every cat is a tabby"
#  "not all cats are tabbies"
#  ~![c]:(U(0,c) & cat(c) => ?[t]:(arg1(t)=c & type(t) & present(t) & arg2(t)=tabby))
#
#  "every cat isn't a tabby"
#  "all cats aren't tabbies"
#  ~![c]:(U(0,c) & cat(c) => ?[t]:(arg1(t)=c & type(t) & present(t) & arg2(t)=tabby))
#  ![c]:(U(0,c) & cat(c) => ~?[t]:(arg1(t)=c & type(t) & present(t) & arg2(t)=tabby))
#
#  "a cat and dog are sleeping"
#  ?[X]:(?[c]:(U(0,c) & cat(c) & ?[d]:(U(1,d) & dog(d) & X=^[x]:(x=c | x=d))) & ![x]:(X(x) => ?[s]:(arg1(s)=x & sleep(s) & present(s))))
#
#  "4 cats, 2 dogs, and a bird are sleeping"
#  ?[X]:(?[C]:(subset(C,^[x]:(U(0,x) & cat(x))) & size(C)=4 & ?[D]:(subset(D,^[x]:(U(1,x) & dog(x))) & size(D)=2 & ?[b]:(U(2,b) & bird(b) & X=^[x]:(x=C | x=D | x=^[y]:y=b)))) & ![Y]:(X(Y) => ![x]:(Y(x) => ?[s]:(arg1(s)=x & sleep(s) & present(s)))))
#
#  "a man and his dog were walking in the park"
#  ?[X]:(?[m]:(U(0,m) & man(m) & ?[h]:(U(1,h) & male_ref(0,h) & ?[d]:(U(2,d) & dog(d) & ?[o]:(arg1(o)=h & own(o) & arg2(o)=d) & X=^[x]:(x=m | x=d)))) & ![x]:(X(x) => ?[w]:(arg1(w)=x & walk(w) & past_progressive(w) & ?[p]:(U(3,p) & park(p) & arg2(w)=p))))
# where `male_ref` is defined in the pragmatics model. We could supervise the
# pragmatics model by specifying that h and m refer to the same object. We
# similarly define `female_ref` for grammatically female anaphora and `ref` for
# anaphora whose grammatical gender is either neutral or unspecified. The first
# argument of `male_ref` is an index parameter so that multiple uses of "he" in
# the same sentence can potentially refer to different objects (just as the
# first argument of `U`).
#
#  "10 girls and boys are in class"
#  ?[X]:(?[G]:(G=^[x]:(U(0,x) & girl(x)) & ?[B]:(B=^[x]:(U(1,x) & boy(x)) & X=^[x]:(x=G | x=B))) & ![Y]:(X(Y) => size(Y)=10) & ![Y]:(X(Y) => ![x]:(Y(x) => ?[p]:(arg1(p)=x & position(p) & ?[c]:(U(2,c) & class(c) & arg2(p)=c)))))
#  ?[X]:(?[G]:(G=^[x]:(U(0,x) & girl(x)) & ?[B]:(B=^[x]:(U(1,x) & boy(x)) & X=^[x]:(x=G | x=B))) & sum(X,^[Y]:size(Y))=10 & ![Y]:(X(Y) => ![x]:(Y(x) => ?[p]:(arg1(p)=x & position(p) & present(p) & ?[c]:(U(2,c) & class(c) & arg2(p)=c)))))
#
#  "a cat is not currently but will be in the room"
#  ?[c]:(U(0,c) & cat(c) & ?[r]:(U(1,r) & room(r) & ?[l]:(arg1(l)=c & located(l) & present(l) & arg2(l)=r & ?[c]:(currently(c) & arg1(c)=l)) & ?[l]:(arg1(l)=c & located(l) & future(l) & arg2(l)=r)))
#
#  "Jane is the only doctor"
#  ?[o]:(arg1(o)=jane & only(o) & present(o) & arg2(o)=^[x]:(U(0,x) & doctor(x)))
#    [or maybe we should do]
#  ?[o]:(arg1(o)=jane & only(o) & present(o) & ?[D]:(D=^[x]:(U(1,x) & doctor(x)) & arg2(o)=D))
#
#  "i did not get much money"
#  ?[m]:(U(0,m) & money(m) & ?[l]:(large_amount(l) & arg1(l)=m) & ~?[r]:(arg1(r)=me & receive(r) & past(r) & arg2(r)=m))
#
#  "i don't like Ralph's destroying the barn"
#  "i don't like Ralph's destruction of the barn"
#  ?[d]:(arg1(d)=ralph & destroy(d) & progressive(d) & ?[b]:(U(0,b) & barn(b) & arg2(d)=b) & ~?[l]:(arg1(l)=me & like(l) & present(l) & arg2(l)=d))
# NOTE: We could require constant arguments (e.g. `ralph` and `me`) to be part
# of U in the discourse model.
#
#  "i don't like the destruction of the barns by the teenagers"
#  ![x]:(U(0,x) & teenager(x) => ![y]:(U(1,y) & barn(y) => ?[d]:(arg1(d)=x & destroy(d) & arg2(d)=y & ~?[l]:(like(l) & arg2(l)=d & arg1(l)=me))))
#    [OR]
#  ?[X]:(X=^[x]:(U(0,x) & teenager(x)) & ?[Y]:(Y=^[y]:(U(1,y) & barn(y)) & ![x]:(X(x) => ![y]:(Y(y) => ?[d]:(arg1(d)=x & destroy(d) & arg2(d)=y & ~?[l]:(arg1(l)=me & like(l) & arg2(l)=d))))))
#
#  "the cat's purring is soothing"
#  ?[p]:(?[c]:(U(0,c) & cat(c) & arg1(p)=c) & purr(p) & progressive(p) & ?[s]:(arg1(s)=p & sooth(s) & progressive(s)))
#
#  "Joan's pen is good"
#  ?[p]:(U(0,p) & pen(p) & ?[o]:(arg1(o)=joan & own(o) & arg2(o)=p) & ?[g]:(arg1(g)=p & good(g) & present(g)))
#
#  "Joan's pens are good"
#  ![x]:(U(0,x) & pen(x) & ?[o]:(arg1(o)=joan & own(o) & arg2(o)=x) => ?[g]:(arg1(g)=x & good(g) & present(g)))
#    [OR]
#  ?[X]:(X=^[p]:(U(0,p) & pen(p) & ?[o]:(arg1(o)=joan & own(o) & arg2(o)=p)) & ![x]:(X(x) => ?[g]:(arg1(g)=x & good(g) & present(g))))
#
#  "the students' pens are good"
#  ?[X]:(?[Y]:(Y=^[y]:(U(0,y) & student(y)) & X=^[x]:(U(1,x) & pen(x) & ?[y]:(Y(y) & ?[o]:(own(o) & arg2(o)=x & arg1(o)=y)))) & ![x]:(X(x) => ?[g]:(arg1(g)=x & good(g) & present(g))))
#
#  "i saw the trees by all the cats"
#  ?[X]:(X=^[x]:(U(0,x) & cat(x)) & ?[Y]:(Y=^[y]:(U(1,y) & tree(y) & ![x]:(X(x) => ?[n]:(near(n) & arg2(n)=y & arg1(n)=x))) & ![y]:(Y(y) => ?[s]:(arg1(s)=me & see(s) & past(s) & arg2(s)=y))))
#    [OR]
#  ![y]:(U(0,y) & tree(y) & ![x]:(U(1,x) & cat(x) => ?[n]:(near(n) & arg2(n)=y & arg1(n)=x)) => ?[s]:(arg1(s)=me & see(s) & past(s) & arg2(s)=y))
#
#  "he works a lot to earn money for school"
#  ?[h]:(U(0,h) & male_ref(0,h) & ?[w]:(arg1(w)=h & work(w) & present(w) & ?[l]:(large_duration(l) & arg1(l)=w) & ?[p]:(purpose(p) & ?[e]:(earn(e) & ?[m]:(U(1,m) & money(m) & arg2(e)=m) & arg2(p)=e) & arg1(p)=w)))
#
#  "the ladder collapsed because it was old"
#  ?[l]:(U(0,l) & ladder(l) & ?[c]:(arg1(c)=l & collapse(c) & past(c) & ?[r]:(reason(r) & ?[i]:(U(0,i) & ref(0,i) & ?[o]:(old(o) & past(o) & arg1(o)=i & arg2(r)=o)) & arg1(r)=c)))
#
#  "Mr. Bibby wrote the letter with a pencil"
#  ?[p]:(U(0,p) & pencil(p) & ?[l]:(U(1,l) & letter(l) & ?[w]:(arg1(x)=w & write(w) & arg2(w)=l & arg1(w)=bibby & ?[x]:(with(x) & arg2(x)=p))))
#
#  "the students wrote the letters with the pencils"
#  ?[S]:(S=^[s]:(U(0,s) & student(s)) & ?[L]:(L=^[l]:(U(1,l) & letter(l)) & ?[P]:(P=^[p]:(U(2,p) & pencil(p)) & !W[s,l,p]:(S(s) & L(l) & P(p) => ?[w]:(arg1(w)=s & wrote(w) & past(w) & arg2(w)=l & ?[x]:(with(x) & arg2(x)=p & arg1(x)=w))))))
#
#  "she sat on the table"
#  ?[x]:(U(0,x) & female_ref(0,x) & ?[s]:(arg1(s)=x & sit(s) & past(s) & ?[o]:(on_top_of(o) & ?[t]:(U(1,t) & table(t) & arg2(o)=t) & arg1(o)=s)))
#
#  "the birds hear each other"
#  ![X]:(X=^[x]:(U(0,x) & bird(x)) & ![x,y]:(X(x) & Y(x) & ~(x=y) => ?[h]:(arg1(h)=x & hear(h) & arg2(h)=y)))
#
#  "some relative of each villager and some relative of each townsman hate each other"
#  ?[a]:(U(0,a) & ![x]:(U(1,x) & villager(x) => ?[r]:(related_to(r) & arg2(r)=x & arg1(r)=a)) & ?[b]:(U(2,b) & ![x]:(U(3,x) & townsman(x) => ?[r]:(related_to(r) & arg2(r)=x & arg1(r)=b)) & ?[X]:(X=^[x]:(x=a | x=b) & ![x,y]:(X(x) & Y(x) & ~(x=y) => ?[h]:(arg1(h)=x & hate(h) & arg2(h)=y)))))
#
#  "in either case, i am going"
#  ?[X]:(subset(X,^[x]:(U(0,x) & case(x))) & size(X)=2 & ![x]:(X(x) => (true(x) => ?[g]:(arg1(g)=me & go(g) & progressive(g)))))
#
#  "if it rains, the grass will be wet"
#  "the grass, if it rains, will be wet"
#  ?[i]:(U(0,i) & ref(0,i) & ?[r]:(rain(r) & present(r) & arg1(r)=i)) => ?[g]:(U(1,g) & grass(g) & ?[w]:(wet(w) & future(w) & arg1(w)=g))
#
#  "he ran with difficulty"
#  ?[h]:(U(0,h) & male_ref(0,h) & ?[r]:(arg1(r)=h & run(r) & past(r) & ?[d]:(difficult(d) & arg1(d)=r)))
#
#  "he stood in silence"
#  ?[h]:(U(0,h) & male_ref(0,h) & ?[s]:(arg1(s)=h & stand(s) & past(s) & ?[x]:(silently(x) & arg1(x)=s)))
# where we could define ![x]:(silently(x) = ?[s]:(is_silent(s) & arg1(s)=arg1(x) & ![t]:(time(x)(t) => time(s)(t))))
#
#  "she helped me with my homework"
#  ?[s]:(U(0,s) & female_ref(0,s) & ?[h]:(arg1(h)=s & help(h) & past(h) & arg2(h)=me & ?[o]:(own(o) & arg2(o)=x & arg1(o)=me) & ?[w]:(with(w) & ?[x]:(U(1,x) & homework(x) & arg2(w)=x & arg1(w)=h))))
#
#  "he stayed for two weeks"
#  ?[h]:(U(0,h) & male_ref(0,h) & ?[s]:(arg1(s)=h & stay(s) & past(s) & ?[d]:(duration(d) & arg2(d)=(2*week) & arg1(d)=s)))
#
#  "it is under the bush"
#  ?[i]:(U(0,i) & ref(0,i) & ?[u]:(arg1(u)=i & is_under(u) & present(u) & ?[b]:(U(1,b) & bush(b) & arg2(u)=b)))
#
#  "the party is at seven o'clock"
#  ?[p]:(U(0,p) & party(p) & ?[s]:(arg1(s)=p & start_time(s) & present(s) & arg2(s)=(7:00pm)))
# where we could define ![x,t]:((start_time(x)=t) = ![s]:(time(x)(s) => t<=s)),
# or perhaps `start_time` and `end_time` should be the elementary event time
# predicates rather than `time`.
# TODO: how do we represent date/time constants?
#
#  "she will leave after she has had breakfast"
#  ?[s]:(U(0,s) & female_ref(0,s) & ?[l]:(arg1(l)=s & leave(l) & future(l) & ?[a]:(arg1(a)=l & after(a) & ?[r]:(U(1,r) & female_ref(1,r) & ?[e]:(eat(e) & ?[b]:(U(2,b) & breakfast(b) & arg2(e)=b) & arg1(e)=r & arg2(a)=e)))))
# where we could define ![a,x,y]:((after(a) & arg1(a)=x & arg2(a)=y) = ~?[s,t]:(time(x)(s) & time(y)(t) & s<t))
#
#  "the ball rotated quickly and heated up slowly"
#  ?[b]:(U(0,b) & ball(b) & ?[r]:(arg1(r)=b & rotate(r) & past(r) & ?[q]:(quickly(q) & arg1(q)=r)) & ?[h]:(arg1(h)=b & heat_up(h) & past(h) & ?[s]:(slowly(s) & arg1(s)=h)))
# NOTE: We originally labeled this sentence with the following logical form:
#  ?[b]:(U(0,b) & ball(b) & ?[r]:(rotate(r) & past(r) & ?[q]:(quickly(q) & arg1(q)=r) & ?[h]:(heat_up(h) & past(h) & ?[s]:(slowly(s) & arg1(s)=h) & ?[X]:(X=^[x]:(x=r | x=h) & ![x]:(X(x) => arg1(x)=b)))))
# However, putting events into sets is problematic if one of the events is
# itself a set of events. See the later example "she made a big cake, and hung
# up some balloons".
#
#  "the ball rotated and heated up slowly"
#  ?[b]:(U(0,b) & ball(b) & ?[r]:(arg1(r)=b & rotate(r) & past(r) & ?[s]:(slowly(s) & arg1(s)=r)) & ?[h]:(arg1(h)=b & heat_up(h) & past(h) & ?[s]:(slowly(s) & arg1(s)=h)))
# NOTE: We originally labeled this sentence with the following logical form:
#  ?[b]:(U(0,b) & ball(b) & ?[r]:(rotate(r) & past(r) & ?[h]:(heat_up(h) & past(h) & ?[X]:(X=^[x]:(x=r | x=h) & ![x]:(X(x) => ?[s]:(slowly(s) & arg1(s)=x) & arg1(x)=b)))))
# However, putting events into sets is problematic if one of the events is
# itself a set of events. See the later example "she made a big cake, and hung
# up some balloons".
#
#  "slowly, the ball rotated and heated up"
#  ?[b]:(U(0,b) & ball(b) & ?[r]:(arg1(r)=b & rotate(r) & past(r) & ?[s]:(slowly(s) & arg1(s)=r)) & ?[h]:(?[s]:(slowly(s) & arg1(s)=h) & arg1(h)=b & heat_up(h) & past(h)))
#
#  "Emma and Noah met"
#  ?[X]:(X=^[x]:(x=emma | x=noah) & ?[m]:(arg1(m)=X & collective_meet(m) & past(m)))
#
#  "Emma and Noah lifted the stone"
#  ?[X]:(X=^[x]:(x=emma | x=noah) & ?[s]:(U(0,s) & stone(s) & ?[l]:(lift(l) & past(l) & arg2(l)=s & arg1(l)=X)))
# Here, "Emma and Noah" has a *collective* interpretation, which also occurs in
# many other sentences in English.
#
#  "i think there is a unicorn"
#  ?[t]:(arg1(t)=me & think(t) & present(t) & arg2(t)=possibility(?[e]:(exists(e) & present(e) & ?[u]:(U(0,u) & unicorn(u) & arg1(e)=u))))
# This is why we need the `true` predicate, since it provides a uniform way to
# handle modality, and to talk about objects and events that may not actually
# exist or be true, but may exist as thoughts or suppositions (the Platonic
# universe). All events have the property that if they are true, then all of
# its arguments are true, with a handful of specified exceptions, including
# `think`, `capable_of`, `want`, `purpose`, etc.
#
#  "i can swim"
#  "i am capable of swimming"
#  ?[c]:(arg1(c)=me & capable_of(c) & present(c) & arg2(c)=possibility(?[s]:(arg1(s)=me & swim(s))))
#
#  "i could swim"
#  "i was capable of swimming"
#  ?[c]:(arg1(c)=me & capable_of(c) & past(c) & arg2(c)=possibility(?[s]:(arg1(s)=me & swim(s))))
#
#  "she made a big cake, and hung up some balloons"
#  {?[s]:(U(0,s) & female_ref(0,s) & ?[B]:(subset(B,^[b]:(U(2,b) & balloon(b))) & ?[m]:(arg1(m)=s & make(m) & past(m) & ?[c]:(U(1,c) & cake(c) & ?[b]:(is_big(b) & arg1(b)=c) & arg2(m)=c)) & ![b]:(B(b) => ?[h]:(arg1(h)=s & hang(h) & past(h) & arg2(h)=b))))}
#
#  "the doctor watched everyone sleep"
#  {?[d]:(U(0,d) & doctor(d) & ?[X]:(X=^[x]:(U(1,x) & person/animate(x)) & ![x]:(X(x) => ?[w]:(arg1(w)=d & watch(w) & past(w) & arg2(w)=x))))}
# NOTE: We model pragmatic domain restriction implicitly. In this example,
# `^[x]:U(0,x)` contains the doctor but `^[x]:U(1,x)` contains everyone being
# monitored by the doctor but does not contain the doctor.
#
#  "John can play the guitar, and Mary, the violin"
#  {?[c]:(arg1(c)=john & capable_of(c) & present(c) & ?[p]:(arg1(c)=john & play(p) & ?[g]:(U(0,g) & guitar(g) & arg2(p)=g) & arg2(c)=p)) & ?[e]:(arg1(e)=mary & empty_ref(0,e) & ?[v]:(U(1,v) & violin(v) & arg2(e)=v))}
#
#  "John can play his guitar. Mary, too"
#  {?[c]:(arg1(c)=john & capable_of(c) & present(c) & ?[p]:(arg1(c)=john & play(p) & ?[g]:(U(0,g) & guitar(g) & arg2(p)=g) & arg2(c)=p)) & ?[e]:(arg1(e)=mary & empty_ref(0,e) & too(e))}


# This is the root nonterminal for declarative sentences.
S nonterminal {} {1.0} {1.0} {} 10 1.0 {}
S -> S':singular
S -> S':plural

# S {... & (~)?[y1]:(f(y1) & g(y1)) & ... & (~)?[yn]:(f(yn) & g(yn))}
#  -> ADVP {... & f'}
#     (COMMA)
#     S {... & (~)?[y1]:g(y1) & ... & (~)?[yn]:g(yn)}
# where f(y) = (~)?[z]:(h(z) & arg2(z)=y) and f' = (~)?[z]:h(z)
#    or f(y) = (~)?[z1]:(h1(z1) & arg2(z1)=y) & ... & (~)?[zn]:(hn(zn) & arg2(zn)=y) and f' = (~)?[z1]:h1(z1) & ... & (~)?[zn]:hn(zn)
#    or f(y) = (~)?[z1]:(h1(z1) & arg2(z1)=y) | ... | (~)?[zn]:(hn(zn) & arg2(zn)=y) and f' = (~)?[z1]:h1(z1) | ... | (~)?[zn]:hn(zn)
S -> ADVP COMMA S
S -> ADVP S

# S {?[X]:(h(X) & ![x]:(X(x) => (true(x) => g(x))))}
#  -> PP {^[P]:?[X]:(h(X) & ![x]:(X(x) => (true(x) => P(x))))}
#     (COMMA)
#     S {g(x)}
# S {... & (~)?[y1]:(f(y1) & g(y1)) & ... & (~)?[yn]:(f(yn) & g(yn))}
#  -> PP {... & f'}
#     (COMMA)
#     S {... & (~)?[y1]:g(y1) & ... & (~)?[yn]:g(yn)}
# S {... & ![x]:(h(x) => (~)?[y1]:(f(y1,x) & g(y1)) & ... & (~)?[yn]:(f(yn,x) & g(yn)))}
#  -> PP {... & ![x]:(h(x) => f'(x))}
#     (COMMA)
#     S {... & (~)?[y1]:g(y1) & ... & (~)?[yn]:g(yn)}
# where f(y) = (~)?[z]:(h(z) & arg2(z)=y) and f' = (~)?[z]:h(z)
#    or f(y) = (~)?[z1]:(h1(z1) & arg2(z1)=y) & ... & (~)?[zn]:(hn(zn) & arg2(zn)=y) and f' = (~)?[z1]:h1(z1) & ... & (~)?[zn]:hn(zn)
#    or f(y) = (~)?[z1]:(h1(z1) & arg2(z1)=y) | ... | (~)?[zn]:(hn(zn) & arg2(zn)=y) and f' = (~)?[z1]:h1(z1) | ... | (~)?[zn]:hn(zn)
S -> PP S
S -> PP COMMA S

# S {?[X]:(f(X) & ![x]:(X(x) => (true(x) => g(x))))}
#  -> S {g(x)}
#     (COMMA)
#     PP {^[P]:?[X]:(f(X) & ![x]:(X(x) => (true(x) => P(x))))}
# NOTE: We don't allow other adjuncts here to avoid the spurious ambiguity
# where the PP could also attach at VP.
S -> S PP
S -> S COMMA PP

# S {A => B} -> IF S {A} (COMMA) (THEN) S {B}
S -> IF S S
S -> IF S COMMA S
S -> IF S THEN S
S -> IF S COMMA THEN S

# S {A => B} -> S {B} (COMMA) IF S {A}
S -> S IF S
S -> S COMMA IF S

# S {A1 & ... & An} -> S {A1} COMMA S {A2 & ... & An}
# S {A1 | ... | An} -> S {A1} COMMA S {A2 | ... | An}
# S {~A1 & ... & ~An} -> S {~A1} COMMA S {~A2 & ... & ~An}
# In the NOR rule, the negation can appear in front of the scope ?[y], or in
# front of any parent scope.
S -> S COMMA S

# S {A1 & A2} -> S {A1} (COMMA) AND S {A2}
S -> S COMMA AND S
S -> S AND S

# S {A1 | A2} -> S {A1} (COMMA) OR S {A2}
S -> S COMMA OR S
S -> S OR S

# S {A1 | A2} -> S {A1} (COMMA) OR S {A2}
S -> S COMMA NOR VP_R:add_req_aux
S -> S NOR VP_R:add_req_aux

# S {... & ?[y1]:(g1(y1) & ?[r]:(arg1(r)=y1 & reason(r) & ?[z]:(h(z) & arg2(r)=z))) & ... & ?[yn]:(gn(yn) & ?[r]:(arg1(r)=yn & reason(r) & ?[z]:(h(z) & arg2(r)=z)))}
#  -> S {... & ?[y1]:g1(y1) & ... & ?[yn]:gn(yn)}
#     (COMMA) BECAUSE/FOR S {f(...)}
S -> S COMMA BECAUSE S
S -> S BECAUSE S
S -> S COMMA FOR S
S -> S FOR S

# S {... & ?[y1]:(?[r]:(arg1(r)=y1 & reason(r) & ?[z]:(h(z) & arg2(r)=z)) & g1(y1)) & ... & ?[yn]:(?[r]:(arg1(r)=yn & reason(r) & ?[z]:(h(z) & arg2(r)=z)) & gn(yn))}
#  -> BECAUSE/FOR S {?[z]:h(z)}
#     (COMMA) S {?[y1]:g1(y1) & ... & ?[yn]:gn(yn)}
S -> BECAUSE S COMMA S
S -> BECAUSE S S
S -> FOR S COMMA S
S -> FOR S S


S' nonterminal {has_not} {1.0, 1.0} {1.0, 1.0} {} 10 1.0 {}

# S' {?[x]:f(x)} -> THERE IS DP {^[P]:?[x]:(f(x) & P(x))}
# NOTE: This above rule is only really useful if we choose to represent "there
# is a cat" as something like ?[x]:(U(0,x) & cat(x)).
S' -> THERE IS DP

# S' {... & ?[y1]:(... & arg1(y1)=a & ...) & ... & ?[yn]:(... & arg1(yn)=a & ...}
#  -> DP {a}
#     VP_R {... & ?[y1]:(...) & ... & ?[yn]:(...)}
# S' {... & (~)![x]:(f(x) => ... & ?[y1]:(... & arg1(y1)=x & ...) & ... & ?[yn]:(... & arg1(yn)=x & ...))}
#  -> DP {^[P]:(~)![x]:(f(x) => P(x))}
#     VP_R {... & ?[y1]:(...) & ... & ?[yn]:(...)}
# S' {... & ?[X]:(f(X) & (~)![x]:(X(x) => ... & ?[y1]:(... & arg1(y1)=x & ...) & ... & ?[yn]:(... & arg1(yn)=x & ...)))}
#  -> DP {^[P]:?[X]:(f(X) & (~)![x]:(X(x) => P(x))}
#     VP_R {... & ?[y1]:(...) & ... & ?[yn]:(...)}
# where g is arg1 or arg2.
# NOTE: The above two rules, during the inverse transformation, the scope of X
# and x can be positioned anywhere above the scope of y. However, to avoid
# producing semantically-equivalent logical forms, for each equivalence class
# of semantically-equivalent inverse logical forms, we only output a single
# logical form (for example, by choosing the logical form in the equivalence
# class in which the scope of X and x are maximal). Also, the above rule can be
# extended to other kinds of quantification over X, such as existential or weak
# universal quantifier. Also, note that f(X) and f(x) cannot depend on any
# variables other than those declared within f(X) and f(x). But note that in
# the example "a cat and dog are sleeping", f(X) includes the definition for
# "cat" and "dog". In the above two rules, the scope of y is the right-most
# and top-most scope of an event variable (a object with arguments).
S' -> DP VP_R

# S' {... & ~![x]:(f(x) => ... & ?[y1]:(... & arg1(y1)=x & ...) & ... & ?[yn]:(... & arg1(yn)=x & ...))}
#  -> DP {^[P]:![x]:(f(x) => P(x))}
#     VP_R {... & ~?[y1]:(...) & ... & ~?[yn]:(...)}
# S' {... & ?[X]:(f(X) & ~![x]:(X(x) => ... & ?[y1]:(... & arg1(y1)=x & ...) & ... & ?[yn]:(... & arg1(yn)=x & ...)))}
#  -> DP {^[P]:?[X]:(f(X) & ![x]:(X(x) => P(x))}
#     VP_R {... & ~?[y1]:(...) & ... & ~?[yn]:(...)}
# NOTE: The above note also applies to the above two rules.
S' -> DP VP_R


VP_R nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# VP_R {... & (~)?[y1]:(g1(y1) & f(y1)) & ... & (~)?[yn]:(gn(yn) & f(yn))}
#  -> VP_R {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
#     ADVP/PP {... & f'}
# VP_R {... & ![x]:(h(x) => (~)?[y1]:(g1(y1) & f(y1,x)) & ... & (~)?[yn]:(gn(yn) & f(yn,x)))}
#  -> VP_R {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
#     ADVP/PP {... & ![x]:(h(x) => f'(x))}
# where f(y) = (~)?[z]:(h(z) & arg2(z)=y) and f' = (~)?[z]:h(z)
#    or f(y) = (~)?[z1]:(h1(z1) & arg2(z1)=y) & ... & (~)?[zn]:(hn(zn) & arg2(zn)=y) and f' = (~)?[z1]:h1(z1) & ... & (~)?[zn]:hn(zn)
#    or f(y) = (~)?[z1]:(h1(z1) & arg2(z1)=y) | ... | (~)?[zn]:(hn(zn) & arg2(zn)=y) and f' = (~)?[z1]:h1(z1) | ... | (~)?[zn]:hn(zn)
VP_R -> VP_R PP
VP_R -> VP_R ADVP

# VP_R {... & (~)?[y1]:(p(y1) & f1(y1) & f(y1)) & ... & (~)?[yn]:(p(yn) & fn(yn) & f(yn))}
#  -> VP_R {... & (~)?[y1]:(p(y1) & f1(y1)) & ... & (~)?[yn]:(p(yn) & fn(yn))}
#     PP {... & ?[y]:(p(y) & f(y))}
# where f(y) = (~)?[z]:(h(z) & arg2(z)=y)
#    or f(y) = (~)?[z1]:(h1(z1) & arg2(z1)=y) & ... & (~)?[zn]:(hn(zn) & arg2(zn)=y)
#    or f(y) = (~)?[z1]:(h1(z1) & arg2(z1)=y) | ... | (~)?[zn]:(hn(zn) & arg2(zn)=y)
VP_R -> VP_R PP

# VP_R {... & (~)?[y1]:(g1(y1) & f(y1)) & ... & (~)?[yn]:(gn(yn) & f(yn))}
#  -> VP_R {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
#     DP {... & f'}
# VP_R {... & ![x]:(h(x) => (~)?[y1]:(g1(y1) & f(y1,x)) & ... & (~)?[yn]:(gn(yn) & f(yn,x)))}
#  -> VP_R {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
#     DP {... & ![x]:(h(x) => f'(x))}
# where f(y) = arg2/arg3(y)=a and f'=a
#    or f(y) = (~)?[z]:(h(z) & arg2/arg3(y)=z) and f' = (~)?[z]:h(z)
#    or f(y) = (~)?[z1]:(h1(z1) & arg2/arg3(y)=z1) & ... & (~)?[zn]:(hn(zn) & arg2/arg3(y)=zn) and f' = (~)?[z1]:h1(z1) & ... & (~)?[zn]:hn(zn)
#    or f(y) = (~)?[z1]:(h1(z1) & arg2/arg3(y)=z1) | ... | (~)?[zn]:(hn(zn) & arg2/arg3(y)=zn) and f' = (~)?[z1]:h1(z1) | ... | (~)?[zn]:hn(zn)
VP_R -> VP_R DP # for arg2
VP_R -> VP_R DP # for arg3 (NOTE: we could make this semantic and have only two args)

# for gapping and stripping
# VP_R {... & (~)?[y]:(empty_ref(0,y) & f(y))}
#  -> ADVP/PP {... & f'}
# VP_R {... & ![x]:(h(x) => (~)?[y]:(empty_ref(0,y) & f(y,x)))}
#  -> ADVP/PP {... & ![x]:(h(x) => f'(x))}
# where f(y) = (~)?[z]:(h(z) & arg2(z)=y) and f' = (~)?[z]:h(z)
#    or f(y) = (~)?[z1]:(h1(z1) & arg2(z1)=y) & ... & (~)?[zn]:(hn(zn) & arg2(zn)=y) and f' = (~)?[z1]:h1(z1) & ... & (~)?[zn]:hn(zn)
#    or f(y) = (~)?[z1]:(h1(z1) & arg2(z1)=y) | ... | (~)?[zn]:(hn(zn) & arg2(zn)=y) and f' = (~)?[z1]:h1(z1) | ... | (~)?[zn]:hn(zn)
VP_R -> PP:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse
VP_R -> ADVP:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse

# for gapping and stripping
# VP_R {... & (~)?[y]:(empty_ref(y) & f(y))}
#  -> DP {... & f'}
# VP_R {... & ![x]:(h(x) => (~)?[y]:(empty_ref(y) & f(y,x)))}
#  -> DP {... & ![x]:(h(x) => f'(x))}
# where f(y) = arg2/arg3(y)=a and f'=a
#    or f(y) = (~)?[z]:(h(z) & arg2/arg3(y)=z) and f' = (~)?[z]:h(z)
#    or f(y) = (~)?[z1]:(h1(z1) & arg2/arg3(y)=z1) & ... & (~)?[zn]:(hn(zn) & arg2/arg3(y)=zn) and f' = (~)?[z1]:h1(z1) & ... & (~)?[zn]:hn(zn)
#    or f(y) = (~)?[z1]:(h1(z1) & arg2/arg3(y)=z1) | ... | (~)?[zn]:(hn(zn) & arg2/arg3(y)=zn) and f' = (~)?[z1]:h1(z1) | ... | (~)?[zn]:hn(zn)
VP_R -> DP:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse

# VP_R {A1 & ... & An} -> VP_R {A1} COMMA VP_R {A2 & ... & An}
# VP_R {A1 | ... | An} -> VP_R {A1} COMMA VP_R {A2 | ... | An}
VP_R -> VP_R COMMA VP_R

# VP_R {A1 & A2} -> VP_R {A1} (COMMA) AND VP_R {A2}
VP_R -> VP_R COMMA AND VP_R
VP_R -> VP_R AND VP_R

# VP_R {A1 | A2} -> VP_R {A1} (COMMA) OR VP_R {A2}
VP_R -> VP_R COMMA OR VP_R
VP_R -> VP_R OR VP_R

# VP_R {~A1 & ~A2} -> VP_R {A1} (COMMA) NOR VP_R {A2}
VP_R -> VP_R COMMA NOR VP_R:add_req_aux
VP_R -> VP_R NOR VP_R:add_req_aux

# TODO: we could require that here are no additional right adjuncts in the head scope
VP_R -> VP_L:identity


VP_L nonterminal {} {1.0} {1.0} {} 10 1.0 {}
VP_L -> ADVP VP_L:require_no_req_aux
VP_L -> COMMA PP:require_no_req_aux COMMA VP_L
VP_L -> WILL VP_R:remove_future,add_infinitive,add_aux,remove_req_aux # future tense
VP_L -> HAVE VP_R:require_no_future,remove_perfect,add_past_participle,add_aux,remove_req_aux # perfect aspect
VP_L -> BE VP_R:require_no_future,require_no_perfect,remove_progressive,add_present_participle,add_aux,remove_req_aux # progressive aspect
VP_L -> DO VP_R:require_no_future,require_no_perfect,require_no_progressive,add_infinitive,add_aux,remove_req_aux # do-support
VP_L -> NOT VP_R:require_aux,remove_not,remove_req_aux
VP_L -> BE VP_R:require_no_future,require_no_perfect,require_no_progressive,remove_inverse,add_past_participle,add_aux,remove_req_aux # passive voice
VP_L -> MODAL VP_R:add_infinitive,remove_req_aux
VP_L -> V:require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,require_no_req_aux,require_no_empty_ref

# for gapping and stripping
VP_L -> WILL:remove_future,remove_req_aux,require_only_empty_ref # future tense
VP_L -> HAVE:require_no_future,remove_perfect,remove_req_aux,require_only_empty_ref # perfect aspect
VP_L -> BE:require_no_future,require_no_perfect,remove_progressive,remove_req_aux,require_only_empty_ref # progressive aspect
VP_L -> DO:require_no_future,require_no_perfect,require_no_progressive,remove_req_aux,require_only_empty_ref # do-support
VP_L -> NOT:require_aux,remove_not,remove_req_aux,require_only_empty_ref
VP_L -> BE:require_no_future,require_no_perfect,require_no_progressive,remove_inverse,remove_req_aux # passive voice,require_only_empty_ref
VP_L -> MODAL:remove_req_aux,require_empty_ref

# VP_L {... & (~)?[y1]:(g1(y1) & f(y1)) & ... & (~)?[yn]:(gn(yn) & f(yn))}
#  -> DP {... & f'}
#     VP_L {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
# VP_L {... & ![x]:(h(x) => (~)?[y1]:(g1(y1) & f(y1,x)) & ... & (~)?[yn]:(gn(yn) & f(yn,x)))}
#  -> DP {... & ![x]:(h(x) => f'(x))}
#     VP_L {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
# where f(y) = arg1(y)=a and f'=a
#    or f(y) = (~)?[z]:(h(z) & arg1(y)=z) and f' = (~)?[z]:h(z)
#    or f(y) = (~)?[z1]:(h1(z1) & arg1(y)=z1) & ... & (~)?[zn]:(hn(zn) & arg1(y)=zn) and f' = (~)?[z1]:h1(z1) & ... & (~)?[zn]:hn(zn)
#    or f(y) = (~)?[z1]:(h1(z1) & arg1(y)=z1) | ... | (~)?[zn]:(hn(zn) & arg1(y)=zn) and f' = (~)?[z1]:h1(z1) | ... | (~)?[zn]:hn(zn)
VP_L -> DP VP_L:require_no_req_aux # for subject-auxiliary inversion


# TODO: should this nonterminal change the universal/existential quantifiers into a single kind of quantifier, to improve generalization for the NP nonterminal and further downstream?
DP nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# DP {A} -> A NP {A}
DP -> DP'

# DP {?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)![x]:(S(x) => ![y]:(x(y) => h(y))))} if xi are set-valued
# or {?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)![x]:(S(x) => h(x)))} if xi are individuals
# or {?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)?[x]:(S(x) & ?[y]:(x(y) & h(y))))} if xi are set-valued
# or {?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)?[x]:(S(x) & h(x)))} if xi are individuals
#  -> DP {?[x1]:(f1(x1) & (~)h(x1))} or {?[x1]:(f1(x1) & (~)![x]:(x1(x) => h(x)))} if x1 is a set
#     COMMA
#     DP {?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)![x]:(S(x) => ![y]:(x(y) => h(y))))}
#     or {?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)![x]:(S(x) => h(x)))}
#     or {?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)?[x]:(S(x) & ?[y]:(x(y) & h(y))))}
#     or {?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)?[x]:(S(x) & h(x)))}
# note: xi could also be constants, rather than existentially-quantified variables
# note: if xi is a set containing a singleton, S would look like ^[x]:(... | x=^[y]:y=singleton | ...)
DP -> DP COMMA:null DP:comma

# DP {?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => ![y]:(x(y) => h(y))))}
# or {?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => h(x)))}
#  -> DP {?[x1]:(f1(x1) & (~)h(x1))} or {?[x1]:(f1(x1) & (~)![x]:(x1(x) => h(x)))} if x1 is a set
#     (COMMA) AND
#     DP {?[x2]:(f2(x2) & (~)h(x2))} or {?[x2]:(f2(x2) & (~)![x]:(x2(x) => h(x)))} if x2 is a set
# note: xi could also be constants, rather than existentially-quantified variables
DP -> DP AND:null DP
DP -> DP COMMA:null AND:null DP

# DP {?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & ?[y]:(x(y) & h(y))))}
# or {?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & h(x)))}
#  -> DP {?[x1]:(f1(x1) & (~)h(x1))} or {?[x1]:(f1(x1) & (~)?[x]:(x1(x) & h(x)))} if x1 is a set
#     (COMMA) OR
#     DP {?[x2]:(f2(x2) & (~)h(x2))} or {?[x2]:(f2(x2) & (~)?[x]:(x2(x) & h(x)))} if x2 is a set
# note: xi could also be constants, rather than existentially-quantified variables
DP -> DP OR:null DP
DP -> DP COMMA:null OR:null DP

# DP {~![x]:(f(x) -> h(x))} -> NO NP {![x]:(f(x) -> h(x))}
# DP {~?[x]:(f(x) & h(x))} -> NO NP {?[x]:(f(x) & h(x))}
# DP {![X]:(f(X) & ~![x]:(X(x) => h(x)))} -> NO NP {![X]:(f(X) & ![x]:(X(x) => h(x)))}
# DP {![X]:(f(X) & ~?[x]:(X(x) & h(x)))} -> NO NP {![X]:(f(X) & ?[x]:(X(x) & h(x)))}
# this depends on whether the head quantifier is negated
DP -> NO NP
DP -> NOT DP

# DP {a} -> NAME {a}
# this depends on whether `a` is a constant vs a predicate, or a more complex formula
DP -> NAME

# DP {A & h(a,c)} => ADV {h(x,c)} DP {A & a}
# DP {A & h(c,a)} => ADV {h(c,x)} DP {A & a}
# where e.g. h could be multiply and c could be 2, which can be expressed as "twice the ..."
DP -> ADV DP:adv

# DP {![X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => h(x)))} -> EACH NP {![X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => h(x)))}
# DP {![X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & h(x)))} -> EACH NP {![X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & h(x)))}
# this depends on whether the set is defined as S=^[x]:f(x) rather than with functions like `subset` or `half`;
# it also depends on whether the head predicate of the left conjunct is `this`, `that`, [TODO: add features for possessive]
DP -> EACH:no_adv NP

# DP {A} -> A NP {A}
#   e.g. "A group of students walks down the street."
DP -> A:null NP:concord_singular

# DP {![X]:(F(subset(X,^[x]:f(x))) & ![x]:(X(x) => h(x)))} -> SOME NP {![X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => h(x)))}
# DP {![X]:(F(subset(X,^[x]:f(x))) & ?[x]:(X(x) & h(x)))} -> SOME NP {![X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & h(x)))}
# this depends on whether the set is defined using `subset` rather than with functions like `half` or as S=^[x]:f(x);
DP -> SOME NP

# DP {A} -> DEF_DP {A}
DP -> DEF_DP

# DP {![X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => h(x)))} -> ALL DEF_NP {![X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => h(x)))}
# DP {![X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & h(x)))} -> ALL DEF_NP {![X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & h(x)))}
# this depends on whether the set is defined as S=^[x]:f(x) rather than with functions like `subset` or `half`;
# it also depends on whether the head predicate of the left conjunct is `this`, `that`, [TODO: add features for possessive]
DP -> ALL DEF_DP
DP -> ALL DP'

# DP {![X]:(F(half(X,^[x]:f(x))) & ![x]:(X(x) => h(x)))} -> HALF DEF_NP {![X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => h(x)))}
# DP {![X]:(F(half(X,^[x]:f(x))) & ?[x]:(X(x) & h(x)))} -> HALF DEF_NP {![X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & h(x)))}
# this depends on whether the set is defined using `half` rather than with functions like `subset` or as S=^[x]:f(x);
# it also depends on whether the head predicate of the left conjunct is `this`, `that`, [TODO: add features for possessive]
DP -> HALF DEF_DP
DP -> HALF A NP


DEF_DP nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# DEF_DP {A} -> THE NP {A}
DEF_DP -> THE DP'

# DP {![x]:(this(x) & f(x) => h(x))} -> THIS NP {![x]:(f(x) => h(x))}
# DP {?[x]:(this(x) & h(x))} -> THIS NP {?[x]:h(x)}
# DP {?[S]:(this(S) & F(S) & ![x]:(S(x) => h(x)))} -> THIS NP {?[S]:(F(S) & ![x]:(S(x) => h(x)))}
# DP {?[S]:(this(S) & F(S) & ?[x]:(S(x) & h(x)))} -> THIS NP {?[S]:(F(S) & ?[x]:(S(x) & h(x)))}
# this depends on whether the head predicate of the left conjunct is `this`
DEF_DP -> THIS DP'

# DP {![x]:(that(x) & f(x) => h(x))} -> THIS NP {![x]:(f(x) => h(x))}
# DP {?[x]:(that(x) & h(x))} -> THIS NP {?[x]:h(x)}
# DP {?[S]:(that(S) & F(S) & ![x]:(S(x) => h(x)))} -> THIS NP {?[S]:(F(S) & ![x]:(S(x) => h(x)))}
# DP {?[S]:(that(S) & F(S) & ?[x]:(S(x) & h(x)))} -> THIS NP {?[S]:(F(S) & ?[x]:(S(x) & h(x)))}
# this depends on whether the head predicate of the left conjunct is `that`
DEF_DP -> THAT DP'

# DEF_DP {?[x]:(belongs(x,a) & f(x))} -> DP {a} DP' {?[x]:f(x)}
# DEF_DP {?[x]:(?[y]:(g(y) & belongs(x,h(y))) & f(x))} -> DP {?[y]:(g(y) & h(y))} DP' {?[x]:f(x)}
# DEF_DP {?[S]:(![x]:(S(x) => belongs(x,a)) & f(S))} -> DP {a} DP' {?[S]:f(S)}
# DEF_DP {?[S]:(?[y]:(g(y) & ![x]:(S(x) => belongs(x,h(y)))) & f(S))} -> DP {?[y]:(g(y) & h(y))} DP' {?[S]:f(S)}
# DEF_DP {?[S]:(?[T]:(g(T) & ![x]:(S(x) => ![y]:(T(y) => belongs(x,h(y))))) & f(S))} -> DP {?[T]:(g(T) & ![y]:(T(y) => h(y)))} DP' {?[S]:f(S)}
# TODO: this is wrong; as written, this is stating for every x in S={x:f(x)} and every y in T={y:g(y)}, y owns x. but we want T to be the set {y:g(y) & some x owns y}
# note: in the above, the head predicate could also be `intended` rather than `belongs`
DEF_DP -> DP:poss DP'

# DEF_DP {?[x]:(f(x) & h(x))} -> DP {?[x]:(f(x) & x)} DP' {h(x)}
# DEF_DP {![x]:(f(x) => h(x))} -> DP {![x]:(f(x) => x)} DP' {h(x)}
# DEF_DP {?[S]:(f(S) & ![x]:(S(x) => h(x)))} -> DP {?[S]:(f(S) & ![x]:(S(x) => x))} DP' {h(x)}
# DEF_DP {?[S]:(f(S) & ?[x]:(S(x) & h(x)))} -> DP {?[S]:(f(S) & ?[x]:(S(x) & x))} DP' {h(x)}
# this depends on whether there is a predicate inside the Q, and its arguments (which argument is `x` in?) and arity
DEF_DP -> DP:poss DP'

# DEF_DP {?[x]:(f(x) & h(a,x))} -> DP {a} DP' {?[x]:(f(x) & h(y,x))}
# DEF_DP {?[x]:(f(x) & h(x,a))} -> DP {a} DP' {?[x]:(f(x) & h(x,y))}
# DEF_DP {![x]:(f(x) => h(a,x))} -> DP {a} DP' {![x]:(f(x) => h(y,x))}
# DEF_DP {![x]:(f(x) => h(x,a))} -> DP {a} DP' {![x]:(f(x) => h(x,y))}
# DEF_DP {?[x]:(f(x) & ?[y]:(g(y) & h(y,x)))} -> DP {?[y]:(g(y) & y)} DP' {?[x]:(f(x) & h(y,x))}
# DEF_DP {?[x]:(f(x) & ?[y]:(g(y) & h(x,y)))} -> DP {?[y]:(g(y) & y)} DP' {?[x]:(f(x) & h(x,y))}
# DEF_DP {![x]:(f(x) => ?[y]:(g(y) & h(y,x)))} -> DP {?[y]:(g(y) & y)} DP' {![x]:(f(x) => h(y,x))}
# DEF_DP {![x]:(f(x) => ?[y]:(g(y) & h(x,y)))} -> DP {?[y]:(g(y) & y)} DP' {![x]:(f(x) => h(x,y))}
# DEF_DP {?[x]:(f(x) & ![y]:(g(y) => h(y,x)))} -> DP {![y]:(g(y) => y)} DP' {?[x]:(f(x) & h(y,x))}
# DEF_DP {?[x]:(f(x) & ![y]:(g(y) => h(x,y)))} -> DP {![y]:(g(y) => y)} DP' {?[x]:(f(x) & h(x,y))}
# DEF_DP {![x]:(f(x) => ![y]:(g(y) => h(y,x)))} -> DP {![y]:(g(y) => y)} DP' {![x]:(f(x) => h(y,x))}
# DEF_DP {![x]:(f(x) => ![y]:(g(y) => h(x,y)))} -> DP {![y]:(g(y) => y)} DP' {![x]:(f(x) => h(x,y))}
# DEF_DP {?[S]:(f(S) & ![x]:(S(x) => h(a,x)))} -> DP {a} DP' {?[S]:(f(S) & ![x]:(S(x) => h(y,x)))}
# DEF_DP {?[S]:(f(S) & ![x]:(S(x) => h(x,y)))} -> DP {a} DP' {?[S]:(f(S) & ![x]:(S(x) => h(x,y)))}
# DEF_DP {?[S]:(f(S) & ?[x]:(S(x) & h(a,x)))} -> DP {a} DP' {?[S]:(f(S) & ?[x]:(S(x) & h(y,x)))}
# DEF_DP {?[S]:(f(S) & ?[x]:(S(x) & h(x,y)))} -> DP {a} DP' {?[S]:(f(S) & ?[x]:(S(x) & h(x,y)))}
# ...there are many more (where in the last four examples, `a` could be an existentially or universally-quantified variable, or a variable quantified over a set)
# this depends on whether there is a predicate in the head, and its arguments (which argument is `x` in?) and arity
DEF_DP -> DP:poss DP'


DP' nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# DP {?[S]:(f(S) & F(S) & ![x]:(S(x) => h(x)))} -> Q {f(S)} NP {?[S]:(F(S) & ![x]:(S(x) => h(x)))}
# this depends on whether the head predicate of the left conjunct is one that expresses information about the size of the set
DP' -> Q NP

# DEF_DP {A} -> THE NP {A}
DP' -> NP


Q nonterminal {} {1.0} {1.0} {} 10 1.0 {}
Q -> NUMBER
Q -> MUCH
Q -> MANY
Q -> MORE
Q -> MOST
Q -> FEW
Q -> FEWER
Q -> FEWEST
Q -> LESS
Q -> LEAST


# TODO: add appositives
# this noun phrase nonterminal is for right-side modifiers
NP nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# NP {A} -> NP' {A}
NP -> NP'

# NP {?[x]:(f(x) & h(x))} -> NP {h(x)} PP {?[x]:(f(x) & x)}
# NP {?[X1]:(F1(X1) & ... & ?[Xn]:(Fn(Xn) & (~)![x1]:(X1(x1) => ... ![xn]:(Xn(xn) => g(h1(x1),h2(x2,...,xn))))))}
#  -> NP {?[X2]:(F2(X2) & ... & ?[Xn]:(Fn(Xn) & (~)![x2]:(X2(x2) => ... ![xn]:(Xn(xn) => g(x1,h2(x2,...,xn))))))}
#     PP {?[X1]:(F1(X1) & ![x1]:(X1(x1) => h1(x1)))}
# NP {?[X1]:(F1(X1) & ... & ?[Xn]:(Fn(Xn) & (~)?[x1]:(X1(x1) => ... ![xn]:(Xn(xn) => g(h1(x1),h2(x2,...,xn))))))}
#  -> NP {?[X2]:(F2(X2) & ... & ?[Xn]:(Fn(Xn) & (~)![x2]:(X2(x2) => ... ![xn]:(Xn(xn) => g(x1,h2(x2,...,xn))))))}
#     PP {?[X1]:(F1(X1) & ?[x1]:(X1(x1) => h1(x1)))}
#  e.g. "destruction of the barn(s)", "destruction of the barn(s) by the termites"
NP -> NP PP

# NP {?[S]:(?[T]:(F(T) & G(S,^[x]:(u(x) & v(x,T)))) & ![x]:(S(x) => h(x)))} -> NP {?[S]:(G(S,^[x]:u(x)) & ![x]:(S(x) => h(x)))} PP {?[T]:(F(T) & v(x,T))}
#  e.g. "tree(s) by all the cats"
# note: S and T could be existentially or universally-quantified individuals rather than set-valued, as well; they could also be constants
NP -> NP PP

NP -> NP REL
NP -> NP COMMA:null REL COMMA:null
NP -> NP VP_R:keep_present_participle
NP -> NP VP_R:flip_predicate_keep_past_participle

# NP {?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)![x]:(S(x) => ![y]:(x(y) => h(y))))} if xi are set-valued
# or {?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)![x]:(S(x) => h(x)))} if xi are individuals
# or {?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)?[x]:(S(x) & ?[y]:(x(y) & h(y))))} if xi are set-valued
# or {?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)?[x]:(S(x) & h(x)))} if xi are individuals
#  -> NP {?[x1]:(f1(x1) & (~)h(x1))} or {?[x1]:(f1(x1) & (~)![x]:(x1(x) => h(x)))} if x1 is a set
#     COMMA
#     NP {?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)![x]:(S(x) => ![y]:(x(y) => h(y))))}
#     or {?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)![x]:(S(x) => h(x)))}
#     or {?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)?[x]:(S(x) & ?[y]:(x(y) & h(y))))}
#     or {?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)?[x]:(S(x) & h(x)))}
# note: xi could also be constants, rather than existentially-quantified variables
# note: if xi is a set containing a singleton, S would look like ^[x]:(... | x=^[y]:y=singleton | ...)
NP -> NP COMMA:null NP:comma

# NP {?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => ![y]:(x(y) => h(y))))}
# or {?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => h(x)))}
#  -> NP {?[x1]:(f1(x1) & (~)h(x1))} or {?[x1]:(f1(x1) & (~)![x]:(x1(x) => h(x)))} if x1 is a set
#     (COMMA) AND
#     NP {?[x2]:(f2(x2) & (~)h(x2))} or {?[x2]:(f2(x2) & (~)![x]:(x2(x) => h(x)))} if x2 is a set
# note: xi could also be constants, rather than existentially-quantified variables
NP -> NP AND:null NP
NP -> NP COMMA:null AND:null NP

# NP {?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & ?[y]:(x(y) & h(y))))}
# or {?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & h(x)))}
#  -> NP {?[x1]:(f1(x1) & (~)h(x1))} or {?[x1]:(f1(x1) & (~)?[x]:(x1(x) & h(x)))} if x1 is a set
#     (COMMA) AND
#     NP {?[x2]:(f2(x2) & (~)h(x2))} or {?[x2]:(f2(x2) & (~)?[x]:(x2(x) & h(x)))} if x2 is a set
# note: xi could also be constants, rather than existentially-quantified variables
NP -> NP OR:null NP
NP -> NP COMMA:null OR:null NP


# this noun phrase nonterminal is for left-side modifiers
NP' nonterminal {} {1.0} {1.0} {} 10 1.0 {}
NP' -> N
NP' -> ADJP NP'


PP nonterminal {} {1.0} {1.0} {} 10 1.0 {}
PP -> P DP
PP -> PP COMMA:null PP
PP -> PP AND PP
PP -> PP COMMA:null AND PP
PP -> PP OR PP
PP -> PP COMMA:null OR PP


ALL nonterminal {} {1.0} {1.0} {} 10 1.0 {}
ALL -> "every"
ALL -> "each"
ALL -> "all"
