# english.gram
# Author: asaparov
#
# Examples of sentences as well as broad strokes of the grammar were found in:
#   Huddleston, R. D. & Pullum, G. K. (2002). The Cambridge Grammar of the English Language Cambridge University Press.
#
# We use neo-Davidsonian/event semantics to represent meaning in logical form.
# Thus, all verbs, nouns, adjectives, adverbs, etc are expressed as quantified
# variables. A "head" of any logical form is the scope `y` such that there is
# no other scope `x` in the logical form with an edge `argn(x)=y` and `y` is
# not a set variable.
#
# We also chose to order the terms in the logical forms to match the order of
# the words/complements/arguments in the sentence as close as possible. This is
# so that, for each nonterminal, when selecting which production rule to
# expand, we only want to inspect one term (or a constant number of terms) in
# the logical form in order to make the decision. However, if the order of `n`
# terms in the head scope of the logical form is canonical, then we would need
# to inspect all `n` terms to capture the correct distribution.
#
#  "cats are mammals."
#  ![x]:(U(0,x) & cat(x) => ?[m]:(U(2,m) & mammal(m) & ?[s]:(arg1(s)=x & U(1,s) & same(s) & present(s) & arg2(s)=m)))
# where `present` is relative to the deictic origo, so it could be defined as
# something like ![x]:(present(x) = time(x)(T)) where time(x) returns the set
# of times at which the event x is true, and T is the current time in the
# discourse model (deictic origo). Also, `U` is the current universe of
# discourse. `U` can either contain the entire universe, as a default,
# U=^[x]:T, or it could change dynamically according to the discourse model.
# The first argument to `U` is an index that increases by one each time `U`
# function is invoked (and so its semantics can differ even within a sentence).
#
# Generally, every event that corresponds to a verb is modified with
# information about the time at which the event occurs. We can do this with the
# following axioms:
#   ![x,t]:(progressive(x,t) = ?[r]:(r>0 & ![s]:(s>(t-r) & s<(t+r) => time(x)(t))))
#   ![x,t]:(perfect(x,t) = ![r]:(time(x)(r) => r<t))
#   ![x,t]:(perfect_progressive(x,t) = (perfect(x,t) & ?[r]:(r>0 & ![s]:(s>(t-r) & s<t => time(x)(t)))))
#   ![x]:(present(x) = time(x)(T))
#   ![x]:(present_progressive(x) = progressive(x,T))
#   ![x]:(present_perfect(x) = perfect(x,T))
#   ![x]:(present_perfect_progressive(x) = perfect_progressive(x,T))
#   ![x]:(past(x) = ?[t]:(t<T & time(x)(t)))
#   ![x]:(past_progressive(x) = ?[t]:(t<T & progressive(x,t)))
#   ![x]:(past_perfect(x) = ?[t]:(t<T & perfect(x,t)))
#   ![x]:(past_perfect_progressive(x) = ?[t]:(t<T & perfect_progressive(x,t)))
#   ![x]:(future(x) = ?[t]:(t>T & time(x)(t)))
#   ![x]:(future_progressive(x) = ?[t]:(t>T & progressive(x,t)))
#   ![x]:(future_perfect(x) = ?[t]:(t>T & perfect(x,t)))
#   ![x]:(future_perfect_progressive(x) = ?[t]:(t>T & perfect_progressive(x,t)))
#
#  "4 cats sleep."
#  ?[X]:(subset(X,^[x]:(U(0,x) & cat(x))) & size(X)=4 & ![x]:(X(x) => ?[s]:(arg1(s)=x & U(1,s) & sleep(s) & present(s))))
#
#  "4 cats slept."
#  ?[X]:(subset(X,^[x]:(U(0,x) & cat(x))) & size(X)=4 & ![x]:(X(x) => ?[s]:(arg1(s)=x & U(1,s) & sleep(s) & past(s))))
#
#  "4 cats will have been sleeping."
#  ?[X]:(subset(X,^[x]:(U(0,x) & cat(x))) & size(X)=4 & ![x]:(X(x) => ?[s]:(arg1(s)=x & U(1,s) & sleep(s) & future_perfect_progressive(s))))
#
#  "there is a cat."
#  ?[x]:(U(0,x) & cat(x))
#    [OR]
#  ?[x]:(U(0,x) & cat(x) & ?[l]:(arg1(l)=x & U(1,l) & location(l) & present(l) & arg2(l)=L))
# where L is the current discourse location (location of deictic origo).
#
#  "3 teachers grade 6 exams."
#  ?[X]:(subset(X,^[x]:(U(0,x) & teacher(x))) & size(X)=3 & ?[Y]:(subset(Y,^[y]:(U(1,y) & exam(y))) & size(Y)=6 & ![x,y]:(X(x) & Y(y) => ?[g]:(arg1(g)=x & U(2,g) & grade(g) & present(g) & arg2(g)=y))))
#  ?[X]:(subset(X,^[x]:(U(0,x) & teacher(x))) & size(X)=3 & ?[Y]:(subset(Y,^[y]:(U(1,y) & exam(y))) & size(Y)=6 & !W[x,y]:(X(x) & Y(y) => ?[g]:(arg1(g)=x & U(2,g) & grade(g) & present(g) & arg2(g)=y))))
#  ?[X]:(subset(X,^[x]:(U(0,x) & teacher(x))) & size(X)=3 & ![x]:(X(x) => ?[Y]:(subset(Y,^[y]:(U(1,y) & exam(y))) & size(Y)=6 & ![y]:(Y(y) => ?[g]:(arg1(g)=x & U(2,g) & grade(g) & present(g) & arg2(g)=y)))))
# where !W is the weak universal quantifier, which is defined as:
# !W[x1,...,xn]:(X1(x1) & ... & Xn(xn) => f(x1,...,xn)) =
#     ![x1]:(X1(x1) => ?[x2,...,xn]:(X2(x2) & ... & Xn(xn) & f(x1,...,xn)))
#   & ![x2]:(X2(x2) => ?[x1,x3,...,xn]:(X1(x1) & X3(x3) & ... & Xn(xn) & f(x1,...,xn)))
#   & ![x3]:(X3(x3) => ?[x1,...,x2,x4,...,xn]:(X1(x1) & ... & X2(x2) & X4(x4) & ... & Xn(xn) & f(x1,...,xn)))
#   & ![x4]:(X4(x4) => ?[x1,...,x3,x5,...,xn]:(X1(x1) & ... & X3(x3) & X5(x5) & ... & Xn(xn) & f(x1,...,xn)))
#   & ... & ![xn]:(Xn(xn) => ?[x1,...,x(n-1)]:(X1(x1) & ... & X(n-1)(x(n-1)) & f(x1,...,xn)))
#
#  "a dog likes every cat."
#  ?[d]:(U(0,d) & dog(d) & ![c]:(U(1,c) & cat(c) => ?[l]:(arg1(l)=d & U(2,l) & like(l) & present(l) & arg2(l)=c)))
#  ![c]:(U(0,c) & cat(c) => ?[d]:(U(1,d) & dog(d) & ?[l]:(arg1(l)=d & U(2,l) & like(l) & present(l) & arg2(l)=c)))
#
#  "a dog is liked by every cat."
#  ?[d]:(U(0,d) & dog(d) & ![c]:(U(1,c) & cat(c) => ?[l]:(arg1(l)=d & U(2,l) & inverse(like)(l) & present(l) & arg2(l)=c)))
#  ![c]:(U(0,c) & cat(c) => ?[d]:(U(1,d) & dog(d) & ?[l]:(arg1(l)=d & U(2,l) & inverse(like)(l) & present(l) & arg2(l)=c)))
# where we can have an axiom like:
#    ![e,t,x,y]:((inverse(t)(e) & arg1(e)=x & arg2(e)=y) = (t(e) & arg1(e)=y & arg2(e)=x))
# In fact, the passive voice is always realized in semantics using the
# `inverse` function.
#
#  "Noah entertained and was reviewed."
#  ?[e]:(arg1(e)=noah & U(0,e) & entertain(e) & past(e)) & ?[r]:(arg1(r)=noah & U(1,r) & inverse(review)(r) & past(r))
# NOTE: We originally labeled this sentence with the following logical form:
#  ?[X]:(?[e]:(U(0,e) & entertain(e) & past(e) & ?[r]:(U(1,r) & inverse(review)(r) & past(r) & X=^[x]:(x=e | x=r))) & ^[x]:(X(x) => arg1(x)=noah))
# However, putting events into sets is problematic if one of the events is
# itself a set of events. See the later example "she made a big cake, and hung
# up some balloons".
#
#  "not every cat is a tabby."
#  "not all cats are tabbies."
#  ~![c]:(U(0,c) & cat(c) => ?[s]:(arg1(s)=c & U(1,s) & same(s) & present(s) & ?[t]:(U(2,t) & tabby(t) & arg2(s)=t))
#
#  "every cat isn't a tabby."
#  "all cats aren't tabbies."
#  ~![c]:(U(0,c) & cat(c) => ?[s]:(arg1(s)=c & U(1,s) & same(s) & present(s) & ?[t]:(U(2,t) & tabby(t) & arg2(s)=t))
#  ![c]:(U(0,c) & cat(c) => ~?[s]:(arg1(s)=c & U(1,s) & same(s) & present(s) & ?[t]:(U(2,t) & tabby(t) & arg2(s)=t))
#
#  "a cat and dog are sleeping."
#  ?[X]:(?[c]:(U(0,c) & cat(c) & ?[d]:(U(1,d) & dog(d) & X=^[x]:(x=c | x=d))) & ![x]:(X(x) => ?[s]:(arg1(s)=x & U(2,s) & sleep(s) & present(s))))
#
#  "4 cats, 2 dogs, and a bird are sleeping."
#  ?[X]:(?[C]:(subset(C,^[x]:(U(0,x) & cat(x))) & size(C)=4 & ?[D]:(subset(D,^[x]:(U(1,x) & dog(x))) & size(D)=2 & ?[b]:(U(2,b) & bird(b) & X=^[x]:(x=C | x=D | x=^[y]:y=b)))) & ![Y]:(X(Y) => ![x]:(Y(x) => ?[s]:(arg1(s)=x & U(3,s) & sleep(s) & present(s)))))
#
#  "a man and his dog were walking in the park."
#  ?[X]:(?[m]:(U(0,m) & man(m) & ?[h]:(U(1,h) & male_ref(0,h) & ?[d]:(U(2,d) & dog(d) & ?[o]:(arg1(o)=h & U(3,o) & own(o) & arg2(o)=d) & X=^[x]:(x=m | x=d)))) & ![x]:(X(x) => ?[w]:(arg1(w)=x & U(4,w) & walk(w) & past_progressive(w) & ?[p]:(U(5,p) & park(p) & arg2(w)=p))))
# where `male_ref` is defined in the pragmatics model. We could supervise the
# pragmatics model by specifying that h and m refer to the same object. We
# similarly define `female_ref` for grammatically female anaphora and `ref` for
# anaphora whose grammatical gender is either neutral or unspecified. The first
# argument of `male_ref` is an index parameter so that multiple uses of "he" in
# the same sentence can potentially refer to different objects (just as the
# first argument of `U`).
#
#  "10 girls and boys are in class."
#  ?[X]:(?[G]:(G=^[x]:(U(0,x) & girl(x)) & ?[B]:(B=^[x]:(U(1,x) & boy(x)) & X=^[x]:(x=G | x=B))) & ![Y]:(X(Y) => size(Y)=10) & ![Y]:(X(Y) => ![x]:(Y(x) => ?[p]:(arg1(p)=x & U(2,p) & location(p) & ?[c]:(U(3,c) & class(c) & arg2(p)=c)))))
#  ?[X]:(?[G]:(G=^[x]:(U(0,x) & girl(x)) & ?[B]:(B=^[x]:(U(1,x) & boy(x)) & X=^[x]:(x=G | x=B))) & sum(X,^[Y]:size(Y))=10 & ![Y]:(X(Y) => ![x]:(Y(x) => ?[p]:(arg1(p)=x & U(2,p) & location(p) & present(p) & ?[c]:(U(3,c) & class(c) & arg2(p)=c)))))
#
#  "a cat is not currently but will be in the room."
#  ?[c]:(U(0,c) & cat(c) & ?[r]:(U(1,r) & room(r) & ?[l]:(arg1(l)=c & U(2,l) & location(l) & present(l) & arg2(l)=r & ?[c]:(U(3,c) & currently(c) & arg1(c)=l)) & ?[l]:(arg1(l)=c & U(4,l) & location(l) & future(l) & arg2(l)=r)))
#
#  "Jane is the only doctor."
#  ?[o]:(arg1(o)=jane & U(0,o) & only(o) & present(o) & arg2(o)=^[x]:(U(1,x) & doctor(x)))
#    [or maybe we should do]
#  ?[o]:(arg1(o)=jane & U(0,o) & only(o) & present(o) & ?[D]:(D=^[x]:(U(1,x) & doctor(x)) & arg2(o)=D))
#
#  "i did not get much money."
#  ?[m]:(U(0,m) & money(m) & ?[l]:(U(1,l) & large_amount(l) & arg1(l)=m) & ~?[r]:(arg1(r)=me & U(2,r) & receive(r) & past(r) & arg2(r)=m))
#
#  "i did not get very much money."
#  ?[m]:(U(0,m) & money(m) & ?[l]:(U(1,l) & very(large_amount)(l) & arg1(l)=m) & ~?[r]:(arg1(r)=me & U(2,r) & receive(r) & past(r) & arg2(r)=m))
#    [OR]
#  ?[m]:(U(0,m) & money(m) & ?[l]:(?[v]:(U(1,v) & very(v) & arg1(v)=l) & U(2,l) & large_amount(l) & arg1(l)=m) & ~?[r]:(arg1(r)=me & U(3,r) & receive(r) & past(r) & arg2(r)=m))
#
#  "i don't like Ralph's destroying the barn."
#  "i don't like Ralph's destruction of the barn."
#  ?[d]:(arg1(d)=ralph & U(0,d) & destroy(d) & progressive(d) & ?[b]:(U(1,b) & barn(b) & arg2(d)=b) & ~?[l]:(arg1(l)=me & U(2,l) & like(l) & present(l) & arg2(l)=d))
# NOTE: We could require constant arguments (e.g. `ralph` and `me`) to be part
# of U in the discourse model.
#
#  "i don't like the destruction of the barns by the teenagers."
#  ![x]:(U(0,x) & teenager(x) => ![y]:(U(1,y) & barn(y) => ?[d]:(arg1(d)=x & U(2,d) & destroy(d) & arg2(d)=y & ~?[l]:(U(3,l) & like(l) & arg2(l)=d & arg1(l)=me))))
#    [OR]
#  ?[X]:(X=^[x]:(U(0,x) & teenager(x)) & ?[Y]:(Y=^[y]:(U(1,y) & barn(y)) & ![x]:(X(x) => ![y]:(Y(y) => ?[d]:(arg1(d)=x & U(2,d) & destroy(d) & arg2(d)=y & ~?[l]:(arg1(l)=me & U(3,l) & like(l) & arg2(l)=d))))))
#
#  "the cat's purring is soothing."
#  ?[p]:(?[c]:(U(0,c) & cat(c) & arg1(p)=c) & U(1,p) & purr(p) & progressive(p) & ?[s]:(arg1(s)=p & U(2,s) & sooth(s) & progressive(s)))
#
#  "Joan's pen is good."
#  ?[p]:(U(0,p) & pen(p) & ?[o]:(arg1(o)=joan & U(1,o) & own(o) & arg2(o)=p) & ?[g]:(arg1(g)=p & U(2,g) & good(g) & present(g)))
#
#  "Joan's pens are good."
#  ![x]:(U(0,x) & pen(x) & ?[o]:(arg1(o)=joan & U(1,o) & own(o) & arg2(o)=x) => ?[g]:(arg1(g)=x & U(2,g) & good(g) & present(g)))
#    [OR]
#  ?[X]:(X=^[p]:(U(0,p) & pen(p) & ?[o]:(arg1(o)=joan & U(1,o) & own(o) & arg2(o)=p)) & ![x]:(X(x) => ?[g]:(arg1(g)=x & U(2,g) & good(g) & present(g))))
#
#  "the students' pens are good."
#  ?[X]:(?[Y]:(Y=^[y]:(U(0,y) & student(y)) & X=^[x]:(U(1,x) & pen(x) & ?[y]:(Y(y) & ?[o]:(U(2,o) & own(o) & arg2(o)=x & arg1(o)=y)))) & ![x]:(X(x) => ?[g]:(arg1(g)=x & U(3,g) & good(g) & present(g))))
#
#  "i saw the trees by all the cats."
#  ?[X]:(X=^[x]:(U(0,x) & cat(x)) & ?[Y]:(Y=^[y]:(U(1,y) & tree(y) & ![x]:(X(x) => ?[n]:(U(2,n) & near(n) & arg2(n)=y & arg1(n)=x))) & ![y]:(Y(y) => ?[s]:(arg1(s)=me & U(3,s) & see(s) & past(s) & arg2(s)=y))))
#    [OR]
#  ![y]:(U(0,y) & tree(y) & ![x]:(U(1,x) & cat(x) => ?[n]:(U(2,n) & near(n) & arg2(n)=y & arg1(n)=x)) => ?[s]:(arg1(s)=me & U(3,s) & see(s) & past(s) & arg2(s)=y))
#
#  "he works a lot to earn money for school."
#  ?[h]:(U(0,h) & male_ref(0,h) & ?[w]:(arg1(w)=h & U(1,w) & work(w) & present(w) & ?[l]:(U(2,l) & large_duration(l) & arg1(l)=w) & ?[p]:(U(3,p) & purpose(p) & ?[e]:(U(4,e) & earn(e) & ?[m]:(U(5,m) & money(m) & arg2(e)=m) & arg2(p)=e) & arg1(p)=w)))
#
#  "the ladder collapsed because it was old."
#  ?[l]:(U(0,l) & ladder(l) & ?[c]:(arg1(c)=l & U(1,c) & collapse(c) & past(c) & ?[r]:(U(2,r) & reason(r) & ?[i]:(U(3,i) & ref(0,i) & ?[o]:(U(4,o) & old(o) & past(o) & arg1(o)=i & arg2(r)=o)) & arg1(r)=c)))
#
#  "Mr. Bibby wrote the letter with a pencil."
#  ?[p]:(U(0,p) & pencil(p) & ?[l]:(U(1,l) & letter(l) & ?[w]:(arg1(x)=w & U(2,w) & write(w) & arg2(w)=l & arg1(w)=bibby & ?[x]:(U(3,x) & with(x) & arg2(x)=p))))
#
#  "the students wrote the letters with the pencils."
#  ?[S]:(S=^[s]:(U(0,s) & student(s)) & ?[L]:(L=^[l]:(U(1,l) & letter(l)) & ?[P]:(P=^[p]:(U(2,p) & pencil(p)) & !W[s,l,p]:(S(s) & L(l) & P(p) => ?[w]:(arg1(w)=s & U(3,w) & wrote(w) & past(w) & arg2(w)=l & ?[x]:(U(4,x) & with(x) & arg2(x)=p & arg1(x)=w))))))
#
#  "she sat on the table."
#  ?[x]:(U(0,x) & female_ref(0,x) & ?[s]:(arg1(s)=x & U(1,s) & sit(s) & past(s) & ?[o]:(U(2,o) & on_top_of(o) & ?[t]:(U(3,t) & table(t) & arg2(o)=t) & arg1(o)=s)))
#
#  "the birds hear each other."
#  ?[X]:(X=^[x]:(U(0,x) & bird(x)) & ![x,y]:(X(x) & Y(x) & ~(x=y) => ?[h]:(arg1(h)=x & U(1,h) & hear(h) & arg2(h)=y)))
#
#  "some relative of each villager and some relative of each townsman hate each other."
#  ?[a]:(U(0,a) & ![x]:(U(1,x) & villager(x) => ?[r]:(U(2,r) & related_to(r) & arg2(r)=x & arg1(r)=a)) & ?[b]:(U(3,b) & ![x]:(U(4,x) & townsman(x) => ?[r]:(U(5,r) & related_to(r) & arg2(r)=x & arg1(r)=b)) & ?[X]:(X=^[x]:(x=a | x=b) & ![x,y]:(X(x) & Y(x) & ~(x=y) => ?[h]:(arg1(h)=x & U(6,h) & hate(h) & arg2(h)=y)))))
#
#  "in either case, i am going."
#  ?[X]:(subset(X,^[x]:(U(0,x) & case(x))) & size(X)=2 & ![x]:(X(x) => (true(x) => ?[g]:(arg1(g)=me & U(1,g) & go(g) & progressive(g)))))
#
#  "if it rains, the grass will be wet."
#  "the grass, if it rains, will be wet."
#  ?[i]:(U(0,i) & ref(0,i) & ?[r]:(U(1,r) & rain(r) & present(r) & arg1(r)=i)) => ?[g]:(U(2,g) & grass(g) & ?[w]:(U(3,w) & wet(w) & future(w) & arg1(w)=g))
#
#  "he ran with difficulty."
#  ?[h]:(U(0,h) & male_ref(0,h) & ?[r]:(arg1(r)=h & U(1,r) & run(r) & past(r) & ?[d]:(U(2,d) & difficult(d) & arg1(d)=r)))
#
#  "he stood in silence."
#  ?[h]:(U(0,h) & male_ref(0,h) & ?[s]:(arg1(s)=h & U(1,s) & stand(s) & past(s) & ?[x]:(U(2,x) & while(is_silent)(x) & arg1(x)=s)))
# where we could define ![x,p]:(while(p)(x) = ?[s]:(p(s) & arg1(s)=arg1(x) & ![t]:(time(x)(t) => time(s)(t))))
#
#  "she helped me with my homework."
#  ?[s]:(U(0,s) & female_ref(0,s) & ?[h]:(arg1(h)=s & U(1,h) & help(h) & past(h) & arg2(h)=me & ?[o]:(U(2,o) & own(o) & arg2(o)=x & arg1(o)=me) & ?[w]:(U(3,w) & with(w) & ?[x]:(U(4,x) & homework(x) & arg2(w)=x & arg1(w)=h))))
#
#  "he stayed for two weeks."
#  ?[h]:(U(0,h) & male_ref(0,h) & ?[s]:(arg1(s)=h & U(1,s) & stay(s) & past(s) & ?[d]:(U(2,d) & duration(d) & arg2(d)=(2*week) & arg1(d)=s)))
#
#  "it is under the bush."
#  ?[i]:(U(0,i) & ref(0,i) & ?[u]:(arg1(u)=i & U(1,u) & is_under(u) & present(u) & ?[b]:(U(2,b) & bush(b) & arg2(u)=b)))
#
#  "the party is at seven o'clock."
#  ?[p]:(U(0,p) & party(p) & ?[s]:(arg1(s)=p & U(1,s) & start_time(s) & present(s) & arg2(s)=(7:00pm)))
# where we could define ![x,t]:((start_time(x)=t) = ![s]:(time(x)(s) => t<=s)),
# or perhaps `start_time` and `end_time` should be the elementary event time
# predicates rather than `time`.
# TODO: how do we represent date/time constants?
#
#  "she will leave after she has had breakfast."
#  ?[s]:(U(0,s) & female_ref(0,s) & ?[l]:(arg1(l)=s & U(1,l) & leave(l) & future(l) & ?[a]:(arg1(a)=l & U(2,a) & after(a) & ?[r]:(U(3,r) & female_ref(1,r) & ?[e]:(U(4,e) & eat(e) & ?[b]:(U(5,b) & breakfast(b) & arg2(e)=b) & arg1(e)=r & arg2(a)=e)))))
# where we could define ![a,x,y]:((after(a) & arg1(a)=x & arg2(a)=y) = ~?[s,t]:(time(x)(s) & time(y)(t) & s<t))
#
#  "the ball rotated quickly and heated up slowly."
#  ?[b]:(U(0,b) & ball(b) & ?[r]:(arg1(r)=b & U(1,r) & rotate(r) & past(r) & ?[q]:(U(2,q) & quick(q) & arg1(q)=r)) & ?[h]:(arg1(h)=b & U(3,h) & heat_up(h) & past(h) & ?[s]:(U(4,s) & slowly(s) & arg1(s)=h)))
# NOTE: We originally labeled this sentence with the following logical form:
#  ?[b]:(U(0,b) & ball(b) & ?[r]:(rotate(r) & past(r) & ?[q]:(quick(q) & arg1(q)=r) & ?[h]:(heat_up(h) & past(h) & ?[s]:(slowly(s) & arg1(s)=h) & ?[X]:(X=^[x]:(x=r | x=h) & ![x]:(X(x) => arg1(x)=b)))))
# However, putting events into sets is problematic if one of the events is
# itself a set of events. See the later example "she made a big cake, and hung
# up some balloons".
#
#  "the ball rotated and heated up slowly."
#  ?[b]:(U(0,b) & ball(b) & ?[r]:(arg1(r)=b & U(1,r) & rotate(r) & past(r) & ?[s]:(U(2,s) & slowly(s) & arg1(s)=r)) & ?[h]:(arg1(h)=b & U(3,h) & heat_up(h) & past(h) & ?[s]:(U(4,s) & slowly(s) & arg1(s)=h)))
# NOTE: We originally labeled this sentence with the following logical form:
#  ?[b]:(U(0,b) & ball(b) & ?[r]:(rotate(r) & past(r) & ?[h]:(heat_up(h) & past(h) & ?[X]:(X=^[x]:(x=r | x=h) & ![x]:(X(x) => ?[s]:(slowly(s) & arg1(s)=x) & arg1(x)=b)))))
# However, putting events into sets is problematic if one of the events is
# itself a set of events. See the later example "she made a big cake, and hung
# up some balloons".
#
#  "slowly, the ball rotated and heated up."
#  ?[b]:(U(0,b) & ball(b) & ?[r]:(?[s]:(U(1,s) & slowly(s) & arg1(s)=r) & arg1(r)=b & U(2,r) & rotate(r) & past(r)) & ?[h]:(?[s]:(U(3,s) & slowly(s) & arg1(s)=h) & arg1(h)=b & U(4,h) & heat_up(h) & past(h)))
#
#  "Emma and Noah met."
#  ?[X]:(X=^[x]:(x=emma | x=noah) & ?[m]:(arg1(m)=X & U(0,m) & collective_meet(m) & past(m)))
#
#  "Emma and Noah lifted the stone."
#  ?[X]:(X=^[x]:(x=emma | x=noah) & ?[s]:(U(0,s) & stone(s) & ?[l]:(U(1,l) & lift(l) & past(l) & arg2(l)=s & arg1(l)=X)))
# Here, "Emma and Noah" has a *collective* interpretation, which also occurs in
# many other sentences in English.
#
#  "i think there is a unicorn."
#  ?[t]:(arg1(t)=me & U(0,t) & think(t) & present(t) & arg2(t)=possibility(?[e]:(U(1,e) & exists(e) & present(e) & ?[u]:(U(2,u) & unicorn(u) & arg1(e)=u))))
# This is why we need the `true` predicate, since it provides a uniform way to
# handle modality, and to talk about objects and events that may not actually
# exist or be true, but may exist as thoughts or suppositions (the Platonic
# universe). All events have the property that if they are true, then all of
# its arguments are true, with a handful of specified exceptions, including
# `think`, `capable_of`, `want`, `purpose`, etc.
#
#  "i can swim."
#  "i am capable of swimming."
#  ?[c]:(arg1(c)=me & U(0,c) & capable_of(c) & present(c) & arg2(c)=possibility(?[s]:(arg1(s)=me & U(1,s) & swim(s))))
#
#  "i could swim."
#  "i was capable of swimming."
#  ?[c]:(arg1(c)=me & U(0,c) & capable_of(c) & past(c) & arg2(c)=possibility(?[s]:(arg1(s)=me & U(1,s) & swim(s))))
#
#  "she made a big cake, and hung up some balloons."
#  ?[s]:(U(0,s) & female_ref(0,s) & ?[B]:(subset(B,^[b]:(U(1,b) & balloon(b))) & ?[m]:(arg1(m)=s & U(2,m) & make(m) & past(m) & ?[c]:(U(3,c) & cake(c) & ?[b]:(U(4,b) & is_big(b) & arg1(b)=c) & arg2(m)=c)) & ![b]:(B(b) => ?[h]:(arg1(h)=s & U(5,h) & hang(h) & past(h) & arg2(h)=b))))
#
#  "the doctor watched everyone sleep."
#  ?[d]:(U(0,d) & doctor(d) & ?[X]:(X=^[x]:(U(1,x) & animate/anthropomorphic(x)) & ![x]:(X(x) => ?[w]:(arg1(w)=d & watch(w) & past(w) & arg2(w)=x))))
# NOTE: We model pragmatic domain restriction implicitly. In this example,
# `^[x]:U(0,x)` contains the doctor but `^[x]:U(1,x)` contains everyone being
# monitored by the doctor but does not contain the doctor.
#
#  "John can play the guitar, and Mary, the violin."
#  ?[c]:(arg1(c)=john & U(0,c) & capable_of(c) & present(c) & arg2(c)=possibility(?[p]:(U(1,p) & play(p) & ?[g]:(U(2,g) & guitar(g) & arg2(p)=g)))) & ?[e]:(arg1(e)=mary & U(3,e) & empty_ref(0,e) & ?[v]:(U(4,v) & violin(v) & arg2(e)=v))
#
#  "John can play his guitar. Mary, too."
#  ?[c]:(arg1(c)=john & U(0,c) & capable_of(c) & present(c) & arg2(c)=possibility(?[p]:(U(1,p) & play(p) & ?[g]:(U(2,g) & guitar(g) & arg2(p)=g)))) & ?[e]:(arg1(e)=mary & U(3,e) & empty_ref(0,e) & too(e))
#
#  "she walked and sat under every tree and near every rock."
#  ?[s]:(U(0,s) & female_ref(0,s) & ?[T]:(T=^[x]:(U(1,x) & tree(x)) & ?[R]:(R=^[y]:(U(2,y) & rock(y)) & ![x]:(T(x) => ![y]:(R(y) => ?[w]:(arg1(w)=s & U(3,w) & walk(w) & past(w) & ?[u]:(U(4,u) & under(u) & arg1(u)=w & arg2(u)=x) & ?[n]:(U(5,n) & near(n) & arg1(n)=w & arg2(n)=y)) & ?[a]:(arg1(a)=s & U(6,a) & sit(a) & past(a) & ?[u]:(U(7,u) & under(u) & arg1(u)=a & arg2(u)=x) & ?[n]:(U(8,n) & near(n) & arg1(n)=a & arg2(n)=y)))))))
#
#  "John wants and is able to swim and dance."
#  "John wants to and is able to swim and dance."
#  ?[w]:(arg1(w)=john & U(0,w) & want(w) & present(w) & arg2(w)=possibility(?[s]:(U(1,s) & swim(s)) & ?[d]:(U(2,s) & dance(d)))) & ?[c]:(arg1(c)=john & U(3,c) & capable_of(c) & present(c) & arg2(c)=possibility(?[s]:(U(4,s) & swim(s)) & ?[d]:(U(5,s) & dance(d))))
#
#  "the house is Kim's."
#  ?[h]:(U(0,h) & house(h) & ?[o]:(arg1(o)=h & U(1,o) & inverse(own)(o) & present(o) & arg2(o)=kim))
#
#  "the pencils are the students'."
#  ?[X]:(X=^[x]:(U(0,x) & pencil(x)) & ?[Y]:(Y=^[y]:(Y(1,y) & student(y)) & ![x,y]:(X(x) & Y(y) => ?[o]:(arg1(o)=x & U(2,o) & inverse(own)(o) & present(o) & arg2(o)=y))))
#
#  "flower seller has carnations."
#  ?[C]:(subset(C,^[x]:(U(0,x) & carnation(x))) & ?[x]:(?[s]:(?[f]:(U(1,f) & flower(f) & arg2(s)=f) & U(2,s) & sell(s) & arg1(s)=x) & U(3,x) & ![c]:(C(c) => ?[o]:(arg1(o)=x & U(4,o) & own(o) & present(o) & arg2(o)=c))))
#
#  "John swam extremely quickly."
#  ?[s]:(arg1(s)=john & U(0,s) & swim(s) & past(s) & ?[q]:(?[e]:(U(1,e) & extreme(e) & arg1(e)=q) & U(2,q) & quick(q) & arg1(q)=s))
#
#  "John arrived 10 minutes late."
#  ?[a]:(arg1(s)=john & U(0,a) & arrive(a) & past(a) & ?[l]:(arg2(l)=(10*minute) & U(1,l) & late(l) & arg1(l)=a))
#
#  "they ran away from the house and from the tree."
#  ?[T]:(U(0,T) & plural_ref(0,T) & ![x]:(T(x) => ?[r]:(arg1(r) & U(1,r) & run(r) & past(r) & ?[a]:(U(2,a) & away(a) & arg1(a)=r & ?[h]:(U(3,h) & house(h) & arg2(a)=h)) & ?[a]:(U(4,a) & away(a) & arg1(a)=r & ?[t]:(U(5,t) & tree(t) & arg2(a)=t)))))
#
#  "they ran away from the house and the tree."
#  ?[T]:(U(0,T) & plural_ref(0,T) & ![x]:(T(x) => ?[r]:(arg1(r) & U(1,r) & run(r) & past(r) & ?[X]:(?[h]:(U(2,h) & house(h) & ?[t]:(U(3,t) & tree(t) & Y=^[y]:(y=h | y=t))) & ![y]:(Y(y) => ?[a]:(U(4,a) & away(a) & arg1(a)=r & arg2(a)=y))))))
#
#  "that Constance is smart is not surprising."
#  ~?[x]:(arg1(x)=possibility(?[s]:(arg1(s)=constance & U(0,s) & smart(s) & present(s))) & U(1,x) & surprise(x) & present_progressive(x))
#
#  "that all cats are mammals is not surprising."
#  ~?[x]:(arg1(x)=possibility(![x]:(U(0,x) & cat(x) => ?[s]:(arg1(s)=x & U(1,s) & same(s) & present(s) & ?[m]:(U(2,m) & mammal(m) & arg2(s)=m)))) & U(3,x) & surprise(x) & present_progressive(x))
#
#  "i am glad that you arrived."
#  ?[h]:(arg1(h)=me & U(0,h) & happy(h) & present(h) & ?[a]:(arg1(a)=you & U(1,a) & arrive(a) & past(a) & arg2(h)=a))
#
#  "i will buy what she wants."
#  "i will buy whatever she wants."
#  ?[b]:(arg1(b)=me & U(0,b) & buy(b) & future(b) & ?[x]:(U(1,x) & ?[w]:(?[h]:(U(2,h) & female_ref(0,h) & arg1(w)=h) & U(3,w) & want(w) & arg2(w)=x) & arg2(b)=x))
#
#  "are you generous?"
#  "you are generous?"
#  ^[x]:(x=?[g]:(arg1(g)=you & U(0,g) & generous(g) & present(g)))
#
#  "how generous are you?"
#  ^[x]:?[g]:(?[d]:(U(0,d) & degree(d) & arg1(d)=g & arg2(d)=x) & arg1(g)=you & U(1,g) & generous(g) & present(g))
#
#  "did they see her?"
#  ^[x]:x=?[T]:(U(0,T) & plural_ref(0,T) & ?[h]:(U(1,h) & female_ref(0,h) & ?[t]:(T(t) & ?[s]:(arg1(s)=t & U(2,s) & see(s) & past(s) & arg2(s)=h))))
#
#  "did they all see her?"
#  ^[x]:x=?[T]:(U(0,T) & plural_ref(0,T) & ?[h]:(U(1,h) & female_ref(0,h) & ![t]:(T(t) => ?[s]:(arg1(s)=t & U(2,s) & see(s) & past(s) & arg2(s)=h))))
#
#  "which store did Jason run to?"
#  "to which store did Jason run?"
#  "Jason ran to which store?"
#  "what store did Jason run to?"
#  "to what store did Jason run?"
#  "Jason ran to what store?"
#  ^[x]:(?[S]:(S=^[s]:(U(s,0) & store(s)) & S(x) & ?[r]:(arg1(r)=jason & U(1,r) & run(r) & past(r) & arg2(r)=x)))
#
#  "which stores did Jason run to?"
#  "to which stores did Jason run?"
#  "Jason ran to which stores?"
#  "what stores did Jason run to?"
#  "to what stores did Jason run?"
#  "Jason ran to what stores?"
#  ^[X]:(subset(X,^[s]:(U(s,0) & store(s))) & ![x]:(X(x) => ?[r]:(arg1(r)=jason & U(1,r) & run(r) & past(r) & arg2(r)=x)))
#
#  "is it red or blue?"
#  ^[x]:?[i]:(U(0,i) & ref(0,i) & true(x) & (x=possibility(?[r]:(arg1(r)=i & U(1,r) & red(r) & present(r))) | x=possibility(?[b]:(arg1(b)=i & U(2,b) & blue(b) & present(b)))))
#
#  "how big is the earth?"
#  ^[x]:?[b]:(?[d]:(U(0,d) & degree(d) & arg1(d)=b & arg2(d)=x) & arg1(b)=earth & U(1,b) & big(b))
#
#  "Kim knows whether the earth is big."
#  ?[k]:(arg1(k)=kim & U(0,k) & know(k) & present(k) & arg2(k)=^[x]:x=?[b]:(arg1(b)=earth & U(1,b) & big(b) & present(b)))
#
#  "Kim knows how big the earth is."
#  ?[k]:(arg1(k)=kim & U(0,k) & know(k) & present(k) & arg2(k)=^[x]:?[b]:(?[d]:(U(1,d) & degree(d) & arg1(d)=b & arg2(d)=x) & arg1(b)=earth & U(2,b) & big(b)))
#
#  "how to make an omelet?"
#  ^[x]:?[m]:(?[y]:(U(0,y) & manner(y) & arg1(y)=m & arg2(y)=x) & U(1,m) & make(m) & ?[o]:(U(2,o) & omelet(o) & arg2(m)=o))
#
#  "Jason knows how to make an omelet."
#  ?[k]:(arg1(k)=jason & U(0,k) & know(k) & present(k) & arg2(k)=^[x]:?[m]:(?[y]:(U(1,y) & manner(y) & arg1(y)=m & arg2(y)=x) & U(2,m) & make(m) & ?[o]:(U(3,o) & omelet(o) & arg2(m)=o)))
#
#  "whether running or swimming, Emma is quick."
#  (?[r]:(arg1(r)=emma & U(0,r) & run(r) & present_progressive(r)) | ?[s]:(arg1(s)=emma & U(1,s) & swim(s) & present_progressive(s))) => ?[q]:(arg1(q)=emma & U(2,q) & quick(q))
#
#  "Noah was intrigued by what strange people inhabited this place."
#  TODO: label this and ensure the grammar can handle it
#
#  "the necklace which Emma gave to her is in the safe."
#  "the necklace, which Emma gave to her, is in the safe."
#  ?[l]:(?[n]:(U(0,n) & necklace(n) & ?[g]:(arg1(g)=emma & U(1,g) & give(g) & past(g) & ?[h]:(U(2,n) & female_ref(0,h) & arg3(g)=h) & arg2(g)=n) & arg1(l)=n) & U(3,l) & location(l) & present(l) & ?[s]:(U(4,s) & safe(s) & arg2(l)=s))
#
#  "Jason, who is my brother, is here."
#  ?[l]:(?[j]:(j=jason & ?[b]:(arg1(b)=me & U(0,b) & brother_of(b) & present(b) & arg2(b)=j) & arg1(l)=j) & U(1,l) & location(l) & present(l) & arg2(l)=here)
#
#  "a person walked into the room who looked like Emma."
#  ?[p]:(U(0,p) & person(p) & ?[w]:(arg1(w)=p & U(1,w) & walk(w) & past(w) & ?[r]:(U(2,r) & room(r) & arg2(w)=r)) & ?[v]:(arg1(v)=p & U(3,v) & visually_similar(v) & arg2(v)=emma))
#
#  "Sirius is brighter."
#  ?[g]:(arg1(g)=sirius & U(0,g) & greater(brightness)(g) & present(g))
#
#  "Sirius is brighter than Vega."
#  ?[g]:(arg1(g)=sirius & U(0,g) & greater(brightness)(g) & present(g) & arg2(g)=vega)
# where we can add an axiom such as ![x,y,f]:(?[g]:(greater(f)(g) & arg1(g)=x & arg2(g)=y) & ~is_real_number(y) & ?[b]:(f(b) & arg1(b)=y) = ?[g]:(greater(f)(g) & arg1(g)=x & ?[b]:(brightness(b) & arg1(b)=y & arg2(g)=arg2(b))))
# as well as equivalent axioms for things like height, shortness, size, length, etc.
#
#  "i see a brighter star than Vega."
#  ?[s]:(arg1(s)=me & U(0,s) & see(s) & present(s) & ?[x,r]:(?[g]:(U(1,g) & greater(brightness)(g) & arg1(g)=x & arg2(g)=r) & U(2,x) & star(x) & r=vega & arg2(s)=x))
#
#  "i see a star brighter than Vega."
#  ?[s]:(arg1(s)=me & U(0,s) & see(s) & present(s) & ?[x]:(U(1,x) & star(x) & ?[g]:(U(2,g) & greater(brightness)(g) & arg1(g)=x & arg2(g)=vega) & arg2(s)=x))
#
#  "Sirius is brighter than we thought."
#  ?[X]:(X=us & ![x]:(X(x) => ?[g]:(arg1(g)=sirius & U(0,g) & greater(brightness)(g) & ?[t]:(arg1(t)=x & U(1,t) & think(t) & past(t) & arg2(t)=arg2(g)))))
#
#  "Sirius is the brightest star."
#  ?[s]:(arg1(s)=sirius & U(0,s) & same(s) & present(s) & ?[X]:(?[g]:(U(1,g) & greatest(brightness)(g) & arg2(s)=arg1(g) & arg2(g)=X) & X=^[x]:(U(2,x) & star(x))))
#
#  "Sirius is the brightest."
#  ?[s]:(arg1(s)=sirius & U(0,s) & same(s) & present(s) & ?[g]:(U(1,g) & greatest(brightness)(g) & arg2(s)=arg1(g)))
#
#  "a brighter star could be seen with the telescope than without it"
#  ?[x,r]:(?[g]:(greater(brightness)(g) & arg1(g)=x & arg2(g)=r) & U(0,x) & star(x) & ?[c]:(U(1,c) & capable_of(c) & arg2(c)=possibility(?[s]:(arg1(s)=x & U(2,s) & inverse(see)(s) & ?[w]:(U(3,w) & with(w) & ?[t]:(U(4,t) & telescope(t) & arg1(w)=t)) & ?[y]:(U(5,y) & arg1(y)=r & ~?[w]:(U(6,w) & with(w) & ?[t]:(U(7,t) & telescope(t) & arg1(w)=t)))))))
#
#  "brighter stars could be seen with the telescope than without it"
#  ?[X,R]:(subset(X,^[x]:(![r]:(R(r) => ?[g]:(U(0,g) & greater(brightness)(g) & arg1(g)=x & arg2(g)=r)) & U(1,x) & star(x))) & ![x]:(X(x) => ?[c]:(U(2,c) & capable_of(c) & arg2(c)=possibility(?[s]:(arg1(s)=x & U(3,s) & inverse(see)(s) & ?[w]:(U(4,w) & with(w) & ?[t]:(U(5,t) & telescope(t) & arg1(w)=t)) & R=^[r]:?[y]:(U(6,y) & arg1(y)=r & ~?[w]:(U(7,w) & with(w) & ?[t]:(U(8,t) & telescope(t) & arg1(w)=t))))))))
#
#  "you can see brighter stars with the telescope than without it"
#  ?[X,R]:(subset(X,^[x]:(![r]:(R(r) => ?[g]:(U(0,g) & greater(brightness)(g) & arg1(g)=x & arg2(g)=r)) & U(1,x) & star(x))) & ![x]:(X(x) => ?[c]:(arg1(c)=you & U(2,c) & capable_of(c) & arg2(c)=possibility(?[s]:(arg1(s)=x & U(3,s) & inverse(see)(s) & ?[w]:(U(4,w) & with(w) & ?[t]:(U(5,t) & telescope(t) & arg1(w)=t)) & R=^[r]:?[y]:(U(6,y) & arg1(y)=r & ~?[w]:(U(7,w) & with(w) & ?[t]:(U(8,t) & telescope(t) & arg1(w)=t))))))))
#
#  "last time i went to campus, i took the bus"
#  ?[t]:(?[l]:(U(0,l) & last_time(l) & arg1(l)=t & arg2(l)=^[g]:(arg1(g)=me & U(1,g) & go(g) & past(g) & ?[c]:(U(2,c) & campus(c) & arg2(g)=c))) & arg1(t)=me & U(3,t) & take(t) & past(t) & ?[b]:(U(4,b) & bus(b) & arg2(t)=b))
#    [OR]
#  ?[t]:(?[l]:(U(0,l) & last_time(l) & arg1(l)=t & ?[S]:(S=^[g]:(arg1(g)=me & U(1,g) & go(g) & past(g) & ?[c]:(U(2,c) & campus(c) & arg2(g)=c)) & arg2(l)=S)) & arg1(t)=me & U(3,t) & take(t) & past(t) & ?[b]:(U(4,b) & bus(b) & arg2(t)=b))
# where we could have an axiom like ![x,S]:(?[l]:(last_time(l) & arg1(l)=x & arg2(l)=S) = ~?[y]:(S(y) & start_time(y)>end_time(x) & start_time(y)<now))
#
#  "last time, i took the bus"
#  ?[t]:(?[l]:(U(0,l) & last_time(l) & arg1(l)=t) & arg1(t)=me & U(1,t) & take(t) & past(t) & ?[b]:(U(2,b) & bus(b) & arg2(t)=b))
#
#  "i took the same bus as i took yesterday."
#  ?[t]:(arg1(t)=me & U(0,t) & take(t) & past(t) & ?[b,r]:(?[s]:(U(1,s) & same(s) & arg1(s)=b & arg2(s)=r) & U(2,b) & bus(b) & ?[y]:(arg1(y)=me & U(3,y) & take(y) & past(y) & arg2(y)=r & ?[z]:(U(4,z) & yesterday(z) & arg1(z)=y)) & arg2(t)=b))
#
#  "i took the same bus as i took last time."
#  ?[t]:(arg1(t)=me & U(0,t) & take(t) & past(t) & ?[b,r]:(?[s]:(U(1,s) & same(s) & arg1(s)=b & arg2(s)=r) & U(2,b) & bus(b) & ?[y]:(arg1(y)=me & U(3,y) & take(y) & past(y) & arg2(y)=r & ?[z]:(U(4,z) & last_time(z) & arg1(z)=y)) & arg2(t)=b))
#
#  "i took the same bus as last time."
#  ?[t]:(arg1(t)=me & U(0,t) & take(t) & past(t) & ?[b,r]:(?[s]:(U(1,s) & same(s) & arg1(s)=b & arg2(s)=r) & U(2,b) & bus(b) & ?[y]:(U(3,y) & arg2(y)=r & ?[z]:(U(4,z) & last_time(z) & arg1(z)=y)) & arg2(t)=b))
#
#  "Sirius is as bright as Vega."
#  ?[g]:(arg1(g)=sirius & U(0,g) & greater_than_or_equal(brightness)(g) & present(g) & arg2(g)=vega)
#
#  "last time i had a party, 7 people came"
#  ?[P]:(subset(P,^[p]:(U(0,p) & person(p))) & size(P)=7 & ![p]:(P(p) => ?[g]:(?[l]:(U(1,l) & last_time(l) & arg1(l)=g & arg2(l)=^[h]:(arg1(h)=me & U(2,h) & have(h) & past(h) & ?[p]:(U(3,p) & party(p) & arg2(h)=p))) & arg1(g)=p & U(4,g) & go(g) & past(g))))
#
#  "more people came to the party than people came last time i had a party."
#  ?[P,R]:(size(P)>size(R) & subset(P,^[p]:(U(0,p) & person(p))) & ![p]:(P(p) => ?[g]:(arg1(g)=p & U(1,g) & go(g) & past(g) & R=^[r]:(U(2,r) & person(r) & ?[g]:(arg1(g)=r & U(3,g) & go(g) & past(g) & ?[l]:(U(4,l) & last_time(l) & arg1(l)=g & arg2(l)=^[h]:(arg1(h)=me & U(5,h) & have(h) & ?[p]:(U(6,p) & party(p) & arg2(h)=p))))))))
#
#  "more people came than people came last time."
#  ?[P,R]:(size(P)>size(R) & subset(P,^[p]:(U(0,p) & person(p))) & ![p]:(P(p) => ?[g]:(arg1(g)=p & U(1,g) & go(g) & past(g) & R=^[r]:(U(2,r) & person(r) & ?[g]:(arg1(g)=r & U(3,g) & go(g) & past(g) & ?[l]:(U(4,l) & last_time(l) & arg1(l)=g))))))
#
#  "more people came than last time."
#  ?[P,R]:(size(P)>size(R) & subset(P,^[p]:(U(0,p) & person(p))) & ![p]:(P(p) => ?[g]:(arg1(g)=p & U(1,g) & go(g) & past(g) & R=^[r]:(U(2,r) & ?[g]:(U(3,g) & arg1(g)=r & ?[l]:(U(4,l) & last_time(l) & arg1(l)=g))))))
#
#  "more girls but fewer boys came than last time."
#  ?[P,R]:(?[G,R1]:(size(G)>size(R1) & subset(G,^[g]:(U(0,g) & girl(g))) & ?[B,R2]:(size(B)<size(R2) & subset(B,^[b]:(U(1,b) & boy(b))) & P=^[s]:(s=G | s=B) & R=^[s]:(s=R1 | s=R2))) & ![s]:(P(s) => ![p]:(s(p) => ?[g]:(arg1(g)=p & U(2,g) & go(g) & past(g) & ![Ri]:(R(Ri) => Ri=^[r]:(U(3,r) & ?[g]:(U(4,g) & arg1(g)=r & ?[l]:(U(5,l) & last_time(l) & arg1(l)=g))))))))
#
#  "a taller person came than last time."
#  ?[x,r]:(?[g]:(U(0,g) & greater(height)(g) & arg1(g)=x & arg2(g)=r) & U(1,x) & person(x) & ?[g]:(arg1(g)=x & U(2,g) & go(g) & past(g) & ?[g]:(U(3,g) & arg1(g)=r & ?[l]:(U(4,l) & last_time(l) & arg1(l)=g))))
#
#  "taller people came than last time."
#  ?[X,R]:(subset(X,^[x]:(![r]:(R(r) => ?[g]:(U(0,g) & greater(height)(g) & arg1(g)=x & arg2(g)=r)) & U(1,x) & person(x))) & ?[g]:(arg1(g)=x & U(2,g) & go(g) & past(g) & R=^[r]:(?[g]:(U(3,g) & arg1(g)=r & ?[l]:(U(4,l) & last_time(l) & arg1(l)=g)))))
#
#  "she is older than i am."
#  ?[g]:(?[h]:(U(0,h) & female_ref(0,h) & arg1(g)=h) & U(1,g) & greater(age)(g) & ?[y]:(U(2,y) & arg1(y)=me & arg2(g)=y))
# where `y` could have type `age_of`.
#
#  "she wrote more plays than i wrote novels."
#  ?[h]:(U(0,h) & female_ref(0,h) & ?[P,N]:(size(P)>size(N) & subset(P,^[p]:(U(1,p) & play(p))) & ![p]:(P(p) => ?[w]:(arg1(w)=h & U(2,w) & write(w) & past(w) & arg2(w)=p & N=^[n]:(U(3,n) & novel(n) & ?[w]:(arg1(w)=me & U(4,w) & write(w) & past(w) & arg2(w)=n))))))
#
#  "we spend more time in France than in Germany."
#  ?[X]:(X=us & ![x]:(X(x) => ?[s]:(arg1(s)=x & U(0,s) & spend_time(s) & present(s) & ?[g]:(U(1,g) & greater(time)(g) & arg1(g)=s & ?[l]:(U(2,l) & location(l) & arg1(l)=s & arg2(l)=france) & ?[y]:(U(3,y) & ?[l]:(U(4,l) & location(l) & arg1(l)=y & arg2(l)=germany) & arg2(g)=y)))))
# TODO: implement this in the grammar
#
#  "he plays better drunk than sober."
#  ?[p]:(?[h]:(U(0,h) & male_ref(0,h) & arg1(p)=h) & U(1,p) & play(p) & present(p) & ?[g]:(U(2,g) & greater(skill)(g) & arg1(g)=p & ?[d]:(U(3,d) & drunk(d) & arg1(d)=p) & ?[y]:(U(4,y) & ?[s]:(U(5,s) & sober(s) & arg1(s)=y) & arg2(g)=y)))
#
#  "it is better to try and fail than to not try at all."
#  ?[b]:(U(0,b) & better(b) & arg1(b)=possibility(?[t]:(U(1,t) & try(t)) & ?[f]:(U(2,f) & fail(f))) & arg2(b)=possibility(~?[t]:(U(3,t) & try(t))))
#
#  "it is better that he tried and failed than not try at all."
#  ?[b]:(U(0,b) & better(b) & arg1(b)=possibility(?[t]:(U(1,t) & try(t) & past(t)) & ?[f]:(U(2,f) & fail(f) & past(f))) & arg2(b)=possibility(~?[t]:(U(3,t) & try(t))))
#
#  "the flower is more red than pink."
#  ?[f]:(U(0,f) & flower(f) & ?[g]:(U(1,g) & greater(degree)(g) & ?[r]:(arg1(r)=f & U(2,r) & red(r) & arg1(g)=r & ?[p]:(U(3,p) & pink(p) & arg2(g)=p))))
#
#  "i saw four times as many cats as i saw dogs."
#  ?[C,D]:(size(C)=4*size(D) & C=^[x]:(U(0,x) & cat(c)) & ![x]:(C(x) => ?[s]:(arg1(s)=me & U(1,s) & see(s) & past(s) & arg2(s)=x & D=^[y]:(?[z]:(arg1(z)=me & U(2,z) & see(z) & past(z) & U(3,y) & dog(y) & arg2(z)=y)))))
#
#  "i saw four times as many cats as dogs."
#  ?[C,D]:(size(C)=4*size(D) & C=^[x]:(U(0,x) & cat(c)) & ![x]:(C(x) => ?[s]:(arg1(s)=me & U(1,s) & see(s) & past(s) & arg2(s)=x & D=^[y]:(?[z]:(U(2,z) & U(3,y) & dog(y) & arg2(z)=y)))))
#
#  "i earn four times as much as Ned earns."
#  ?[X,R]:(size(X)=4*size(R) & ![x]:(X(x) => ?[e]:(arg1(e)=me & U(0,e) & earn(e) & present(e) & arg2(e)=x & R=^[r]:(U(1,r) & ?[y]:(arg1(y)=ned & U(2,y) & earn(y) & present(y) & arg2(y)=r)))))
#
#  "they work harder the more we pay them."
#  ?[t]:(U(0,t) & plural_ref(0,t) & ![x]:(t(x) => ?[p]:(?[i]:(U(1,i) & increase(quantity)(i) & arg1(i)=p) & arg1(p)=we & U(2,p) & pay(p) & present(p) & arg2(p)=x))) => ?[t]:(U(3,t) & plural_ref(1,t) & ![x]:(t(x) => ?[w]:(arg1(w)=x & U(4,w) & work(w) & present(w) & ?[i]:(U(5,i) & increase(effort)(i) & arg1(i)=w))))
#
#  "they work harder if we pay them more."
#  ?[t]:(U(0,t) & plural_ref(0,t) & ![x]:(t(x) => ?[p]:(arg1(p)=we & U(1,p) & pay(p) & present(p) & arg2(p)=x & ?[i]:(U(2,i) & increase(quantity)(i) & arg1(i)=p)))) => ?[t]:(U(3,t) & plural_ref(1,t) & ![x]:(t(x) => ?[w]:(arg1(w)=x & U(4,w) & work(w) & present(w) & ?[i]:(U(5,i) & increase(effort)(i) & arg1(i)=w))))
#
#  "the more we pay them, the harder they work."
#  ?[t]:(U(0,t) & plural_ref(0,t) & ![x]:(t(x) => ?[p]:(?[i]:(U(1,i) & increase(quantity)(i) & arg1(i)=p) & arg1(p)=we & U(2,p) & pay(p) & present(p) & arg2(p)=x))) => ?[t]:(U(3,t) & plural_ref(1,t) & ![x]:(t(x) => ?[w]:(?[i]:(U(4,i) & increase(effort)(i) & arg1(i)=w) & arg1(w)=x & U(5,w) & work(w) & present(w))))
#
#  "the more money we pay them, the harder they work."
#  ?[t]:(U(0,t) & plural_ref(0,t) & ![x]:(t(x) => ?[p]:(?[i]:(U(1,i) & increase(quantity)(i) & ?[m]:(U(2,m) & money(m) & arg1(i)=m & arg3(p)=m)) & arg1(p)=we & U(3,p) & pay(p) & present(p) & arg2(p)=x))) => ?[t]:(U(4,t) & plural_ref(1,t) & ![x]:(t(x) => ?[w]:(?[i]:(U(5,i) & increase(effort)(i) & arg1(i)=w) & arg1(w)=x & U(6,w) & work(w) & present(w))))
#
#  "he is richer."
#  ?[h]:(U(0,h) & male_ref(0,h) & ?[i]:(arg1(i)=h & U(1,i) & increase(wealth)(i) & present(i)))
#
#  "he became richer."
#  ?[h]:(U(0,h) & male_ref(0,h) & ?[i]:(arg1(i)=h & U(1,i) & increase(wealth)(i) & past(i)))
#
#  "it is a difficult book to understand."
#  ?[i]:(U(0,i) & ref(0,i) & ?[s]:(arg1(s)=i & U(1,s) & same(s) & present(s) & ?[b]:(?[d]:(U(2,d) & difficult(d) & arg1(d)=b & arg2(d)=possibility(?[u]:(arg2(u)=b & U(3,u) & understand(u)))) & U(4,b) & book(b) & arg2(s)=b)))
#
#  "i saw the cats, but not the dogs."
#  but(?[C]:(C=^[c]:(U(0,c) & cat(c)) & ![c]:(C(c) => ?[s]:(arg1(s)=me & U(1,s) & see(s) & past(s) & arg2(s)=c))), ?[D]:(D=^[d]:(U(2,d) & dog(d)) & ![d]:(D(d) => ~?[e]:(empty_ref(0,e) & arg2(e)=d))))
# NOTE: We model this the same way as we model ellipsis. But if we were to
# model it as coordination, their logical forms would be as follows:
#  ?[C]:(C=^[c]:(U(0,c) & cat(c)) & ?[D]:(D=^[d]:(U(1,d) & dog(d)) & ![c,d]:(C(c) & D(d) => ?[s]:(arg1(s)=me & U(2,s) & see(s) & past(s) & arg2(s)=c) & ~?[s]:(arg1(s)=me & U(3,s) & see(s) & past(s) & arg2(s)=d))))
#
#  "i saw the cats, not the dogs."
#  instead_of(?[C]:(C=^[c]:(U(0,c) & cat(c)) & ![c]:(C(c) => ?[s]:(arg1(s)=me & U(1,s) & see(s) & past(s) & arg2(s)=c))) & ?[D]:(D=^[d]:(U(2,d) & dog(d)), ![d]:(D(d) => ~?[e]:(empty_ref(0,e) & arg2(e)=d))))
# NOTE: We model this the same way as we model ellipsis. But if we were to
# model it as coordination, their logical forms would be as follows:
#  ?[C]:(C=^[c]:(U(0,c) & cat(c)) & ?[D]:(D=^[d]:(U(1,d) & dog(d)) & ![c,d]:(C(c) & D(d) => instead_of(?[s]:(arg1(s)=me & U(2,s) & see(s) & past(s) & arg2(s)=c),?[s]:(arg1(s)=me & U(3,s) & see(s) & past(s) & arg2(s)=d)))))
# where `instead_of` is a special function like `possibility` where
# `instead_of(A,B)` implies `A & ~B` but before this sentence, `A | B` and
# `~(A & B)` are true. (this function is special because its truth-functional
# definition depends not on a particular model/structure, but rather that
# before this logical form is incorporated into the theory, both `A | B` and
# `~(A & B)` are provable)
#
# "a cat, not a dog, was walking in the park."
# ?[c]:(U(0,c) & cat(c) & ~dog(c) & ?[w]:(arg1(w)=c & U(2,w) & walk(w) & past(w) & ?[p]:(U(3,p) & park(p) & arg2(w)=p)))
#
# "4 cats, not dogs, were walking in the park."
# ?[C]:(C=^[c]:(U(0,c) & cat(c) & ~dog(c)) & size(C)=4 & ![c]:(C(c) => ?[w]:(arg1(w)=c & U(1,w) & walk(w) & past(w) & ?[p]:(U(2,p) & park(p) & arg2(w)=p))))
#
# "4 cats, not 4 dogs, were walking in the park."
# ?[C]:(C=^[c]:(U(0,c) & cat(c)) & size(C)=4 & ~(C=^[d]:(U(1,d) & dog(d)) & size(C)=4) & ![c]:(C(c) => ?[w]:(arg1(w)=c & U(2,w) & walk(w) & past(w) & ?[p]:(U(3,p) & park(p) & arg2(w)=p))))
#
# "he not only photocopied it, but had even read it."
# ?[h]:(U(0,h) & male_ref(h) & but(?[p]:(~?[o]:(U(1,o) & only(o) & arg1(o)=p) & arg1(p)=h & U(2,p) & photocopy(p) & past(p) & ?[i]:(U(3,i) & ref(0,i) & arg2(p)=i)),?[r]:(arg1(r)=h & U(4,r) & read(r) & past(r) & ?[i]:(U(5,i) & ref(1,i) & arg2(r)=i))))
#
# "i saw a dog rather than a cat."
# "rather than a cat, i saw a dog."
# ?[d]:(instead_of(U(0,d) & dog(d), U(1,c) & cat(c)) & ?[s]:(arg1(s)=me & U(2,s) & see(s) & past(s) & arg2(s)=d))
# TODO: implement this in the grammar
#
# "i like to walk rather than run."
# "rather than run, i like to walk."
# ?[l]:(arg1(l)=me & U(0,l) & like(l) & present(l) & instead_of(?[w]:(U(1,w) & walk(w) & arg2(l)=w),?[r]:(U(2,r) & run(r) & arg2(l)=r)))
#
# "he didn't wake up, let alone go to school."
# TODO: implement this in the grammar
#
# coordination of determinatives
# "i made little or no money."
# TODO: implement this in the grammar
#
# coordination of determinatives
# "there were one or two mistakes."
# TODO: implement this in the grammar
#
# coordination of determinatives
# "some or all cats were sleeping."
# TODO: implement this in the grammar
#
# coordination of prepositions
# "i slept before and after dinner."
# TODO: implement this in the grammar
#
# coordination of prepositions
# "i am at or near the tree."
# TODO: implement this in the grammar
#
# "Kim and Pat's children are cute."
# "Kim's and Pat's children are cute."
# ?[X]:(X=^[x]:(?[P]:(P=^[p]:(p=kim | p=pat) & ![p]:(P(p) => ?[o]:(arg1(o)=p & U(0,o) & own(o) & arg2(o)=x))) & U(1,x) & child(x)) & ![x]:(X(x) => ?[c]:(arg1(c)=x & U(2,c) & cute(c) & present(c))))
# TODO: implement this in the grammar
#
# "in the tree and afraid, the cat and dog are."
# ?[c](U(0,c) & cat(c) & ?[d]:(U(1,d) & dog(d) & ?[X]:(X=^[x]:(x=c | x=d) & ![x]:(X(x) => ?[l]:(U(2,l) & location(l) & present(l) & arg1(l)=x & ?[t]:(U(3,t) & tree(t) & arg2(l)=t)) & ?[a]:(U(4,a) & afraid(a) & present(a) & arg1(a)=x)))))


S nonterminal {} {1.0} {1.0} {} 10 1.0 {}

S -> S':mark_wide_scope PERIOD

# for closed interrogatives that are essentially declarative with a question mark
# S {^[x]:x=A} -> S' {A}
# S {^[x]:(... & true(x) & (x=possibility(A1) | ... | x=possibility(An)))} -> S' {... & (A1 | ... | An)}
# e.g. "it is red?", "it is red or blue?"
#S -> S':remove_closed_lambda_equality,mark_wide_scope QUESTION
#S -> S':remove_lambda_possibilities,mark_wide_scope QUESTION

# for all other interrogatives
# S {^[x]:A} -> S' {^[x]:A}
S -> S':mark_wide_scope QUESTION


# This is the root nonterminal for declarative sentences.
S' nonterminal {} {1.0} {1.0} {} 10 1.0 {}
S' -> S'':add_singular,require_no_conjunction,try_remove_is_adjunct
S' -> S'':add_plural,require_no_conjunction,try_remove_is_adjunct

# for subordinate clauses
S' -> THAT S':try_remove_correlated,try_remove_is_adjunct,remove_that
S' -> WHETHER S':try_remove_correlated,try_remove_is_adjunct,remove_whether
S' -> WHETHER OR NOT S':try_remove_correlated,try_remove_is_adjunct,remove_whether
S' -> IF S':try_remove_correlated,try_remove_is_adjunct,remove_if
S' -> BECAUSE S':try_remove_correlated,try_remove_is_adjunct,remove_because
S' -> FOR S':try_remove_correlated,try_remove_is_adjunct,remove_for

# (non-predicative) preposed VP complements/adjuncts
# S' {... & (~)?[y1]:(g1(y1) & f(y1)) & ... & (~)?[yn]:(gn(yn) & f(yn))}
#  -> V_ADJUNCT {... & ?[y1]:(p1(y1) & f(y1)) & ... & ?[yn]:(pn(yn) & f(yn))}
#     (COMMA) S' {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
#S' -> V_ADJUNCT:try_remove_nullable_subject,require_no_conjunction,try_remove_is_adjunct,require_no_correlator,select_right_conjunct S':try_remove_correlated,try_remove_is_adjunct,remove_right_conjunct
#S' -> V_ADJUNCT:try_remove_nullable_subject,require_no_conjunction,try_remove_is_adjunct,require_no_correlator,select_right_conjunct COMMA S':try_remove_correlated,try_remove_is_adjunct,remove_right_conjunct

# (predicative) preposed VP complements/adjuncts
# S' {... & (~)?[y1]:(U(i1,y1) & p1(y1) & f(y1) & h1(y1)) & ... & (~)?[yn]:(U(in,yn) & pn(yn) & f(yn) & hn(yn))}
#  -> V_ADJUNCT {... & ?[y1]:(U(i1,y1) & p1(y1) & h1(y1)) & ... & ?[yn]:(U(in,yn) & pn(yn) & hn(yn))}
#     (COMMA) S' {... & (~)?[y]:f(y)}
# This rule removes the predicate `p` from the event corresponding to the verb
# (and so the verb is semantically empty) such as in "blue, the cat is" and "in
# the tree, the cat is". `f` contains verb-specific terms such as `present` as
# well as any adjuncts or other arguments of y whereas `h` contains everything
# else, such as the argument.
#S' -> V_ADJUNCT:try_remove_nullable_subject,require_no_conjunction,try_remove_is_adjunct,require_no_correlator,select_right_conjunct S':try_remove_correlated,try_remove_is_adjunct,remove_right_conjunct,remove_left_predicate_and_factor
#S' -> V_ADJUNCT:try_remove_nullable_subject,require_no_conjunction,try_remove_is_adjunct,require_no_correlator,select_right_conjunct COMMA S':try_remove_correlated,try_remove_is_adjunct,remove_right_conjunct,remove_left_predicate_and_factor

# preposed coordination
# TODO: coordinates from other levels can be moved here to (as well as to other levels), such as NP, NOMINAL_R, N_ADJUNCT
# S' {... & (~)?[y]:(... & (A1 & ... & An))}
#  -> AS WELL AS/IN ADDITION TO/PLUS V_ADJUNCT {?[y]:(p(y) & A1)}
#     COMMA S' {... & (~)?[y]:(... & (A2 & ... & An))}
#S' -> AS WELL AS V_ADJUNCT:select_left_conjunct_in_right_conjunct COMMA S':remove_left_conjunct_in_right_conjunct
#S' -> IN ADDITION TO V_ADJUNCT:select_left_conjunct_in_right_conjunct COMMA S':remove_left_conjunct_in_right_conjunct
#S' -> PLUS V_ADJUNCT:select_left_conjunct_in_right_conjunct COMMA S':remove_left_conjunct_in_right_conjunct
# S' {... & (~)?[y]:(... & instead_of(A1, A2))}
#  -> RATHER THAN V_ADJUNCT {?[y]:(p(y) & A2)}
#     COMMA S' {... & (~)?[y]:(... & A1)}
#S' -> RATHER THAN V_ADJUNCT:select_right_in_right_instead_of COMMA S':remove_right_in_right_instead_of

# S' {?[X]:(f(X) & ![x]:(X(x) => (true(x) => g(x))))}
#  -> S' {g(x)}
#     (COMMA) IF
#     PP {?[X]:(f(X) & ![x]:(X(x) => true(x)))}
# NOTE: We don't allow other adjuncts here to avoid the spurious ambiguity
# where the PP could also attach at VP.
#S' -> S':require_no_conjunction,try_remove_is_adjunct,select_consequent_in_cases PP:try_remove_nullable_subject,try_remove_correlated,try_remove_correlator,try_remove_is_adjunct,remove_consequent_in_cases
#S' -> S':require_no_conjunction,try_remove_is_adjunct,select_consequent_in_cases COMMA PP:try_remove_nullable_subject,try_remove_correlated,try_remove_correlator,try_remove_is_adjunct,remove_consequent_in_cases

# S' {A => B} -> IF/WHETHER S' {A} (COMMA) (THEN) S' {B}
# S' {^[x]:x=(A => B)} -> IF/WHETHER S' {A} (COMMA) (THEN) S' {^[x]:x=B}
#S' -> S':require_no_conjunction,try_remove_is_adjunct,add_if,select_antecedent S':try_remove_correlated,try_remove_correlator,try_remove_is_adjunct,remove_antecedent
#S' -> S':require_no_conjunction,try_remove_is_adjunct,add_if,select_antecedent COMMA S':try_remove_correlated,try_remove_is_adjunct,try_remove_correlator,remove_antecedent
#S' -> S':require_no_conjunction,try_remove_is_adjunct,add_if,select_antecedent THEN S':try_remove_correlated,try_remove_is_adjunct,try_remove_correlator,remove_antecedent
#S' -> S':require_no_conjunction,try_remove_is_adjunct,add_if,select_antecedent COMMA THEN S':try_remove_correlated,try_remove_is_adjunct,try_remove_correlator,remove_antecedent
#S' -> S':require_no_conjunction,try_remove_is_adjunct,add_whether,select_antecedent S':try_remove_correlated,try_remove_is_adjunct,try_remove_correlator,remove_antecedent
#S' -> S':require_no_conjunction,try_remove_is_adjunct,add_whether,select_antecedent COMMA S':try_remove_correlated,try_remove_is_adjunct,try_remove_correlator,remove_antecedent
#S' -> S':require_no_conjunction,try_remove_is_adjunct,add_if,add_subjunctive,select_antecedent S':try_remove_correlated,try_remove_is_adjunct,try_remove_correlator,remove_antecedent
#S' -> S':require_no_conjunction,try_remove_is_adjunct,add_if,add_subjunctive,select_antecedent COMMA S':try_remove_correlated,try_remove_is_adjunct,try_remove_correlator,remove_antecedent
#S' -> S':require_no_conjunction,try_remove_is_adjunct,add_if,add_subjunctive,select_antecedent THEN S':try_remove_correlated,try_remove_is_adjunct,try_remove_correlator,remove_antecedent
#S' -> S':require_no_conjunction,try_remove_is_adjunct,add_if,add_subjunctive,select_antecedent COMMA THEN S':try_remove_correlated,try_remove_is_adjunct,try_remove_correlator,remove_antecedent
#S' -> S':require_no_conjunction,try_remove_is_adjunct,add_whether,add_subjunctive,select_antecedent S':try_remove_correlated,try_remove_is_adjunct,try_remove_correlator,remove_antecedent
#S' -> S':require_no_conjunction,try_remove_is_adjunct,add_whether,add_subjunctive,select_antecedent COMMA S':try_remove_correlated,try_remove_is_adjunct,try_remove_correlator,remove_antecedent

# (not preposed) correlative comparative constructions
# S' {... & ?[y]:(?[i]:f(i) & g(y)) => B}
#  -> S' {B}
#     THE ADJP_L/ADVP_L {... & ?[i]:f(i)}
#     S' {... & ?[y]:g(y)}
# S' {... & ?[i]:(U(j,i) & p(i) & f(i)) => B}
#  -> S' {B}
#     THE ADJP_L/ADVP_L {... & ?[i]:(U(k,i) & p(i))}
#     S' {... & ?[i]:f(i)}
# e.g. "they work harder the more (money) we pay them.", "he becomes more cynical the older he gets."
#S' -> S':require_no_conjunction,select_consequent THE ADJP_L:try_remove_correlated,try_remove_is_adjunct,try_remove_correlator,select_left_conjunct_without_head S':try_remove_correlated,try_remove_is_adjunct,try_remove_correlator,select_antecedent,remove_left_conjunct
#S' -> S':require_no_conjunction,select_consequent THE ADVP_L:try_remove_correlated,try_remove_is_adjunct,try_remove_correlator,select_left_conjunct_without_head S':try_remove_correlated,try_remove_is_adjunct,try_remove_correlator,select_antecedent,remove_left_conjunct

# (preposed) correlative comparative constructions
# S' {... & ?[y]:(?[i]:f1(i) & g1(y)) => ... & ?[y]:(?[i]:f2(i) & g2(y))}
#  -> THE ADJP_L/ADVP_L {... & ?[i]:f1(i)}
#     S' {... & ?[y]:g1(y)}
#     COMMA THE ADJP_L/ADVP_L {... & ?[i]:f2(i)}
#     S' {... & ?[y]:g2(y)}
# S' {... & ?[i]:(p1(i) & f1(y)) => ... & ?[y]:(?[i]:f2(i) & g2(y))}
#  -> THE ADJP_L/ADVP_L {... & ?[i]:p1(i)}
#     S' {... & ?[y]:f1(y)}
#     COMMA THE ADJP_L/ADVP_L {... & ?[i]:f2(i)}
#     S' {... & ?[y]:g2(y)}
# NOTE: The consequent could also be predicative in the same way as the antecedent.
# e.g. "the more (money) we pay them, the harder they work.", "the older he gets, the more cynical he becomes."
#S' -> THE ADJP_L:try_remove_correlated,try_remove_is_adjunct,select_antecedent,select_left_conjunct_without_head S':try_remove_correlated,try_remove_is_adjunct,require_no_conjunction,require_no_correlator,select_antecedent,remove_left_conjunct COMMA THE ADJP_L:try_remove_correlated,try_remove_is_adjunct,select_consequent,select_left_conjunct_without_head S':try_remove_correlated,try_remove_is_adjunct,select_consequent,remove_left_conjunct
#S' -> THE ADJP_L:try_remove_correlated,try_remove_is_adjunct,select_antecedent,select_left_conjunct_without_head S':try_remove_correlated,try_remove_is_adjunct,require_no_conjunction,require_no_correlator,select_antecedent,remove_left_conjunct COMMA THE ADVP_L:try_remove_correlated,try_remove_is_adjunct,select_consequent,select_left_conjunct_without_head S':try_remove_correlated,try_remove_is_adjunct,select_consequent,remove_left_conjunct
#S' -> THE ADVP_L:try_remove_correlated,try_remove_is_adjunct,select_antecedent,select_left_conjunct_without_head S':try_remove_correlated,try_remove_is_adjunct,require_no_conjunction,require_no_correlator,select_antecedent,remove_left_predicate_and_factor COMMA THE ADJP_L:try_remove_correlated,try_remove_is_adjunct,select_consequent,select_left_conjunct_without_head S':try_remove_correlated,try_remove_is_adjunct,select_consequent,remove_left_conjunct
#S' -> THE ADVP_L:try_remove_correlated,try_remove_is_adjunct,select_antecedent,select_left_conjunct_without_head S':try_remove_correlated,try_remove_is_adjunct,require_no_conjunction,require_no_correlator,remove_left_predicate_and_factor COMMA THE ADVP_L:try_remove_correlated,try_remove_is_adjunct,select_consequent,select_left_conjunct_without_head S':try_remove_correlated,try_remove_is_adjunct,select_consequent,remove_left_conjunct

S' -> EITHER S':require_not_adjunct,remove_either

# for correlated coordination
# NOTE: For the following rules, the coordination doesn't have to be at head
# scope, it can be the left-most coordination that is a descendant of the head
# scope as well, so long as there is no negation between the coordination and
# the root. However, we need some measure of "distance" between the
# coordination and the head scope to be a feature to decide between the rules
# at this nonterminal (e.g. "both" moves left much less often than "either").
# S' {A1 | ... | An} -> EITHER S' {A1 | ... | An}
#S' -> S':require_not_correlated,require_not_adjunct,add_either,add_correlated_by_either,require_disjunction # this transformation requires the coordination is at the head
#S' -> EITHER S':require_not_correlated,require_not_adjunct,add_correlated_by_either,require_disjunction # this transformation requires the coordination is a descendant of the head

# NOTE: In the below rules, we require that none of the Ai are themselves
# coordinations with the coordinator (unless Ai is negated).
# S' {(~)A1 & ... & (~)An} -> S' {(~)A1} S_COORDINATION {(~)A2 & ... & (~)An}
#S' -> S':require_not_adjunct,require_conjunction,select_left_operand S_COORDINATION:try_remove_correlator,add_and,remove_left_operand
#S' -> S':require_not_adjunct,require_conjunction,select_left_operand S_COORDINATION:try_remove_correlator,add_and,remove_left_operand,add_comma
# S' {(~)A1 | ... | (~)An} -> S' {(~)A1} S_COORDINATION {(~)A2 | ... | (~)An}
#S' -> S':require_not_adjunct,require_disjunction,select_left_operand S_COORDINATION:try_remove_correlator,add_or,remove_left_operand
#S' -> S':require_not_adjunct,require_disjunction,select_left_operand S_COORDINATION:try_remove_correlator,add_or,remove_left_operand,add_comma
# S' {~A1 & ... & ~An} -> S' {~A1} S_COORDINATION {~A2 & ... & ~An}
# TODO: We need to store information in the source logical form that there was
# originally a negation (that this is a negative context), and "nor" can only
# appear in negative contexts.
#S' -> S':require_not_adjunct,require_negative_conjunction,select_left_operand S_COORDINATION:try_remove_correlator,add_nor,remove_left_operand
#S' -> S':require_not_adjunct,require_negative_conjunction,select_left_operand S_COORDINATION:try_remove_correlator,add_nor,remove_left_operand,add_comma

# S' {but((~)A1,(~)A2)} -> S' {(~)A1} (COMMA) BUT S' {(~)A2}
#S' -> S':require_not_adjunct,select_left_in_but BUT S':try_remove_correlator,select_right_in_but
#S' -> S':require_not_adjunct,select_left_in_but COMMA BUT S':try_remove_correlator,select_right_in_but


S_COORDINATION nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# S_COORDINATION {(~)A1 & ... & (~)An} -> (COMMA) S' {(~)A1} S_COORDINATION {(~)A2 & ... & (~)An}
# S_COORDINATION {(~)A1 | ... | (~)An} -> (COMMA) S' {(~)A1} S_COORDINATION {(~)A2 | ... | (~)An}
#S_COORDINATION -> COMMA:require_comma S':remove_coordinator,remove_comma,select_left_operand S_COORDINATION:remove_left_operand
# S_COORDINATION {(~)A1} -> (COMMA) S' {(~)A1}
#S_COORDINATION -> COMMA:require_comma S':remove_coordinator,remove_comma

# S_COORDINATION {(~)A1 & ... & (~)An} -> (COMMA) AND S' {(~)A1} S_COORDINATION {(~)A2 & ... & (~)An}
#S_COORDINATION -> AND:require_and S':remove_coordinator,remove_comma,select_left_operand S_COORDINATION:remove_left_operand
#S_COORDINATION -> COMMA:require_comma AND:require_and S':remove_coordinator,remove_comma,select_left_operand S_COORDINATION:remove_left_operand
# S_COORDINATION {(~)A1} -> (COMMA) AND S' {(~)A1}
#S_COORDINATION -> AND:require_and S':remove_coordinator,remove_comma
#S_COORDINATION -> COMMA:require_comma AND:require_and S':remove_coordinator,remove_comma

# S_COORDINATION {(~)A1 & ... & (~)An} -> (COMMA) OR S' {(~)A1} S_COORDINATION {(~)A2 & ... & (~)An}
#S_COORDINATION -> OR:require_or S':remove_coordinator,remove_comma,select_left_operand S_COORDINATION:remove_left_operand
#S_COORDINATION -> COMMA:require_comma OR:require_or S':remove_coordinator,remove_comma,select_left_operand S_COORDINATION:remove_left_operand
# S_COORDINATION {(~)A1} -> (COMMA) OR S' {(~)A1}
#S_COORDINATION -> OR:require_or S':remove_coordinator,remove_comma
#S_COORDINATION -> COMMA:require_comma OR:require_or S':remove_coordinator,remove_comma

# S_COORDINATION {~A1 & ... & (~)An} -> (COMMA) NOR VP_R {~A1} S_COORDINATION {(~)A2 & ... & (~)An}
#S_COORDINATION -> NOR:require_nor VP_R:add_req_aux,remove_coordinator,remove_comma,select_left_operand S_COORDINATION:remove_left_operand
#S_COORDINATION -> COMMA:require_comma NOR:require_nor VP_R:add_req_aux,remove_coordinator,remove_comma,select_left_operand S_COORDINATION:remove_left_operand
# S_COORDINATION {~A1} -> (COMMA) NOR S' {~A1}
#S_COORDINATION -> NOR:require_nor VP_R:add_req_aux,remove_coordinator,remove_comma
#S_COORDINATION -> COMMA:require_comma NOR:require_nor VP_R:add_req_aux,remove_coordinator,remove_comma


S'' nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# S'' {(~)?[x]:f(x)} -> THERE IS NP {^[P]:?[X]:(X=^[x]:f(x) & (~)?[x]:(X(x) & P(x)))}
# NOTE: This above rule is only really useful if we choose to represent "there
# is a cat" as something like ?[x]:(U(0,x) & cat(x)).
#S'' -> THERE IS NP:try_remove_nullable_subject,require_no_lambda,try_remove_correlated,require_no_correlator,predicative

# S'' {... & (~)?[y1]:(f(y1) & g1(y1)) & ... & (~)?[yn]:(f(yn) & gn(yn))}
#  -> V_ADJUNCT {... & ?[y1]:(p1(y1) & f(y1)) & ... & ?[yn]:(pn(yn) & f(yn))}
#     VP_R {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
# where `f` contains the `arg1` term.
# TODO: why do we have this rule? it's identical to the one below it
#S'' -> V_ADJUNCT:try_remove_nullable_subject,require_no_subordinate,try_remove_correlator,select_left_conjunct VP_R:try_remove_nullable_subject,try_remove_correlated,remove_left_conjunct

# S'' {... & (~)?[x]:(f(x) & ?[y1]:(... & arg1/arg2(y1)=x) & ... & ?[yn]:(... & arg1/arg2(yn)=x))}
#  -> V_ADJUNCT {... & ?[x]:(f(x) & ?[y1]:(p1(y1) & arg1/arg2(y1)=x) & ... & ?[yn]:(pn(yn) & arg1/arg2(yn)=x))}
#     VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
# S'' {... & (~)![x]:(f(x) => ... & ?[y1]:(... & arg1/arg2(y1)=x) & ... & ?[yn]:(... & arg1/arg2(yn)=x))}
#  -> V_ADJUNCT {... & ![x]:(f(x) => ... & ?[y1]:(p1(yn) & arg1/arg2(y1)=x) & ... & ?[yn]:(pn(yn) & arg1/arg2(yn)=x))}
#     VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
# S'' {... & ?[X]:(f(X) & (~)![x]:(X(x) => ... & ?[y1]:(... & arg1/arg2(y1)=x) & ... & ?[yn]:(... & arg1/arg2(yn)=x)))}
#  -> V_ADJUNCT {... & ?[X]:(f(X) & ![x]:(X(x) => ... & ?[y1]:(p1(y1) & arg1/arg2(y1)=x) & ... & ?[yn]:(pn(yn) & arg1/arg2(yn)=x)))}
#     VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
# NOTE: This rule also handles open interrogatives but only when the unknown
# variable is in the logical form for the V_ADJUNCT. In the logical forms of
# some interrogatives, X may be declared as a lambda variable.
# NOTE: The `arg2` version of the rule is for preposing.
# NOTE: In comparative constructions where sizes of sets are compared, this
# requires that the quantified variables are used in the same way in both
# consequents. That is, in:
#   ?[X]:(... & ?[R]:(f(size(X),size(R)) & ... & ![r]:(R(r) => ?[y]:(arg1/arg2/arg3(y)=r & ...))) & ... & ![x]:(X(x) => ?[y]:(arg1/arg2/arg3(y)=x & ...)))
# This rule requires that `arg1(y)=r` and `arg1(y)=x` appear in both
# consequents (or `arg2(y)=r` and `arg2(y)=x`, etc).
S'' -> V_ADJUNCT:try_remove_nullable_subject,require_no_subordinate,try_remove_correlator,select_left_conjunct VP_R:try_remove_nullable_subject,try_remove_correlated,remove_left_conjunct
# TODO: do we need an arg2 version of this rule?

# open interrogative clauses with movement
# S'' {^[x]:(... ?[X]:(... & X(x) & ... & ?[r]:(f(r) & arg1/arg2/arg3(r)=x)))} note that X is not quantified here; `X(x)` kind of plays the role of a quantifier
#  -> V_ADJUNCT {^[x]:(... ?[X]:(... & X(x) & ... & ?[r]:(p(r) & arg1/arg2/arg3(r)=x)))}
#     VP_R {... & ?[r]:f(r)}
# S'' {^[X]:(... & ![x]:(X(x) => ?[r]:(f(r) & arg1/arg2/arg3(r)=x)))}
#  -> V_ADJUNCT {^[X]:(... & ![x]:(X(x) => ?[r]:(p(r) & arg1/arg2/arg3(r)=x)))}
#     VP_R {... & ?[r]:f(r)}
# S'' {^[x]:(... & ?[r]:(f(r) & arg1/arg2/arg3(r)=x))}
#  -> V_ADJUNCT {^[x]:(... & ?[r]:(p(r) & arg1/arg2/arg3(r)=x))}
#     VP_R {... & ?[r]:f(r)}
# e.g. "which store did Jason run to?", "what store did Jason run to?", "who is she speaking with?"
# e.g. "to which store did Jason run?", "with whom is she speaking?" (for the rules with add_preposition)
#S'' -> V_ADJUNCT:try_remove_nullable_subject,try_remove_subordinate,try_remove_correlator,select_right_of_lambda VP_R:try_remove_nullable_subject,try_add_req_aux,try_remove_subordinate,try_remove_correlated,remove_right_of_lambda # requires do-support unless subordinate
#S'' -> V_ADJUNCT:try_remove_nullable_subject,try_remove_subordinate,try_remove_correlator,select_right_of_lambda VP_R:try_remove_nullable_subject,try_add_req_aux,try_remove_subordinate,try_remove_correlated,remove_right_of_lambda,add_to_infinitive # requires do-support unless subordinate
#S'' -> V_ADJUNCT:try_remove_nullable_subject,try_remove_subordinate,add_preposition,try_remove_correlator,select_right_of_lambda VP_R:try_remove_nullable_subject,try_add_req_aux,try_remove_subordinate,add_preposition,try_remove_correlated,remove_right_of_lambda # requires do-support unless subordinate
#S'' -> V_ADJUNCT:try_remove_nullable_subject,try_remove_subordinate,add_preposition,try_remove_correlator,select_right_of_lambda VP_R:try_remove_nullable_subject,try_add_req_aux,try_remove_subordinate,add_preposition,try_remove_correlated,remove_right_of_lambda,add_to_infinitive # requires do-support unless subordinate
# for predicative subjects
# S'' {^[x]:(... ?[r]:(g(x,r) & U(i,r) & p(r) & f(r)))}
#  -> V_ADJUNCT {^[x]:?[r]:(g(x,r) & U(i,r) & p(r))}
#     VP_R {^[x]:(... ?[r]:f(r))
# e.g. "how big is the earth?"
# NOTE: `r` does not have to be the head of the logical form.
# NOTE: `r` can also be any scope that is an ancestor of x.
#S'' -> V_ADJUNCT:try_remove_nullable_subject,try_remove_subordinate,try_remove_correlator,select_right_of_lambda VP_R:try_remove_nullable_subject,try_add_req_aux,try_remove_subordinate,try_remove_correlated,remove_right_and_predicate_of_lambda # requires do-support unless subordinate
#S'' -> V_ADJUNCT:try_remove_nullable_subject,try_remove_subordinate,try_remove_correlator,select_right_of_lambda VP_R:try_remove_nullable_subject,try_add_req_aux,try_remove_subordinate,try_remove_correlated,remove_right_and_predicate_of_lambda,add_to_infinitive # requires do-support unless subordinate

# open interrogative clauses with movement
# S'' {^[x]:(... ?[r]:(g(r) & U(i,r) & p(r) & f(r)))}
#  -> ADJP {^[x]:?[r]:(g(r) & U(i,r) & p(r))}
#     VP_R {^[x]:(... ?[r]:f(r))}
# NOTE: `r` does not have to be the head of the logical form.
# This rule removes the predicate `p` from the event corresponding to the verb
# (and so the verb is semantically empty).
# TODO: is this not subsumed by the above rules?
#S'' -> ADJP:try_remove_nullable_subject,try_remove_subordinate,try_remove_correlator,select_right_of_lambda VP_R:try_remove_nullable_subject,try_add_req_aux,try_remove_subordinate,try_remove_correlated,remove_right_and_predicate_of_lambda # requires do-support unless subordinate
#S'' -> ADJP:try_remove_nullable_subject,try_remove_subordinate,try_remove_correlator,select_right_of_lambda VP_R:try_remove_nullable_subject,try_add_req_aux,try_remove_subordinate,try_remove_correlated,remove_right_and_predicate_of_lambda,add_to_infinitive # requires do-support unless subordinate

# subject-less infinitival closed interrogative clauses
# S'' {^[x]:x=A} -> VP_R {A}
# S'' {^[x]:(... & true(x) & (x=possibility(A1) | ... | x=possibility(An)))} -> VP_R {... & (A1 | ... | An)}
#S'' -> VP_R:remove_subordinate,require_no_arg1,require_to_infinitive,remove_closed_lambda_equality
#S'' -> VP_R:remove_subordinate,require_no_arg1,require_to_infinitive,remove_lambda_possibilities

# subject-less infinitival open interrogative clauses
# S'' {^[x]:A} -> VP_R {^[x]:A}
#S'' -> VP_R:try_remove_subordinate,require_no_arg1,add_to_infinitive,require_lambda

# closed interrogative clauses, which require subject-auxiliary inversion
# (excluding closed interrogative clauses we handle at the nonterminal S)
# S'' {^[x]:x=A} -> VP_R {A}
# S'' {^[x]:(... & true(x) & (x=possibility(A1) | ... | x=possibility(An)))} -> VP_R {... & (A1 | ... | An)}
#S'' -> VP_R:try_add_req_aux,remove_closed_lambda_equality # requires do-support unless subordinate
#S'' -> VP_R:try_add_req_aux,remove_lambda_possibilities # requires do-support unless subordinate

# comparative constructions
# S'' {... & ?[x,r]:(?[g1]:(U(i1,g1) & p(f1)(g1) & arg1(g1)=x & arg2(g1)=r) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & arg1(gn)=x & arg2(gn)=r) & ... & ?[y]:(... & arg1(y)=x & ... & h(r) & ...))}
#  -> NP {^[P]:(... & ?[X]:(X=^[x]:(?[g1]:(U(i1,g1) & p(f1)(g1) & arg1(g1)=x) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & arg1(gn)=x) & ...) & ?[x]:(X(x) & P(x))))}
#     VP_R {... & ?[r]:(?[g]:(U(i,g) & p(fn)(g) & arg2(g)=r) & ... & ?[y]:(... & h(r) & ...))}
# where h(r) could either be `r=a` if r is a constant or it can define a new object like `U(i,r) & p(r) & ...`.
# S'' {... & ?[X,R]:(... & p_comp(size(X),size(R)) & ... & F(X=^[x]:(![r]:(R(r) => ?[g1]:(U(i1,g1) & p(f1)(g1) & arg1(g1)=x & arg2(g1)=r) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & arg1(gn)=x & arg2(gn)=r)) & ...)) & ... & ![x]:(X(x) => ?[y]:(... & arg1(y)=x & ... & R=^[r]:(...) & ...)))}
#  -> NP {^[P]:(... & ?[X]:(... & p_comp(size(X)) & ... & F(X=^[x]:(?[g1]:(U(i1,g1) & p(f1)(g1) & arg1(g1)=x) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & arg1(gn)=x))) & ... & ![x]:(X(x) => P(x))))}
#     VP_R {... & ?[R]:(p_comp(size(R)) & ... & ![r]:(R(r) => ?[g]:(U(i,g) & p(fn)(g) & arg2(g)=r)) & ... & ?[y]:(... & R=^[r]:(...) & ...))}
# S'' {... & ?[X,R]:(?[X1,R1]:(... & p_comp(size(X1),size(R1)) & ... & F(X1=^[x]:(![r]:(R1(r) => ?[g1]:(U(i1,g1) & p(f1)(g1) & arg1(g1)=x & arg2(g1)=r) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & arg1(gn)=x & arg2(gn)=r)) & ...)) & ?[X2,R2]:(... & p_comp(size(X2),size(R2)) & ... & F(X2=^[x]:(...)) & ... & X=^[S]:(S=X1 | ... | S=Xn) & R=^[S]:(S=R1 | ... | S=Rn))) & ... & ![S]:(X(S) => ![x]:(S(x) => ?[y]:(... & arg1(y)=x & ... & ![Ri]:(R(Ri) => Ri=^[r]:(...)) & ...))))}
#  -> NP {^[P]:(... & ?[X]:(?[X1]:(... & p_comp(size(X1)) & ... & F(X1=^[x]:(?[g1]:(U(i1,g1) & p(f1)(g1) & arg1(g1)=x) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & arg1(gn)=x) & ...)) & ?[X2]:(... & p_comp(size(X2)) & ... & F(X2=^[x]:(...)) & ... & X=^[S]:(S=X1 | ... | S=Xn))) & ... & ![S]:(X(S) => ![x]:(S(x) => P(x)))))}
#     VP_R {... & ?[Rn]:(p_comp(size(Rn)) & ... & ![r]:(Rn(r) => ?[g]:(U(i,g) & p(fn)(g) & arg2(g)=r)) & ... & ?[y]:(... & Rn=^[r]:(...) & ...))}
# NOTE: The predicate could also be a simple `p` rather than `p(f)`. The terms
# `p_comp(size(X),size(R))` and `?[gi]:(...)` are optional (but there must be
# at least one). The term `p_comp(size(X),size(R))` handles comparative
# constructions where sizes of sets are compared.
# e.g. "a brighter star could be seen with the telescope than without it", "more people came than last time", "more girls but fewer boys came to the event than last time"
#S'' -> NP:require_no_subordinate,select_left_comparator_predicative,try_remove_nullable_subject,try_remove_correlator VP_R:remove_left_comparator,try_remove_nullable_subject,try_remove_correlated

# S'' {A} -> VP_R {A}
S'' -> VP_R:remove_nullable_subject


VP_R nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# VP_R {... & (~)?[y1]:(g1(y1) & f(y1)) & ... & (~)?[yn]:(gn(yn) & f(yn))}
#  -> VP_R {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
#     V_ADJUNCT {... & ?[y1]:(p1(y1) & f(y1)) & ... & ?[yn]:(pn(yn) & f(yn))}
VP_R -> VP_R:remove_right_conjunct V_ADJUNCT:select_right_conjunct,try_remove_correlated,try_remove_correlator,try_remove_aux,try_remove_number,add_singular
VP_R -> VP_R:remove_right_conjunct V_ADJUNCT:select_right_conjunct,try_remove_correlated,try_remove_correlator,try_remove_aux,try_remove_number,add_plural
VP_R -> VP_R:remove_right_conjunct,add_preposition V_ADJUNCT:select_right_conjunct,try_remove_correlated,try_remove_correlator,try_remove_aux,try_remove_number,add_singular,add_preposition
VP_R -> VP_R:remove_right_conjunct,add_preposition V_ADJUNCT:select_right_conjunct,try_remove_correlated,try_remove_correlator,try_remove_aux,try_remove_number,add_plural,add_preposition

# VP_R {... & (~)?[y1]:(U(i1,y1) & p(y1) & f1(y1) & f(y1)) & ... & (~)?[yn]:(U(in,yn) & p(yn) & fn(yn) & f(yn))}
#  -> VP_R {... & (~)?[y1]:f1(y1) & ... & (~)?[yn]:fn(yn)}
#     V_ADJUNCT {... & ?[y]:(U(i,y) & p(y) & f(y))}
# This rule removes the predicate `p` from the event corresponding to the verb
# (and so the verb is semantically empty) such as in "the cat is blue" and "the
# cat is in the tree". `fi` contains verb-specific terms such as `present` as
# well as any adjuncts or other arguments of y whereas `f` contains everything
# else, such as the argument.
#VP_R -> VP_R:remove_right_conjunct,remove_left_predicate V_ADJUNCT:select_right_conjunct_and_factor,try_remove_correlated,try_remove_correlator,try_remove_aux,try_remove_number,add_singular
#VP_R -> VP_R:remove_right_conjunct,remove_left_predicate V_ADJUNCT:select_right_conjunct_and_factor,try_remove_correlated,try_remove_correlator,try_remove_aux,try_remove_number,add_plural

# comparative constructions
# VP_R {... & ?[x,r]:(?[g1]:(U(i1,g1) & p(f1)(g1) & arg1(g1)=x & arg2(g1)=r) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & arg1(gn)=x & arg2(gn)=r) & ... & ?[y]:(... & arg1(y)=x & ... & h(r) & ...))}
#  -> VP_R {... & ?[x]:(?[g1]:(U(i1,g1) & p(f1)(g1) & arg1(g1)=x) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & arg1(gn)=x) & ... & ?[y]:(... & arg1(y)=x & ... ))}
#     V_ADJUNCT {... & ?[r]:(?[g1]:(U(i1,g1) & p(f1)(g1) & arg2(g1)=r) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & arg2(gn)=r) & ... & ?[y]:(p(y) & h(r)))}
# VP_R {... & ?[X,R]:(... & f(size(X),size(R)) & ... & F(X=^[x]:(![r]:(R(r) => ?[g1]:(U(i1,g1) & p(f1)(g1) & arg1(g1)=x & arg2(g1)=r) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & arg1(gn)=x & arg2(gn)=r)) & ...)) & ... & ![x]:(X(x) => ?[y]:(... & arg1(y)=x & ... & R=^[r]:h(r) & ...)))}
#  -> VP_R {... & ?[X]:(... & f(size(X)) & ... & F(X=^[x]:(?[g1]:(U(i1,g1) & p(f1)(g1) & arg1(g1)=x) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & arg1(gn)=x) & ...)) & ... & ![x]:(X(x) => ?[y]:(... & arg1(y)=x & ...)))}
#     V_ADJUNCT {... & ?[R]:(... & f(size(R)) & ... & ![r]:(R(r) => ?[g1]:(U(i1,g1) & p(f1)(g1) & arg2(g1)=r) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & arg2(gn)=r)) & ... & ?[y]:(p(y) & R=^[r]:h(r)))}
# VP_R {... & ?[X,R]:(?[X1,R1]:(... & f(size(X1),size(R1)) & ... & F(X1=^[x]:(![r]:(R(r) => ?[g1]:(U(i1,g1) & p(f1)(g1) & arg1(g1)=x & arg2(g1)=r) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & arg1(gn)=x & arg2(gn)=r)) & ...)) & ?[X2,R2]:(... & f(size(X2),size(R2)) & ... & F(X2=^[x]:(...)) & ... & X=^[S]:(S=X1 | ... | S=Xn) & R=^[S]:(S=R1 | ... | S=Rn))) & ... & ![S]:(X(S) => ![x]:(S(x) => ?[y]:(... & arg1(y)=x & ... & ![Ri]:(R(Ri) => Ri=^[r]:h(r)) & ...))))}
#  -> VP_R {... & ?[X]:(?[X1]:(... & f(size(X1)) & ... & F(X1=^[x]:(?[g1]:(U(i1,g1) & p(f1)(g1) & arg1(g1)=x) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & arg1(gn)=x) & ...)) & ?[X2]:(... & f(size(X2)) & ... & F(X2=^[x]:(...)) & ... & X=^[S]:(S=X1 | ... | S=Xn))) & ... & ![S]:(X(S) => ![x]:(S(x) => ?[y]:(... & arg1(y)=x & ...))))}
#     V_ADJUNCT {... & ?[R]:(?[R1]:(... & f(size(R1)) & ... & ![r]:(R(r) => ?[g1]:(U(i1,g1) & p(f1)(g1) & arg2(g1)=r) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & arg2(gn)=r)) & ... & ?[R2]:(... & f(size(R2)) & ... & R=^[S]:(S=R1 | ... | S=Rn))) & ... & ?[y]:(p(y) & ![Ri]:(R(Ri) => Ri=^[r]:h(r))))}
# NOTE: The predicate could also be a simple `p` rather than `p(f)`. The terms
# `f(size(X),size(R))` and `?[gi]:(...)` are optional (but there must be at
# least one). The term `f(size(X),size(R))` handles comparative constructions
# where sizes of sets are compared.
# e.g. "you can see a brighter star with the telescope than without it", "i saw more people at the party than last time", "there were more girls but fewer boys at the event than last time"
#VP_R -> VP_R:select_left_comparator V_ADJUNCT:remove_left_comparator,try_remove_correlated,try_remove_correlator,try_remove_aux

# comparative constructions
# VP_R {... & ?[r]:(?[g]:(U(i,g) & p(f)(g) & arg2(g)=r) & ... & ?[y]:(... & h(r) & ...))}
#  -> VP_R {... & ?[y]:(...)}
#     V_ADJUNCT {... & ?[r]:(?[g]:(U(i,g) & p(f)(g) & arg2(g)=r) & ... & ?[y]:(p(y) & h(r)))}
# VP_R {... & ?[R]:(f(size(R)) & ... & ![r]:(R(r) => ?[g]:(U(i,g) & p(f)(g) & arg2(g)=r)) & ... & ?[y]:(... & R=^[r]:h(r) & ...))}
#  -> VP_R {... & ?[y]:(...)}
#     V_ADJUNCT {... & ?[R]:(f(size(R)) & ... & ![r]:(R(r) => ?[g]:(U(i,g) & p(f)(g) & arg2(g)=r)) & ... & ?[y]:(p(y) & R=^[r]:h(r)))}
# NOTE: The predicate could also be a simple `p` rather than `p(f)`. The terms
# `f(size(R))` and `?[gi]:(...)` are optional (but there must be at least one).
# The term `f(size(R))` handles comparative constructions where sizes of sets
# are compared.
# e.g. "a brighter star could be seen with the telescope than without it", "more people came than last time", "more girls but fewer boys came to the event than last time"
#VP_R -> VP_R:remove_right_comparator V_ADJUNCT:select_right_comparator,try_remove_correlated,try_remove_correlator,try_remove_aux

# for (conditional) closed interrogative finite subordinate clauses
# VP_R {A => B} -> VP_R {B} (COMMA) IF/WHETHER S' {A} (COMMA)
# VP_R {^[x]:x=(A => B)} -> VP_R {^[x]:x=B} (COMMA) IF/WHETHER S' {A} (COMMA)
#VP_R -> VP_R:remove_antecedent S':select_antecedent,try_remove_correlated,add_req_no_aux,try_remove_correlator,add_whether
#VP_R -> VP_R:remove_antecedent S':select_antecedent,try_remove_correlated,add_req_no_aux,try_remove_correlator,add_if
#VP_R -> VP_R:remove_antecedent COMMA S':select_antecedent,try_remove_correlated,add_req_no_aux,try_remove_correlator,add_whether COMMA
#VP_R -> VP_R:remove_antecedent COMMA S':select_antecedent,try_remove_correlated,add_req_no_aux,try_remove_correlator,add_if COMMA
#VP_R -> VP_R:remove_antecedent S':select_antecedent,try_remove_correlated,add_req_no_aux,try_remove_correlator,add_whether,add_subjunctive
#VP_R -> VP_R:remove_antecedent S':select_antecedent,try_remove_correlated,add_req_no_aux,try_remove_correlator,add_if,add_subjunctive
#VP_R -> VP_R:remove_antecedent COMMA S':select_antecedent,try_remove_correlated,add_req_no_aux,try_remove_correlator,add_whether,add_subjunctive COMMA
#VP_R -> VP_R:remove_antecedent COMMA S':select_antecedent,try_remove_correlated,add_req_no_aux,try_remove_correlator,add_if,add_subjunctive COMMA

# We need this rule for constructions like "she brought down the bed" and "she brought the bed down".
#VP_R -> VP_R:add_particle PARTICLE_PLACEHOLDER

# postposed NP complements/adjuncts
# VP_R {... & ?[x]:(... ?[y1]:(... & arg1/arg2/arg3(y1)=x & ...) & ... & ?[yn]:(... & arg1/arg2/arg3(yn)=x & ...) & ... & f(x))}
#  -> VP_R {... & ?[x]:(... ?[y1]:(... & arg1/arg2/arg3(y1)=x & ...) & ... & ?[yn]:(... & arg1/arg2/arg3(yn)=x & ...) & ...)}
#     V_ADJUNCT {... & ?[x]:(p(x) & f(x))}
# Note that f(x) may also contain variables which are universally-quantified,
# above the scope of zi, either within the scope of xi (e.g. "i lent the book
# to her with every fact about chemistry") or above it ("i lent a book to her
# from each student").
# In this case, the universal quantifiers are also moved into f'.
# e.g. "i lent the book to Kim with all the information she needs", "Kim lent a book to Ed that contained all the information he needed"
#VP_R -> VP_R N_ADJUNCT:try_remove_correlated,try_remove_correlator,try_remove_aux

# for gapping and stripping
# VP_R {... & (~)?[y1]:(U(i1,y1) & empty_ref(j1,y1) & f(y1)) & ... & (~)?[yn]:(U(in,yn) & empty_ref(jn,yn) & f(yn))}
#  -> V_ADJUNCT {... & ?[y1]:(p1(y1) & f(y1)) & ... & ?[yn]:(pn(yn) & f(yn))}
# e.g. "Mary wants to run, and John, swim"
# TODO: What about gapping/stripping predicatives, such as "the cat is orange, and the dog, white"?
#VP_R -> V_ADJUNCT:try_remove_aux

# TODO: we could require that here are no additional right adjuncts in the head scope
VP_R -> VP_L:identity

# for correlated coordination
# NOTE: For the following rules, the coordination doesn't have to be at head
# scope, it can be the left-most coordination that is a descendant of the head
# scope as well, so long as there is no negation between the coordination and
# the root. However, we need some measure of "distance" between the
# coordination and the head scope to be a feature to decide between the rules
# at this nonterminal (e.g. "both" moves left much less often than "either").
# VP_R {A1 | ... | An} -> EITHER VP_R {A1 | ... | An}
# VP_R {... ?[y]:(... & arg2(y)=possibility(A1 | ... | An))} -> EITHER VP_R {... ?[y]:(... & arg2(y)=possibility(A1 | ... | An))}
#VP_R -> VP_R:require_not_correlated,add_either,add_correlated_by_either,require_disjunction # this transformation requires the coordination is at the head
#VP_R -> EITHER VP_R:require_not_correlated,add_correlated_by_either,require_disjunction # this transformation requires the coordination is a descendant of the head
# VP_R {A1 & A2} -> BOTH VP_R {A1 & A2}
# VP_R {... ?[y]:(... & arg2(y)=possibility(A1 & A2))} -> BOTH VP_R {... ?[y]:(... & arg2(y)=possibility(A1 & A2))}
#VP_R -> VP_R:require_not_correlated,add_both,add_correlated_by_both,require_binary_conjunction # this transformation requires the coordination is at the head
#VP_R -> VP_R:require_not_correlated,add_both,add_correlated_by_both,require_binary_conjunction_in_arg2_possibility # this transformation requires the coordination is at the head
#VP_R -> BOTH VP_R:require_not_correlated,add_correlated_by_both,require_binary_conjunction # this transformation requires the coordination is a descendant of the head
#VP_R -> BOTH VP_R:require_not_correlated,add_correlated_by_both,require_binary_conjunction_in_arg2_possibility # this transformation requires the coordination is a descendant of the head
# VP_R {~A1 & ... & ~An} -> NEITHER VP_R {A1 | ... | An}
# VP_R {... ?[y]:(... & arg2(y)=possibility(~A1 & ... & ~An))} -> NEITHER VP_R {... ?[y]:(... & arg2(y)=possibility(~A1 & ... & ~An))}
#VP_R -> VP_R:require_not_correlated,add_neither,add_correlated_by_neither,negated_conjunction_into_disjunction # this transformation requires the coordination is at the head
#VP_R -> NEITHER VP_R:require_not_correlated,add_correlated_by_neither,add_negative,negated_conjunction_into_disjunction # this transformation requires the coordination is a descendant of the head
#VP_R -> VP_R:require_not_correlated,add_neither,add_correlated_by_neither,negated_conjunction_into_disjunction_in_arg2_possibility # this transformation requires the coordination is at the head
#VP_R -> NEITHER VP_R:require_not_correlated,add_correlated_by_neither,add_negative,negated_conjunction_into_disjunction_in_arg2_possibility # this transformation requires the coordination is a descendant of the head

# NOTE: In the below rules, we require that none of the Ai are themselves
# coordinations with the coordinator (unless Ai is negated).
# VP_R {(~)A1 & ... & (~)An} -> VP_R {(~)A1} VP_COORDINATION {(~)A2 & ... & (~)An}
#VP_R -> VP_R:select_left_operand VP_COORDINATION:try_remove_correlator,add_and,remove_left_operand
#VP_R -> VP_R:select_left_operand VP_COORDINATION:try_remove_correlator,add_and,remove_left_operand,add_comma
# VP_R {(~)A1 | ... | (~)An} -> VP_R {(~)A1} VP_COORDINATION {(~)A2 | ... | (~)An}
#VP_R -> VP_R:select_left_operand VP_COORDINATION:try_remove_correlator,add_or,remove_left_operand
#VP_R -> VP_R:select_left_operand VP_COORDINATION:try_remove_correlator,add_or,remove_left_operand,add_comma
# VP_R {(~)A1 | ... | (~)An} -> VP_R {(~)A1} VP_COORDINATION {(~)A2 | ... | (~)An}
#VP_R -> VP_R:select_left_operand VP_COORDINATION:try_remove_correlator,add_nor,require_negative,remove_left_operand
#VP_R -> VP_R:select_left_operand VP_COORDINATION:try_remove_correlator,add_nor,require_negative,remove_left_operand,add_comma

# VP_R {but((~)A1,(~)A2)} -> VP_R {(~)A1} (COMMA) BUT VP_R {(~)A2}
#VP_R -> VP_R:select_left_in_but BUT VP_R:try_remove_correlator,select_right_in_but
#VP_R -> VP_R:select_left_in_but COMMA BUT VP_R:try_remove_correlator,select_right_in_but

# VP_R {instead_of((~)A1,(~)A2)} -> VP_R {(~)A1} (COMMA) NOT VP_R {(~)A2}
#VP_R -> VP_R:select_left_in_instead_of NOT VP_R:try_remove_correlator,add_negative,select_right_in_instead_of
#VP_R -> VP_R:select_left_in_instead_of COMMA NOT VP_R:try_remove_correlator,add_negative,select_right_in_instead_of


VP_COORDINATION nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# VP_COORDINATION {(~)A1 & ... & (~)An} -> (COMMA) VP_R {(~)A1} VP_COORDINATION {(~)A2 & ... & (~)An}
# VP_COORDINATION {(~)A1 | ... | (~)An} -> (COMMA) VP_R {(~)A1} VP_COORDINATION {(~)A2 | ... | (~)An}
#VP_COORDINATION -> COMMA:require_comma VP_R:remove_coordinator,remove_comma,select_left_operand VP_COORDINATION:remove_left_operand
# VP_COORDINATION {(~)A1} -> (COMMA) VP_R {(~)A1}
#VP_COORDINATION -> COMMA:require_comma VP_R:remove_coordinator,remove_comma

# VP_COORDINATION {(~)A1 & ... & (~)An} -> (COMMA) AND VP_R {(~)A1} VP_COORDINATION {(~)A2 & ... & (~)An}
#VP_COORDINATION -> AND:require_and VP_R:remove_coordinator,remove_comma,select_left_operand VP_COORDINATION:remove_left_operand
#VP_COORDINATION -> COMMA:require_comma AND:require_and VP_R:remove_coordinator,remove_comma,select_left_operand VP_COORDINATION:remove_left_operand
# VP_COORDINATION {(~)A1} -> (COMMA) AND VP_R {(~)A1}
#VP_COORDINATION -> AND:require_and VP_R:remove_coordinator,remove_comma
#VP_COORDINATION -> COMMA:require_comma AND:require_and VP_R:remove_coordinator,remove_comma

# VP_COORDINATION {(~)A1 & ... & (~)An} -> (COMMA) OR VP_R {(~)A1} VP_COORDINATION {(~)A2 & ... & (~)An}
#VP_COORDINATION -> OR:require_or VP_R:remove_coordinator,remove_comma,select_left_operand VP_COORDINATION:remove_left_operand
#VP_COORDINATION -> COMMA:require_comma OR:require_or VP_R:remove_coordinator,remove_comma,select_left_operand VP_COORDINATION:remove_left_operand
# VP_COORDINATION {(~)A1} -> (COMMA) OR VP_R {(~)A1}
#VP_COORDINATION -> OR:require_or VP_R:remove_coordinator,remove_comma
#VP_COORDINATION -> COMMA:require_comma OR:require_or VP_R:remove_coordinator,remove_comma

# VP_COORDINATION {(~)A1 | ... | (~)An} -> (COMMA) NOR VP_R {(~)A1} VP_COORDINATION {(~)A2 | ... | (~)An}
#VP_COORDINATION -> NOR:require_nor VP_R:add_req_aux,remove_coordinator,remove_comma,add_negative,select_left_operand VP_COORDINATION:remove_left_operand
#VP_COORDINATION -> COMMA:require_comma NOR:require_nor VP_R:add_req_aux,remove_coordinator,remove_comma,add_negative,select_left_operand VP_COORDINATION:remove_left_operand
# VP_COORDINATION {(~)A1} -> (COMMA) NOR VP_R {(~)A1}
#VP_COORDINATION -> NOR:require_nor VP_R:add_req_aux,remove_coordinator,remove_comma,add_negative
#VP_COORDINATION -> COMMA:require_comma NOR:require_nor VP_R:add_req_aux,remove_coordinator,remove_comma,add_negative


V_ADJUNCT nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# V_ADJUNCT {... & ?[y1]:(... & f(y1)) & ... & ?[yn]:(... & f(yn))}
#  -> ADJP_R/PP {... & f'}
# where f(y) = (~)?[z]:(h(z) & arg1/arg2(z)=y) and f' = (~)?[z]:h(z)
#    or f(y) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=y) & ... & (~)?[zn]:(hn(zn) & arg1/arg2(zn)=y) and f' = (~)?[z1]:h1(z1) & ... & (~)?[zn]:hn(zn)
#    or f(y) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=y) | ... | (~)?[zn]:(hn(zn) & arg1/arg2(zn)=y) and f' = (~)?[z1]:h1(z1) | ... | (~)?[zn]:hn(zn)
# Note that f(y) may also contain variables which are universally-quantified,
# above the scope of zi, either within the scope of yi (e.g. "it flew faster
# than every bird") or above it ("i have been to every restaurant"). In this
# case, the universal quantifiers are also moved into f'.
# NOTE: This rule also works if the yi's are ORed.
#
# An example of a sentence with coordination in both the verb and adverb is:
#  "she walked and sat under every tree and near every rock"
#V_ADJUNCT -> PP:add_is_adjunct,select_right_arg1_of_without_head # for arg1
#V_ADJUNCT -> ADJP_R:add_is_adjunct,require_no_preposition,select_right_arg1_of_without_head # for arg1
#V_ADJUNCT -> COMMA PP:require_no_preposition,try_remove_correlator,select_right_arg1_of_without_head # for arg1
#V_ADJUNCT -> COMMA ADJP_R:require_no_preposition,try_remove_correlator,select_right_arg1_of_without_head # for arg1
#V_ADJUNCT -> PP:add_is_adjunct,select_right_arg2_of_without_head # for arg2
#V_ADJUNCT -> ADJP_R:add_is_adjunct,require_no_preposition,select_right_arg2_of_without_head # for arg2
#V_ADJUNCT -> COMMA PP:require_no_preposition,try_remove_correlator,select_right_arg2_of_without_head # for arg2
#V_ADJUNCT -> COMMA ADJP_R:require_no_preposition,try_remove_correlator,select_right_arg2_of_without_head # for arg2

# predicative complements
# V_ADJUNCT {A} -> PP/ADJP_R/ADVP_R {A}
# e.g. "Sirius is brighter than Vega", "the cat is in the house"
V_ADJUNCT -> PP:add_is_adjunct,require_no_preposition
V_ADJUNCT -> ADJP_R:add_is_adjunct,require_no_preposition
V_ADJUNCT -> ADVP_R:add_is_adjunct,require_no_preposition

# for prepositional verbs (i.e. "look forward to", etc)
# V_ADJUNCT {... & ?[y]:(U(i,y) & p(y) & f(y))}
#  -> PP {... & ?[y]:(U(i,y) & p(y) & f(y))}
# where `p` is the predicate, `fi` contains verb-specific terms such as
# `present` as well as any adjuncts of y whereas `f` contains everything else,
# such as the arguments.
V_ADJUNCT -> PP:add_is_adjunct

# V_ADJUNCT {... & ?[y1]:(inverse(own)(y1) & arg2(y1)=a) & ... & ?[yn]:(inverse(own)(yn) & arg2(yn)=a)}
#  -> NP {^[P]:?[X]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x)))}
# V_ADJUNCT {... & (~)?[x]:(f(x) & ?[y1]:(inverse(own)(y1) & arg2(y1)=x) & ... & ?[yn]:(inverse(own)(yn) & arg2(yn)=x))} if x is not a set variable
#  -> NP {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)?[x]:(X(x) & P(x))))}
# V_ADJUNCT {... & (~)![x]:(f(x) => ?[y1]:(inverse(own)(y1) & arg2(y1)=x) & ... & ?[yn]:(inverse(own)(yn) & arg2(yn)=x))}
#  -> NP {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)![x]:(X(x) => P(x))))}
# V_ADJUNCT {... & ?[X]:(f(X) & (~)![x]:(X(x) => ?[y1]:(inverse(own)(y1) & arg2(y1)=x) & ... & ?[yn]:(inverse(own)(yn) & arg2(yn)=x)))}
#  -> NP {^[P]:(... & ?[X]:(f(X) & (~)![x]:(X(x) => P(x))))}
# V_ADJUNCT {... & ?[X]:(f(X) & ?[y1]:(inverse(own)(y1) & arg2(y1)=X) & ... & ?[yn]:(inverse(own)(yn) & arg2(yn)=X))} if X is a set variable
#  -> NP {^[P]:(... & ?[X]:(f(X) & ![x]:(X(x) => P(x))))}
# e.g. "the pencil is Emma's", "the pencils are the students'"
#V_ADJUNCT -> NP:require_no_preposition,add_genitive,require_left_predicate_inverse_own,select_right_arg2_without_head_predicative_and_factor,add_singular
#V_ADJUNCT -> NP:require_no_preposition,add_genitive,require_left_predicate_inverse_own,select_right_arg2_without_head_predicative_and_factor,add_plural

# V_ADJUNCT {... & ?[y1]:(... & arg1/arg2/arg3(y1)=a) & ... & ?[yn]:(... & arg1/arg2/arg3(yn)=a)}
#  -> NP/ADJP_R {^[P]:?[X]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x)))}
# V_ADJUNCT {... & (~)?[x]:(f(x) & ?[y1]:(... & arg1/arg2/arg3(y1)=x) & ... & ?[yn]:(... & arg1/arg2/arg3(yn)=x))} if x is not a set variable
#  -> NP/ADJP_R {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)?[x]:(X(x) & P(x))))}
# V_ADJUNCT {... & (~)![x]:(f(x) => ?[y1]:(... & arg1/arg2/arg3(y1)=x) & ... & ?[yn]:(... & arg1/arg2/arg3(yn)=x))}
#  -> NP/ADJP_R {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)![x]:(X(x) => P(x))))}
# V_ADJUNCT {... & ?[X]:(f(X) & (~)![x]:(X(x) => ?[y1]:(... & arg1/arg2/arg3(y1)=x) & ... & ?[yn]:(... & arg1/arg2/arg3(yn)=x)))}
#  -> NP/ADJP_R {^[P]:(... & ?[X]:(f(X) & (~)![x]:(X(x) => P(x))))}
# V_ADJUNCT {... & ?[X]:(f(X) & ?[y1]:(... & arg1/arg2/arg3(y1)=X) & ... & ?[yn]:(... & arg1/arg2/arg3(yn)=X))} if X is a set variable
#  -> NP/ADJP_R {^[P]:(... & ?[X]:(f(X) & ![x]:(X(x) => P(x))))}
# e.g. "it is not a cat nor is it a dog"
# NOTE: The above rules, during the inverse transformation, the scope of X and
# x can be positioned anywhere above the scope of y. However, to avoid
# producing semantically-equivalent logical forms, for each equivalence class
# of semantically-equivalent inverse logical forms, we only output a single
# logical form (for example, by choosing the logical form in the equivalence
# class in which the scope of X and x are maximal). Also, the above rule can be
# extended to other kinds of quantification over X, such as existential or weak
# universal quantifier. Also, note that f(X) and f(x) cannot depend on any
# variables other than those declared within f(X) and f(x). But note that in
# the example "a cat and dog are sleeping", f(X) includes the definition for
# "cat" and "dog". In the above three rules, the scope of y is the right-most
# and top-most scope of an event variable (a object with arguments).
# NOTE: This rule also handles open interrogatives but only when the unknown
# variable is in the logical form for the NP. In the logical forms of some
# interrogatives, X may be declared as a lambda variable.
# NOTE: The `arg2` version of the rule is for preposing.
# NOTE: In comparative constructions where sizes of sets are compared, this
# requires that the quantified variables are used in the same way in both
# consequents. That is, in:
#   ?[X]:(... & ?[R]:(f(size(X),size(R)) & ... & ![r]:(R(r) => ?[y]:(arg1/arg2/arg3(y)=r & ...))) & ... & ![x]:(X(x) => ?[y]:(arg1/arg2/arg3(y)=x & ...)))
# This rule requires that `arg1(y)=r` and `arg1(y)=x` appear in both
# consequents (or `arg2(y)=r` and `arg2(y)=x`, etc).
# NOTE: The ADJP_R transformations don't have `^[P]`.
V_ADJUNCT -> NP:require_no_preposition,require_no_inverse,try_remove_req_aux,select_right_arg1_without_head_predicative_and_factor # for arg1
V_ADJUNCT -> NP:require_no_preposition,require_no_inverse,select_right_arg2_without_head_predicative_and_factor # for arg2
V_ADJUNCT -> NP:require_no_preposition,require_no_inverse,select_right_arg3_without_head_predicative_and_factor # for arg3 (NOTE: we could make this semantic and have only two args)
#V_ADJUNCT -> ADJP_R:add_is_adjunct,require_no_preposition,require_no_inverse,try_remove_req_aux,select_right_arg1_without_head_and_factor # for arg1
#V_ADJUNCT -> ADJP_R:add_is_adjunct,require_no_preposition,require_no_inverse,select_right_arg2_without_head_and_factor # for arg2
#V_ADJUNCT -> ADJP_R:add_is_adjunct,require_no_preposition,require_no_inverse,select_right_arg3_without_head_and_factor # for arg3 (NOTE: we could make this semantic and have only two args)
#V_ADJUNCT -> BY NP:require_no_preposition,require_left_predicate_inverse,try_remove_correlated,select_right_arg2_without_head_predicative_and_factor # for arg2
#V_ADJUNCT -> BY NP:require_no_preposition,require_left_predicate_inverse,try_remove_correlated,select_right_arg3_without_head_predicative_and_factor # for arg3 (NOTE: we could make this semantic and have only two args)

# V_ADJUNCT {... & ?[y1]:(... & f(y1)) & ... & ?[yn]:(... & f(yn))}
#  -> (COMMA) (THAT) S' {... & f'}
# where f(y) = (~)?[z]:(h(z) & arg1/arg2(y)=z) and f' = (~)?[z]:h(z)
#    or f(y) = arg1/arg2(y)=possibility(A) and f' = A
# V_ADJUNCT {... & ?[X]:(X=^[x]:(x=z1 | ... | x=zm) & ![x]:(X(x) => ?[y1]:(... & arg1/arg2(y1)=x) & ... & ?[yn]:(... & arg1/arg2(yn)=x)))}
#  -> (COMMA) (THAT) S' {... & (?[z1]:(...) & ... & ?[zm]:(...))}
# V_ADJUNCT {... & ?[X]:(X=^[x]:(x=z1 | ... | x=zm) & ?[x]:(X(x) & ?[y1]:(... & arg1/arg2(y1)=x) & ... & ?[yn]:(... & arg1/arg2(yn)=x)))}
#  -> (COMMA) (THAT) S' {... & (?[z1]:(...) | ... | ?[zm]:(...))}
# where f(y) = (~)?[z]:(h(z) & arg1/arg2(y)=z) and f' = (~)?[z]:h(z)
#    or f(y) = ?[p]:(U(i,p) & purpose(p) & arg1(p)=y & arg2(p)=possibility(A)) and f' = A (for purpose constructions with to-infinitival clauses)
# NOTE: z could also be universally quantified above the scope of yi
# NOTE: The arg1 version is for postposing/it-cleft constructions such as "it
# didn't worry him that she was early".
# e.g. "he wants to fly"
#V_ADJUNCT -> S':add_is_adjunct,require_no_preposition,add_to_infinitive,add_nullable_subject,select_right_arg1_possibility_and_factor
# e.g. "he wants for Jason to fly"
#V_ADJUNCT -> S':add_is_adjunct,require_no_preposition,add_to_infinitive,add_for,select_right_arg1_possibility_and_factor
# e.g. "i bought it to give to Martha"
#V_ADJUNCT -> S':add_is_adjunct,require_no_preposition,add_to_infinitive,add_for,select_right_arg1_without_head,require_left_predicate_purpose,select_right_arg2_possibility_and_factor # for `purpose` predicates
# e.g. "he insists she be here", "he insists that she be here"
#V_ADJUNCT -> S':add_is_adjunct,require_no_preposition,add_subjunctive,add_nullable_subject,select_right_arg1_possibility_and_factor
#V_ADJUNCT -> COMMA S':require_no_preposition,add_subjunctive,add_nullable_subject,try_remove_correlator,select_right_arg1_possibility_and_factor
#V_ADJUNCT -> S':add_is_adjunct,require_no_preposition,add_subjunctive,add_nullable_subject,select_right_arg1_possibility_and_factor,add_that
# e.g. "i think Emma returned the books yesterday", "i think that Emma returned the books yesterday"
#V_ADJUNCT -> S':add_is_adjunct,require_no_preposition,select_right_arg1_possibility_and_factor # TODO: remove grammatical features from S'
#V_ADJUNCT -> S':add_is_adjunct,require_no_preposition,select_right_arg1_possibility_and_factor,add_that # TODO: remove grammatical features from S'
# e.g. "he didn't like it that the barn was destroyed"
#V_ADJUNCT -> IT S':require_no_preposition,add_that,select_right_arg1_without_head # TODO: remove grammatical features from S'
# e.g. "we must stop him coming back tomorrow"
# NOTE: The following rule requires a subject to avoid spurious ambiguity with
# gerund noun phrases (i.e. "i opposed destroying the barn").
#V_ADJUNCT -> S':add_is_adjunct,require_no_preposition,add_present_participle,select_right_arg1_without_head,require_arg1 # TODO: remove grammatical features from S'

# V_ADJUNCT {... & ?[y1]:(... & ?[r]:(arg1(r)=y1 & reason(r) & ?[z]:(h(z) & arg2(r)=z))) & ... & ?[yn]:(... & ?[r]:(arg1(r)=yn & reason(r) & ?[z]:(h(z) & arg2(r)=z)))}
#  -> (COMMA) BECAUSE/FOR S' {?[z]:h(z)}
#V_ADJUNCT -> COMMA S':add_because,try_remove_correlator,select_right_arg1_without_head,require_left_predicate_reason,select_right_arg2_possibility_and_factor
#V_ADJUNCT -> S':add_is_adjunct,add_because,select_right_arg1_without_head,require_left_predicate_reason,select_right_arg2_possibility_and_factor
#V_ADJUNCT -> COMMA FOR S':try_remove_correlated,try_remove_correlator,select_right_arg1_without_head,require_left_predicate_reason,select_right_arg2_possibility_and_factor
#V_ADJUNCT -> FOR S':try_remove_correlated,select_right_arg1_without_head,require_left_predicate_reason,select_right_arg2_possibility_and_factor

# (non-conditional) closed interrogative finite subordinate clause
# V_ADJUNCT {... & ?[y1]:(... & f(y1)) & ... & ?[yn]:(... & f(yn))}
#  -> (COMMA) IF/WHETHER S' {... & f'} (COMMA)
# where f(y) = arg2(y)=^[x]:A and f' = ^[x]:A
#V_ADJUNCT -> S':add_is_adjunct,require_no_preposition,add_req_no_aux,select_right_arg2_without_head_and_factor,require_lambda,add_whether
#V_ADJUNCT -> S':add_is_adjunct,require_no_preposition,add_req_no_aux,select_right_arg2_without_head_and_factor,require_lambda,add_if
#V_ADJUNCT -> COMMA S':require_no_preposition,add_req_no_aux,select_right_arg2_without_head_and_factor,require_lambda,add_whether,try_remove_correlator COMMA
#V_ADJUNCT -> COMMA S':require_no_preposition,add_req_no_aux,select_right_arg2_without_head_and_factor,require_lambda,add_if,try_remove_correlator COMMA
#V_ADJUNCT -> S':add_is_adjunct,require_no_preposition,add_req_no_aux,select_right_arg2_without_head_and_factor,require_lambda,add_whether,add_subjunctive
#V_ADJUNCT -> S':add_is_adjunct,require_no_preposition,add_req_no_aux,select_right_arg2_without_head_and_factor,require_lambda,add_if,add_subjunctive
#V_ADJUNCT -> COMMA S':require_no_preposition,add_req_no_aux,select_right_arg2_without_head_and_factor,require_lambda,add_whether,add_subjunctive,try_remove_correlator COMMA
#V_ADJUNCT -> COMMA S':require_no_preposition,add_req_no_aux,select_right_arg2_without_head_and_factor,require_lambda,add_if,add_subjunctive,try_remove_correlator COMMA

# open interrogative finite subordinate clause
# V_ADJUNCT {... & ?[y1]:(U(i1,y1) & p(y1) & f(y1)) & ... & ?[yn]:(U(in,yn) & p(yn) & f(yn))}
#  -> S' {... & f'}
# where f(y) = arg1/arg2(y)=^[x]:A and f' = ^[x]:A
# NOTE: The `arg1` form is for subject-auxiliary inversion.
#V_ADJUNCT -> S':add_is_adjunct,require_no_preposition,add_req_no_aux,add_subordinate,select_right_arg1_without_head_and_factor
#V_ADJUNCT -> S':add_is_adjunct,require_no_preposition,add_req_no_aux,add_subordinate,select_right_arg2_without_head_and_factor

# comparative constructions
# V_ADJUNCT {... & ?[r]:(?[g1]:(U(i1,g1) & p(f1)(g1) & arg2(g1)=r) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & arg2(gn)=r) & ... & ?[y]:(p(y) & h(r)))}
#  -> COMP {p}
#     V_ADJUNCT {h'}
# V_ADJUNCT {... & ?[R]:(... & f(size(R)) & ... & ![r]:(R(r) => ?[g1]:(U(i1,g1) & p(f1)(g1) & arg2(g1)=r) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & arg2(gn)=r)) & ... & ?[y]:(p(y) & R=^[r]:h(r)))}
#  -> COMP {p} (or `f`, whichever comes last)
#     V_ADJUNCT {h'}
# V_ADJUNCT {... & ?[R]:(?[R1]:(... & f(size(R1)) & ... & ![r]:(R(r) => ?[g1]:(U(i1,g1) & p(f1)(g1) & arg2(g1)=r) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & arg2(gn)=r)) & ... & ?[R2]:(... & f(size(R2)) & ... & R=^[S]:(S=R1 | ... | S=Rn))) & ... & ?[y]:(p(y) & ![Ri]:(R(Ri) => Ri=^[r]:h(r))))}
#  -> COMP {p} (or `f`, whichever comes last)
#     V_ADJUNCT {h'}
# where h(r) = r=a and h' = ?[gn]:(arg2(gn)=a)
#    or h(r) = U(i,r) & p(r) & ?[x]:(arg1/arg2(x)=r & ...) and h' = ?[gn]:?[r]:(U(i,r) & p(r) & ?[x]:(arg1/arg2(x)=r & ...)) (TODO: what is this? where is it even used?)
#    or h(r) = ?[x]:(arg1/arg2(x)=r & ...) and h' = ?[x]:(...)
# NOTE: The predicate could also be a simple `p` rather than `p(f)`. The terms
# `f(size(X),size(R))` and `?[gi]:(...)` are optional (but there must be at
# least one). The term `f(size(X),size(R))` handles comparative constructions
# where sizes of sets are compared.
# e.g. "you can see a brighter star with the telescope than without it", "i saw more people at the party than last time", "there were more girls but fewer boys at the event than last time"
#V_ADJUNCT -> COMP:comparator_predicate V_ADJUNCT:try_remove_correlated,select_comparator_arg

# comparative constructions
# V_ADJUNCT {... & ?[r]:(?[g]:(U(i,g) & p(f)(g) & arg2(g)=r) & ... & ?[y]:(p(y) & h(r)))}
#  -> COMP {p}
#     V_ADJUNCT {h'}
# V_ADJUNCT {... & ?[R]:(f(size(R)) & ... & ![r]:(R(r) => ?[g]:(U(i,g) & p(f)(g) & arg2(g)=r)) & ... & ?[y]:(p(y) & R=^[r]:h(r)))}
#     COMP {p}
#     V_ADJUNCT {h'}
# where h(r) = r=a and h' = ?[g]:(arg2(g)=a)
#    or h(r) = U(i,r) & p(r) & ?[x]:(arg1/arg2(x)=r & ...) and h' = ?[g]:?[r]:(U(i,r) & p(r) & ?[x]:(arg1/arg2(x)=r & ...)) (TODO: what is this? where is it even used?)
#    or h(r) = ?[x]:(arg1/arg2(x)=r & ...) and h' = ?[x]:(...)
# NOTE: The predicate could also be a simple `p` rather than `p(f)`. The terms
# `f(size(R))` and `?[gi]:(...)` are optional (but there must be at least one).
# The term `f(size(R))` handles comparative constructions where sizes of sets
# are compared.
# e.g. "a brighter star could be seen with the telescope than without it", "more people came than last time", "more girls but fewer boys came to the event than last time"
#V_ADJUNCT -> COMP:comparator_predicate V_ADJUNCT:try_remove_correlated,select_comparator_arg

# for correlated coordination
# NOTE: For the following rules, the coordination doesn't have to be at head
# scope, it can be the left-most coordination that is a descendant of the head
# scope as well, so long as there is no negation between the coordination and
# the root. However, we need some measure of "distance" between the
# coordination and the head scope to be a feature to decide between the rules
# at this nonterminal (e.g. "both" moves left much less often than "either").
# V_ADJUNCT {A1 | ... | An} -> EITHER V_ADJUNCT {A1 | ... | An}
#V_ADJUNCT -> V_ADJUNCT:require_not_correlated,add_either,add_correlated_by_either,require_disjunction # this transformation requires the coordination is at the head
#V_ADJUNCT -> EITHER V_ADJUNCT:require_not_correlated,add_correlated_by_either,require_disjunction # this transformation requires the coordination is a descendant of the head
# V_ADJUNCT {A1 & A2} -> BOTH V_ADJUNCT {A1 & A2}
#V_ADJUNCT -> V_ADJUNCT:require_not_correlated,add_both,add_correlated_by_both,require_binary_conjunction # this transformation requires the coordination is at the head
#V_ADJUNCT -> BOTH V_ADJUNCT:require_not_correlated,add_correlated_by_both,require_binary_conjunction # this transformation requires the coordination is a descendant of the head
# V_ADJUNCT {~A1 | ... | ~An} -> NEITHER V_ADJUNCT {A1 | ... | An}
#V_ADJUNCT -> V_ADJUNCT:require_not_correlated,add_neither,add_correlated_by_neither,negated_disjunction_into_disjunction # this transformation requires the coordination is at the head
#V_ADJUNCT -> NEITHER V_ADJUNCT:require_not_correlated,add_correlated_by_neither,add_negative,negated_disjunction_into_disjunction # this transformation requires the coordination is a descendant of the head

# NOTE: In the below rules, we require that none of the Ai are themselves
# coordinations with the coordinator (unless Ai is negated).
# V_ADJUNCT {(~)A1 & ... & (~)An} -> V_ADJUNCT {(~)A1} V_ADJUNCT_COORDINATION {(~)A2 & ... & (~)An}
#V_ADJUNCT -> V_ADJUNCT:select_left_operand V_ADJUNCT_COORDINATION:remove_left_operand,try_remove_correlator,add_and
#V_ADJUNCT -> V_ADJUNCT:select_left_operand V_ADJUNCT_COORDINATION:remove_left_operand,try_remove_correlator,add_and,add_comma
# V_ADJUNCT {(~)A1 | ... | (~)An} -> V_ADJUNCT {(~)A1} V_ADJUNCT_COORDINATION {(~)A2 | ... | (~)An}
#V_ADJUNCT -> V_ADJUNCT:select_left_operand V_ADJUNCT_COORDINATION:remove_left_operand,try_remove_correlator,add_or
#V_ADJUNCT -> V_ADJUNCT:select_left_operand V_ADJUNCT_COORDINATION:remove_left_operand,try_remove_correlator,add_or,add_comma
# V_ADJUNCT {(~)A1 | ... | (~)An} -> V_ADJUNCT {(~)A1} VP_COORDINATION {(~)A2 | ... | (~)An}
#V_ADJUNCT -> V_ADJUNCT:select_left_operand VP_COORDINATION:remove_left_operand,try_remove_correlator,add_nor,require_negative
#V_ADJUNCT -> V_ADJUNCT:select_left_operand VP_COORDINATION:remove_left_operand,try_remove_correlator,add_nor,require_negative,add_comma

# V_ADJUNCT {but((~)A1,(~)A2)} -> V_ADJUNCT {(~)A1} (COMMA) BUT V_ADJUNCT {(~)A2}
#V_ADJUNCT -> V_ADJUNCT:select_left_in_but BUT V_ADJUNCT:select_right_in_but,try_remove_correlator
#V_ADJUNCT -> V_ADJUNCT:select_left_in_but COMMA BUT V_ADJUNCT:select_right_in_but,try_remove_correlator

# V_ADJUNCT {instead_of((~)A1,(~)A2)} -> V_ADJUNCT {(~)A1} (COMMA) NOT V_ADJUNCT {(~)A2}
#V_ADJUNCT -> V_ADJUNCT:select_left_in_instead_of NOT V_ADJUNCT:select_right_in_instead_of,try_remove_correlator,add_negative
#V_ADJUNCT -> V_ADJUNCT:select_left_in_instead_of COMMA NOT V_ADJUNCT:select_right_in_instead_of,try_remove_correlator,add_negative


V_ADJUNCT_COORDINATION nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# V_ADJUNCT_COORDINATION {(~)A1 & ... & (~)An} -> (COMMA) V_ADJUNCT {(~)A1} V_ADJUNCT_COORDINATION {(~)A2 & ... & (~)An}
# V_ADJUNCT_COORDINATION {(~)A1 | ... | (~)An} -> (COMMA) V_ADJUNCT {(~)A1} V_ADJUNCT_COORDINATION {(~)A2 | ... | (~)An}
#V_ADJUNCT_COORDINATION -> COMMA:require_comma V_ADJUNCT:remove_coordinator,remove_comma,select_left_operand V_ADJUNCT_COORDINATION:remove_left_operand
# V_ADJUNCT_COORDINATION {(~)A1} -> (COMMA) V_ADJUNCT {(~)A1}
#V_ADJUNCT_COORDINATION -> COMMA:require_comma V_ADJUNCT:remove_coordinator,remove_comma

# V_ADJUNCT_COORDINATION {(~)A1 & ... & (~)An} -> (COMMA) AND V_ADJUNCT {(~)A1} V_ADJUNCT_COORDINATION {(~)A2 & ... & (~)An}
#V_ADJUNCT_COORDINATION -> AND:require_and V_ADJUNCT:remove_coordinator,remove_comma,select_left_operand V_ADJUNCT_COORDINATION:remove_left_operand
#V_ADJUNCT_COORDINATION -> COMMA:require_comma AND:require_and V_ADJUNCT:remove_coordinator,remove_comma,select_left_operand V_ADJUNCT_COORDINATION:remove_left_operand
# V_ADJUNCT_COORDINATION {(~)A1} -> (COMMA) AND V_ADJUNCT {(~)A1}
#V_ADJUNCT_COORDINATION -> AND:require_and V_ADJUNCT:remove_coordinator,remove_comma
#V_ADJUNCT_COORDINATION -> COMMA:require_comma AND:require_and V_ADJUNCT:remove_coordinator,remove_comma

# V_ADJUNCT_COORDINATION {(~)A1 & ... & (~)An} -> (COMMA) OR V_ADJUNCT {(~)A1} V_ADJUNCT_COORDINATION {(~)A2 & ... & (~)An}
#V_ADJUNCT_COORDINATION -> OR:require_or V_ADJUNCT:remove_coordinator,remove_comma,select_left_operand V_ADJUNCT_COORDINATION:remove_left_operand
#V_ADJUNCT_COORDINATION -> COMMA:require_comma OR:require_or V_ADJUNCT:remove_coordinator,remove_comma,select_left_operand V_ADJUNCT_COORDINATION:remove_left_operand
# V_ADJUNCT_COORDINATION {(~)A1} -> (COMMA) OR V_ADJUNCT {(~)A1}
#V_ADJUNCT_COORDINATION -> OR:require_or V_ADJUNCT:remove_coordinator,remove_comma
#V_ADJUNCT_COORDINATION -> COMMA:require_comma OR:require_or V_ADJUNCT:remove_coordinator,remove_comma

# V_ADJUNCT_COORDINATION {(~)A1 | ... | (~)An} -> (COMMA) NOR V_ADJUNCT {(~)A1} V_ADJUNCT_COORDINATION {(~)A2 | ... | (~)An}
#V_ADJUNCT_COORDINATION -> NOR:require_nor V_ADJUNCT:add_req_aux,remove_coordinator,remove_comma,add_negative,select_left_operand V_ADJUNCT_COORDINATION:remove_left_operand
#V_ADJUNCT_COORDINATION -> COMMA:require_comma NOR:require_nor V_ADJUNCT:add_req_aux,remove_coordinator,remove_comma,add_negative,select_left_operand V_ADJUNCT_COORDINATION:remove_left_operand
# V_ADJUNCT_COORDINATION {(~)A1} -> (COMMA) NOR V_ADJUNCT {(~)A1}
#V_ADJUNCT_COORDINATION -> NOR:require_nor V_ADJUNCT:add_req_aux,remove_coordinator,remove_comma,add_negative
#V_ADJUNCT_COORDINATION -> COMMA:require_comma NOR:require_nor V_ADJUNCT:add_req_aux,remove_coordinator,remove_comma,add_negative


VP_L nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# VP_L {... & (~)?[y1]:(f(y1) & g1(y1)) & ... & (~)?[yn]:(f(yn) & gn(yn))}
#  -> (COMMA) ADVP_R/PP {... & f'}
#     (COMMA) VP_L {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
# where f(y) = (~)?[z]:(h(z) & arg1/arg2(z)=y) and f' = (~)?[z]:h(z)
#    or f(y) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=y) & ... & (~)?[zn]:(hn(zn) & arg1/arg2(zn)=y) and f' = (~)?[z1]:h1(z1) & ... & (~)?[zn]:hn(zn)
#    or f(y) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=y) | ... | (~)?[zn]:(hn(zn) & arg1/arg2(zn)=y) and f' = (~)?[z1]:h1(z1) | ... | (~)?[zn]:hn(zn)
# Note that f(y) may also contain variables which are universally-quantified,
# above the scope of zi, either within the scope of yi (e.g. "it flew faster
# than every bird") or above it ("i have been at every restaurant"). In this
# case, the universal quantifiers are also moved into f'.
#
# An example of a sentence with coordination in both the verb and adverb is:
#  "she walked and sat under every tree and near every rock"
#VP_L -> ADVP_L:try_remove_correlator,select_left_arg1_of_without_head VP_L:require_no_req_aux,try_remove_correlated,remove_left_conjunct
#VP_L -> COMMA PP:require_no_req_aux,require_no_correlator,select_left_arg1_of_without_head COMMA VP_L:try_remove_correlated,remove_left_conjunct
#VP_L -> ADVP_L:try_remove_correlator,select_left_arg2_of_without_head VP_L:require_no_req_aux,try_remove_correlated,remove_left_conjunct
#VP_L -> COMMA PP:require_no_req_aux,require_no_correlator,select_left_arg2_of_without_head COMMA VP_L:try_remove_correlated,remove_left_conjunct

VP_L -> WILL VP_R:try_remove_correlated,remove_future,add_infinitive,add_aux,require_no_subjunctive # future "tense"
VP_L -> HAVE:identity VP_R:try_remove_correlated,require_no_future,remove_perfect,add_past_participle,add_aux,require_no_subjunctive # perfect aspect
VP_L -> BE:identity VP_R:try_remove_correlated,require_no_future,require_no_perfect,remove_progressive,add_present_participle,add_aux # progressive aspect
VP_L -> DO:identity VP_R:try_remove_correlated,require_no_future,require_no_perfect,require_no_progressive,add_infinitive,add_aux,require_no_subjunctive # do-support
VP_L -> NOT VP_R:try_remove_correlated,require_aux_or_subjunctive_or_infinitive_or_to_infinitive,remove_not,try_remove_req_aux,add_negative
VP_L -> BE:identity VP_R:try_remove_correlated,require_no_future,require_no_perfect,require_no_progressive,remove_inverse,add_past_participle,add_aux # passive voice
VP_L -> GET:identity VP_R:try_remove_correlated,require_no_future,require_no_perfect,require_no_progressive,remove_inverse,add_past_participle,add_aux # passive voice
VP_L -> TO VP_R:try_remove_correlated,remove_to_infinitive,add_infinitive,require_no_future,require_no_req_aux
#VP_L -> MODAL:try_remove_correlator VP_R:try_remove_correlated,add_infinitive,try_remove_req_aux,require_no_subjunctive

# VP_L {?[x]:(U(0,x) & p(x))} -> V {p}
# NOTE: If subjunctive, and the resulting inflected verb has the same form as
# that without the subjunctive mood, this rule fails. This is to avoid spurious
# ambiguity where the verb can be interpreted as either being in the
# subjunctive mood or not (e.g. "it's vital that we keep them informed.").
VP_L -> V:require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,require_no_req_aux,require_no_empty_ref,require_no_to_infinitive,require_no_correlator,predicate_and_tense

# VP_L {?[x]:()} -> BE
# This is the semantically empty "be"/"is"/"was"/"were" as in "the cat is blue"
# and "the cat is in the tree".
# NOTE: If subjunctive, and the resulting inflected verb has the same form as
# that without the subjunctive mood, this rule fails. This is to avoid spurious
# ambiguity where the verb can be interpreted as either being in the
# subjunctive mood or not (e.g. "it's vital that we keep them informed.").
#VP_L -> BE:require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,require_no_req_aux,require_no_empty_ref,require_no_to_infinitive,require_no_correlator,require_empty_head

# for gapping and stripping
#VP_L -> WILL:remove_future,try_remove_req_aux,require_only_empty_ref,require_no_subjunctive,require_no_correlator # future "tense"
#VP_L -> HAVE:require_no_future,remove_perfect,try_remove_req_aux,require_only_empty_ref,require_no_subjunctive,require_no_correlator # perfect aspect
#VP_L -> BE:require_no_future,require_no_perfect,remove_progressive,try_remove_req_aux,require_only_empty_ref,require_no_correlator # progressive aspect
#VP_L -> DO:require_no_future,require_no_perfect,require_no_progressive,try_remove_req_aux,require_only_empty_ref,require_no_subjunctive,require_no_correlator # do-support
#VP_L -> NOT:require_aux_or_subjunctive_or_infinitive_or_to_infinitive,remove_not,try_remove_req_aux,require_only_empty_ref,require_no_correlator
#VP_L -> BE:require_no_future,require_no_perfect,require_no_progressive,remove_inverse,try_remove_req_aux,require_no_correlator # passive voice,require_only_empty_ref
#VP_L -> MODAL:try_remove_req_aux,require_empty_ref,require_no_subjunctive,require_no_correlator

# VP_L {... & (~)?[y1]:(f(y1) & g1(y1)) & ... & (~)?[yn]:(f(yn) & gn(yn))}
#  -> V_ADJUNCT {... & ?[y1]:(p1(y1) & f(y1)) & ... & ?[yn]:(pn(yn) & f(yn))}
#     VP_L {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
# where `f` contains the `arg1` term.
# e.g. "it is not a cat nor will it be a cat", "what did they do?"
#VP_L -> V_ADJUNCT:try_remove_correlator,select_left_conjunct VP_L:require_no_req_aux,try_remove_correlated,remove_left_conjunct # for subject-auxiliary inversion

# VP_L {^[x]:(... & ?[y1]:(?[l]:(location(l) & arg1(l)=y1 & arg2(l)=x) & ...) & ... & ?[yn]:(?[l]:(location(l) & arg1(l)=y1 & arg2(l)=x) & ...))}
#  -> WHERE VP_L {... & ?[y1]:(...) & ... & ?[yn]:(...)}
#VP_L -> WHERE VP_L:try_remove_correlated,require_left_conjunct_location_lambda,remove_left_conjunct

# VP_L {^[x]:(... & ?[y1]:(?[t]:(time(t) & arg1(t)=y1 & arg2(t)=x) & ...) & ... & ?[yn]:(?[t]:(time(t) & arg1(t)=y1 & arg2(t)=x) & ...))}
#  -> WHEN VP_L {... & ?[y1]:(...) & ... & ?[yn]:(...)}
#VP_L -> WHEN VP_L:try_remove_correlated,require_left_conjunct_time_lambda,remove_left_conjunct

# VP_L {^[x]:(... & ?[y1]:(?[m]:(manner(m) & arg1(m)=y1 & arg2(m)=x) & ...) & ... & ?[yn]:(?[m]:(manner(m) & arg1(m)=y1 & arg2(m)=x) & ...))}
#  -> HOW VP_L {... & ?[y1]:(...) & ... & ?[yn]:(...)}
#VP_L -> HOW VP_L:try_remove_correlated,require_left_conjunct_manner_lambda,remove_left_conjunct

# VP_L {^[x]:(... & ?[y1]:(?[r]:(reason(r) & arg1(r)=y1 & arg2(r)=x) & ...) & ... & ?[yn]:(?[r]:(reason(r) & arg1(r)=y1 & arg2(r)=x) & ...))}
#  -> WHY VP_L {... & ?[y1]:(...) & ... & ?[yn]:(...)}
#VP_L -> WHY VP_L:try_remove_correlated,require_left_conjunct_reason_lambda,remove_left_conjunct

VP_L -> EITHER VP_L:remove_either
VP_L -> BOTH VP_L:remove_both
VP_L -> NEITHER VP_L:remove_neither,add_negative


# TODO: should this nonterminal change the universal/existential quantifiers into a single kind of quantifier, to improve generalization for the NP nonterminal and further downstream?
NP nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# NP {A} -> A NP' {A}
NP -> A NP':require_singular,try_remove_adv,require_no_correlator,require_predicative_existential

# NP {A} -> NP' {A}
# where A = ^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))
NP -> NP':require_plural,try_remove_adv,require_no_correlator,require_predicative_universal
# NP {A} -> NP' {A}
# where A = ^[P]:(... & W(... & ?[X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & P(x)))))
#    or A = ^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ... & W(... & ?[x]:(X(x) & P(x)))))
NP -> NP':require_plural,try_remove_adv,require_no_correlator,require_predicative_existential,require_wide_scope

# NP {A} -> NP' {A}
# where A = ^[P]:(... & ?[X]:(F(X=^[x]:x=a) & ?[x]:(X(x) & P(x))))
NP -> NP':require_singular,try_remove_adv,require_no_correlator,require_predicative_existential,require_constant_in_set

# NP {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ~![x]:(X(x) => P(x))))} -> NO NOMINAL_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# NP {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ~?[x]:(X(x) & P(x))))} -> NO NOMINAL_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ~?[x]:(X(x) & P(x))))}
# NP {^[P]:(... & ?[X]:(f(X) & ~![x]:(X(x) => P(x))))} -> NOT NP {^[P]:?[X]:(f(X) & ![x]:(X(x) => P(x)))}
# NP {^[P]:(... & ?[X]:(f(X) & ~?[x]:(X(x) & P(x))))} -> NOT NP {^[P]:?[X]:(f(X) & ?[x]:(X(x) & P(x)))}
# NP {^[P]:(... & ?[X]:(f(X=^[x]:~f(x)) & ![x]:(X(x) => P(x))))} -> NOT NP {^[P]:?[X]:(f(X=^[x]:f(x)) & ![x]:(X(x) => P(x)))}
# NP {^[P]:(... & ?[X]:(f(X=^[x]:~f(x)) & ?[x]:(X(x) & P(x))))} -> NOT NP {^[P]:?[X]:(f(X=^[x]:f(x)) & ?[x]:(X(x) & P(x)))}
# NP {^[P]:(... & ?[X]:(f(X) & ~?[x]:(X(x) & P(x))))} -> NEITHER NP {^[P]:?[X]:(f(X) & ?[x]:(X(x) & P(x)))}
# this depends on whether the head quantifier is negated
#NP -> NO NOMINAL_R:try_remove_adv,try_remove_correlated,require_no_correlator,add_negative,remove_predicative_not
#NP -> NOT NP:try_remove_adv,try_remove_correlated,add_negative,remove_predicative_not
#NP -> NOT NP:try_remove_adv,try_remove_correlated,add_negative,remove_predicative_set_complement
#NP -> NEITHER NOMINAL_R:try_remove_adv,try_remove_correlated,require_no_correlator,add_negative,remove_predicative_not,require_predicative_existential

# NP {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))} -> EACH NOMINAL_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# this depends on whether the set is defined as S=^[x]:f(x) rather than with functions like `subset` or `half`;
# it also depends on whether the head predicate of the left conjunct is `this`, `that`, [TODO: add features for possessive]
NP -> EACH NOMINAL_R:require_no_adv,try_remove_correlated,require_no_correlator,require_predicative_universal

# NP {A} -> A NOMINAL_R {A}
#   e.g. "A group of students walks down the street."
#NP -> A NOMINAL_R:add_concord_singular,try_remove_adv,try_remove_correlated,require_no_correlator
# TODO: in the above example, maybe we should model "students" as the head, rather than "group"

# NP {^[P]:(... & ?[X]:(F(subset(X,^[x]:f(x))) & ![x]:(X(x) => P(x))))} -> SOME NOMINAL_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# NP {^[P]:(... & ?[X]:(F(subset(X,^[x]:f(x))) & ?[x]:(X(x) & P(x))))} -> SOME NOMINAL_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & P(x))))}
# this depends on whether the set is defined using `subset` rather than with functions like `half` or as S=^[x]:f(x);
#NP -> SOME NOMINAL_R:try_remove_adv,try_remove_correlated,require_no_correlator,replace_predicative_subset_with_equality

# NP {A} -> DEF_NP {A}
NP -> DEF_NP:try_remove_adv,require_no_correlator

# NP {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))} -> ALL DEF_NP {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# this depends on whether the set is defined as S=^[x]:f(x) rather than with functions like `subset` or `half`;
# it also depends on whether the head predicate of the left conjunct is `this`, `that`, [TODO: add features for possessive]
NP -> ALL DEF_NP:try_remove_adv,try_remove_correlated,require_no_correlator,require_predicative_universal
NP -> ALL NP':try_remove_adv,try_remove_correlated,require_no_correlator,require_predicative_universal

# NP {^[P]:(... & ?[X]:(F(half(X,^[x]:f(x))) & ![x]:(X(x) => P(x))))} -> HALF DEF_NP {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# NP {^[P]:(... & ?[X]:(F(half(X,^[x]:f(x))) & ![x]:(X(x) => P(x))))} -> HALF A NOMINAL_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# this depends on whether the set is defined using `half` rather than with functions like `subset` or as S=^[x]:f(x);
# it also depends on whether the head predicate of the left conjunct is `this`, `that`, [TODO: add features for possessive]
#NP -> HALF DEF_NP:try_remove_adv,try_remove_correlated,require_no_correlator,replace_predicative_half_with_equality
#NP -> HALF A NOMINAL_R:try_remove_adv,try_remove_correlated,require_no_correlator,replace_predicative_half_with_equality

# NP {^[P]:(... & ?[X]:(F(p(X,A)) & (~)![x]:(X(x) => P(x))))} -> ADV {p} NP {^[P]:(... & ?[X]:(F(X=A) & (~)![x]:(X(x) => P(x))))}
# NP {^[P]:(... & ?[X]:(F(p(X,A)) & (~)?[x]:(X(x) & P(x))))} -> ADV {p} NP {^[P]:(... & ?[X]:(F(X=A) & (~)?[x]:(X(x) & P(x))))}
# NOTE: If A is an existentially-quantified variable, we replace all
# occurrences of A with X (such as in the construction "almost half the cats").
# this depends on whether `p` is `half`, `subset`, or `almost`
#NP -> ADV:predicative_set_predicate NP:add_adv,try_remove_correlated,replace_predicative_predicate_with_equality

# NP {^[P]:(... & ?[X]:(X=^[x]:(first_name(x)=n1) & ?[x]:(X(x) & P(x))))} -> NAME {first_name(x)=n1}
# NP {^[P]:(... & ?[X]:(X=^[x]:(first_name(x)=n1 & last_name(x)=n2) & ?[x]:(X(x) & P(x))))} -> NAME {first_name(x)=n1 & last_name(x)=n2}
# NP {^[P]:(... & ?[X]:(X=^[x]:(nickname(x,n1)) & ?[x]:(X(x) & P(x))))} -> NAME {nickname(x,n1)}
#NP -> NAME

# NP {^[P,x]:(... & ?[X]:(X=^[x]:f(x) & ... & X(x) & P(x)))}
#  -> WHICH/WHAT NOMINAL_R {^[P]:(... & ?[X]:(X=^[x]:f(x) & ... & ?[x]:(X(x) & P(x))))}
#NP -> WHICH NOMINAL_R:try_remove_adv,try_remove_correlated,require_no_correlator,replace_predicative_lambda_with_existential
#NP -> WHAT NOMINAL_R:try_remove_adv,try_remove_correlated,require_no_correlator,replace_predicative_lambda_with_existential

# TODO: wait what? what happened to NOMINAL_R lol?
# NP {^[P]:(... & ?[X]:(X=^[x]:f(x) & ... & ?[x]:(X(x) & P(x))))} -> WHATEVER/WHICHEVER
# NP {^[P]:(... & ?[X]:(X=^[x]:f(x) & ... & ![x]:(X(x) => P(x))))} -> WHATEVER/WHICHEVER
#NP -> WHICHEVER NOMINAL_R:try_remove_adv,try_remove_correlated,require_no_correlator
#NP -> WHATEVER NOMINAL_R:try_remove_adv,try_remove_correlated,require_no_correlator

NP -> EITHER NP:remove_either
NP -> BOTH NP:remove_both
NP -> NEITHER NP:remove_neither,add_negative

# for correlated coordination
# NOTE: For the following rules, the coordination doesn't have to be at head
# scope, it can be the left-most coordination that is a descendant of the head
# scope as well, so long as there is no negation between the coordination and
# the root. However, we need some measure of "distance" between the
# coordination and the head scope to be a feature to decide between the rules
# at this nonterminal (e.g. "both" moves left much less often than "either").
# NP {A} -> EITHER NP {A}
# where A = ^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))
#    or A = ^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & P(x))))
#NP -> NP:require_not_correlated,add_either,add_correlated_by_either # this transformation requires the coordination is at the head
#NP -> EITHER:require_not_correlated NP:add_correlated_by_either # this transformation requires the coordination is a descendant of the head descendant of the head
# NP {A} -> BOTH NP {A}
# where A = ^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & ![x]:(S(x) => ![y]:(x(y) => P(y)))))
#    or A = ^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & ![x]:(S(x) => P(x))))
#NP -> NP:require_not_correlated,add_both,add_correlated_by_both # this transformation requires the coordination is at the head
#NP -> BOTH:require_not_correlated NP:add_correlated_by_both # this transformation requires the coordination is a descendant of the head descendant of the head
# NP {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ~?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
#  -> NEITHER NP {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
# NP {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ~?[x]:(S(x) & P(x))))}
#  -> NEITHER NP {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & P(x))))}
#NP -> NP:require_not_correlated,add_neither,add_correlated_by_neither # this transformation requires the coordination is at the head
#NP -> NEITHER:require_not_correlated NP:add_correlated_by_neither,add_negative # this transformation requires the coordination is a descendant of the head descendant of the head

# NOTE: In the below rules, we require that none of the Ai are themselves
# coordinations with the coordinator (unless Ai is negated).
# NP {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ![x]:(S(x) => ![y]:(x(y) => P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ![x]:(S(x) => P(x))))}
#  -> NP {^[P]:(... & ?[x1]:(f1(x1) & P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & ![x]:(x1(x) => P(x))))} if x1 is a set
#     NP_COORDINATION {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ![x]:(S(x) => ![y]:(x(y) => P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ![x]:(S(x) => P(x))))}
# NP {^[P]:(... & ?[S]:(F(S=^[x]:(f1(x) & ... & fn(x))) & ...))}
#  -> NP {^[P]:(... & ?[S]:(F(S=^[x]:f1(x)) & ...))}
#     NP_COORDINATION {^[P]:(... & ?[S]:(F(S=^[x]:(f2(x) & ... & fn(x))) & ...))}
# NP {^[P]:(... & ?[S]:(F1(S) & ... & Fn(S) & ...))}
#  -> NP {^[P]:(... & ?[S]:(F1(S) & ...))}
#     NP_COORDINATION {^[P]:(... & ?[S]:(F2(S) & ... & Fn(S) & ...))}
# NOTE: xi could also be constants, rather than existentially-quantified variables
#NP -> NP NP_COORDINATION:try_remove_correlator,add_and
#NP -> NP NP_COORDINATION:try_remove_correlator,add_and,add_comma

# NP {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & P(x))))}
#  -> NP {^[P]:(... & ?[x1]:(f1(x1) & P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & ![x]:(x1(x) => P(x))))} if x1 is a set
#     NP_COORDINATION {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ?[x]:(S(x) & P(x))))}
# NOTE: xi could also be constants, rather than existentially-quantified variables
#NP -> NP NP_COORDINATION:try_remove_correlator,add_or
#NP -> NP NP_COORDINATION:try_remove_correlator,add_or,add_comma

# NP {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & P(x))))}
#  -> NP {^[P]:(... & ?[x1]:(f1(x1) & P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & ![x]:(x1(x) => P(x))))} if x1 is a set
#     NP_COORDINATION {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ?[x]:(S(x) & P(x))))}
# NOTE: xi could also be constants, rather than existentially-quantified variables
#NP -> NP NP_COORDINATION:try_remove_correlator,add_nor,require_negative
#NP -> NP NP_COORDINATION:try_remove_correlator,add_nor,require_negative,add_comma

# NP {^[P]:(... & ?[S]:(but(F(S),G(S)) & ...))}
#  -> NP {^[P]:(... & ?[S]:(F(S) & ...))} (COMMA) BUT NP {^[P]:(... & ?[S]:(G(S) & ...))}
# NP {^[P]:(... & ?[S]:(F(S=^[x]:but(f(x),g(x))) & ...))}
#  -> NP {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ...))} (COMMA) BUT NP {^[P]:(... & ?[S]:(F(S=^[x]:g(x)) & ...))}
#NP -> NP BUT NP:try_remove_correlator
#NP -> NP COMMA BUT NP:try_remove_correlator


NP_COORDINATION nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# NOTE: In the below rules, we require that none of the Ai are themselves
# coordinations with the coordinator (unless Ai is negated).
# NP_COORDINATION {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ![x]:(S(x) => ![y]:(x(y) => P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ![x]:(S(x) => P(x))))}
#  -> (COMMA) NP {^[P]:(... & ?[x1]:(f1(x1) & P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & ![x]:(x1(x) => P(x))))} if x1 is a set
#     NP_COORDINATION {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ![x]:(S(x) => ![y]:(x(y) => P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ![x]:(S(x) => P(x))))}
# NP_COORDINATION {^[P]:(... & ?[S]:(F(S=^[x]:(f1(x) & ... & fn(x))) & ...))}
#  -> (COMMA) NP {^[P]:(... & ?[S]:(F(S=^[x]:f1(x)) & ...))}
#     NP_COORDINATION {^[P]:(... & ?[S]:(F(S=^[x]:(f2(x) & ... & fn(x))) & ...))}
# NP_COORDINATION {^[P]:(... & ?[S]:(F1(S) & ... & Fn(S) & ...))}
#  -> (COMMA) NP {^[P]:(... & ?[S]:(F1(S) & ...))}
#     NP_COORDINATION {^[P]:(... & ?[S]:(F2(S) & ... & Fn(S) & ...))}
# NP_COORDINATION {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & P(x))))}
#  -> (COMMA) NP {^[P]:(... & ?[x1]:(f1(x1) & P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & ![x]:(x1(x) => P(x))))} if x1 is a set
#     NP_COORDINATION {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ?[x]:(S(x) & P(x))))}
# NOTE: xi could also be constants, rather than existentially-quantified variables
#NP_COORDINATION -> COMMA:require_comma NP:remove_coordinator,remove_comma NP_COORDINATION
# NP_COORDINATION {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & S=^[x]:x=x1) & ![x]:(S(x) => ![y]:(x(y) => P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & S=^[x]:x=x1) & ![x]:(S(x) => P(x))))}
#  -> (COMMA) NP {^[P]:(... & ?[x1]:(f1(x1) & P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & ![x]:(x1(x) => P(x))))} if x1 is a set
# NP_COORDINATION {^[P]:(... & ?[S]:(F(S=^[x]:f1(x)) & ...))}
#  -> (COMMA) NP {^[P]:(... & ?[S]:(F(S=^[x]:f1(x)) & ...))}
# NP_COORDINATION {^[P]:(... & ?[S]:(F1(S) & ...))}
#  -> (COMMA) NP {^[P]:(... & ?[S]:(F1(S) & ...))}
# NP_COORDINATION {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & S=^[x]:x=x1) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & S=^[x]:x=x1) & ?[x]:(S(x) & P(x))))}
#  -> (COMMA) NP {^[P]:(... & ?[x1]:(f1(x1) & P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & ![x]:(x1(x) => P(x))))} if x1 is a set
# NOTE: xi could also be constants, rather than existentially-quantified variables
#NP_COORDINATION -> COMMA:require_comma NP:remove_coordinator,remove_comma

# NOTE: In the below rules, we require that none of the Ai are themselves
# coordinations with the coordinator (unless Ai is negated).
# NP_COORDINATION {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ![x]:(S(x) => ![y]:(x(y) => P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ![x]:(S(x) => P(x))))}
#  -> (COMMA) AND NP {^[P]:(... & ?[x1]:(f1(x1) & P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & ![x]:(x1(x) => P(x))))} if x1 is a set
#     NP_COORDINATION {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ![x]:(S(x) => ![y]:(x(y) => P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ![x]:(S(x) => P(x))))}
# NP_COORDINATION {^[P]:(... & ?[S]:(F(S=^[x]:(f1(x) & ... & fn(x))) & ...))}
#  -> (COMMA) AND NP {^[P]:(... & ?[S]:(F(S=^[x]:f1(x)) & ...))}
#     NP_COORDINATION {^[P]:(... & ?[S]:(F(S=^[x]:(f2(x) & ... & fn(x))) & ...))}
# NP_COORDINATION {^[P]:(... & ?[S]:(F1(S) & ... & Fn(S) & ...))}
#  -> (COMMA) AND NP {^[P]:(... & ?[S]:(F1(S) & ...))}
#     NP_COORDINATION {^[P]:(... & ?[S]:(F2(S) & ... & Fn(S) & ...))}
# NOTE: xi could also be constants, rather than existentially-quantified variables
#NP_COORDINATION -> AND:require_and NP:remove_coordinator,remove_comma NP_COORDINATION
#NP_COORDINATION -> COMMA:require_comma AND:require_and NP:remove_coordinator,remove_comma NP_COORDINATION
# NP_COORDINATION {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & S=^[x]:x=x1) & ![x]:(S(x) => ![y]:(x(y) => P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & S=^[x]:x=x1) & ![x]:(S(x) => P(x))))}
#  -> (COMMA) AND NP {^[P]:(... & ?[x1]:(f1(x1) & P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & ![x]:(x1(x) => P(x))))} if x1 is a set
# NP_COORDINATION {^[P]:(... & ?[S]:(F(S=^[x]:f1(x)) & ...))}
#  -> (COMMA) AND NP {^[P]:(... & ?[S]:(F(S=^[x]:f1(x)) & ...))}
# NP_COORDINATION {^[P]:(... & ?[S]:(F1(S) & ...))}
#  -> (COMMA) AND NP {^[P]:(... & ?[S]:(F1(S) & ...))}
# NOTE: xi could also be constants, rather than existentially-quantified variables
#NP_COORDINATION -> AND:require_and NP:remove_coordinator,remove_comma
#NP_COORDINATION -> COMMA:require_comma AND:require_and NP:remove_coordinator,remove_comma

# NOTE: In the below rules, we require that none of the Ai are themselves
# coordinations with the coordinator (unless Ai is negated).
# NP_COORDINATION {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & P(x))))}
#  -> (COMMA) OR NP {^[P]:(... & ?[x1]:(f1(x1) & P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & ![x]:(x1(x) => P(x))))} if x1 is a set
#     NP_COORDINATION {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ?[x]:(S(x) & P(x))))}
# NOTE: xi could also be constants, rather than existentially-quantified variables
#NP_COORDINATION -> OR:require_or NP:remove_coordinator,remove_comma NP_COORDINATION
#NP_COORDINATION -> COMMA:require_comma OR:require_or NP:remove_coordinator,remove_comma NP_COORDINATION
# NP_COORDINATION {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & S=^[x]:x=x1) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & S=^[x]:x=x1) & ?[x]:(S(x) & P(x))))}
#  -> (COMMA) OR NP {^[P]:(... & ?[x1]:(f1(x1) & P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & ![x]:(x1(x) => P(x))))} if x1 is a set
# NOTE: xi could also be constants, rather than existentially-quantified variables
#NP_COORDINATION -> OR:require_or NP:remove_coordinator,remove_comma
#NP_COORDINATION -> COMMA:require_comma OR:require_or NP:remove_coordinator,remove_comma

# NOTE: In the below rules, we require that none of the Ai are themselves
# coordinations with the coordinator (unless Ai is negated).
# NP_COORDINATION {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & P(x))))}
#  -> (COMMA) NOR NP {^[P]:(... & ?[x1]:(f1(x1) & P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & ![x]:(x1(x) => P(x))))} if x1 is a set
#     NP_COORDINATION {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ?[x]:(S(x) & P(x))))}
# NOTE: xi could also be constants, rather than existentially-quantified variables
#NP_COORDINATION -> NOR:require_nor NP:add_req_aux,remove_coordinator,remove_comma,add_negative NP_COORDINATION
#NP_COORDINATION -> COMMA:require_comma NOR:require_nor NP:add_req_aux,remove_coordinator,remove_comma,add_negative NP_COORDINATION
# NP_COORDINATION {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & S=^[x]:x=x1) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & S=^[x]:x=x1) & ?[x]:(S(x) & P(x))))}
#  -> (COMMA) NOR NP {^[P]:(... & ?[x1]:(f1(x1) & P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & ![x]:(x1(x) => P(x))))} if x1 is a set
# NOTE: xi could also be constants, rather than existentially-quantified variables
#NP_COORDINATION -> NOR:require_nor NP:add_req_aux,remove_coordinator,remove_comma,add_negative
#NP_COORDINATION -> COMMA:require_comma NOR:require_nor NP:add_req_aux,remove_coordinator,remove_comma,add_negative


NAME nonterminal {} {1.0} {1.0} {} 10 1.0 {}
# NAME {nickname(x,s)} -> STRING {s}
#NAME -> STRING:require_no_correlator,select_nickname
# NAME {first_name(x)=s} -> STRING {s}
#NAME -> STRING:require_no_correlator,select_first_name
# NAME {first_name(x)=s1 & last_name(x)=s2} -> STRING {s1} STRING {s2}
#NAME -> STRING:require_no_correlator,select_first_name STRING:select_last_name


DEF_NP nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# DEF_NP {A} -> THE NP' {A}
DEF_NP -> THE NP':try_remove_correlated

# NP {^[P]:(... & ?[S]:(this(S) & F(S) & ![x]:(S(x) => P(x))))} -> THIS NP' {^[P]:(... & ?[S]:(F(S) & ![x]:(S(x) => P(x))))}
# NP {^[P]:(... & ?[S]:(this(S) & F(S) & ?[x]:(S(x) & P(x))))} -> THIS NP' {^[P]:(... & ?[S]:(F(S) & ?[x]:(S(x) & P(x))))}
# this depends on whether the head predicate of the left conjunct is `this`
# TODO: make `THIS` into a special nonterminal that can yield either "this" or "these", depending on grammatical number
#DEF_NP -> THIS NP':try_remove_correlated

# NP {^[P]:(... & ?[S]:(that(S) & F(S) & ![x]:(S(x) => P(x))))} -> THIS NP' {^[P]:(... & ?[S]:(F(S) & ![x]:(S(x) => P(x))))}
# NP {^[P]:(... & ?[S]:(that(S) & F(S) & ?[x]:(S(x) & P(x))))} -> THIS NP' {^[P]:(... & ?[S]:(F(S) & ?[x]:(S(x) & P(x))))}
# this depends on whether the head predicate of the left conjunct is `that`
# TODO: make `THAT` into a special nonterminal that can yield either "that" or "those", depending on grammatical number
#DEF_NP -> THAT NP':try_remove_correlated

# DEF_NP {^[P]:(... & ?[X]:(F(X=^[x]:(?[o]:(own(o) & arg2(o)=x & arg1(o)=a) & f(x))) & ![x]:(X(x) => P(x))))}
#  -> NP {^[P]:?[X]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x)))}
#     NP' {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# DEF_NP {^[P]:(... & ?[X]:(F(X=^[x]:(?[o]:(own(o) & arg2(o)=x & ?[y]:(g(y) & arg1(o)=y)) & f(x))) & ![x]:(X(x) => P(x))))}
#  -> NP {^[P]:(... & ?[X]:(X=^[x]:g(x) & ?[x]:(X(x) & P(x))))}
#     NP' {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# DEF_NP {^[P]:(... & ?[X]:(F(X=^[x]:(?[y]:(g(y) & ?[o]:(own(o) & arg2(o)=x & arg1(o)=y)) & f(x))) & ![x]:(X(x) => P(x))))}
#  -> NP {^[P]:(... & ?[X]:(X=^[x]:g(x) & ![x]:(X(x) => P(x))))}
#     NP' {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# DEF_NP {^[P]:(... & ?[X]:(F(X=^[x]:(![y]:(g(y) => ?[o]:(own(o) & arg2(o)=x & arg1(o)=y)) & f(x))) & ![x]:(X(x) => P(x))))}
#  -> NP {^[P]:(... & ?[X]:(X=^[x]:g(x) & ![x]:(X(x) => P(x))))}
#     NP' {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# NOTE: In the last two rules, if `g(y)` is just a set membership test `Y(y)`,
# then in the left child logical form, we replace `X=^[x]:g(x)` with the
# definition of `Y` (effectively renaming `Y` to `X`).
# NOTE: This rule also works if X is existentially-quantified.
#DEF_NP -> NP:add_genitive,add_singular NP':try_remove_correlated
#DEF_NP -> NP:add_genitive,add_plural NP':try_remove_correlated
# TODO: the above rule can also be used for `inverse(intended_for)` in addition to `own`

# DEF_NP {^[P]:(... & ?[S]:(F(S=^[x]:(arg1/arg2(x)=a & f(x))) & ![x]:(S(x) => P(x))))}
#  -> NP {^[P]:?[S]:(S=^[x]:(x=a) & ?[x]:(S(x) & P(x)))}
#     NP' {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
# DEF_NP {^[P]:(... & ?[S]:(F(S=^[x]:(?[y]:(g(y) & arg1/arg2(x)=y) & f(x))) & ![x]:(S(x) => P(x))))}
#  -> NP {^[P]:(... & ?[S]:(S=^[x]:g(x) & ?[x]:(S(x) & P(x))))}
#     NP' {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
# DEF_NP {^[P]:(... & ![y]:(g(y) => ... ?[S]:(F(S=^[x]:(arg1/arg2(x)=y & f(x))) & ![x]:(S(x) => P(x)))))}
#  -> NP {^[P]:(... & ?[S]:(S=^[x]:g(x) & ![x]:(S(x) => P(x))))}
#     NP' {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
# DEF_NP {^[P]:(... & ?[Y]:(G(Y) & ... & ![y]:(Y(y) => ?[S]:(F(S=^[x]:(arg1/arg2(x)=y & f(x))) & ![x]:(S(x) => P(x))))))}
#  -> NP {^[P]:(... & ?[S]:(G(S) & ![x]:(S(x) => P(x))))}
#     NP' {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
# NOTE: This rule also works if S is existentially-quantified.
#  e.g. "the arson's/termites' destruction of the barn(s)"
#DEF_NP -> NP:add_genitive,add_singular NP':try_remove_correlated # for arg1
#DEF_NP -> NP:add_genitive,add_singular NP':try_remove_correlated # for arg2
#DEF_NP -> NP:add_genitive,add_plural NP':try_remove_correlated # for arg1
#DEF_NP -> NP:add_genitive,add_plural NP':try_remove_correlated # for arg2

# DEF_NP {^[P]:(... ?[X]:(X=^[x]:(?[o]:(arg1(o)=a & own(o) & arg2(o)=x)) & ![x]:(X(x) => P(x))))}
#  -> NP {^[P]:(... ?[Y]:(Y=^[y]:(y=a) & ?[y]:(Y(y) & P(y))))}
# DEF_NP {^[P]:(... ?[y]:(f(y) & ... & ?[X]:(X=^[x]:(?[o]:(arg1(o)=y & own(o) & arg2(o)=x)) & ![x]:(X(x) => P(x)))))}
#  -> NP {^[P]:(... ?[Y]:(Y=^[y]:f(y) & ?[y]:(Y(y) => P(y))))}
# DEF_NP {^[P]:(... ?[Y]:(F(Y) & ... & ?[X]:(X=^[x]:(?[y]:(Y(y) & ?[o]:(arg1(o)=y & own(o) & arg2(o)=x))) & ![x]:(X(x) => P(x)))))}
#  -> NP {^[P]:(... ?[Y]:(F(Y) & ?[y]:(Y(y) & P(y))))}
# DEF_NP {^[P]:(... ?[Y]:(F(Y) & ... & ?[X]:(X=^[x]:(![y]:(Y(y) => ?[o]:(arg1(o)=y & own(o) & arg2(o)=x))) & ![x]:(X(x) => P(x)))))}
#  -> NP {^[P]:(... ?[Y]:(F(Y) & ![y]:(Y(y) => P(y))))}
# NOTE: This rule also works if X is existentially-quantified.
# e.g. "Jason's is better"
#DEF_NP -> NP:require_no_genitive,add_genitive,add_singular
#DEF_NP -> NP:require_no_genitive,add_genitive,add_plural



NP' nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# NP {^[P]:(... & ?[S]:(f(S) & g(S=^[x]:f(x)) & ...))} -> Q {f(S)} NOMINAL_R {^[P]:(... & ?[S]:(g(S=^[x]:f(x)) & ...))}
# this depends on whether the head predicate of the left conjunct f(S) is one that expresses information about the size of the set
#NP' -> Q NOMINAL_R:try_remove_correlated

# NP' {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))} -> NOMINAL_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# NP' {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & P(x))))} -> NOMINAL_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & P(x))))}
NP' -> NOMINAL_R:identity


Q nonterminal {} {1.0} {1.0} {} 10 1.0 {}
# TODO: to decide between the following rules, we need information about the countability of the noun

# Q {?[l]:(mod(f)(l) & ...)} -> ADV {mod} Q {?[l]:(f(l) & ...)} where f is the type predicate of `l`
#   [OR]
# Q {?[l]:(?[m]:(mod(m) & arg1(m)=l) & f(l) & ...)} -> ADV {mod} Q {?[l]:(f(l) & ...)} where f is the type predicate of `l`
#
# Q {?[a]:(mod(a) & arg1(a)=A & arg2(a)=B)} -> ADV {mod} Q {A=B}
#   [OR]
# Q {p(A,B)} -> ADV {p} Q {A=B}
# The last two rules are for adverbs like "almost", "nearly", "more than", etc.
#Q -> ADVP_L Q:try_remove_correlated

# Q {size(x)=n} -> NUMBER {n}
#Q -> NUMBER

# comparative constructions where sizes of sets are compared
# Q {?[R]:size(X)>size(R)} -> MORE
# e.g. "more people came than last time"
#Q -> MORE

# comparative constructions where sizes of sets are compared
# Q {?[R]:size(X)<size(R)} -> LESS/FEWER
# e.g. "more people came than last time"
#Q -> FEWER
#Q -> LESS

# Q {?[R]:size(X)=k*size(R)} -> NUMBER {k} TIMES (AS MUCH/MANY)
# e.g. "four times as many/much"
#Q -> NUMBER TIMES
#Q -> NUMBER TIMES AS MUCH
#Q -> NUMBER TIMES AS MANY

#Q -> MUCH
#Q -> MANY
#Q -> MOST
#Q -> FEW
#Q -> FEWEST
#Q -> LEAST


# this noun phrase nonterminal is for right-side modifiers
NOMINAL_R nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# NOMINAL_R {A} -> NOMINAL_L {A}
NOMINAL_R -> NOMINAL_L:identity

# NOMINAL_R {^[P]:(... & ?[S]:(F(S=^[x]:(f(x) & g(x))) & ...))}
#  -> NOMINAL_R {^[P]:?[S]:(S=^[x]:f(x) & ...)}
#     N_ADJUNCT {... & ?[x]:(p(x) & g(x))}
# NOMINAL_R {^[P]:(... & ?[S]:(F(S=^[x]:(f(x) & ?[y]:(g(y) & arg1/arg2(x)=y))) & ...))}
#  -> NOMINAL_R {^[P]:?[S]:(S=^[x]:f(x) & ...)}
#     N_ADJUNCT {... & ?[x]:(p(x) & ?[y]:(g(y) & arg1/arg2(x)=y))}
# NOMINAL_R {^[P]:(... & ![y]:(g(y) => ... ?[S]:(F(S=^[x]:(f(x) & arg1/arg2(x)=y)) & ...)))}
#  -> NOMINAL_R {^[P]:?[S]:(S=^[x]:f(x) & ...)}
#     N_ADJUNCT {... & ![y]:(g(y) => ... ?[x]:(p(x) & arg1/arg2(x)=y))}
# NOMINAL_R {^[P]:(... & ?[Y]:(G(Y) & ... & ![y]:(Y(y) => ?[S]:(F(S=^[x]:(arg1/arg2(x)=y & f(x))) & ...))))}
#  -> NOMINAL_R {^[P]:?[S]:(S=^[x]:f(x) & ...)}
#     N_ADJUNCT {... & ?[Y]:(G(Y) & ... & ![y]:(Y(y) => ... ?[x]:(p(x) & arg1/arg2(x)=y)))}
# for some open interrogative finite subordinate clauses (relative clauses)
# and for relative clauses where the relative phrase is a complement of a preposition
# NOMINAL_R {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => A(x)) & ...))}
#  -> NOMINAL_R {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ...))}
#     N_ADJUNCT {... & ?[x]:(p(x) & A(x))}
NOMINAL_R -> NOMINAL_R:try_remove_genitive,remove_right_conjunct_in_set N_ADJUNCT:try_remove_correlated,select_right_conjunct_in_set

# comparative constructions
# NOMINAL_R {^[P]:(... & ?[X,r]:(... & F(X=^[x]:(?[g1]:(U(i1,g1) & p(f1)(g1) & arg1(g1)=x & arg2(g1)=r) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & arg1(gn)=x & arg2(gn)=r) & ... & h(r) & ...)) & ...))}
#  -> NOMINAL_R {^[P]:(... & ?[X]:(... & F(X=^[x]:(?[g1]:(U(i1,g1) & p(f1)(g1) & arg1(g1)=x) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & arg1(gn)=x) & ...)) & ...))}
#     N_ADJUNCT {... & ?[r]:(... & ?[g1]:(U(i1,g1) & p(f1)(g1) & arg2(g1)=r) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & arg2(gn)=r) & ... & h(r) & ...)}
# NOMINAL_R {^[P]:(... & ?[X,R]:(... & p_comp(size(X),size(R)) & ... & F(X=^[x]:(![r]:(R(r) => ?[g1]:(U(i1,g1) & p(f1)(g1) & arg1(g1)=x & arg2(g1)=r) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & arg1(gn)=x & arg2(gn)=r)) & ...)) & ... & R=^[r]:h(r) & ...))}
#  -> NOMINAL_R {^[P]:(... & ?[X]:(... & p_comp(size(X)) & ... & F(X=^[x]:(?[g1]:(U(i1,g1) & p(f1)(g1) & arg1(g1)=x) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & arg1(gn)=x) & ...)) & ...))}
#     N_ADJUNCT {... & ?[R]:(... & p_comp(size(R)) & ... & ![r]:(R(r) => ?[g1]:(U(i1,g1) & p(f1)(g1) & arg2(g1)=r) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & arg2(gn)=r)) & ... & R=^[r]:h(r) & ...)}
# NOMINAL_R {^[P]:(... & ?[X,R]:(?[X1,R1]:(... & p_comp(size(X1),size(R1)) & ... & F(X1=^[x]:(![r]:(R(r) => ?[g1]:(U(i1,g1) & p(f1)(g1) & arg1(g1)=x & arg2(g1)=r) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & arg1(gn)=x & arg2(gn)=r)) & ...)) & ?[X2,R2]:(... & p_comp(size(X2),size(R2)) & ... & F(X2=^[x]:(...)) & ... & X=^[S]:(S=X1 | ... | S=Xn) & R=^[S]:(S=R1 | ... | S=Rn))) & ... & ![Ri]:(R(Ri) => Ri=^[r]:h(r)) & ...))}
#  -> NOMINAL_R {^[P]:(... & ?[X]:(?[X1]:(... & p_comp(size(X1)) & ... & F(X1=^[x]:(?[g1]:(U(i1,g1) & p(f1)(g1) & arg1(g1)=x) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & arg1(gn)=x) & ...)) & ?[X2]:(... & p_comp(size(X2)) & ... & F(X2=^[x]:(...)) & ... & X=^[S]:(S=X1 | ... | S=Xn))) & ...))}
#     N_ADJUNCT {... & ?[R]:(?[R1]:(... & p_comp(size(R1)) & ... & ![r]:(R(r) => ?[g1]:(U(i1,g1) & p(f1)(g1) & arg2(g1)=r) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & arg2(gn)=r)) & ... & ?[R2]:(... & p_comp(size(R2)) & ... & R=^[S]:(S=R1 | ... | S=Rn))) & ... & ![Ri]:(R(Ri) => Ri=^[r]:h(r)) & ...)}
#NOMINAL_R -> NOMINAL_R:try_remove_genitive N_ADJUNCT:try_remove_correlated

# postposed infinitival clause from ADJP_R
# NOMINAL_R {^[P]:(... & ?[X]:(F(X=^[x]:(?[d]:(f(d) & ... & h(d)) & ...)) & ...))}
#  -> NOMINAL_R {^[P]:(... & ?[X]:(F(X=^[x]:(?[d]:(f(d) & ...) & ...)) & ...))}
#     VP_R {... & h'}
# where h(d) = ?[y]:(g(y) & arg1/arg2(y)=d) and h' = ?[y]:g(y)
#    or h(d) = arg1/arg2(d)=possibility(A) and h' = A
# e.g. "a difficult book to understand"
#NOMINAL_R -> NOMINAL_R:try_remove_genitive VP_R:add_to_infinitive,try_remove_correlated

# NOMINAL_R {^[P]:(... & ?[X]:(X=^[x]:f(x) & ![x]:(X(x) => P(x))))} -> VP_R {... & f(x)} if X is not a union
# NOMINAL_R {^[P]:(... & ?[X]:(X=^[x]:f(x) & ?[x]:(X(x) & P(x))))} -> VP_R {... & f(x)} if X is not a union
# NOMINAL_R {^[P]:(... & ?[X]:(X=^[x]:(x=x1 | ... | x=xn) & ![x]:(X(x) => P(x))))} -> VP_R {... & ?[x1]:(...) & ... & ?[xn]:(...)} if X is a union
# NOMINAL_R {^[P]:(... & ?[X]:(X=^[x]:(x=x1 | ... | x=xn) & ?[x]:(X(x) & P(x))))} -> VP_R {... & ?[x1]:(...) & ... & ?[xn]:(...)} if X is a union
# e.g. "the heating of the food"
#NOMINAL_R -> VP_R:add_present_participle,remove_adv

# pronouns
# NOMINAL_R {A} -> PRO {A}
NOMINAL_R -> PRO:remove_adv

# noun phrases headed by quantifiers
# NOMINAL_R {A} -> Q {A}
NOMINAL_R -> Q:remove_adv

# NOTE: In the below rules, we require that none of the Ai are themselves
# coordinations with the coordinator (unless Ai is negated).
# NOMINAL_R {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ![x]:(S(x) => ![y]:(x(y) => P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ![x]:(S(x) => P(x))))}
#  -> NOMINAL_R {^[P]:(... & ?[x1]:(f1(x1) & P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & ![x]:(x1(x) => P(x))))} if x1 is a set
#     NOMINAL_COORDINATION {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ![x]:(S(x) => ![y]:(x(y) => P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ![x]:(S(x) => P(x))))}
# NOMINAL_R {^[P]:(... & ?[S]:(F(S=^[x]:(f1(x) & ... & fn(x))) & ...))}
#  -> NOMINAL_R {^[P]:(... & ?[S]:(F(S=^[x]:f1(x)) & ...))}
#     NOMINAL_COORDINATION {^[P]:(... & ?[S]:(F(S=^[x]:(f2(x) & ... & fn(x))) & ...))}
# NOMINAL_R {^[P]:(... & ?[S]:(F1(S) & ... & Fn(S) & ...))}
#  -> NOMINAL_R {^[P]:(... & ?[S]:(F1(S) & ...))}
#     NOMINAL_COORDINATION {^[P]:(... & ?[S]:(F2(S) & ... & Fn(S) & ...))}
# NOTE: xi could also be constants, rather than existentially-quantified variables
#NOMINAL_R -> NOMINAL_R NOMINAL_COORDINATION:try_remove_correlator,add_and
#NOMINAL_R -> NOMINAL_R NOMINAL_COORDINATION:try_remove_correlator,add_and,add_comma

# NOMINAL_R {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & P(x))))}
#  -> NOMINAL_R {^[P]:(... & ?[x1]:(f1(x1) & P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & ![x]:(x1(x) => P(x))))} if x1 is a set
#     NOMINAL_COORDINATION {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ?[x]:(S(x) & P(x))))}
# NOTE: xi could also be constants, rather than existentially-quantified variables
#NOMINAL_R -> NOMINAL_R NOMINAL_COORDINATION:try_remove_correlator,add_or
#NOMINAL_R -> NOMINAL_R NOMINAL_COORDINATION:try_remove_correlator,add_or,add_comma

# NOMINAL_R {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & P(x))))}
#  -> NOMINAL_R {^[P]:(... & ?[x1]:(f1(x1) & P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & ![x]:(x1(x) => P(x))))} if x1 is a set
#     NOMINAL_COORDINATION {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ?[x]:(S(x) & P(x))))}
# NOTE: xi could also be constants, rather than existentially-quantified variables
#NOMINAL_R -> NOMINAL_R NOMINAL_COORDINATION:try_remove_correlator,add_nor,require_negative
#NOMINAL_R -> NOMINAL_R NOMINAL_COORDINATION:try_remove_correlator,add_nor,require_negative,add_comma

# NOMINAL_R {^[P]:(... & ?[S]:(but(F(S),G(S)) & ...))}
#  -> NOMINAL_R {^[P]:(... & ?[S]:(F(S) & ...))} (COMMA) BUT NOMINAL_R {^[P]:(... & ?[S]:(G(S) & ...))}
# NOMINAL_R {^[P]:(... & ?[S]:(F(S=^[x]:but(f(x),g(x))) & ...))}
#  -> NOMINAL_R {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ...))} (COMMA) BUT NOMINAL_R {^[P]:(... & ?[S]:(F(S=^[x]:g(x)) & ...))}
#NOMINAL_R -> NOMINAL_R BUT NOMINAL_R:try_remove_correlator
#NOMINAL_R -> NOMINAL_R COMMA BUT NOMINAL_R:try_remove_correlator


NOMINAL_COORDINATION nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# NOTE: In the below rules, we require that none of the Ai are themselves
# coordinations with the coordinator (unless Ai is negated).
# NOMINAL_COORDINATION {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ![x]:(S(x) => ![y]:(x(y) => P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ![x]:(S(x) => P(x))))}
#  -> (COMMA) NOMINAL_R {^[P]:(... & ?[x1]:(f1(x1) & P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & ![x]:(x1(x) => P(x))))} if x1 is a set
#     NOMINAL_COORDINATION {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ![x]:(S(x) => ![y]:(x(y) => P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ![x]:(S(x) => P(x))))}
# NOMINAL_COORDINATION {^[P]:(... & ?[S]:(F(S=^[x]:(f1(x) & ... & fn(x))) & ...))}
#  -> (COMMA) NOMINAL_R {^[P]:(... & ?[S]:(F(S=^[x]:f1(x)) & ...))}
#     NOMINAL_COORDINATION {^[P]:(... & ?[S]:(F(S=^[x]:(f2(x) & ... & fn(x))) & ...))}
# NOMINAL_COORDINATION {^[P]:(... & ?[S]:(F1(S) & ... & Fn(S) & ...))}
#  -> (COMMA) NOMINAL_R {^[P]:(... & ?[S]:(F1(S) & ...))}
#     NOMINAL_COORDINATION {^[P]:(... & ?[S]:(F2(S) & ... & Fn(S) & ...))}
# NOMINAL_COORDINATION {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & P(x))))}
#  -> (COMMA) NOMINAL_R {^[P]:(... & ?[x1]:(f1(x1) & P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & ![x]:(x1(x) => P(x))))} if x1 is a set
#     NOMINAL_COORDINATION {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ?[x]:(S(x) & P(x))))}
# NOTE: xi could also be constants, rather than existentially-quantified variables
#NOMINAL_COORDINATION -> COMMA:require_comma NOMINAL_R:remove_coordinator,remove_comma NOMINAL_COORDINATION
# NOMINAL_COORDINATION {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & S=^[x]:x=x1) & ![x]:(S(x) => ![y]:(x(y) => P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & S=^[x]:x=x1) & ![x]:(S(x) => P(x))))}
#  -> (COMMA) NOMINAL_R {^[P]:(... & ?[x1]:(f1(x1) & P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & ![x]:(x1(x) => P(x))))} if x1 is a set
# NOMINAL_COORDINATION {^[P]:(... & ?[S]:(F(S=^[x]:f1(x)) & ...))}
#  -> (COMMA) NOMINAL_R {^[P]:(... & ?[S]:(F(S=^[x]:f1(x)) & ...))}
# NOMINAL_COORDINATION {^[P]:(... & ?[S]:(F1(S) & ...))}
#  -> (COMMA) NOMINAL_R {^[P]:(... & ?[S]:(F1(S) & ...))}
# NOMINAL_COORDINATION {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & S=^[x]:x=x1) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & S=^[x]:x=x1) & ?[x]:(S(x) & P(x))))}
#  -> (COMMA) NOMINAL_R {^[P]:(... & ?[x1]:(f1(x1) & P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & ![x]:(x1(x) => P(x))))} if x1 is a set
# NOTE: xi could also be constants, rather than existentially-quantified variables
#NOMINAL_COORDINATION -> COMMA:require_comma NOMINAL_R:remove_coordinator,remove_comma

# NOTE: In the below rules, we require that none of the Ai are themselves
# coordinations with the coordinator (unless Ai is negated).
# NOMINAL_COORDINATION {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ![x]:(S(x) => ![y]:(x(y) => P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ![x]:(S(x) => P(x))))}
#  -> (COMMA) AND NOMINAL_R {^[P]:(... & ?[x1]:(f1(x1) & P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & ![x]:(x1(x) => P(x))))} if x1 is a set
#     NOMINAL_COORDINATION {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ![x]:(S(x) => ![y]:(x(y) => P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ![x]:(S(x) => P(x))))}
# NOMINAL_COORDINATION {^[P]:(... & ?[S]:(F(S=^[x]:(f1(x) & ... & fn(x))) & ...))}
#  -> (COMMA) AND NOMINAL_R {^[P]:(... & ?[S]:(F(S=^[x]:f1(x)) & ...))}
#     NOMINAL_COORDINATION {^[P]:(... & ?[S]:(F(S=^[x]:(f2(x) & ... & fn(x))) & ...))}
# NOMINAL_COORDINATION {^[P]:(... & ?[S]:(F1(S) & ... & Fn(S) & ...))}
#  -> (COMMA) AND NOMINAL_R {^[P]:(... & ?[S]:(F1(S) & ...))}
#     NOMINAL_COORDINATION {^[P]:(... & ?[S]:(F2(S) & ... & Fn(S) & ...))}
# NOTE: xi could also be constants, rather than existentially-quantified variables
#NOMINAL_COORDINATION -> AND:require_and NOMINAL_R:remove_coordinator,remove_comma NOMINAL_COORDINATION
#NOMINAL_COORDINATION -> COMMA:require_comma AND:require_and NOMINAL_R:remove_coordinator,remove_comma NOMINAL_COORDINATION
# NOMINAL_COORDINATION {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & S=^[x]:x=x1) & ![x]:(S(x) => ![y]:(x(y) => P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & S=^[x]:x=x1) & ![x]:(S(x) => P(x))))}
#  -> (COMMA) AND NOMINAL_R {^[P]:(... & ?[x1]:(f1(x1) & P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & ![x]:(x1(x) => P(x))))} if x1 is a set
# NOMINAL_COORDINATION {^[P]:(... & ?[S]:(F(S=^[x]:f1(x)) & ...))}
#  -> (COMMA) AND NOMINAL_R {^[P]:(... & ?[S]:(F(S=^[x]:f1(x)) & ...))}
# NOMINAL_COORDINATION {^[P]:(... & ?[S]:(F1(S) & ...))}
#  -> (COMMA) AND NOMINAL_R {^[P]:(... & ?[S]:(F1(S) & ...))}
# NOTE: xi could also be constants, rather than existentially-quantified variables
#NOMINAL_COORDINATION -> AND:require_and NOMINAL_R:remove_coordinator,remove_comma
#NOMINAL_COORDINATION -> COMMA:require_comma AND:require_and NOMINAL_R:remove_coordinator,remove_comma

# NOTE: In the below rules, we require that none of the Ai are themselves
# coordinations with the coordinator (unless Ai is negated).
# NOMINAL_COORDINATION {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & P(x))))}
#  -> (COMMA) OR NOMINAL_R {^[P]:(... & ?[x1]:(f1(x1) & P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & ![x]:(x1(x) => P(x))))} if x1 is a set
#     NOMINAL_COORDINATION {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ?[x]:(S(x) & P(x))))}
# NOTE: xi could also be constants, rather than existentially-quantified variables
#NOMINAL_COORDINATION -> OR:require_or NOMINAL_R:remove_coordinator,remove_comma NOMINAL_COORDINATION
#NOMINAL_COORDINATION -> COMMA:require_comma OR:require_or NOMINAL_R:remove_coordinator,remove_comma NOMINAL_COORDINATION
# NOMINAL_COORDINATION {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & S=^[x]:x=x1) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & S=^[x]:x=x1) & ?[x]:(S(x) & P(x))))}
#  -> (COMMA) OR NOMINAL_R {^[P]:(... & ?[x1]:(f1(x1) & P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & ![x]:(x1(x) => P(x))))} if x1 is a set
# NOTE: xi could also be constants, rather than existentially-quantified variables
#NOMINAL_COORDINATION -> OR:require_or NOMINAL_R:remove_coordinator,remove_comma
#NOMINAL_COORDINATION -> COMMA:require_comma OR:require_or NOMINAL_R:remove_coordinator,remove_comma

# NOTE: In the below rules, we require that none of the Ai are themselves
# coordinations with the coordinator (unless Ai is negated).
# NOMINAL_COORDINATION {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))) & ?[x]:(S(x) & P(x))))}
#  -> (COMMA) NOR NOMINAL_R {^[P]:(... & ?[x1]:(f1(x1) & P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & ![x]:(x1(x) => P(x))))} if x1 is a set
#     NOMINAL_COORDINATION {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))) & ?[x]:(S(x) & P(x))))}
# NOTE: xi could also be constants, rather than existentially-quantified variables
#NOMINAL_COORDINATION -> NOR:require_nor NOMINAL_R:add_req_aux,remove_coordinator,remove_comma,add_negative NOMINAL_COORDINATION
#NOMINAL_COORDINATION -> COMMA:require_comma NOR:require_nor NOMINAL_R:add_req_aux,remove_coordinator,remove_comma,add_negative NOMINAL_COORDINATION
# NOMINAL_COORDINATION {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & S=^[x]:x=x1) & ?[x]:(S(x) & ?[y]:(x(y) & P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & S=^[x]:x=x1) & ?[x]:(S(x) & P(x))))}
#  -> (COMMA) NOR NOMINAL_R {^[P]:(... & ?[x1]:(f1(x1) & P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & ![x]:(x1(x) => P(x))))} if x1 is a set
# NOTE: xi could also be constants, rather than existentially-quantified variables
#NOMINAL_COORDINATION -> NOR:require_nor NOMINAL_R:add_req_aux,remove_coordinator,remove_comma,add_negative
#NOMINAL_COORDINATION -> COMMA:require_comma NOR:require_nor NOMINAL_R:add_req_aux,remove_coordinator,remove_comma,add_negative


N_ADJUNCT nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# appositives
# N_ADJUNCT {... & ?[x]:(p(x) & (x=a1 & ... & x=an))}
#  -> NP {^[P]:?[Y]:(Y=^[y]:(y=a1 | ... | y=an) & ?[y]:(Y(y) & P(y)))}
# N_ADJUNCT {... & ?[x]:(p(x) & (?[y1]:(f1(y1) & x=y1) & ... & ?[yn]:(fn(yn) & x=yn)))}
#  -> NP {^[P]:?[y1]:(f1(y1) & ... & ?[yn]:(fn(yn) & ?[Y]:(Y=^[y]:(y=y1 | ... | y=yn) & ?[y]:(Y(y) & P(y)))))}
# e.g. "Kim Jones, President of the Union, ...", "the year 2024"
#N_ADJUNCT -> NP
#N_ADJUNCT -> COMMA NP COMMA
#N_ADJUNCT -> OF NP

# N_ADJUNCT {A} -> PP {A}
#  e.g. "destruction of the barn(s)", "destruction of the barn(s) by the termites"
N_ADJUNCT -> PP

# N_ADJUNCT  {... & ?[x]:(p(x) & g(x))}
#  -> ADJP_R/PP {... & g'}
# where g(x) = (~)?[z]:(h(z) & arg1/arg2(z)=x) and g' = (~)?[z]:h(z)
#    or g(x) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=x) & ... & (~)?[zn]:(hn(zn) & arg1/arg2(zn)=x) and g' = (~)?[z1]:h1(z1) & ... & (~)?[zn]:hn(zn)
#    or g(x) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=x) | ... | (~)?[zn]:(hn(zn) & arg1/arg2(zn)=x) and g' = (~)?[z1]:h1(z1) | ... | (~)?[zn]:hn(zn)
# Note that g(x) may also contain variables which are universally-quantified,
# above the scope of zi, either within the scope of xi (e.g. "i like the house
# next to the trees") or above it ("a student from each class spoke to her").
# In this case, the universal quantifiers are also moved into g'.
N_ADJUNCT -> PP:try_remove_correlated,select_right_arg1_of_without_head
N_ADJUNCT -> PP:try_remove_correlated,select_right_arg2_of_without_head
N_ADJUNCT -> ADJP_R:try_remove_correlated,select_right_arg1_of_without_head
N_ADJUNCT -> ADJP_R:try_remove_correlated,select_right_arg2_of_without_head

# comparative constructions
# N_ADJUNCT {... & ?[r]:(... & ?[g1]:(U(i1,g1) & p(f1)(g1) & arg2(g1)=r) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & arg2(gn)=r) & ... & h(r) & ...)}
#  -> COMP {p}
#     V_ADJUNCT {h'}
# N_ADJUNCT {... & ?[R]:(... & p_comp(size(R)) & ... & ![r]:(R(r) => ?[g1]:(U(i1,g1) & p(f1)(g1) & arg2(g1)=r) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & arg2(gn)=r)) & ... & R=^[r]:h(r) & ...)}
#  -> COMP {p}
#     V_ADJUNCT {h'}
# N_ADJUNCT {... & ?[R]:(?[R1]:(... & p_comp(size(R1)) & ... & ![r]:(R(r) => ?[g1]:(U(i1,g1) & p(f1)(g1) & arg2(g1)=r) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & arg2(gn)=r)) & ... & ?[R2]:(... & p_comp(size(R2)) & ... & R=^[S]:(S=R1 | ... | S=Rn))) & ... & ![Ri]:(R(Ri) => Ri=^[r]:h(r)) & ...)}
#  -> COMP {p}
#     V_ADJUNCT {h'}
# where h(r) = r=a and h' = ?[gn]:(arg2(gn)=a)
#    or h(r) = U(i,r) & p(r) & ?[x]:(arg1/arg2(x)=r & ...) and h' = ?[gn]:(?[r]:(U(i,r) & p(r) & ?[x]:(arg1/arg2(x)=r & ...))) (TODO: what is this? where is it even used?)
#    or h(r) = ?[x]:(arg1/arg2(x)=r & ...) and h' = ?[x]:(...)
# NOTE: The predicate could also be a simple `p` rather than `p(f)`. The terms
# `p_comp(size(X),size(R))` and `?[gi]:(...)` are optional (but there must be
# at least one). The term `p_comp(size(X),size(R))` handles comparative
# constructions where sizes of sets are compared.
# e.g. "brighter star than Vega", "more people than last time", "more girls but fewer boys than last time"
#N_ADJUNCT -> COMP V_ADJUNCT:try_remove_correlated

# N_ADJUNCT {... & ?[x]:(... & ?[g1]:(p(x) & arg1/arg2/arg3(g1)=x) & ... & ?[gn]:(... & arg1/arg2/arg3(gn)=x))}
#  -> (COMMA) (THAT) S' {?[g1]:(...) & ... & ?[gn]:(...)} (COMMA)
# e.g. "the book (that) I gave Kim"
#N_ADJUNCT -> S' # TODO: remove grammatical features from S'
#N_ADJUNCT -> S':add_that,add_nullable_subject # TODO: remove grammatical features from S'
#N_ADJUNCT -> COMMA S':add_that,add_nullable_subject COMMA # TODO: remove grammatical features from S'

# N_ADJUNCT {... & ?[x]:(p(x) & ?[y]:(g(y) & arg1/arg2(x)=y))}
#  -> (COMMA) (THAT) S' {... & ?[y]:g(y)} (COMMA)
# e.g. "the toys (that) you don't want"
# N_ADJUNCT {... & ?[x]:(p(x) & arg2(x)=^[y]:g(y))}
#  -> (THAT) S' {... & ?[y]:g(y)}
# NOTE: This second rule does not allow a comma.
# e.g. "last time (that) i went to campus"
#N_ADJUNCT -> S' # TODO: remove grammatical features from S'
#N_ADJUNCT -> S':add_that,add_nullable_subject # TODO: remove grammatical features from S'
#N_ADJUNCT -> COMMA S':add_that,add_nullable_subject COMMA # TODO: remove grammatical features from S'
# e.g. "the demand that she be here"
#N_ADJUNCT -> S':add_that,add_subjunctive # TODO: remove grammatical features from S'
#N_ADJUNCT -> COMMA S':add_that,add_subjunctive COMMA # TODO: remove grammatical features from S'

# closed interrogative finite subordinate clause
# N_ADJUNCT {... & ?[x]:(p(x) & g(x))}
#  -> IF/WHETHER S' {... & g'}
# where g(x) = arg2(x)=^[y]:A and g' = ^[y]:A
# e.g. "the question whether he arrived or not"
#N_ADJUNCT -> S':add_req_no_aux,add_whether

# open interrogative finite subordinate clause (relative clauses)
# N_ADJUNCT {... & ?[x]:(p(x) & A(x))}
#  -> (COMMA) S' {^[x]:A(x)} (COMMA)
# TODO: Integrated relative clauses require there be no commas.
# e.g. "the toys which you don't want", "the people whose house we are renting", "the state through which the Allegheny runs", "a problem with which to challenge the students"
#N_ADJUNCT -> S':add_req_no_aux,add_subordinate
#N_ADJUNCT -> COMMA S':add_req_no_aux,add_subordinate COMMA

# relative clauses where the relative phrase is a complement of a preposition
# N_ADJUNCT {... & ?[x]:(f(x) & A(?[y]:(g(y) & arg2(y)=x)))}
#  -> (COMMA) THAT S' {A(?[y]:(g(y) & ?[x]:(U(i,x) & empty_ref(x) & arg2(y)=x)))} (COMMA)
# TODO: Integrated relative clauses require there be no commas.
# e.g. "the knife (that) he was trying to cut it with"
#N_ADJUNCT -> S' # TODO: remove grammatical features from S'
#N_ADJUNCT -> S':add_that,add_nullable_subject # TODO: remove grammatical features from S'
#N_ADJUNCT -> COMMA S':add_that,add_nullable_subject COMMA # TODO: remove grammatical features from S'

# N_ADJUNCT {... & ?[x]:(p(x) & (?[g1]:(... & arg1(g1)=x) & ... & ?[gn]:(... & arg1(gn)=x)))}
#  -> VP_R {?[g1]:(...) & ... & ?[gn]:(...)}
# e.g. "the cat sleeping on the bed"
#N_ADJUNCT -> VP_R:require_present_participle

# N_ADJUNCT {... & ?[x]:(p(x) & ?[g1]:(p1(g1) & ... & arg2(g1)=x) & ... & ?[gn]:(pn(gn) & ... & arg2(gn)=x))}
#  -> VP_R {?[g1]:(inverse(p1)(g1) & ...) & ... & ?[gn]:(inverse(pn)(gn) & ...)}
# e.g. "the letter written by me"
#N_ADJUNCT -> VP_R:invert_predicate,require_past_participle

# N_ADJUNCT {... & ?[x]:(p(x) & ?[g1]:(... & arg1(g1)=x) & ... & ?[gn]:(... & arg1(gn)=x))}
#  -> VP_R {?[g1]:(...) & ... & ?[gn]:(...)}
# e.g. "the person to see the comet", "decision to go to Boston"
#N_ADJUNCT -> VP_R:add_to_infinitive

# for correlated coordination
# NOTE: For the following rules, the coordination doesn't have to be at head
# scope, it can be the left-most coordination that is a descendant of the head
# scope as well, so long as there is no negation between the coordination and
# the root. However, we need some measure of "distance" between the
# coordination and the head scope to be a feature to decide between the rules
# at this nonterminal (e.g. "both" moves left much less often than "either").
# N_ADJUNCT {... & ?[x]:(p(x) & (?[x1]:f1(x1) | ... | ?[xn]:fn(xn)))} -> EITHER N_ADJUNCT {... & ?[x]:(p(x) & (?[x1]:f1(x1) | ... | ?[xn]:fn(xn)))}
#N_ADJUNCT -> N_ADJUNCT:require_not_correlated,add_either,add_correlated_by_either # this transformation requires the coordination is at the head
#N_ADJUNCT -> EITHER:require_not_correlated N_ADJUNCT:add_correlated_by_either # this transformation requires the coordination is a descendant of the head
# N_ADJUNCT {... & ?[x]:(p(x) & (?[x1]:f1(x1) & ?[x2]:f2(x2)))} -> BOTH N_ADJUNCT {... & ?[x]:(p(x) & (?[x1]:f1(x1) & ?[x2]:f2(x2)))}
#N_ADJUNCT -> N_ADJUNCT:require_not_correlated,add_both,add_correlated_by_both # this transformation requires the coordination is at the head
#N_ADJUNCT -> BOTH:require_not_correlated N_ADJUNCT:add_correlated_by_both # this transformation requires the coordination is a descendant of the head
# N_ADJUNCT {... & ?[x]:(p(x) & (~?[x1]:f1(x1) | ... | ~?[xn]:fn(xn)))} -> NEITHER N_ADJUNCT {... & ?[x]:(p(x) & (?[x1]:f1(x1) | ... | ?[xn]:fn(xn)))}
#N_ADJUNCT -> N_ADJUNCT:require_not_correlated,add_neither,add_correlated_by_neither # this transformation requires the coordination is at the head
#N_ADJUNCT -> NEITHER:require_not_correlated N_ADJUNCT:add_correlated_by_neither,add_negative # this transformation requires the coordination is a descendant of the head

# NOTE: In the below rules, we require that none of the Ai are themselves
# coordinations with the coordinator (unless Ai is negated).
# N_ADJUNCT {... & ?[x]:(p(x) & ((~)?[x1]:f1(x1) & ... & (~)?[xn]:fn(xn)))} -> N_ADJUNCT {... & ?[x]:(p(x) & (~)?[x1]:f1(x1))} N_ADJUNCT_COORDINATION {... & ?[x]:(p(x) & ((~)?[x2]:f2(x2) & ... & (~)?[xn]:fn(xn)))}
#N_ADJUNCT -> N_ADJUNCT N_ADJUNCT_COORDINATION:try_remove_correlator,add_and
#N_ADJUNCT -> N_ADJUNCT N_ADJUNCT_COORDINATION:try_remove_correlator,add_and,add_comma
# N_ADJUNCT {... & ?[x]:(p(x) & ((~)?[x1]:f1(x1) | ... | (~)?[xn]:fn(xn)))} -> N_ADJUNCT {... & ?[x]:(p(x) & (~)?[x1]:f1(x1))} N_ADJUNCT_COORDINATION {... & ?[x]:(p(x) & ((~)?[x2]:f2(x2) | ... | (~)?[xn]:fn(xn)))}
#N_ADJUNCT -> N_ADJUNCT N_ADJUNCT_COORDINATION:try_remove_correlator,add_or
#N_ADJUNCT -> N_ADJUNCT N_ADJUNCT_COORDINATION:try_remove_correlator,add_or,add_comma
# N_ADJUNCT {... & ?[x]:(p(x) & ((~)?[x1]:f1(x1) | ... | (~)?[xn]:fn(xn)))} -> N_ADJUNCT {... & ?[x]:(p(x) & (~)?[x1]:f1(x1))} N_ADJUNCT_COORDINATION {... & ?[x]:(p(x) & ((~)?[x2]:f2(x2) | ... | (~)?[xn]:fn(xn)))}
#N_ADJUNCT -> N_ADJUNCT N_ADJUNCT_COORDINATION:try_remove_correlator,add_nor,require_negative
#N_ADJUNCT -> N_ADJUNCT N_ADJUNCT_COORDINATION:try_remove_correlator,add_nor,require_negative,add_comma

# N_ADJUNCT {... & ?[x]:(p(x) & but((~)?[x1]:f1(x1),(~)?[x2]:f2(x2)))} -> N_ADJUNCT {... & ?[x]:(p(x) & (~)?[x1]:f1(x1))} N_ADJUNCT_COORDINATION {... & ?[x]:(p(x) & (~)?[x2]:f2(x2))}
#N_ADJUNCT -> N_ADJUNCT BUT N_ADJUNCT:try_remove_correlator
#N_ADJUNCT -> N_ADJUNCT COMMA BUT N_ADJUNCT:try_remove_correlator

# N_ADJUNCT {... & ?[x]:(p(x) & instead_of((~)?[x1]:f1(x1),(~)?[x2]:f2(x2)))} -> N_ADJUNCT {... & ?[x]:(p(x) & (~)?[x1]:f1(x1))} N_ADJUNCT_COORDINATION {... & ?[x]:(p(x) & (~)?[x2]:f2(x2))}
#N_ADJUNCT -> N_ADJUNCT NOT N_ADJUNCT:try_remove_correlator,add_negative
#N_ADJUNCT -> N_ADJUNCT COMMA NOT N_ADJUNCT:try_remove_correlator,add_negative


N_ADJUNCT_COORDINATION nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# N_ADJUNCT_COORDINATION {... & ?[x]:(p(x) & ((~)?[x1]:f1(x1) & ... & (~)?[xn]:fn(xn)))} -> COMMA N_ADJUNCT {... & ?[x]:(p(x) & (~)?[x1]:f1(x1))} N_ADJUNCT_COORDINATION {... & ?[x]:(p(x) & ((~)?[x2]:f2(x2) & ... & (~)?[xn]:fn(xn)))}
# N_ADJUNCT_COORDINATION {... & ?[x]:(p(x) & ((~)?[x1]:f1(x1) | ... | (~)?[xn]:fn(xn)))} -> COMMA N_ADJUNCT {... & ?[x]:(p(x) & (~)?[x1]:f1(x1))} N_ADJUNCT_COORDINATION {... & ?[x]:(p(x) & ((~)?[x2]:f2(x2) | ... | (~)?[xn]:fn(xn)))}
#N_ADJUNCT_COORDINATION -> COMMA:require_comma N_ADJUNCT:remove_coordinator,remove_comma N_ADJUNCT_COORDINATION
# N_ADJUNCT_COORDINATION {... & ?[x]:(p(x) & (~)?[x1]:f1(x1))} -> COMMA N_ADJUNCT {... & ?[x]:(p(x) & (~)?[x1]:f1(x1))}
#N_ADJUNCT_COORDINATION -> COMMA:require_comma N_ADJUNCT:remove_coordinator,remove_comma

# N_ADJUNCT_COORDINATION {... & ?[x]:(p(x) & ((~)?[x1]:f1(x1) & ... & (~)?[xn]:fn(xn)))} -> (COMMA) AND N_ADJUNCT {... & ?[x]:(p(x) & (~)?[x1]:f1(x1))} N_ADJUNCT_COORDINATION {... & ?[x]:(p(x) & ((~)?[x2]:f2(x2) & ... & (~)?[xn]:fn(xn)))}
#N_ADJUNCT_COORDINATION -> AND:require_and N_ADJUNCT:remove_coordinator,remove_comma N_ADJUNCT_COORDINATION
#N_ADJUNCT_COORDINATION -> COMMA:require_comma AND:require_and N_ADJUNCT:remove_coordinator,remove_comma N_ADJUNCT_COORDINATION
# N_ADJUNCT_COORDINATION {... & ?[x]:(p(x) & (~)?[x1]:f1(x1))} -> (COMMA) AND N_ADJUNCT {... & ?[x]:(p(x) & (~)?[x1]:f1(x1))}
#N_ADJUNCT_COORDINATION -> AND:require_and N_ADJUNCT:remove_coordinator,remove_comma
#N_ADJUNCT_COORDINATION -> COMMA:require_comma AND:require_and N_ADJUNCT:remove_coordinator,remove_comma

# N_ADJUNCT_COORDINATION {... & ?[x]:(p(x) & ((~)?[x1]:f1(x1) | ... | (~)?[xn]:fn(xn)))} -> (COMMA) OR N_ADJUNCT {... & ?[x]:(p(x) & (~)?[x1]:f1(x1))} N_ADJUNCT_COORDINATION {... & ?[x]:(p(x) & ((~)?[x2]:f2(x2) | ... | (~)?[xn]:fn(xn)))}
#N_ADJUNCT_COORDINATION -> OR:require_or N_ADJUNCT:remove_coordinator,remove_comma N_ADJUNCT_COORDINATION
#N_ADJUNCT_COORDINATION -> COMMA:require_comma OR:require_or N_ADJUNCT:remove_coordinator,remove_comma N_ADJUNCT_COORDINATION
# N_ADJUNCT_COORDINATION {... & ?[x]:(p(x) & (~)?[x1]:f1(x1))} -> (COMMA) OR N_ADJUNCT {... & ?[x]:(p(x) & (~)?[x1]:f1(x1))}
#N_ADJUNCT_COORDINATION -> OR:require_or N_ADJUNCT:remove_coordinator,remove_comma
#N_ADJUNCT_COORDINATION -> COMMA:require_comma OR:require_or N_ADJUNCT:remove_coordinator,remove_comma

# N_ADJUNCT_COORDINATION {... & ?[x]:(p(x) & ((~)?[x1]:f1(x1) | ... | (~)?[xn]:fn(xn)))} -> (COMMA) NOR N_ADJUNCT {... & ?[x]:(p(x) & (~)?[x1]:f1(x1))} N_ADJUNCT_COORDINATION {... & ?[x]:(p(x) & ((~)?[x2]:f2(x2) | ... | (~)?[xn]:fn(xn)))}
#N_ADJUNCT_COORDINATION -> NOR:require_nor N_ADJUNCT:add_req_aux,remove_coordinator,remove_comma,add_negative N_ADJUNCT_COORDINATION
#N_ADJUNCT_COORDINATION -> COMMA:require_comma NOR:require_nor N_ADJUNCT:add_req_aux,remove_coordinator,remove_comma,add_negative N_ADJUNCT_COORDINATION
# N_ADJUNCT_COORDINATION {... & ?[x]:(p(x) & (~)?[x1]:f1(x1))} -> (COMMA) NOR N_ADJUNCT {... & ?[x]:(p(x) & (~)?[x1]:f1(x1))}
#N_ADJUNCT_COORDINATION -> NOR:require_nor N_ADJUNCT:add_req_aux,remove_coordinator,remove_comma,add_negative
#N_ADJUNCT_COORDINATION -> COMMA:require_comma NOR:require_nor N_ADJUNCT:add_req_aux,remove_coordinator,remove_comma,add_negative


# pronouns
PRO nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# PRO {^[P]:?[X]:(^[x]:(x=me) & ?[x]:(X(x) & P(x)))} -> I/ME
#PRO -> I
#PRO -> ME

# PRO {^[P]:?[X]:(^[x]:(x=you) & ?[x]:(X(x) & P(x)))} -> YOU
#PRO -> YOU

# PRO {^[P]:?[X]:(^[x]:(U(0,x) & female_ref(0,x)) & ?[x]:(X(x) & P(x)))} -> SHE/HER
#PRO -> SHE
#PRO -> HER

# PRO {^[P]:?[X]:(^[x]:(U(0,x) & male_ref(0,x)) & ?[x]:(X(x) & P(x)))} -> HE/HIM
#PRO -> HE
#PRO -> HIM

# PRO {^[P]:?[X]:(^[x]:(U(0,x) & ref(0,x)) & ?[x]:(X(x) & P(x)))} -> IT
#PRO -> IT

# PRO {^[P]:?[X]:(plural_ref(X) & ?[x]:(X(x) & P(x)))} -> THEY/THEM
#PRO -> THEY
#PRO -> THEM

# PRO {^[P,x]:?[X]:(X=^[x]:U(0,x) & X(x) & P(x))} -> WHICH/WHAT/WHICHEVER/WHATEVER
#PRO -> WHICH
#PRO -> WHAT
#PRO -> WHICHEVER
#PRO -> WHATEVER

# PRO {^[P,x]:?[X]:(X=^[x]:(U(0,x) & animate(x)) & X(x) & P(x))} -> WHO/WHOM/WHOEVER/WHOMEVER
#PRO -> WHO
#PRO -> WHOM
#PRO -> WHOEVER
#PRO -> WHOMEVER

# PRO {^[P,x]:?[X]:(X=^[x]:(U(0,x) & location(x)) & X(x) & P(x))} -> WHERE/WHEREVER
#PRO -> WHERE
#PRO -> WHEREVER


# this noun phrase nonterminal is for left-side modifiers
NOMINAL_L nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# NOMINAL_L {^[P]:?[X]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x)))} -> N {a}
# NOMINAL_L {^[P]:?[X]:(X=^[x]:(U(0,x) & p(x)) & ?[x]:(X(x) & P(x)))} -> N {p}
# NOMINAL_L {^[P]:?[X]:(X=^[x]:(U(0,x) & p(x)) & ![x]:(X(x) => P(x)))} -> N {p}
# This depends on whether `p` is an event (i.e. typically has arguments, even
# if it doesnt in this particular logical form).
NOMINAL_L -> N:require_no_correlator,select_predicate_in_set

# NOMINAL_L {^[P]:?[X]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x)))} -> V {a}
# NOMINAL_L {^[P]:?[X]:(X=^[x]:(U(0,x) & p(x)) & ?[x]:(X(x) & P(x)))} -> V {p}
# NOMINAL_L {^[P]:?[X]:(X=^[x]:(U(0,x) & p(x)) & ![x]:(X(x) => P(x)))} -> V {p}
# This depends on whether `p` is an event (i.e. typically has arguments, even
# if it doesnt in this particular logical form).
NOMINAL_L -> V:require_no_correlator,select_predicate_in_set,add_tion

# NOMINAL_L {^[P]:?[X]:(X=^[x]:(?[y]:(U(0,y) & p(y) & arg1(p)=x)) & ?[x]:(X(x) & P(x)))} -> V {p}
# NOMINAL_L {^[P]:?[X]:(X=^[x]:(?[y]:(U(0,y) & p(y) & arg1(p)=x)) & ![x]:(X(x) => P(x)))} -> V {p}
#NOMINAL_L -> V:require_no_correlator,add_er # this adds "ers" if the number is plural, as well as any duplicated consonants if appropriate (i.e. "programmers")

# NOMINAL_L {^[P]:(... & ?[X]:(F(X=^[x]:(... & f(x))) & ... & ![x]:(X(x) => P(x))))}
#  -> ADJP_R {... & f'}
#     NOMINAL_L {^[P]:(... & ?[X]:(F(X=^[x]:(...) & ... & ![x]:(X(x) => P(x))))}
# where f(x) = (~)?[z]:(h(z) & arg1/arg2(z)=x) and f' = (~)?[z]:h(z)
#    or f(x) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=x) & ... & (~)?[zn]:(hn(zn) & arg1/arg2(zn)=x) and f' = (~)?[z1]:h1(z1) & ... & (~)?[zn]:hn(zn)
#    or f(x) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=x) | ... | (~)?[zn]:(hn(zn) & arg1/arg2(zn)=x) and f' = (~)?[z1]:h1(z1) | ... | (~)?[zn]:hn(zn)
# NOTE: This rule also works if X is existentially-quantified or used collectively.
#NOMINAL_L -> ADJP_R:try_remove_genitive NOMINAL_L:try_remove_correlated

# NOMINAL_L {^[P]:(... & ?[X]:(F(X=^[x]:(... & f(x))) & ... & ![x]:(X(x) => P(x))))}
#  -> ADJP_R {... & f'}
#     NOMINAL_L {^[P]:(... & ?[X]:(F(X=^[x]:(...) & ... & ![x]:(X(x) => P(x))))}
# where f(x) = (~)?[z]:(h(z) & arg1/arg2(z)=x) and f' = (~)?[z]:h(z)
#    or f(x) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=x) & ... & (~)?[zn]:(hn(zn) & arg1/arg2(zn)=x) and f' = (~)?[z1]:h1(z1) & ... & (~)?[zn]:hn(zn)
#    or f(x) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=x) | ... | (~)?[zn]:(hn(zn) & arg1/arg2(zn)=x) and f' = (~)?[z1]:h1(z1) | ... | (~)?[zn]:hn(zn)
# NOTE: This rule also works if X is existentially-quantified or used collectively.
#NOMINAL_L -> ADJP_R:try_remove_genitive NOMINAL_L:try_remove_correlated

# NOMINAL_L {^[P]:(... & ?[X]:(F(X) & ?[g1]:(... & P(arg1(g1)) & ... & greatest/least(f)(g1) & ... & arg2(g1)=X) & ... & ?[gn]:(... & P(arg1(gn)) & ... & greatest/least(f)(gn) & ... & arg2(gn)=X)))}
#  -> ADJP_R {?[g1]:greatest/least(f)(g1) & ... & ?[gn]:greatest/least(f)(gn)}
#     NOMINAL_L {^[P]:(... & ?[X]:(F(X) & ?[x]:(X(x) & P(x))))}
# e.g. "closest and brightest star"
#NOMINAL_L -> ADJP_R:try_remove_genitive NOMINAL_L:try_remove_correlated

# NOMINAL_L {^[P]:(... & ?[X]:(F(X=^[x]:(?[s]:(arg2(s)=a & ... & arg1(s)=x) & U(0,x)))) & ...)}
#  -> NOMINAL_L {^[P]:?[Y]:(Y=^[y]:(y=a) & ?[y]:(Y(y) & P(y)))}
#     NOMINAL_L {^[P]:(... & ?[X]:(F(X=^[x]:(?[s]:(... & arg1(s)=x) & U(0,x)))) & ...)}
# NOMINAL_L {^[P]:(... & ?[X]:(F(X=^[x]:(?[s]:(?[y]:(f(y) & arg2(s)=y) & ... & arg1(s)=x) & U(0,x)))) & ...)}
#  -> NOMINAL_L {^[P]:?[Y]:(Y=^[y]:f(y) & ?[y]:(Y(y) & P(y)))}
#     NOMINAL_L {^[P]:(... & ?[X]:(F(X=^[x]:(?[s]:(... & arg1(s)=x) & U(0,x)))) & ...)}
# e.g. "potion seller"
#NOMINAL_L -> NOMINAL_L:try_remove_genitive NOMINAL_L:try_remove_correlated

# NOMINAL_L {^[P]:(... & ?[X]:(F(X=^[x]:(?[c]:(consists_of(c) & arg1(c)=x & arg2(c)=a) & ...)) & ...))}
#  -> NOMINAL_L {^[P]:?[Y]:(Y=^[y]:(y=a) & ?[y]:(Y(y) & P(y)))}
#     NOMINAL_L {^[P]:(... & ?[X]:(F(X=^[x]:(...)) & ...))}
# NOMINAL_L {^[P]:(... & ?[X]:(F(X=^[x]:(?[c]:(consists_of(c) & ?[y]:(f(y) & arg1(c)=y) & arg2(c)=a) & ...)) & ...))}
#  -> NOMINAL_L {^[P]:?[Y]:(Y=^[y]:f(y) & ?[y]:(Y(y) & P(y)))}
#     NOMINAL_L {^[P]:(... & ?[X]:(F(X=^[x]:(...)) & ...))}
# e.g. "apple pie"
# TODO: what about "California Senator"
#NOMINAL_L -> NOMINAL_L:try_remove_genitive NOMINAL_L:try_remove_correlated # for `consists_of` (or maybe `contains`?)
#NOMINAL_L -> NOMINAL_L:try_remove_genitive NOMINAL_L:try_remove_correlated # for `purpose`
#NOMINAL_L -> NOMINAL_L:try_remove_genitive NOMINAL_L:try_remove_correlated # for `location`

# NOMINAL_L {^[P]:(... & ?[X]:(F(X=^[x]:(?[m1]:(g1(m1) & arg1/arg2(m1)=x) & ... & ?[mn]:(gn(mn) & arg1/arg2(mn)=x) & ...)) & ...))}
#  -> VP_L {?[m1]:g1(m1) & ... & ?[mn]:gn(mn)}
#     NOMINAL_L {^[P]:(... & ?[X]:(F(X=^[x]:(...)) & ...))}
# e.g. "recently published article", "melting marshmellows"
#NOMINAL_L -> VP_L:try_remove_genitive,add_present_participle NOMINAL_L:try_remove_correlated
#NOMINAL_L -> VP_L:try_remove_genitive,add_past_participle NOMINAL_L:try_remove_correlated


PP nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# transitive prepositions
# PP {... & ?[x]:(U(i,x) & p(x) & arg1/arg2/arg3(x)=a)}
#  -> P {?[x]:(U(i,x) & p(x))}
#     NP {^[P]:?[Y]:(Y=^[y]:(y=a) & ?[y]:(Y(y) & P(y)))}
# PP {... & ?[x]:(U(i,x) & p(x) & arg1/arg2/arg3(x)=possibility(A))}
#  -> P {?[x]:(U(i,x) & p(x))}
#     NP {^[P]:A'} where p is something that expresses possibility like `capable_of`, and A' has a `P(z)` term added to the head scope (it will also need to be changed into the set-centric form expected by NP)
# PP {... & ?[x]:(U(i,x) & p(x) & ?[y]:(f(y) & arg1/arg2/arg3(x)=y))}
#  -> P {?[x]:(U(i,x) & p(x))}
#     NP {^[P]:?[Y]:(Y=^[y]:f(y) & ?[y]:(Y(y) & P(y)))}
# PP {... & ![y]:(f(y) => ?[x]:(U(i,x) & p(x) & arg1/arg2/arg3(x)=y))}
#  -> P {?[x]:(U(i,x) & p(x))}
#     NP {^[P]:?[Y]:(Y=^[y]:f(y) & ![y]:(Y(y) => P(y)))}
# PP {... & ?[Y]:(F(Y) & ... & ![y]:(Y(y) => ?[x]:(U(i,x) & p(x) & arg1/arg2/arg3(x)=y)))}
#  -> P {?[x]:(U(i,x) & p(x))}
#     NP {^[P]:?[Y]:(F(Y) & ![y]:(Y(y) => P(y)))}
# e.g. "house(s) next to the tree(s)"
PP -> P:require_no_preposition,remove_right_conjunct NP:try_remove_correlated,try_remove_is_adjunct,select_right_arg2_without_head_predicative_and_factor
# e.g. "friend of Mary's", "eyes of Mary's"
#PP -> P:require_no_preposition,remove_right_conjunct NP:add_genitive,try_remove_correlated,try_remove_is_adjunct
# for prepositional verbs (i.e. "look forward to", etc)
#PP -> P_PLACEHOLDER:require_preposition,remove_right_conjunct NP:try_remove_correlated,try_remove_is_adjunct

# for (intransitive) prepositional verbs (i.e. "look forward to", etc)
# PP {... & ?[x]:(U(i,x) & p(x))}
#  -> P {p}
#PP -> P_PLACEHOLDER:require_preposition NP:try_remove_correlated,try_remove_is_adjunct

# PP {... & ?[x]:(U(i,x) & p(x) & ?[y]:(f(y) & arg1/arg2(x)=y))}
#  -> P {p}
#     S' {... & ?[y]:f(y)}
# e.g. "before the meeting ended"
#PP -> P:require_no_preposition S':try_remove_correlated,try_remove_is_adjunct

# closed interrogative finite subordinate clause
# PP {... & (~)?[y]:(g(y) & f(y))}
#  -> P {p}
#     S' {... & f'}
# where f(y) = arg2(y)=^[x]:A and f' = ^[x]:A
# e.g. "he is worried about whether or not the game ended"
#PP -> P S':add_req_no_aux,add_whether,try_remove_correlated,try_remove_is_adjunct

# open interrogative finite subordinate clause
# PP {^[P]:(... & (~)?[y]:(g(y) & f(y))}
#  -> P {p}
#     S' {... & f'}
# where f(y) = arg2(y)=^[x]:A and f' = ^[x]:A
# e.g. "he is worried about when she will arrive"
#PP -> P S':add_req_no_aux,add_subordinate,try_remove_correlated,try_remove_is_adjunct

# prepositional phrase complements
# PP {... & ?[x]:(U(i,x) & p(x) & f(x))}
#  -> P {p}
#     PP {... & ?[x]:(U(i,x) & p(x) & f(x))}
# e.g. "apart from Jill", "away from me", "since before the war"
PP -> P:require_no_preposition,predicate PP:add_preposition,try_remove_correlated,try_remove_is_adjunct

# postpositions
# PP {... & ?[x]:(U(i,x) & p(x) & arg1/arg2(x)=a)}
#  -> NP {^[P]:?[Y]:(Y=^[y]:(y=a) & ?[y]:(Y(y) & P(y)))}
#     P {p}
# PP {... & ?[x]:(U(i,x) & p(x) & arg1/arg2(x)=possibility(A))}
#  -> NP {^[P]:A'} where p is something that expresses possibility like `capable_of`, and A' has a `P(z)` term added to the head scope
#     P {p}
# PP {... & ?[x]:(U(i,x) & p(x) & ?[y]:(f(y) & arg1/arg2(x)=y))}
#  -> NP {^[P]:?[Y]:(Y=^[y]:f(y) & ?[y]:(Y(y) & P(y)))}
#     P {p}
# PP {... & ![y]:(f(y) => ?[x]:(U(i,x) & p(x) & arg1/arg2(x)=y))}
#  -> NP {^[P]:?[Y]:(Y=^[y]:f(y) & ![y]:(Y(y) => P(y)))}
#     P {p}
# PP {... & ?[Y]:(F(Y) & ... & ![y]:(Y(y) => ?[x]:(U(i,x) & p(x) & arg1/arg2(x)=y)))}
#  -> NP {^[P]:?[Y]:(F(Y) & ![y]:(Y(y) => P(y)))}
#     P {p}
# e.g. "ten years ago"
#PP -> NP:try_remove_is_adjunct POSTPOSITION:require_no_preposition

# PP {... & ~?[x]:f(x)}
#  -> NOT PP {... & ?[x]:f(x)}
#PP -> NOT PP:try_remove_correlated,add_negative,try_remove_is_adjunct

# PP {... & (~)?[x]:((~)?[v1]:g1(v1) & ... & (~)?[vn]:gn(vn) & f(x))}
#  -> ADVP_L {(~)?[v1]:g1(v1) & ... & (~)?[vn]:gn(vn)}
#     PP {... & (~)?[x]:f(x)}
#PP -> ADVP_L:try_remove_correlator PP:try_remove_correlated,try_remove_is_adjunct

# preposition stranding
# e.g. "what school did Jason run to?"
#PP -> P:require_no_preposition,require_empty_ref,require_no_correlator

PP -> EITHER:require_not_adjunct PP:remove_either
PP -> BOTH:require_not_adjunct PP:remove_both
PP -> NEITHER:require_not_adjunct PP:remove_neither,add_negative

# for correlated coordination
# NOTE: For the following rules, the coordination doesn't have to be at head
# scope, it can be the left-most coordination that is a descendant of the head
# scope as well, so long as there is no negation between the coordination and
# the root. However, we need some measure of "distance" between the
# coordination and the head scope to be a feature to decide between the rules
# at this nonterminal (e.g. "both" moves left much less often than "either").
# PP {... & ?[x]:(p(x) & (?[x1]:f1(x1) | ... | ?[xn]:fn(xn)))} -> EITHER PP {... & ?[x]:(p(x) & (?[x1]:f1(x1) | ... | ?[xn]:fn(xn)))}
#PP -> PP:require_not_correlated,require_not_adjunct,add_either,add_correlated_by_either # this transformation requires the coordination is at the head
#PP -> EITHER:require_not_correlated,require_not_adjunct PP:add_correlated_by_either # this transformation requires the coordination is a descendant of the head
# PP {... & ?[x]:(p(x) & (?[x1]:f1(x1) & ?[x2]:f2(x2)))} -> BOTH PP {... & ?[x]:(p(x) & (?[x1]:f1(x1) & ?[x2]:f2(x2)))}
#PP -> PP:require_not_correlated,require_not_adjunct,add_both,add_correlated_by_both # this transformation requires the coordination is at the head
#PP -> BOTH:require_not_correlated,require_not_adjunct PP:add_correlated_by_both # this transformation requires the coordination is a descendant of the head
# PP {... & ?[x]:(p(x) & (~?[x1]:f1(x1) | ... | ~?[xn]:fn(xn)))} -> NEITHER PP {... & ?[x]:(p(x) & (?[x1]:f1(x1) | ... | ?[xn]:fn(xn)))}
#PP -> PP:require_not_correlated,require_not_adjunct,add_neither,add_correlated_by_neither # this transformation requires the coordination is at the head
#PP -> NEITHER:require_not_correlated,require_not_adjunct PP:add_correlated_by_neither,add_negative # this transformation requires the coordination is a descendant of the head

# NOTE: In the below rules, we require that none of the Ai are themselves
# coordinations with the coordinator (unless Ai is negated).
# PP {... & ((~)?[x1]:f1(x1) & ... & (~)?[xn]:fn(xn))} -> PP {... & (~)?[x1]:f1(x1)} PP_COORDINATION {... & ((~)?[x2]:f2(x2) & ... & (~)?[xn]:fn(xn))}
#PP -> PP:require_not_adjunct PP_COORDINATION:try_remove_correlator,add_and
#PP -> PP:require_not_adjunct PP_COORDINATION:try_remove_correlator,add_and,add_comma
# PP {... & ((~)?[x1]:f1(x1) | ... | (~)?[xn]:fn(xn))} -> PP {... & (~)?[x1]:f1(x1)} PP_COORDINATION {... & ((~)?[x2]:f2(x2) | ... | (~)?[xn]:fn(xn))}
#PP -> PP:require_not_adjunct PP_COORDINATION:try_remove_correlator,add_or
#PP -> PP:require_not_adjunct PP_COORDINATION:try_remove_correlator,add_or,add_comma
# PP {... & ((~)?[x1]:f1(x1) | ... | (~)?[xn]:fn(xn))} -> PP {... & (~)?[x1]:f1(x1)} PP_COORDINATION {... & ((~)?[x2]:f2(x2) | ... | (~)?[xn]:fn(xn))}
#PP -> PP:require_not_adjunct PP_COORDINATION:try_remove_correlator,add_nor,require_negative
#PP -> PP:require_not_adjunct PP_COORDINATION:try_remove_correlator,add_nor,require_negative,add_comma

# PP {... & but((~)?[x1]:f1(x1),(~)?[x2]:f2(x2))} -> PP {... & (~)?[x1]:f1(x1)} PP_COORDINATION {... & (~)?[x2]:f2(x2)}
#PP -> PP:require_not_adjunct BUT PP:try_remove_correlator
#PP -> PP:require_not_adjunct COMMA BUT PP:try_remove_correlator

# PP {... & instead_of((~)?[x1]:f1(x1),(~)?[x2]:f2(x2))} -> PP {... & (~)?[x1]:f1(x1)} PP_COORDINATION {... & (~)?[x2]:f2(x2)}
#PP -> PP:require_not_adjunct NOT PP:try_remove_correlator,add_negative
#PP -> PP:require_not_adjunct COMMA NOT PP:try_remove_correlator,add_negative


PP_COORDINATION nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# PP_COORDINATION {... & ((~)?[x1]:f1(x1) & ... & (~)?[xn]:fn(xn))} -> COMMA PP {... & (~)?[x1]:f1(x1)} PP_COORDINATION {... & ((~)?[x2]:f2(x2) & ... & (~)?[xn]:fn(xn))}
# PP_COORDINATION {... & ((~)?[x1]:f1(x1) | ... | (~)?[xn]:fn(xn))} -> COMMA PP {... & (~)?[x1]:f1(x1)} PP_COORDINATION {... & ((~)?[x2]:f2(x2) | ... | (~)?[xn]:fn(xn))}
#PP_COORDINATION -> COMMA:require_comma PP:remove_coordinator,remove_comma PP_COORDINATION
# PP_COORDINATION {... & (~)?[x1]:f1(x1)} -> COMMA PP {... & (~)?[x1]:f1(x1)}
#PP_COORDINATION -> COMMA:require_comma PP:remove_coordinator,remove_comma

# PP_COORDINATION {... & ((~)?[x1]:f1(x1) & ... & (~)?[xn]:fn(xn))} -> (COMMA) AND PP {... & (~)?[x1]:f1(x1)} PP_COORDINATION {... & ((~)?[x2]:f2(x2) & ... & (~)?[xn]:fn(xn))}
#PP_COORDINATION -> AND:require_and PP:remove_coordinator,remove_comma PP_COORDINATION
#PP_COORDINATION -> COMMA:require_comma AND:require_and PP:remove_coordinator,remove_comma PP_COORDINATION
# PP_COORDINATION {... & (~)?[x1]:f1(x1)} -> (COMMA) AND PP {... & (~)?[x1]:f1(x1)}
#PP_COORDINATION -> AND:require_and PP:remove_coordinator,remove_comma
#PP_COORDINATION -> COMMA:require_comma AND:require_and PP:remove_coordinator,remove_comma

# PP_COORDINATION {... & ((~)?[x1]:f1(x1) | ... | (~)?[xn]:fn(xn))} -> (COMMA) OR PP {... & (~)?[x1]:f1(x1)} PP_COORDINATION {... & ((~)?[x2]:f2(x2) | ... | (~)?[xn]:fn(xn))}
#PP_COORDINATION -> OR:require_or PP:remove_coordinator,remove_comma PP_COORDINATION
#PP_COORDINATION -> COMMA:require_comma OR:require_or PP:remove_coordinator,remove_comma PP_COORDINATION
# PP_COORDINATION {... & (~)?[x1]:f1(x1)} -> (COMMA) OR PP {... & (~)?[x1]:f1(x1)}
#PP_COORDINATION -> OR:require_or PP:remove_coordinator,remove_comma
#PP_COORDINATION -> COMMA:require_comma OR:require_or PP:remove_coordinator,remove_comma

# PP_COORDINATION {... & ((~)?[x1]:f1(x1) | ... | (~)?[xn]:fn(xn))} -> (COMMA) NOR PP {... & (~)?[x1]:f1(x1)} PP_COORDINATION {... & ((~)?[x2]:f2(x2) | ... | (~)?[xn]:fn(xn))}
#PP_COORDINATION -> NOR:require_nor PP:add_req_aux,remove_coordinator,remove_comma,add_negative PP_COORDINATION
#PP_COORDINATION -> COMMA:require_comma NOR:require_nor PP:add_req_aux,remove_coordinator,remove_comma,add_negative PP_COORDINATION
# PP_COORDINATION {... & (~)?[x1]:f1(x1)} -> (COMMA) NOR PP {... & (~)?[x1]:f1(x1)}
#PP_COORDINATION -> NOR:require_nor PP:add_req_aux,remove_coordinator,remove_comma,add_negative
#PP_COORDINATION -> COMMA:require_comma NOR:require_nor PP:add_req_aux,remove_coordinator,remove_comma,add_negative


ADJP_R nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# ADJP_R {... & ?[g1]:(... & p1(g1) & ... & f1(g1)) & ... & ?[gn]:(... & pn(gn) & ... & fn(gn))}
#  -> ADJP_R {... & ?[g1]:(...) & ... & ?[gn]:(...)}
#     PP {... & ?[g1]:(p1(g1) & f1') & ... ?[gn]:(pn(gn) & fn')}
# where fi(g) = ?[x]:(... & arg2(g)=x) and fi' = ?[x]:(...)
# e.g. "afraid of dogs", "capable of swimming"
# NOTE: `x` could also be universally-quantified, in which case it is passed to the PP.
#ADJP_R -> ADJP_R:try_remove_is_adjunct PP:try_remove_correlated,try_remove_correlator,try_remove_is_adjunct

# ADJP_R {... & ?[g1]:(... & f1(g1)) & ... & ?[gn]:(... & fn(gn))}
#  -> ADJP_R {... & ?[g1]:(...) & ... & ?[gn]:(...)}
#     S' {f1' & ... & fn'}
# where fi(g) = ?[x]:(h(x) & arg2(g)=x) and fi' = ?[x]:h(x)
#    or fi(g) = arg2(g)=possibility(A) and fi' = A
# e.g. "glad that you arrived"
#ADJP_R -> ADJP_R:try_remove_is_adjunct S':try_remove_correlated,try_remove_correlator,try_remove_is_adjunct
#ADJP_R -> ADJP_R:try_remove_is_adjunct S':try_remove_correlated,try_remove_correlator,try_remove_is_adjunct,add_that

# closed interrogative finite subordinate clause
# ADJP_R {... & (~)?[y1]:(g1(y1) & f(y1)) & ... & (~)?[yn]:(gn(yn) & f(yn))}
#  -> ADJP_R {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
#     IF/WHETHER S' {... & f'}
# where f(y) = arg2(y)=^[x]:A and f' = ^[x]:A
# e.g. "i'm not sure whether he arrived or not"
#ADJP_R -> ADJP_R:try_remove_is_adjunct S':try_remove_correlated,add_req_no_aux,try_remove_correlator,try_remove_is_adjunct,add_whether
#ADJP_R -> ADJP_R:try_remove_is_adjunct S':try_remove_correlated,add_req_no_aux,try_remove_correlator,try_remove_is_adjunct,add_if

# open interrogative finite subordinate clause
# ADJP_R {... & (~)?[y1]:(g1(y1) & f(y1)) & ... & (~)?[yn]:(gn(yn) & f(yn))}
#  -> ADJP_R {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
#     S' {... & f'}
# where f(y) = arg2(y)=^[x]:A and f' = ^[x]:A
# e.g. "i'm not sure when she arrived"
#ADJP_R -> ADJP_R:try_remove_is_adjunct S':try_remove_correlated,add_req_no_aux,add_subordinate,try_remove_correlator,try_remove_is_adjunct

# ADJP_R {... & ?[g1]:(... & f1(g1)) & ... & ?[gn]:(... & fn(gn))}
#  -> ADJP_R {... & ?[g1]:(...) & ... & ?[gn]:(...)}
#     NP {^[P]:(f1' & ... & fn')}
# where fi(g) = ?[x]:(h(x) & arg2(g)=x) and fi' = ?[x]:(h(x) & P(x))
# e.g. "worth three dollars"
#ADJP_R -> ADJP_R:try_remove_is_adjunct NP:try_remove_correlated,try_remove_correlator,try_remove_is_adjunct

# ADJP_R {?[g1]:(... & h(g1)) & ... & ?[gn]:(... & h(gn))}
#  -> ADJP_R {?[g1]:(...) & ... & ?[gn]:(...)}
#     VP_R/FOR S' {... & h'}
# where h(g) = ?[y]:(f(y) & arg2(g)=y) and h' = ?[y]:f(y)
#    or h(g) = arg2(g)=possibility(A) and h' = A
# e.g. "happy to help", "easy for me to sympathize", "too hot to drink", "too hot for you to drink"
#ADJP_R -> ADJP_R:try_remove_is_adjunct VP_R:try_remove_correlated,add_to_infinitive,try_remove_correlator,try_remove_is_adjunct
#ADJP_R -> ADJP_R:try_remove_is_adjunct S':try_remove_correlated,add_to_infinitive,try_remove_correlator,try_remove_is_adjunct,add_for

# ADJP_R {?[g1]:(... & h(g1)) & ... & ?[gn]:(... & h(gn))}
#  -> ADJP_R {?[g1]:(...) & ... & ?[gn]:(...)}
#     VP_R {... & h'}
# where h(g) = ?[y]:(f(y) & arg2(g)=y) and h' = ?[y]:f(y)
#    or h(g) = arg2(g)=possibility(A) and h' = A
# e.g. "busy preparing the report"
#ADJP_R -> ADJP_R:try_remove_is_adjunct VP_R:try_remove_correlated,add_present_participle,try_remove_correlator,try_remove_is_adjunct

# comparative constructions
# ADJP_R {... & ?[g1]:(U(i1,g1) & p(f1)(g1) & ... & arg2(g1)=a) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & ... & arg2(gn)=a) & ...}
#  -> ADJP_R {... & ?[g1]:(U(i1,g1) & p(f1)(g1) & ...) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & ...) & ...}
#     COMP {p}
#     V_ADJUNCT {?[gn]:(arg2(gn)=a)}
# ADJP_R {... & ?[r]:(... & ?[g1]:(U(i1,g1) & p(f1)(g1) & ... & arg2(g1)=r) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & ... & arg2(gn)=r) & ... & h(r) & ...)}
#  -> ADJP_R {... & ?[g1]:(U(i1,g1) & p(f1)(g1) & ...) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & ...) & ...}
#     COMP {p}
#     V_ADJUNCT {h'}
# ADJP_R {... & ?[R]:(... & ![r]:(R(r) => ?[g1]:(U(i1,g1) & p(f1)(g1) & ... & arg2(g1)=r) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & ... & arg2(gn)=r)) & ... & R=^[r]:h(r) & ...)}
#  -> ADJP_R {... & ?[g1]:(U(i1,g1) & p(f1)(g1) & ...) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & ...) & ...}
#     COMP {p}
#     V_ADJUNCT {h'}
# where h(r) = r=a and h' = ?[gn]:(arg2(gn)=a)
#    or h(r) = U(i,r) & p(r) & ?[x]:(arg1/arg2(x)=r & ...) and h' = ?[gn]:(?[r]:(U(i,r) & p(r) & ?[x]:(arg1/arg2(x)=r & ...))) (TODO: what is this? where is it even used?)
#    or h(r) = ?[x]:(arg1/arg2(x)=r & ...) and h' = ?[x]:(...)
# NOTE: The predicate could also be a simple `p` rather than `p(f)`.
# e.g. "more powerful than my car", "brighter than Vega"
#ADJP_R -> ADJP_R:try_remove_is_adjunct COMP V_ADJUNCT:try_remove_correlated,try_remove_correlator,try_remove_is_adjunct

# ADJP_R {^[x]:?[r]:(?[d]:(degree(d) & arg1(d)=r & arg2(d)=x) & ...)}
#  -> HOW ADJP_R {?[r]:(...)}
#ADJP_R -> HOW ADJP_R:try_remove_is_adjunct

# ADJP_R {A} -> ADJP_L {A}
ADJP_R -> ADJP_L:try_remove_is_adjunct

# for correlated coordination
# NOTE: For the following rules, the coordination doesn't have to be at head
# scope, it can be the left-most coordination that is a descendant of the head
# scope as well, so long as there is no negation between the coordination and
# the root. However, we need some measure of "distance" between the
# coordination and the head scope to be a feature to decide between the rules
# at this nonterminal (e.g. "both" moves left much less often than "either").
# ADJP_R {... & ?[x]:(p(x) & (?[x1]:f1(x1) | ... | ?[xn]:fn(xn)))} -> EITHER ADJP_R {... & ?[x]:(p(x) & (?[x1]:f1(x1) | ... | ?[xn]:fn(xn)))}
#ADJP_R -> ADJP_R:require_not_correlated,require_not_adjunct,add_either,add_correlated_by_either # this transformation requires the coordination is at the head
#ADJP_R -> EITHER:require_not_correlated,require_not_adjunct ADJP_R:add_correlated_by_either # this transformation requires the coordination is a descendant of the head
# ADJP_R {... & ?[x]:(p(x) & (?[x1]:f1(x1) & ?[x2]:f2(x2)))} -> BOTH ADJP_R {... & ?[x]:(p(x) & (?[x1]:f1(x1) & ?[x2]:f2(x2)))}
#ADJP_R -> ADJP_R:require_not_correlated,require_not_adjunct,add_both,add_correlated_by_both # this transformation requires the coordination is at the head
#ADJP_R -> BOTH:require_not_correlated,require_not_adjunct ADJP_R:add_correlated_by_both # this transformation requires the coordination is a descendant of the head
# ADJP_R {... & ?[x]:(p(x) & (~?[x1]:f1(x1) | ... | ~?[xn]:fn(xn)))} -> NEITHER ADJP_R {... & ?[x]:(p(x) & (?[x1]:f1(x1) | ... | ?[xn]:fn(xn)))}
#ADJP_R -> ADJP_R:require_not_correlated,require_not_adjunct,add_neither,add_correlated_by_neither # this transformation requires the coordination is at the head
#ADJP_R -> NEITHER:require_not_correlated,require_not_adjunct ADJP_R:add_correlated_by_neither,add_negative # this transformation requires the coordination is a descendant of the head

# NOTE: In the below rules, we require that none of the Ai are themselves
# coordinations with the coordinator (unless Ai is negated).
# ADJP_R {... & ((~)?[x1]:f1(x1) & ... & (~)?[xn]:fn(xn))} -> ADJP_R {... & (~)?[x1]:f1(x1)} ADJP_COORDINATION {... & ((~)?[x2]:f2(x2) & ... & (~)?[xn]:fn(xn))}
#ADJP_R -> ADJP_R:require_not_adjunct ADJP_COORDINATION:try_remove_correlator,add_and
#ADJP_R -> ADJP_R:require_not_adjunct ADJP_COORDINATION:try_remove_correlator,add_and,add_comma
# ADJP_R {... & ((~)?[x1]:f1(x1) | ... | (~)?[xn]:fn(xn))} -> ADJP_R {... & (~)?[x1]:f1(x1)} ADJP_COORDINATION {... & ((~)?[x2]:f2(x2) | ... | (~)?[xn]:fn(xn))}
#ADJP_R -> ADJP_R:require_not_adjunct ADJP_COORDINATION:try_remove_correlator,add_or
#ADJP_R -> ADJP_R:require_not_adjunct ADJP_COORDINATION:try_remove_correlator,add_or,add_comma
# ADJP_R {... & ((~)?[x1]:f1(x1) | ... | (~)?[xn]:fn(xn))} -> ADJP_R {... & (~)?[x1]:f1(x1)} ADJP_COORDINATION {... & ((~)?[x2]:f2(x2) | ... | (~)?[xn]:fn(xn))}
#ADJP_R -> ADJP_R:require_not_adjunct ADJP_COORDINATION:try_remove_correlator,add_nor,require_negative
#ADJP_R -> ADJP_R:require_not_adjunct ADJP_COORDINATION:try_remove_correlator,add_nor,require_negative,add_comma

# ADJP_R {... & but((~)?[x1]:f1(x1),(~)?[x2]:f2(x2))} -> ADJP_R {... & (~)?[x1]:f1(x1)} ADJP_COORDINATION {... & (~)?[x2]:f2(x2)}
#ADJP_R -> ADJP_R:require_not_adjunct BUT ADJP_R:try_remove_correlator
#ADJP_R -> ADJP_R:require_not_adjunct COMMA BUT ADJP_R:try_remove_correlator

# ADJP_R {... & instead_of((~)?[x1]:f1(x1),(~)?[x2]:f2(x2))} -> ADJP_R {... & (~)?[x1]:f1(x1)} ADJP_COORDINATION {... & (~)?[x2]:f2(x2)}
#ADJP_R -> ADJP_R:require_not_adjunct NOT ADJP_R:try_remove_correlator,add_negative
#ADJP_R -> ADJP_R:require_not_adjunct COMMA NOT ADJP_R:try_remove_correlator,add_negative


ADJP_COORDINATION nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# ADJP_COORDINATION {... & ((~)?[x1]:f1(x1) & ... & (~)?[xn]:fn(xn))} -> COMMA ADJP_R {... & (~)?[x1]:f1(x1)} ADJP_COORDINATION {... & ((~)?[x2]:f2(x2) & ... & (~)?[xn]:fn(xn))}
# ADJP_COORDINATION {... & ((~)?[x1]:f1(x1) | ... | (~)?[xn]:fn(xn))} -> COMMA ADJP_R {... & (~)?[x1]:f1(x1)} ADJP_COORDINATION {... & ((~)?[x2]:f2(x2) | ... | (~)?[xn]:fn(xn))}
#ADJP_COORDINATION -> COMMA:require_comma ADJP_R:remove_coordinator,remove_comma ADJP_COORDINATION
# ADJP_COORDINATION {... & (~)?[x1]:f1(x1)} -> COMMA ADJP_R {... & (~)?[x1]:f1(x1)}
#ADJP_COORDINATION -> COMMA:require_comma ADJP_R:remove_coordinator,remove_comma

# ADJP_COORDINATION {... & ((~)?[x1]:f1(x1) & ... & (~)?[xn]:fn(xn))} -> (COMMA) AND ADJP_R {... & (~)?[x1]:f1(x1)} ADJP_COORDINATION {... & ((~)?[x2]:f2(x2) & ... & (~)?[xn]:fn(xn))}
#ADJP_COORDINATION -> AND:require_and ADJP_R:remove_coordinator,remove_comma ADJP_COORDINATION
#ADJP_COORDINATION -> COMMA:require_comma AND:require_and ADJP_R:remove_coordinator,remove_comma ADJP_COORDINATION
# ADJP_COORDINATION {... & (~)?[x1]:f1(x1)} -> (COMMA) AND ADJP_R {... & (~)?[x1]:f1(x1)}
#ADJP_COORDINATION -> AND:require_and ADJP_R:remove_coordinator,remove_comma
#ADJP_COORDINATION -> COMMA:require_comma AND:require_and ADJP_R:remove_coordinator,remove_comma

# ADJP_COORDINATION {... & ((~)?[x1]:f1(x1) | ... | (~)?[xn]:fn(xn))} -> (COMMA) OR ADJP_R {... & (~)?[x1]:f1(x1)} ADJP_COORDINATION {... & ((~)?[x2]:f2(x2) | ... | (~)?[xn]:fn(xn))}
#ADJP_COORDINATION -> OR:require_or ADJP_R:remove_coordinator,remove_comma ADJP_COORDINATION
#ADJP_COORDINATION -> COMMA:require_comma OR:require_or ADJP_R:remove_coordinator,remove_comma ADJP_COORDINATION
# ADJP_COORDINATION {... & (~)?[x1]:f1(x1)} -> (COMMA) OR ADJP_R {... & (~)?[x1]:f1(x1)}
#ADJP_COORDINATION -> OR:require_or ADJP_R:remove_coordinator,remove_comma
#ADJP_COORDINATION -> COMMA:require_comma OR:require_or ADJP_R:remove_coordinator,remove_comma

# ADJP_COORDINATION {... & ((~)?[x1]:f1(x1) | ... | (~)?[xn]:fn(xn))} -> (COMMA) NOR ADJP_R {... & (~)?[x1]:f1(x1)} ADJP_COORDINATION {... & ((~)?[x2]:f2(x2) | ... | (~)?[xn]:fn(xn))}
#ADJP_COORDINATION -> NOR:require_nor ADJP_R:add_req_aux,remove_coordinator,remove_comma,add_negative ADJP_COORDINATION
#ADJP_COORDINATION -> COMMA:require_comma NOR:require_nor ADJP_R:add_req_aux,remove_coordinator,remove_comma,add_negative ADJP_COORDINATION
# ADJP_COORDINATION {... & (~)?[x1]:f1(x1)} -> (COMMA) NOR ADJP_R {... & (~)?[x1]:f1(x1)}
#ADJP_COORDINATION -> NOR:require_nor ADJP_R:add_req_aux,remove_coordinator,remove_comma,add_negative
#ADJP_COORDINATION -> COMMA:require_comma NOR:require_nor ADJP_R:add_req_aux,remove_coordinator,remove_comma,add_negative


ADJP_L nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# ADJP_L {?[g]:(U(0,g) & p(g))} -> ADJ {p}
ADJP_L -> ADJ:require_no_correlator,predicate_only

# ADJP_L {?[g]:(U(0,g) & greatest/least(p)(g))} -> ADJ {p}
#ADJP_L -> ADJ:require_no_correlator,add_superlative

# ADJP_L {?[g]:(U(0,g) & greatest/least(p)(g))} -> ADJP_L {?[g]:(U(0,g) & p(g))}
#ADJP_L -> MOST ADJP_L:try_remove_correlated # for `greatest` only
#ADJP_L -> LEAST ADJP_L:try_remove_correlated # for `least` only

# ADJP_L {?[g]:(U(0,g) & greater/less(p)(g))} -> ADJ {p}
#ADJP_L -> ADJ:require_no_correlator,add_comparative

# ADJP_L {?[g]:(U(0,g) & greater/less(p)(g))} -> ADJP_L {?[g]:(U(0,g) & p(g))}
#ADJP_L -> MORE ADJP_L:try_remove_correlated # for `greater` only
#ADJP_L -> LESS ADJP_L:try_remove_correlated # for `less` only

# ADJP_L {... & ~?[g1]:f1(g1) & ... & ~?[gn]:fn(gn)}
#  -> NOT ADJP_L {... & ?[g1]:f1(g1) & ... & ?[gn]:fn(gn)}
# e.g. "not tall"
#ADJP_L -> NOT ADJP_L:try_remove_correlated,add_negative

# ADJP_L {... & (~)?[g1]:((~)?[x]:(... & arg1(x)=g1) & ...) & ... & (~)?[gn]:((~)?[x]:(... & arg1(x)=gn) & ...)}
#  -> ADVP_L {... & (~)?[x]:(...)}
#     ADJP_L {... & (~)?[g1]:(...) & ... & (~)?[gn]:(...)}
# e.g. "very tall"
#ADJP_L -> ADVP_L:require_no_correlator ADJP_L:try_remove_correlated

# ADJP_L {... & (~)?[g1]:(... & f1(g1)) & ... & (~)?[gn]:(... & fn(gn))}
#  -> NP {^[P]:(f1' & ... & fn')}
#     ADJP_L {... & (~)?[g1]:(...) & ... & (~)?[gn]:(...)}
# where fi(g) = ?[x]:(h(x) & arg2(g)=x) and fi' = ?[x]:(h(x) & P(x))
# e.g. "500 feet tall"
#ADJP_L -> NP:require_no_correlator ADJP_L:try_remove_correlated

ADJP_L -> EITHER ADJP_L:remove_either
ADJP_L -> BOTH ADJP_L:remove_both
ADJP_L -> NEITHER ADJP_L:remove_neither,add_negative


ADVP_R nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# ADVP_R {... & (~)?[g1]:(... & p1(g1) & ... & f1(g1)) & ... & (~)?[gn]:(... & pn(gn) & ... & fn(gn))}
#  -> ADVP_R {... & (~)?[g1]:(...) & ... & (~)?[gn]:(...)}
#     PP {... & (~)?[g1]:(p1(g1) & f1') & ... & (~)?[gn]:(pn(gn) & fn')}
# where fi(g) = ?[x]:(... & arg2(g)=x) and fi' = ?[x]:(...)
# e.g. "differently than him", "equally as effective"
# NOTE: `x` could also be universally-quantified, in which case it is passed to the PP.
#ADVP_R -> ADVP_R:try_remove_is_adjunct PP:try_remove_correlated,try_remove_correlator,try_remove_is_adjunct

# e.g. "so softly that no one heard", "much rather give it to charity"
# TODO: implement this
#ADVP_R -> ADVP_R REL?

# comparative constructions
# ADVP_R {... & ?[r]:(... & ?[g1]:(U(i1,g1) & p(f1)(g1) & ... & arg2(g1)=a) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & ... & arg2(gn)=a) & ...)}
#  -> ADVP_R {... & ?[g1]:(U(i1,g1) & p(f1)(g1) & ...) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & ...) & ...}
#     COMP {p}
#     V_ADJUNCT {?[gn]:(arg2(gn)=a)}
# ADVP_R {... & ?[r]:(... & ?[g1]:(U(i1,g1) & p(f1)(g1) & ... & arg2(g1)=r) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & ... & arg2(gn)=r) & ... & h(r) & ...)}
#  -> ADVP_R {... & ?[g1]:(U(i1,g1) & p(f1)(g1) & ...) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & ...) & ...}
#     COMP {p}
#     V_ADJUNCT {h'}
# ADVP_R {... & ?[R]:(... & ![r]:(R(r) => ?[g1]:(U(i1,g1) & p(f1)(g1) & ... & arg2(g1)=r) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & ... & arg2(gn)=r)) & ... & R=^[r]:h(r) & ...)}
#  -> ADVP_R {... & ?[g1]:(U(i1,g1) & p(f1)(g1) & ...) & ... & ?[gn]:(U(in,gn) & p(fn)(gn) & ...) & ...}
#     COMP {p} (or `f`, whichever comes last)
#     V_ADJUNCT {h'}
# where h(r) = r=a and h' = ?[gn]:(arg2(gn)=a)
#    or h(r) = U(i,r) & p(r) & ?[x]:(arg1/arg2(x)=r & ...) and h' = ?[gn]:(?[r]:(U(i,r) & p(r) & ?[x]:(arg1/arg2(x)=r & ...))) (TODO: what is this? where is it even used?)
#    or h(r) = ?[x]:(arg1/arg2(x)=r & ...) and h' = ?[x]:(...)
# NOTE: The predicate could also be a simple `p` rather than `p(f)`.
# e.g. "more persuasively than me"
#ADVP_R -> ADVP_R:try_remove_is_adjunct COMP V_ADJUNCT:try_remove_correlated,try_remove_correlator,try_remove_is_adjunct

ADVP_R -> ADVP_L:try_remove_is_adjunct

# for correlated coordination
# NOTE: For the following rules, the coordination doesn't have to be at head
# scope, it can be the left-most coordination that is a descendant of the head
# scope as well, so long as there is no negation between the coordination and
# the root. However, we need some measure of "distance" between the
# coordination and the head scope to be a feature to decide between the rules
# at this nonterminal (e.g. "both" moves left much less often than "either").
# ADVP_R {... & ?[x]:(p(x) & (?[x1]:f1(x1) | ... | ?[xn]:fn(xn)))} -> EITHER ADVP_R {... & ?[x]:(p(x) & (?[x1]:f1(x1) | ... | ?[xn]:fn(xn)))}
#ADVP_R -> ADVP_R:require_not_correlated,require_not_adjunct,add_either,add_correlated_by_either # this transformation requires the coordination is at the head
#ADVP_R -> EITHER:require_not_correlated,require_not_adjunct ADVP_R:add_correlated_by_either # this transformation requires the coordination is a descendant of the head
# ADVP_R {... & ?[x]:(p(x) & (?[x1]:f1(x1) & ?[x2]:f2(x2)))} -> BOTH ADVP_R {... & ?[x]:(p(x) & (?[x1]:f1(x1) & ?[x2]:f2(x2)))}
#ADVP_R -> ADVP_R:require_not_correlated,require_not_adjunct,add_both,add_correlated_by_both # this transformation requires the coordination is at the head
#ADVP_R -> BOTH:require_not_correlated,require_not_adjunct ADVP_R:add_correlated_by_both # this transformation requires the coordination is a descendant of the head
# ADVP_R {... & ?[x]:(p(x) & (~?[x1]:f1(x1) | ... | ~?[xn]:fn(xn)))} -> NEITHER ADVP_R {... & ?[x]:(p(x) & (?[x1]:f1(x1) | ... | ?[xn]:fn(xn)))}
#ADVP_R -> ADVP_R:require_not_correlated,require_not_adjunct,add_neither,add_correlated_by_neither # this transformation requires the coordination is at the head
#ADVP_R -> NEITHER:require_not_correlated,require_not_adjunct ADVP_R:add_correlated_by_neither,add_negative # this transformation requires the coordination is a descendant of the head

# NOTE: In the below rules, we require that none of the Ai are themselves
# coordinations with the coordinator (unless Ai is negated).
# ADVP_R {... & ((~)?[x1]:f1(x1) & ... & (~)?[xn]:fn(xn))} -> ADVP_R {... & (~)?[x1]:f1(x1)} ADVP_COORDINATION {... & ((~)?[x2]:f2(x2) & ... & (~)?[xn]:fn(xn))}
#ADVP_R -> ADVP_R:require_not_adjunct ADVP_COORDINATION:try_remove_correlator,add_and
#ADVP_R -> ADVP_R:require_not_adjunct ADVP_COORDINATION:try_remove_correlator,add_and,add_comma
# ADVP_R {... & ((~)?[x1]:f1(x1) | ... | (~)?[xn]:fn(xn))} -> ADVP_R {... & (~)?[x1]:f1(x1)} ADVP_COORDINATION {... & ((~)?[x2]:f2(x2) | ... | (~)?[xn]:fn(xn))}
#ADVP_R -> ADVP_R:require_not_adjunct ADVP_COORDINATION:try_remove_correlator,add_or
#ADVP_R -> ADVP_R:require_not_adjunct ADVP_COORDINATION:try_remove_correlator,add_or,add_comma
# ADVP_R {... & ((~)?[x1]:f1(x1) | ... | (~)?[xn]:fn(xn))} -> ADVP_R {... & (~)?[x1]:f1(x1)} ADVP_COORDINATION {... & ((~)?[x2]:f2(x2) | ... | (~)?[xn]:fn(xn))}
#ADVP_R -> ADVP_R:require_not_adjunct ADVP_COORDINATION:try_remove_correlator,add_nor,require_negative
#ADVP_R -> ADVP_R:require_not_adjunct ADVP_COORDINATION:try_remove_correlator,add_nor,require_negative,add_comma

# ADVP_R {... & but((~)?[x1]:f1(x1),(~)?[x2]:f2(x2))} -> ADVP_R {... & (~)?[x1]:f1(x1)} ADVP_COORDINATION {... & (~)?[x2]:f2(x2)}
#ADVP_R -> ADVP_R:require_not_adjunct BUT ADVP_R:try_remove_correlator
#ADVP_R -> ADVP_R:require_not_adjunct COMMA BUT ADVP_R:try_remove_correlator

# ADVP_R {... & instead_of((~)?[x1]:f1(x1),(~)?[x2]:f2(x2))} -> ADVP_R {... & (~)?[x1]:f1(x1)} ADVP_COORDINATION {... & (~)?[x2]:f2(x2)}
#ADVP_R -> ADVP_R:require_not_adjunct NOT ADVP_R:try_remove_correlator,add_negative
#ADVP_R -> ADVP_R:require_not_adjunct COMMA NOT ADVP_R:try_remove_correlator,add_negative


ADVP_COORDINATION nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# ADVP_COORDINATION {... & ((~)?[x1]:f1(x1) & ... & (~)?[xn]:fn(xn))} -> COMMA ADJP_R {... & (~)?[x1]:f1(x1)} ADVP_COORDINATION {... & ((~)?[x2]:f2(x2) & ... & (~)?[xn]:fn(xn))}
# ADVP_COORDINATION {... & ((~)?[x1]:f1(x1) | ... | (~)?[xn]:fn(xn))} -> COMMA ADJP_R {... & (~)?[x1]:f1(x1)} ADVP_COORDINATION {... & ((~)?[x2]:f2(x2) | ... | (~)?[xn]:fn(xn))}
#ADVP_COORDINATION -> COMMA:require_comma ADJP_R:remove_coordinator,remove_comma ADVP_COORDINATION
# ADVP_COORDINATION {... & (~)?[x1]:f1(x1)} -> COMMA ADJP_R {... & (~)?[x1]:f1(x1)}
#ADVP_COORDINATION -> COMMA:require_comma ADJP_R:remove_coordinator,remove_comma

# ADVP_COORDINATION {... & ((~)?[x1]:f1(x1) & ... & (~)?[xn]:fn(xn))} -> (COMMA) AND ADJP_R {... & (~)?[x1]:f1(x1)} ADVP_COORDINATION {... & ((~)?[x2]:f2(x2) & ... & (~)?[xn]:fn(xn))}
#ADVP_COORDINATION -> AND:require_and ADJP_R:remove_coordinator,remove_comma ADVP_COORDINATION
#ADVP_COORDINATION -> COMMA:require_comma AND:require_and ADJP_R:remove_coordinator,remove_comma ADVP_COORDINATION
# ADVP_COORDINATION {... & (~)?[x1]:f1(x1)} -> (COMMA) AND ADJP_R {... & (~)?[x1]:f1(x1)}
#ADVP_COORDINATION -> AND:require_and ADJP_R:remove_coordinator,remove_comma
#ADVP_COORDINATION -> COMMA:require_comma AND:require_and ADJP_R:remove_coordinator,remove_comma

# ADVP_COORDINATION {... & ((~)?[x1]:f1(x1) | ... | (~)?[xn]:fn(xn))} -> (COMMA) OR ADJP_R {... & (~)?[x1]:f1(x1)} ADVP_COORDINATION {... & ((~)?[x2]:f2(x2) | ... | (~)?[xn]:fn(xn))}
#ADVP_COORDINATION -> OR:require_or ADJP_R:remove_coordinator,remove_comma ADVP_COORDINATION
#ADVP_COORDINATION -> COMMA:require_comma OR:require_or ADJP_R:remove_coordinator,remove_comma ADVP_COORDINATION
# ADVP_COORDINATION {... & (~)?[x1]:f1(x1)} -> (COMMA) OR ADJP_R {... & (~)?[x1]:f1(x1)}
#ADVP_COORDINATION -> OR:require_or ADJP_R:remove_coordinator,remove_comma
#ADVP_COORDINATION -> COMMA:require_comma OR:require_or ADJP_R:remove_coordinator,remove_comma

# ADVP_COORDINATION {... & ((~)?[x1]:f1(x1) | ... | (~)?[xn]:fn(xn))} -> (COMMA) NOR ADJP_R {... & (~)?[x1]:f1(x1)} ADVP_COORDINATION {... & ((~)?[x2]:f2(x2) | ... | (~)?[xn]:fn(xn))}
#ADVP_COORDINATION -> NOR:require_nor ADJP_R:add_req_aux,remove_coordinator,remove_comma,add_negative ADVP_COORDINATION
#ADVP_COORDINATION -> COMMA:require_comma NOR:require_nor ADJP_R:add_req_aux,remove_coordinator,remove_comma,add_negative ADVP_COORDINATION
# ADVP_COORDINATION {... & (~)?[x1]:f1(x1)} -> (COMMA) NOR ADJP_R {... & (~)?[x1]:f1(x1)}
#ADVP_COORDINATION -> NOR:require_nor ADJP_R:add_req_aux,remove_coordinator,remove_comma,add_negative
#ADVP_COORDINATION -> COMMA:require_comma NOR:require_nor ADJP_R:add_req_aux,remove_coordinator,remove_comma,add_negative


ADVP_L nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# ADVP_L {?[g]:(U(0,g) & p(g))} -> ADV {p}
ADVP_L -> ADV:require_no_correlator,predicate_only

# ADVP_L {?[g]:(U(0,g) & p(g))} -> ADJ {p}
ADVP_L -> ADJ:require_no_correlator,predicate_only,add_ly

# ADVP_L {?[g]:(U(0,g) & greatest/least(p)(g))} -> ADV {p}
# e.g. "soonest", "most seriously"
#ADVP_L -> ADV:require_no_correlator,add_superlative

# ADVP_L {?[g]:(U(0,g) & greatest/least(p)(g))} -> ADVP_L {?[g]:(U(0,g) & p(g))}
#ADVP_L -> MOST ADVP_L:try_remove_correlated # for `greatest` only
#ADVP_L -> LEAST ADVP_L:try_remove_correlated # for `least` only

# ADVP_L {?[g]:(U(0,g) & greater/less(p)(g))} -> ADV {p}
# e.g. "sooner", "more seriously"
#ADVP_L -> ADV:require_no_correlator,add_comparative

# ADVP_L {?[g]:(U(0,g) & greater/less(p)(g))} -> ADVP_L {?[g]:(U(0,g) & p(g))}
#ADVP_L -> MORE ADVP_L:try_remove_correlated # for `greater` only
#ADVP_L -> LESS ADVP_L:try_remove_correlated # for `less` only

# ADVP_L {... & ~?[g1]:f(g1) & ... & ~?[gn]:f(gn)}
#  -> NOT ADVP_L {... & ?[g1]:f(g1) & ... & ?[gn]:f(gn)}
# e.g. "not slowly"
#ADVP_L -> NOT ADVP_L:try_remove_correlated,add_negative

# ADVP_L {... & (~)?[g1]:((~)?[x]:(... & arg1(x)=g1) & ...) & ... & (~)?[gn]:((~)?[x]:(... & arg1(x)=gn) & ...)}
#  -> ADVP_L {... & (~)?[x]:(...)}
#     ADVP_L {... & (~)?[g1]:(...) & ... & (~)?[gn]:(...)}
# e.g. "very slowly"
#ADVP_L -> ADVP_L:require_no_correlator ADVP_L:try_remove_correlated

# ADVP_L {... & ?[g1]:(... & f1(g1)) & ... & ?[gn]:(... & fn(gn))}
#  -> NP {^[P]:(f1' & ... & fn')}
#     ADVP_L {... & ?[g1]:(...) & ... & ?[gn]:(...)}
# where fi(g) = ?[x]:(h(x) & arg2(g)=x) and fi' = ?[x]:(h(x) & P(x))
# e.g. "12 minutes late"
#ADVP_L -> NP:require_no_correlator ADVP_L:try_remove_correlated

ADVP_L -> EITHER ADVP_L:remove_either
ADVP_L -> BOTH ADVP_L:remove_both
ADVP_L -> NEITHER ADVP_L:remove_neither,add_negative


V preterminal {predicate} {1.0, 10.0} {1.0, 0.1} {"than", "that", "those", "of", "in", "with", "whose", "who", "to", "on", "for", "by", "over", "at", "per", "outside", "from", "within", "as", "?", ".", "a", "an", "any", "all", "the", "what", "which", "how", "many", "much", "where", "bigger", "smaller", "longer", "shorter", "taller", "lower", "higher", "greater", "less", "more", "highest", "lowest", "longest", "shortest", "largest", "smallest", "biggest", "most", "least", "greatest", "fewest", "maximum", "minimum", "next", "not", "number", "and", "but", "or", "no", "it", "there", "one", "me", "dont", "only", "some", "can", "could", "you", "u"} 10000 0.95 verb {"through"}

N preterminal {constant} {1.0, 10.0} {1.0, 0.1} {"be", "is", "are", "do", "does", "did", "has", "have", "than", "that", "of", "in", "through", "with", "whose", "who", "to", "on", "for", "by", "over", "at", "per", "outside", "from", "within", "as", "?", ".", "a", "an", "any", "all", "the", "what", "which", "how", "many", "much", "where", "bigger", "smaller", "longer", "shorter", "taller", "lower", "higher", "greater", "less", "more", "highest", "lowest", "longest", "shortest", "largest", "smallest", "biggest", "most", "least", "greatest", "fewest", "maximum", "minimum", "next", "not", "number", "and", "but", "or", "no", "there", "name", "tell", "give", "show", "one", "count", "me", "dont", "find", "only", "list", "some", "can", "could", "you", "u", "called"} 10000 0.9995 noun {}

ADJ preterminal {} {1.0} {1.0} {"be", "is", "are", "do", "does", "did", "has", "have", "than", "that", "of", "in", "through", "with", "whose", "who", "to", "on", "for", "by", "over", "at", "per", "outside", "from", "within", "as", "?", ".", "a", "an", "any", "all", "the", "what", "which", "how", "many", "much", "where", "bigger", "smaller", "longer", "shorter", "taller", "lower", "higher", "greater", "less", "more", "number", "and", "but", "or", "no", "not", "it", "there", "name", "tell", "give", "show", "one", "count", "me", "dont", "find", "only", "list", "some", "can", "could", "you", "u"} 10000 1.0 adjective {}

ADV preterminal {} {1.0} {1.0} {} 10000 1.0 adverb {}

P preterminal {predicate_only} {1.0, 10.0} {1.0, 0.1} {} 10000 1.0 {}
P -> "of"
P -> "in"
P -> "through"
P -> "with"
P -> "to"
P -> "on"
P -> "for"
P -> "by"
P -> "over"
P -> "at"
P -> "from"
P -> "within"
P -> "as"

ALL preterminal {} {1.0} {1.0} {} 10 1.0 {}
ALL -> "every"
ALL -> "each"
ALL -> "all"

COMP preterminal {} {1.0} {1.0} {} 10 1.0 {}
COMP -> "as"
COMP -> "than"
# TODO: is "that" a comparator? as in a relative clause like "the same hotel that we stayed at last year", or could we model all comparative phrases as relative clauses (or other kinds of subordinate clauses)?
COMP -> "rather than"
COMP -> "from"
COMP -> "to"

AND preterminal {} {1.0} {1.0} {} 10 1.0 {}
AND -> "and"
AND -> "as well as"
AND -> "in addition to"
AND -> "plus"

NOT preterminal {} {1.0} {1.0} {} 10 1.0 {}
NOT -> "not"
NOT -> "rather than"

PERIOD preterminal {} {1.0} {1.0} {} 10 1.0 {}
PERIOD -> "."

QUESTION preterminal {} {1.0} {1.0} {} 10 1.0 {}
QUESTION -> "?"

THAT preterminal {} {1.0} {1.0} {} 10 1.0 {}
THAT -> "that"

WHETHER preterminal {} {1.0} {1.0} {} 10 1.0 {}
WHETHER -> "whether"

OR preterminal {} {1.0} {1.0} {} 10 1.0 {}
OR -> "or"

IF preterminal {} {1.0} {1.0} {} 10 1.0 {}
IF -> "if"

BECAUSE preterminal {} {1.0} {1.0} {} 10 1.0 {}
BECAUSE -> "because"

FOR preterminal {} {1.0} {1.0} {} 10 1.0 {}
FOR -> "for"

EITHER preterminal {} {1.0} {1.0} {} 10 1.0 {}
EITHER -> "either"

NEITHER preterminal {} {1.0} {1.0} {} 10 1.0 {}
NEITHER -> "neither"

BOTH preterminal {} {1.0} {1.0} {} 10 1.0 {}
BOTH -> "both"

WILL preterminal {} {1.0} {1.0} {} 10 1.0 {}
WILL -> "will"

HAVE preterminal {} {1.0} {1.0} {} 10 1.0 {}
HAVE -> "have"

BE preterminal {} {1.0} {1.0} {} 10 1.0 verb {}
BE -> "be"

DO preterminal {} {1.0} {1.0} {} 10 1.0 verb {}
DO -> "do"

GET preterminal {} {1.0} {1.0} {} 10 1.0 verb {}
GET -> "get"

TO preterminal {} {1.0} {1.0} {} 10 1.0 {}
TO -> "to"

A preterminal {} {1.0} {1.0} {} 10 1.0 {}
A -> "a"

THE preterminal {} {1.0} {1.0} {} 10 1.0 {}
THE -> "the"

EACH preterminal {} {1.0} {1.0} {} 10 1.0 {}
EACH -> "each"
