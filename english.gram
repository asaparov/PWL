# We use neo-Davidsonian/event semantics to represent meaning in logical form.
# Thus, all verbs, nouns, adjectives, adverbs, etc are expressed as quantified
# variables. The "head" of any logical form is the right-most scope (not
# necessarily the deepest) that is an event (excluding `capable_of` events with
# an event argument). For example:
#
#  "cats are mammals."
#  ![x]:(U(0,x) & cat(x) => ?[s]:(arg1(s)=x & same(s) & present(s) & ?[m]:(U(1,m) & mammal(m) & arg2(s)=m)))
# where `present` is relative to the deictic origo, so it could be defined as
# something like ![x]:(present(x) = time(x)(T)) where time(x) returns the set
# of times at which the event x is true, and T is the current time in the
# discourse model (deictic origo). Also, `U` is the current universe of
# discourse. `U` can either contain the entire universe, as a default,
# U=^[x]:T, or it could change dynamically according to the discourse model.
# The first argument to `U` is an index that increases by one each time `U`
# function is invoked (and so its semantics can differ even within a sentence).
#
# Generally, every event that corresponds to a verb is modified with
# information about the time at which the event occurs. We can do this with the
# following axioms:
#   ![x,t]:(progressive(x,t) = ?[r]:(r>0 & ![s]:(s>(t-r) & s<(t+r) => time(x)(t))))
#   ![x,t]:(perfect(x,t) = ![r]:(time(x)(r) => r<t))
#   ![x,t]:(perfect_progressive(x,t) = (perfect(x,t) & ?[r]:(r>0 & ![s]:(s>(t-r) & s<t => time(x)(t)))))
#   ![x]:(present(x) = time(x)(T))
#   ![x]:(present_progressive(x) = progressive(x,T))
#   ![x]:(present_perfect(x) = perfect(x,T))
#   ![x]:(present_perfect_progressive(x) = perfect_progressive(x,T))
#   ![x]:(past(x) = ?[t]:(t<T & time(x)(t)))
#   ![x]:(past_progressive(x) = ?[t]:(t<T & progressive(x,t)))
#   ![x]:(past_perfect(x) = ?[t]:(t<T & perfect(x,t)))
#   ![x]:(past_perfect_progressive(x) = ?[t]:(t<T & perfect_progressive(x,t)))
#   ![x]:(future(x) = ?[t]:(t>T & time(x)(t)))
#   ![x]:(future_progressive(x) = ?[t]:(t>T & progressive(x,t)))
#   ![x]:(future_perfect(x) = ?[t]:(t>T & perfect(x,t)))
#   ![x]:(future_perfect_progressive(x) = ?[t]:(t>T & perfect_progressive(x,t)))
#
#  "4 cats sleep."
#  ?[X]:(subset(X,^[x]:(U(0,x) & cat(x))) & size(X)=4 & ![x]:(X(x) => ?[s]:(arg1(s)=x & sleep(s) & present(s))))
#
#  "4 cats slept."
#  ?[X]:(subset(X,^[x]:(U(0,x) & cat(x))) & size(X)=4 & ![x]:(X(x) => ?[s]:(arg1(s)=x & sleep(s) & past(s))))
#
#  "4 cats will have been sleeping."
#  ?[X]:(subset(X,^[x]:(U(0,x) & cat(x))) & size(X)=4 & ![x]:(X(x) => ?[s]:(arg1(s)=x & sleep(s) & future_perfect_progressive(s))))
#
#  "there is a cat."
#  ?[x]:(U(0,x) & cat(x))
#    [OR]
#  ?[c]:(U(0,x) & cat(x) & ?[l]:(arg1(l)=x & location(l) & present(l) & arg2(l)=L))
# where L is the current discourse location (location of deictic origo).
#
#  "3 teachers grade 6 exams."
#  ?[X]:(subset(X,^[x]:(U(0,x) & teacher(x))) & size(X)=3 & ?[Y]:(subset(Y,^[y]:(U(1,y) & exam(y))) & size(Y)=6 & ![x,y]:(X(x) & Y(y) => ?[g]:(arg1(g)=x & grade(g) & present(g) & arg2(g)=y))))
#  ?[X]:(subset(X,^[x]:(U(0,x) & teacher(x))) & size(X)=3 & ?[Y]:(subset(Y,^[y]:(U(1,y) & exam(y))) & size(Y)=6 & !W[x,y]:(X(x) & Y(y) => ?[g]:(arg1(g)=x & grade(g) & present(g) & arg2(g)=y))))
#  ?[X]:(subset(X,^[x]:(U(0,x) & teacher(x))) & size(X)=3 & ![x]:(X(x) => ?[Y]:(subset(Y,^[y]:(U(1,y) & exam(y))) & size(Y)=6 & ![y]:(Y(y) => ?[g]:(arg1(g)=x & grade(g) & present(g) & arg2(g)=y)))))
# where !W is the weak universal quantifier, which is defined as:
# !W[x1,...,xn]:(X1(x1) & ... & Xn(xn) => f(x1,...,xn)) =
#     ![x1]:(X1(x1) => ?[x2,...,xn]:(X2(x2) & ... & Xn(xn) & f(x1,...,xn)))
#   & ![x2]:(X2(x2) => ?[x1,x3,...,xn]:(X1(x1) & X3(x3) & ... & Xn(xn) & f(x1,...,xn)))
#   & ![x3]:(X3(x3) => ?[x1,...,x2,x4,...,xn]:(X1(x1) & ... & X2(x2) & X4(x4) & ... & Xn(xn) & f(x1,...,xn)))
#   & ![x4]:(X4(x4) => ?[x1,...,x3,x5,...,xn]:(X1(x1) & ... & X3(x3) & X5(x5) & ... & Xn(xn) & f(x1,...,xn)))
#   & ... & ![xn]:(Xn(xn) => ?[x1,...,x(n-1)]:(X1(x1) & ... & X(n-1)(x(n-1)) & f(x1,...,xn)))
#
#  "a dog likes every cat."
#  ?[d]:(U(0,d) & dog(d) & ![c]:(U(1,c) & cat(c) => ?[l]:(arg1(l)=d & like(l) & present(l) & arg2(l)=c)))
#  ![c]:(U(0,c) & cat(c) => ?[d]:(U(1,d) & dog(d) & ?[l]:(arg1(l)=d & like(l) & present(l) & arg2(l)=c)))
#
#  "a dog is liked by every cat."
#  ?[d]:(U(0,d) & dog(d) & ![c]:(U(1,c) & cat(c) => ?[l]:(arg1(l)=d & inverse(like)(l) & present(l) & arg2(l)=c)))
#  ![c]:(U(0,c) & cat(c) => ?[d]:(U(1,d) & dog(d) & ?[l]:(arg1(l)=d & inverse(like)(l) & present(l) & arg2(l)=c)))
# where we can have an axiom like:
#    ![e,t,x,y]:((inverse(t)(e) & arg1(e)=x & arg2(e)=y) = (t(e) & arg1(e)=y & arg2(e)=x))
# In fact, the passive voice is always realized in semantics using the
# `inverse` function.
#
#  "Noah entertained and was reviewed."
#  ?[e]:(arg1(e)=noah & entertain(e) & past(e)) & ?[r]:(arg1(r)=noah & inverse(review)(r) & past(r))
# NOTE: We originally labeled this sentence with the following logical form:
#  ?[X]:(?[e]:(entertain(e) & past(e) & ?[r]:(inverse(review)(r) & past(r) & X=^[x]:(x=e | x=r))) & ^[x]:(X(x) => arg1(x)=noah))
# However, putting events into sets is problematic if one of the events is
# itself a set of events. See the later example "she made a big cake, and hung
# up some balloons".
#
#  "not every cat is a tabby."
#  "not all cats are tabbies."
#  ~![c]:(U(0,c) & cat(c) => ?[s]:(arg1(s)=c & same(s) & present(s) & ?[t]:(U(1,t) & tabby(t) & arg2(s)=t))
#
#  "every cat isn't a tabby."
#  "all cats aren't tabbies."
#  ~![c]:(U(0,c) & cat(c) => ?[s]:(arg1(s)=c & same(s) & present(s) & ?[t]:(U(1,t) & tabby(t) & arg2(s)=t))
#  ![c]:(U(0,c) & cat(c) => ~?[s]:(arg1(s)=c & same(s) & present(s) & ?[t]:(U(1,t) & tabby(t) & arg2(s)=t))
#
#  "a cat and dog are sleeping."
#  ?[X]:(?[c]:(U(0,c) & cat(c) & ?[d]:(U(1,d) & dog(d) & X=^[x]:(x=c | x=d))) & ![x]:(X(x) => ?[s]:(arg1(s)=x & sleep(s) & present(s))))
#
#  "4 cats, 2 dogs, and a bird are sleeping."
#  ?[X]:(?[C]:(subset(C,^[x]:(U(0,x) & cat(x))) & size(C)=4 & ?[D]:(subset(D,^[x]:(U(1,x) & dog(x))) & size(D)=2 & ?[b]:(U(2,b) & bird(b) & X=^[x]:(x=C | x=D | x=^[y]:y=b)))) & ![Y]:(X(Y) => ![x]:(Y(x) => ?[s]:(arg1(s)=x & sleep(s) & present(s)))))
#
#  "a man and his dog were walking in the park."
#  ?[X]:(?[m]:(U(0,m) & man(m) & ?[h]:(U(1,h) & male_ref(0,h) & ?[d]:(U(2,d) & dog(d) & ?[o]:(arg1(o)=h & own(o) & arg2(o)=d) & X=^[x]:(x=m | x=d)))) & ![x]:(X(x) => ?[w]:(arg1(w)=x & walk(w) & past_progressive(w) & ?[p]:(U(3,p) & park(p) & arg2(w)=p))))
# where `male_ref` is defined in the pragmatics model. We could supervise the
# pragmatics model by specifying that h and m refer to the same object. We
# similarly define `female_ref` for grammatically female anaphora and `ref` for
# anaphora whose grammatical gender is either neutral or unspecified. The first
# argument of `male_ref` is an index parameter so that multiple uses of "he" in
# the same sentence can potentially refer to different objects (just as the
# first argument of `U`).
#
#  "10 girls and boys are in class."
#  ?[X]:(?[G]:(G=^[x]:(U(0,x) & girl(x)) & ?[B]:(B=^[x]:(U(1,x) & boy(x)) & X=^[x]:(x=G | x=B))) & ![Y]:(X(Y) => size(Y)=10) & ![Y]:(X(Y) => ![x]:(Y(x) => ?[p]:(arg1(p)=x & location(p) & ?[c]:(U(2,c) & class(c) & arg2(p)=c)))))
#  ?[X]:(?[G]:(G=^[x]:(U(0,x) & girl(x)) & ?[B]:(B=^[x]:(U(1,x) & boy(x)) & X=^[x]:(x=G | x=B))) & sum(X,^[Y]:size(Y))=10 & ![Y]:(X(Y) => ![x]:(Y(x) => ?[p]:(arg1(p)=x & location(p) & present(p) & ?[c]:(U(2,c) & class(c) & arg2(p)=c)))))
#
#  "a cat is not currently but will be in the room."
#  ?[c]:(U(0,c) & cat(c) & ?[r]:(U(1,r) & room(r) & ?[l]:(arg1(l)=c & located(l) & present(l) & arg2(l)=r & ?[c]:(currently(c) & arg1(c)=l)) & ?[l]:(arg1(l)=c & located(l) & future(l) & arg2(l)=r)))
#
#  "Jane is the only doctor."
#  ?[o]:(arg1(o)=jane & only(o) & present(o) & arg2(o)=^[x]:(U(0,x) & doctor(x)))
#    [or maybe we should do]
#  ?[o]:(arg1(o)=jane & only(o) & present(o) & ?[D]:(D=^[x]:(U(1,x) & doctor(x)) & arg2(o)=D))
#
#  "i did not get much money."
#  ?[m]:(U(0,m) & money(m) & ?[l]:(large_amount(l) & arg1(l)=m) & ~?[r]:(arg1(r)=me & receive(r) & past(r) & arg2(r)=m))
#
#  "i did not get very much money."
#  ?[m]:(U(0,m) & money(m) & ?[l]:(very(large_amount)(l) & arg1(l)=m) & ~?[r]:(arg1(r)=me & receive(r) & past(r) & arg2(r)=m))
#    [OR]
#  ?[m]:(U(0,m) & money(m) & ?[l]:(?[v]:(very(v) & arg1(v)=l) & large_amount(l) & arg1(l)=m) & ~?[r]:(arg1(r)=me & receive(r) & past(r) & arg2(r)=m))
#
#  "i don't like Ralph's destroying the barn."
#  "i don't like Ralph's destruction of the barn."
#  ?[d]:(arg1(d)=ralph & destroy(d) & progressive(d) & ?[b]:(U(0,b) & barn(b) & arg2(d)=b) & ~?[l]:(arg1(l)=me & like(l) & present(l) & arg2(l)=d))
# NOTE: We could require constant arguments (e.g. `ralph` and `me`) to be part
# of U in the discourse model.
#
#  "i don't like the destruction of the barns by the teenagers."
#  ![x]:(U(0,x) & teenager(x) => ![y]:(U(1,y) & barn(y) => ?[d]:(arg1(d)=x & destroy(d) & arg2(d)=y & ~?[l]:(like(l) & arg2(l)=d & arg1(l)=me))))
#    [OR]
#  ?[X]:(X=^[x]:(U(0,x) & teenager(x)) & ?[Y]:(Y=^[y]:(U(1,y) & barn(y)) & ![x]:(X(x) => ![y]:(Y(y) => ?[d]:(arg1(d)=x & destroy(d) & arg2(d)=y & ~?[l]:(arg1(l)=me & like(l) & arg2(l)=d))))))
#
#  "the cat's purring is soothing."
#  ?[p]:(?[c]:(U(0,c) & cat(c) & arg1(p)=c) & purr(p) & progressive(p) & ?[s]:(arg1(s)=p & sooth(s) & progressive(s)))
#
#  "Joan's pen is good."
#  ?[p]:(U(0,p) & pen(p) & ?[o]:(arg1(o)=joan & own(o) & arg2(o)=p) & ?[g]:(arg1(g)=p & good(g) & present(g)))
#
#  "Joan's pens are good."
#  ![x]:(U(0,x) & pen(x) & ?[o]:(arg1(o)=joan & own(o) & arg2(o)=x) => ?[g]:(arg1(g)=x & good(g) & present(g)))
#    [OR]
#  ?[X]:(X=^[p]:(U(0,p) & pen(p) & ?[o]:(arg1(o)=joan & own(o) & arg2(o)=p)) & ![x]:(X(x) => ?[g]:(arg1(g)=x & good(g) & present(g))))
#
#  "the students' pens are good."
#  ?[X]:(?[Y]:(Y=^[y]:(U(0,y) & student(y)) & X=^[x]:(U(1,x) & pen(x) & ?[y]:(Y(y) & ?[o]:(own(o) & arg2(o)=x & arg1(o)=y)))) & ![x]:(X(x) => ?[g]:(arg1(g)=x & good(g) & present(g))))
#
#  "i saw the trees by all the cats."
#  ?[X]:(X=^[x]:(U(0,x) & cat(x)) & ?[Y]:(Y=^[y]:(U(1,y) & tree(y) & ![x]:(X(x) => ?[n]:(near(n) & arg2(n)=y & arg1(n)=x))) & ![y]:(Y(y) => ?[s]:(arg1(s)=me & see(s) & past(s) & arg2(s)=y))))
#    [OR]
#  ![y]:(U(0,y) & tree(y) & ![x]:(U(1,x) & cat(x) => ?[n]:(near(n) & arg2(n)=y & arg1(n)=x)) => ?[s]:(arg1(s)=me & see(s) & past(s) & arg2(s)=y))
#
#  "he works a lot to earn money for school."
#  ?[h]:(U(0,h) & male_ref(0,h) & ?[w]:(arg1(w)=h & work(w) & present(w) & ?[l]:(large_duration(l) & arg1(l)=w) & ?[p]:(purpose(p) & ?[e]:(earn(e) & ?[m]:(U(1,m) & money(m) & arg2(e)=m) & arg2(p)=e) & arg1(p)=w)))
#
#  "the ladder collapsed because it was old."
#  ?[l]:(U(0,l) & ladder(l) & ?[c]:(arg1(c)=l & collapse(c) & past(c) & ?[r]:(reason(r) & ?[i]:(U(0,i) & ref(0,i) & ?[o]:(old(o) & past(o) & arg1(o)=i & arg2(r)=o)) & arg1(r)=c)))
#
#  "Mr. Bibby wrote the letter with a pencil."
#  ?[p]:(U(0,p) & pencil(p) & ?[l]:(U(1,l) & letter(l) & ?[w]:(arg1(x)=w & write(w) & arg2(w)=l & arg1(w)=bibby & ?[x]:(with(x) & arg2(x)=p))))
#
#  "the students wrote the letters with the pencils."
#  ?[S]:(S=^[s]:(U(0,s) & student(s)) & ?[L]:(L=^[l]:(U(1,l) & letter(l)) & ?[P]:(P=^[p]:(U(2,p) & pencil(p)) & !W[s,l,p]:(S(s) & L(l) & P(p) => ?[w]:(arg1(w)=s & wrote(w) & past(w) & arg2(w)=l & ?[x]:(with(x) & arg2(x)=p & arg1(x)=w))))))
#
#  "she sat on the table."
#  ?[x]:(U(0,x) & female_ref(0,x) & ?[s]:(arg1(s)=x & sit(s) & past(s) & ?[o]:(on_top_of(o) & ?[t]:(U(1,t) & table(t) & arg2(o)=t) & arg1(o)=s)))
#
#  "the birds hear each other."
#  ?[X]:(X=^[x]:(U(0,x) & bird(x)) & ![x,y]:(X(x) & Y(x) & ~(x=y) => ?[h]:(arg1(h)=x & hear(h) & arg2(h)=y)))
#
#  "some relative of each villager and some relative of each townsman hate each other."
#  ?[a]:(U(0,a) & ![x]:(U(1,x) & villager(x) => ?[r]:(related_to(r) & arg2(r)=x & arg1(r)=a)) & ?[b]:(U(2,b) & ![x]:(U(3,x) & townsman(x) => ?[r]:(related_to(r) & arg2(r)=x & arg1(r)=b)) & ?[X]:(X=^[x]:(x=a | x=b) & ![x,y]:(X(x) & Y(x) & ~(x=y) => ?[h]:(arg1(h)=x & hate(h) & arg2(h)=y)))))
#
#  "in either case, i am going."
#  ?[X]:(subset(X,^[x]:(U(0,x) & case(x))) & size(X)=2 & ![x]:(X(x) => (true(x) => ?[g]:(arg1(g)=me & go(g) & progressive(g)))))
#
#  "if it rains, the grass will be wet."
#  "the grass, if it rains, will be wet."
#  ?[i]:(U(0,i) & ref(0,i) & ?[r]:(rain(r) & present(r) & arg1(r)=i)) => ?[g]:(U(1,g) & grass(g) & ?[w]:(wet(w) & future(w) & arg1(w)=g))
#
#  "he ran with difficulty."
#  ?[h]:(U(0,h) & male_ref(0,h) & ?[r]:(arg1(r)=h & run(r) & past(r) & ?[d]:(difficult(d) & arg1(d)=r)))
#
#  "he stood in silence."
#  ?[h]:(U(0,h) & male_ref(0,h) & ?[s]:(arg1(s)=h & stand(s) & past(s) & ?[x]:(silently(x) & arg1(x)=s)))
# where we could define ![x]:(silently(x) = ?[s]:(is_silent(s) & arg1(s)=arg1(x) & ![t]:(time(x)(t) => time(s)(t))))
#
#  "she helped me with my homework."
#  ?[s]:(U(0,s) & female_ref(0,s) & ?[h]:(arg1(h)=s & help(h) & past(h) & arg2(h)=me & ?[o]:(own(o) & arg2(o)=x & arg1(o)=me) & ?[w]:(with(w) & ?[x]:(U(1,x) & homework(x) & arg2(w)=x & arg1(w)=h))))
#
#  "he stayed for two weeks."
#  ?[h]:(U(0,h) & male_ref(0,h) & ?[s]:(arg1(s)=h & stay(s) & past(s) & ?[d]:(duration(d) & arg2(d)=(2*week) & arg1(d)=s)))
#
#  "it is under the bush."
#  ?[i]:(U(0,i) & ref(0,i) & ?[u]:(arg1(u)=i & is_under(u) & present(u) & ?[b]:(U(1,b) & bush(b) & arg2(u)=b)))
#
#  "the party is at seven o'clock."
#  ?[p]:(U(0,p) & party(p) & ?[s]:(arg1(s)=p & start_time(s) & present(s) & arg2(s)=(7:00pm)))
# where we could define ![x,t]:((start_time(x)=t) = ![s]:(time(x)(s) => t<=s)),
# or perhaps `start_time` and `end_time` should be the elementary event time
# predicates rather than `time`.
# TODO: how do we represent date/time constants?
#
#  "she will leave after she has had breakfast."
#  ?[s]:(U(0,s) & female_ref(0,s) & ?[l]:(arg1(l)=s & leave(l) & future(l) & ?[a]:(arg1(a)=l & after(a) & ?[r]:(U(1,r) & female_ref(1,r) & ?[e]:(eat(e) & ?[b]:(U(2,b) & breakfast(b) & arg2(e)=b) & arg1(e)=r & arg2(a)=e)))))
# where we could define ![a,x,y]:((after(a) & arg1(a)=x & arg2(a)=y) = ~?[s,t]:(time(x)(s) & time(y)(t) & s<t))
#
#  "the ball rotated quickly and heated up slowly."
#  ?[b]:(U(0,b) & ball(b) & ?[r]:(arg1(r)=b & rotate(r) & past(r) & ?[q]:(quick(q) & arg1(q)=r)) & ?[h]:(arg1(h)=b & heat_up(h) & past(h) & ?[s]:(slowly(s) & arg1(s)=h)))
# NOTE: We originally labeled this sentence with the following logical form:
#  ?[b]:(U(0,b) & ball(b) & ?[r]:(rotate(r) & past(r) & ?[q]:(quick(q) & arg1(q)=r) & ?[h]:(heat_up(h) & past(h) & ?[s]:(slowly(s) & arg1(s)=h) & ?[X]:(X=^[x]:(x=r | x=h) & ![x]:(X(x) => arg1(x)=b)))))
# However, putting events into sets is problematic if one of the events is
# itself a set of events. See the later example "she made a big cake, and hung
# up some balloons".
#
#  "the ball rotated and heated up slowly."
#  ?[b]:(U(0,b) & ball(b) & ?[r]:(arg1(r)=b & rotate(r) & past(r) & ?[s]:(slowly(s) & arg1(s)=r)) & ?[h]:(arg1(h)=b & heat_up(h) & past(h) & ?[s]:(slowly(s) & arg1(s)=h)))
# NOTE: We originally labeled this sentence with the following logical form:
#  ?[b]:(U(0,b) & ball(b) & ?[r]:(rotate(r) & past(r) & ?[h]:(heat_up(h) & past(h) & ?[X]:(X=^[x]:(x=r | x=h) & ![x]:(X(x) => ?[s]:(slowly(s) & arg1(s)=x) & arg1(x)=b)))))
# However, putting events into sets is problematic if one of the events is
# itself a set of events. See the later example "she made a big cake, and hung
# up some balloons".
#
#  "slowly, the ball rotated and heated up."
#  ?[b]:(U(0,b) & ball(b) & ?[r]:(arg1(r)=b & rotate(r) & past(r) & ?[s]:(slowly(s) & arg1(s)=r)) & ?[h]:(?[s]:(slowly(s) & arg1(s)=h) & arg1(h)=b & heat_up(h) & past(h)))
#
#  "Emma and Noah met."
#  ?[X]:(X=^[x]:(x=emma | x=noah) & ?[m]:(arg1(m)=X & collective_meet(m) & past(m)))
#
#  "Emma and Noah lifted the stone."
#  ?[X]:(X=^[x]:(x=emma | x=noah) & ?[s]:(U(0,s) & stone(s) & ?[l]:(lift(l) & past(l) & arg2(l)=s & arg1(l)=X)))
# Here, "Emma and Noah" has a *collective* interpretation, which also occurs in
# many other sentences in English.
#
#  "i think there is a unicorn."
#  ?[t]:(arg1(t)=me & think(t) & present(t) & arg2(t)=possibility(?[e]:(exists(e) & present(e) & ?[u]:(U(0,u) & unicorn(u) & arg1(e)=u))))
# This is why we need the `true` predicate, since it provides a uniform way to
# handle modality, and to talk about objects and events that may not actually
# exist or be true, but may exist as thoughts or suppositions (the Platonic
# universe). All events have the property that if they are true, then all of
# its arguments are true, with a handful of specified exceptions, including
# `think`, `capable_of`, `want`, `purpose`, etc.
#
#  "i can swim."
#  "i am capable of swimming."
#  ?[c]:(arg1(c)=me & capable_of(c) & present(c) & arg2(c)=possibility(?[s]:(arg1(s)=me & swim(s))))
#
#  "i could swim."
#  "i was capable of swimming."
#  ?[c]:(arg1(c)=me & capable_of(c) & past(c) & arg2(c)=possibility(?[s]:(arg1(s)=me & swim(s))))
#
#  "she made a big cake, and hung up some balloons."
#  ?[s]:(U(0,s) & female_ref(0,s) & ?[B]:(subset(B,^[b]:(U(2,b) & balloon(b))) & ?[m]:(arg1(m)=s & make(m) & past(m) & ?[c]:(U(1,c) & cake(c) & ?[b]:(is_big(b) & arg1(b)=c) & arg2(m)=c)) & ![b]:(B(b) => ?[h]:(arg1(h)=s & hang(h) & past(h) & arg2(h)=b))))
#
#  "the doctor watched everyone sleep."
#  ?[d]:(U(0,d) & doctor(d) & ?[X]:(X=^[x]:(U(1,x) & animate/anthropomorphic(x)) & ![x]:(X(x) => ?[w]:(arg1(w)=d & watch(w) & past(w) & arg2(w)=x))))
# NOTE: We model pragmatic domain restriction implicitly. In this example,
# `^[x]:U(0,x)` contains the doctor but `^[x]:U(1,x)` contains everyone being
# monitored by the doctor but does not contain the doctor.
#
#  "John can play the guitar, and Mary, the violin."
#  ?[c]:(arg1(c)=john & capable_of(c) & present(c) & arg2(c)=possibility(?[p]:(play(p) & ?[g]:(U(0,g) & guitar(g) & arg2(p)=g)))) & ?[e]:(arg1(e)=mary & empty_ref(0,e) & ?[v]:(U(1,v) & violin(v) & arg2(e)=v))
#
#  "John can play his guitar. Mary, too."
#  ?[c]:(arg1(c)=john & capable_of(c) & present(c) & arg2(c)=possibility(?[p]:(play(p) & ?[g]:(U(0,g) & guitar(g) & arg2(p)=g)))) & ?[e]:(arg1(e)=mary & empty_ref(0,e) & too(e))
#
#  "she walked and sat under every tree and near every rock."
#  ?[s]:(U(0,s) & female_ref(s) & ?[T]:(T=^[x]:(U(1,x) & tree(x)) & ?[R]:(R=^[y]:(U(2,y) & rock(y)) & ![x]:(T(x) => ![y]:(R(y) => ?[w]:(arg1(w)=s & walk(w) & past(w) & ?[u]:(under(u) & arg1(u)=w & arg2(u)=x) & ?[n]:(near(n) & arg1(n)=w & arg2(n)=y)) & ?[a]:(arg1(a)=s & sit(a) & past(a) & ?[u]:(under(u) & arg1(u)=a & arg2(u)=x) & ?[n]:(near(n) & arg1(n)=a & arg2(n)=y)))))))
#
#  "John wants and is able to swim and dance."
#  "John wants to and is able to swim and dance."
#  ?[w]:(arg1(w)=john & want(w) & present(w) & arg2(w)=possibility(?[s]:swim(s) & ?[d]:dance(d))) & ?[c]:(arg1(c)=john & capable_of(c) & present(c) & arg2(c)=possibility(?[s]:swim(s) & ?[d]:dance(d)))
#
#  "the house is Kim's."
#  ?[h]:(U(0,h) & house(h) & ?[o]:(arg1(o)=h & inverse(own)(o) & present(o) & arg2(o)=kim))
#
#  "the pencils are the students'."
#  ?[X]:(X=^[x]:(U(0,x) & pencil(x)) & ?[Y]:(Y=^[y]:(Y(1,y) & student(y)) & ![x,y]:(X(x) & Y(y) => ?[o]:(arg1(o)=x & inverse(own)(o) & present(o) & arg2(o)=y))))
#
#  "flower seller has carnations."
#  ?[C]:(subset(C,^[x]:(U(0,x) & carnation(x))) & ?[x]:(?[s]:(?[f]:(U(1,f) & flower(f) & arg2(s)=f) sell(s) & arg1(s)=x) & U(2,x) & ![c]:(C(c) => ?[o]:(arg1(o)=x & own(o) & present(o) & arg2(o)=c))))
#
#  "John swam extremely quickly."
#  ?[s]:(arg1(s)=john & swim(s) & past(s) & ?[q]:(?[e]:(extreme(e) & arg1(e)=q) & quick(q) & arg1(q)=s))
#
#  "John arrived 10 minutes late."
#  ?[a]:(arg1(s)=john & arrive(a) & past(a) & ?[l]:(arg2(l)=(10*minute) & late(l) & arg1(l)=a))
#
#  "they ran away from the house and from the tree."
#  ?[T]:(U(0,T) & plural_ref(T) & ![x]:(T(x) => ?[r]:(arg1(r) & run(r) & past(r) & ?[a]:(away(a) & arg1(a)=r & ?[h]:(U(1,h) & house(h) & arg2(a)=h)) & ?[a]:(away(a) & arg1(a)=r & ?[t]:(U(2,t) & tree(t) & arg2(a)=t)))))
#
#  "they ran away from the house and the tree."
#  ?[T]:(U(0,T) & plural_ref(T) & ![x]:(T(x) => ?[r]:(arg1(r) & run(r) & past(r) & ?[X]:(?[h]:(U(1,h) & house(h) & ?[t]:(U(2,t) & tree(t) & Y=^[y]:(y=h | y=t))) & ![y]:(Y(y) => ?[a]:(away(a) & arg1(a)=r & arg2(a)=y))))))
#
#  "that Constance is smart is not surprising."
#  ~?[x]:(arg1(x)=possibility(?[s]:(arg1(s)=constance & smart(s) & present(s))) & surprise(x) & present_progressive(x))
#
#  "that all cats are mammals is not surprising."
#  ~?[x]:(arg1(x)=possibility(![x]:(U(0,x) & cat(x) => ?[s]:(arg1(s)=x & same(s) & present(s) & ?[m]:(U(1,m) & mammal(m) & arg2(s)=m)))) & surprise(x) & present_progressive(x))
#
#  "i am glad that you arrived."
#  ?[h]:(arg1(h)=me & happy(h) & present(h) & ?[a]:(arg1(a)=you & arrive(a) & past(a) & arg2(h)=a))
#
#  "i will buy what she wants."
#  "i will buy whatever she wants."
#  ?[b]:(arg1(b)=me & buy(b) & future(b) & ?[x]:(?[w]:(?[h]:(U(0,h) & female_ref(h) & arg1(w)=h) & want(w) & arg2(w)=x) & arg2(b)=x))
#
#  "are you generous?"
#  "you are generous?"
#  ^[x]:(x=?[g]:(arg1(g)=you & generous(g) & present(g)))
#
#  "how generous are you?"
#  ^[x]:?[g]:(?[d]:(degree(d) & arg1(d)=g & arg2(d)=x) & arg1(g)=you & generous(g) & present(g))
#
#  "did they see her?"
#  ^[x]:x=?[T]:(U(0,T) & plural_ref(T) & ?[h]:(U(1,h) & female_ref(h) & ?[t]:(T(t) & ?[s]:(arg1(s)=t & see(s) & past(s) & arg2(s)=h))))
#
#  "did they all see her?"
#  ^[x]:x=?[T]:(U(0,T) & plural_ref(T) & ?[h]:(U(1,h) & female_ref(h) & ![t]:(T(t) => ?[s]:(arg1(s)=t & see(s) & past(s) & arg2(s)=h))))
#
#  "which store did Jason run to?"
#  "to which store did Jason run?"
#  "Jason ran to which store?"
#  "what store did Jason run to?"
#  "to what store did Jason run?"
#  "Jason ran to what store?"
#  ^[x]:(?[S]:(S=^[s]:(U(s,0) & store(s)) & S(x) & ?[r]:(arg1(r)=jason & run(r) & past(r) & arg2(r)=x)))
#
#  "which stores did Jason run to?"
#  "to which stores did Jason run?"
#  "Jason ran to which stores?"
#  "what stores did Jason run to?"
#  "to what stores did Jason run?"
#  "Jason ran to what stores?"
#  ^[X]:(subset(X,^[s]:(U(s,0) & store(s))) & ![x]:(X(x) => ?[r]:(arg1(r)=jason & run(r) & past(r) & arg2(r)=x)))
#
#  "is it red or blue?"
#  ^[x]:?[i]:(U(0,i) & ref(i) & true(x) & (x=possibility(?[r]:(arg1(r)=i & red(r) & present(r))) | x=possibility(?[b]:(arg1(b)=i & blue(b) & present(b)))))
#
#  "how big is the earth?"
#  ^[x]:?[b]:(?[d]:(degree(d) & arg1(d)=b & arg2(d)=x) arg1(b)=earth & big(b))
#
#  "Kim knows whether the earth is big."
#  ?[k]:(arg1(k)=kim & know(k) & present(k) & arg2(k)=^[x]:x=?[b]:(arg1(b)=earth & big(b) & present(b)))
#
#  "Kim knows how big the earth is."
#  ?[k]:(arg1(k)=kim & know(k) & present(k) & arg2(k)=^[x]:?[b]:(?[d]:(degree(d) & arg1(d)=b & arg2(d)=x) arg1(b)=earth & big(b)))
#
#  "how to make an omelet?"
#  ^[x]:?[m]:(?[y]:(manner(y) & arg1(y)=m & arg2(y)=x) & make(m) & ?[o]:(U(0,o) & omelet(o) & arg2(m)=o))
#
#  "Jason knows how to make an omelet."
#  ?[k]:(arg1(k)=jason & know(k) & present(k) & arg2(k)=^[x]:?[m]:(?[y]:(manner(y) & arg1(y)=m & arg2(y)=x) & make(m) & ?[o]:(U(0,o) & omelet(o) & arg2(m)=o)))
#
#  "whether running or swimming, Emma is quick."
#  (?[r]:(arg1(r)=emma & run(r) & present_progressive(r)) | ?[s]:(arg1(s)=emma & swim(s) & present_progressive(s))) => ?[q]:(arg1(q)=emma & quick(q))
#
#  "Noah was intrigued by what strange people inhabited this place."
#  TODO: label this and ensure the grammar can handle it
#
#  "the necklace which Emma gave to her is in the safe."
#  "the necklace, which Emma gave to her, is in the safe."
#  ?[l]:(?[n]:(U(0,n) & necklace(n) & ?[g]:(arg1(g)=emma & give(g) & past(g) & ?[h]:(U(1,n) & female_ref(h) & arg3(g)=h) & arg2(g)=n) & arg1(l)=n) & location(l) & present(l) & ?[s]:(U(2,s) & safe(s) & arg2(l)=s))
#
#  "Jason, who is my brother, is here."
#  ?[l]:(?[j]:(j=jason & ?[b]:(arg1(b)=me & brother_of(b) & present(b) & arg2(b)=j) & arg1(l)=j) location(l) & present(l) & arg2(l)=here)
#
#  "a person walked into the room who looked like Emma."
#  ?[p]:(U(0,p) & person(p) & ?[w]:(arg1(w)=p & walk(w) & past(w) & ?[r]:(U(1,r) & room(r) & arg2(w)=r)) & ?[v]:(arg1(v)=p & visually_similar(v) & arg2(v)=emma))
#
#  "Sirius is brighter."
#  ?[g]:(arg1(g)=sirius & greater(brightness)(g) & present(g))
#
#  "Sirius is brighter than Vega."
#  ?[g]:(arg1(g)=sirius & greater(brightness)(g) & present(g) & arg2(g)=vega)
# where we can add an axiom such as ![x,y,f]:(?[g]:(greater(f)(g) & arg1(g)=x & arg2(g)=y) & ~is_real_number(y) & ?[b]:(f(b) & arg1(b)=y) = ?[g]:(greater(f)(g) & arg1(g)=x & ?[b]:(brightness(b) & arg1(b)=y & arg2(g)=arg2(b))))
# as well as equivalent axioms for things like height, shortness, size, length, etc.
#
#  "i see a brighter star than Vega."
#  ?[s]:(arg1(s)=me & see(s) & present(s) & ?[x]:(?[g]:(greater(brightness)(g) & arg1(g)=x & U(0,x) & star(x) & arg2(g)=vega) & arg2(s)=x))
#
#  "i see a star brighter than Vega."
#  ?[s]:(arg1(s)=me & see(s) & present(s) & ?[x]:(?[g]:(greater(brightness)(g) & arg1(g)=x & arg2(g)=vega) & U(0,x) & star(x) & arg2(s)=x))
#
#  "Sirius is brighter than we thought."
#  ?[X]:(X=us & ![x]:(X(x) => ?[g]:(arg1(g)=sirius & greater(brightness)(g) & ?[t]:(arg1(t)=x & think(t) & past(t) & arg2(t)=arg2(g)))))
#
#  "Sirius is the brightest star."
#  ?[s]:(arg1(s)=sirius & same(s) & present(s) & ?[X]:(?[g]:(greatest(brightness)(g) & arg2(s)=arg1(g) & arg2(g)=X) & X=^[x]:(U(0,x) & star(x))))
#
#  "Sirius is the brightest."
#  ?[s]:(arg1(s)=sirius & same(s) & present(s) & ?[g]:(greatest(brightness)(g) & arg2(s)=arg1(g)))
#
#  "a brighter star could be seen with the telescope than without it"
#  ?[x,r]:(?[g]:(greater(brightness)(g) & arg1(g)=x & arg2(g)=r) & U(0,x) & star(x) & ?[c]:(capable_of(c) & arg2(c)=possibility(?[s]:(arg1(s)=x & inverse(see)(s) & ?[w]:(with(w) & ?[t]:(U(2,t) & telescope(t) & arg1(w)=t)) & ?[y]:(arg1(y)=r & ~?[w]:(with(w) & ?[t]:(U(1,t) & telescope(t) & arg1(w)=t)))))))
#
#  "brighter stars could be seen with the telescope than without it"
#  ?[X,R]:(subset(X,^[x]:(![r]:(R(r) => ?[g]:(greater(brightness)(g) & arg1(g)=x & arg2(g)=r)) & U(0,x) & star(x))) & ![x]:(X(x) => ?[c]:(capable_of(c) & arg2(c)=possibility(?[s]:(arg1(s)=x & inverse(see)(s) & ?[w]:(with(w) & ?[t]:(U(2,t) & telescope(t) & arg1(w)=t)) & R=^[r]:?[y]:(arg1(y)=r & ~?[w]:(with(w) & ?[t]:(U(1,t) & telescope(t) & arg1(w)=t))))))))
#
#  "last time i went to campus, i took the bus"
#  ?[t]:(?[l]:(last_time(l) & arg1(l)=t & arg2(l)=^[g]:(arg1(g)=me & go(g) & past(g) & ?[c]:(U(0,c) & campus(c) & arg2(g)=c))) & arg1(t)=me & take(t) & past(t) & ?[b]:(U(1,b) & bus(b) & arg2(t)=b))
#    [OR]
#  ?[t]:(?[l]:(last_time(l) & arg1(l)=t & ?[S]:(S=^[g]:(arg1(g)=me & go(g) & past(g) & ?[c]:(U(0,c) & campus(c) & arg2(g)=c)) & arg2(l)=S)) & arg1(t)=me & take(t) & past(t) & ?[b]:(U(1,b) & bus(b) & arg2(t)=b))
# where we could have an axiom like ![x,S]:(?[l]:(last_time(l) & arg1(l)=x & arg2(l)=S) = ~?[y]:(S(y) & start_time(y)>end_time(x) & start_time(y)<now))
#
#  "last time, i took the bus"
#  ?[t]:(?[l]:(last_time(l) & arg1(l)=t) & arg1(t)=me & take(t) & past(t) & ?[b]:(U(0,b) & bus(b) & arg2(t)=b))
#
#  "i took the same bus as i took yesterday."
#  ?[t]:(arg1(t)=me & take(t) & past(t) & ?[b,r]:(?[s]:(same(s) & arg1(s)=b & arg2(s)=r) & U(0,b) & bus(b) & ?[y]:(arg1(y)=me & take(y) & past(y) & arg2(y)=r & ?[z]:(yesterday(z) & arg1(z)=y)) & arg2(t)=b))
#
#  "i took the same bus as i took last time."
#  ?[t]:(arg1(t)=me & take(t) & past(t) & ?[b,r]:(?[s]:(same(s) & arg1(s)=b & arg2(s)=r) & U(0,b) & bus(b) & ?[y]:(arg1(y)=me & take(y) & past(y) & arg2(y)=r & ?[z]:(last_time(z) & arg1(z)=y)) & arg2(t)=b))
#
#  "i took the same bus as last time."
#  ?[t]:(arg1(t)=me & take(t) & past(t) & ?[b,r]:(?[s]:(same(s) & arg1(s)=b & arg2(s)=r) & U(0,b) & bus(b) & ?[y]:(arg2(y)=r & ?[z]:(last_time(z) & arg1(z)=y)) & arg2(t)=b))
#
#  "Sirius is as bright as Vega."
#  ?[g]:(arg1(g)=sirius & greater_than_or_equal(brightness)(g) & present(g) & arg2(g)=vega)
#
#  "last time i had a party, 7 people came"
#  ?[P]:(subset(P,^[p]:(U(0,p) & person(p))) & size(P)=7 & ![p]:(P(p) => ?[g]:(?[l]:(last_time(l) & arg1(l)=g & arg2(l)=^[h]:(arg1(h)=me & have(h) & past(h) & ?[p]:(U(1,p) & party(p) & arg2(h)=p))) & arg1(g)=p & go(g) & past(g))))
#
#  "more people came to the party than people came last time i had a party."
#  ?[P,R]:(size(P)>size(R) & subset(P,^[p]:(U(0,p) & person(p))) & ![p]:(P(p) => ?[g]:(arg1(g)=p & go(g) & past(g) & R=^[r]:(U(1,r) & person(r) & ?[g]:(arg1(g)=r & go(g) & past(g) & ?[l]:(last_time(l) & arg1(l)=g & arg2(l)=^[h]:(arg1(h)=me & have(h) & ?[p]:(U(2,p) & party(p) & arg2(h)=p))))))))
#
#  "more people came than people came last time."
#  ?[P,R]:(size(P)>size(R) & subset(P,^[p]:(U(0,p) & person(p))) & ![p]:(P(p) => ?[g]:(arg1(g)=p & go(g) & past(g) & R=^[r]:(U(1,r) & person(r) & ?[g]:(arg1(g)=r & go(g) & past(g) & ?[l]:(last_time(l) & arg1(l)=g))))))
#
#  "more people came than last time."
#  ?[P,R]:(size(P)>size(R) & subset(P,^[p]:(U(0,p) & person(p))) & ![p]:(P(p) => ?[g]:(arg1(g)=p & go(g) & past(g) & R=^[r]:(?[g]:(arg1(g)=r & ?[l]:(last_time(l) & arg1(l)=g))))))
#
#  "more girls but fewer boys came than last time."
#  ?[P,R]:(?[G,R1]:(size(G)>size(R1) & subset(G,^[g]:(U(0,g) & girl(g))) & ?[B,R2]:(size(B)<size(R2) & subset(B,^[b]:(U(1,b) & boy(b))) & P=^[s]:(s=G | s=B) & R=^[s]:(s=R1 | s=R2))) & ![s]:(P(s) => ![p]:(s(p) => ?[g]:(arg1(g)=p & go(g) & past(g) & ![Ri]:(R(Ri) => Ri=^[r]:(?[g]:(arg1(g)=r & ?[l]:(last_time(l) & arg1(l)=g))))))))
#
#  "taller people came than last time."
#  ?[X,R]:(subset(X,^[x]:(![r]:(R(r) => ?[g]:(greater(height)(g) & arg1(g)=x & arg2(g)=r)) & U(0,x) & person(x))) & ?[g]:(arg1(g)=x & go(g) & past(g) & R=^[r]:(?[g]:(arg1(g)=r & ?[l]:(last_time(l) & arg1(l)=g)))))
#
#  "she is older than i am."
#  ?[g]:(?[h]:(U(0,h) & female_ref(h) & arg1(g)=h) & greater(age)(g) & ?[y]:(arg1(y)=me & arg2(g)=y))
# where `y` could have type `age_of`.
#
#  "she wrote more plays than i wrote novels."
#  ?[h]:(U(0,h) & female_ref(h) & ?[P,N]:(size(P)>size(N) & subset(P,^[p]:(U(1,p) & play(p))) & ![p]:(P(p) => ?[w]:(arg1(w)=h & write(w) & past(w) & arg2(w)=p & N=^[n]:(U(2,n) & novel(n) & ?[w]:(arg1(w)=me & write(w) & past(w) & arg2(w)=n))))))
#
#  "we spend more time in France than in Germany."
#  ?[X]:(X=us & ![x]:(X(x) => ?[s]:(arg1(s)=x & spend_time(s) & present(s) & ?[g]:(greater(time)(g) & arg1(g)=s & ?[l]:(located(l) & arg1(l)=s & arg2(l)=france) & ?[y]:(?[l]:(located(l) & arg1(l)=y & arg2(l)=germany) & arg2(g)=y)))))
#
#  "he plays better drunk than sober."
#  ?[p]:(?[h]:(U(0,h) & male_ref(h) & arg1(p)=h) & play(p) & present(p) & ?[g]:(greater(skill)(g) & arg1(g)=p & ?[d]:(drunk(d) & arg1(d)=p) & ?[y]:(?[s]:(sober(s) & arg1(s)=y) arg2(g)=y)))
#
#  "it is better to try and fail than to not try at all."
#  ?[b]:(better(b) & arg1(b)=possibility(?[t]:try(t) & ?[f]:fail(f)) & arg2(b)=possibility(~?[t]:try(t)))
#
#  "it is better that he tried and failed than not try at all."
#  ?[b]:(better(b) & arg1(b)=possibility(?[t]:(try(t) & past(t)) & ?[f]:(fail(f) & past(f))) & arg2(b)=possibility(~?[t]:try(t)))
#
#  "the flower is more red than pink."
#  ?[f]:(U(0,f) & flower(f) & ?[g]:(greater(degree)(g) & ?[r]:(arg1(r)=f & red(r) & arg1(g)=r & ?[p]:(pink(p) & arg2(g)=p))))


S nonterminal {} {1.0} {1.0} {} 10 1.0 {}

S -> S' PERIOD

# for closed interrogatives that are essentially declarative with a question mark
# S {^[x]:x=A} -> S' {A}
# S {^[x]:(... & true(x) & (x=possibility(A1) | ... | x=possibility(An)))} -> S' {... & (A1 | ... | An)}
S -> S' QUESTION

# for all other interrogatives
# S {^[x]:A} -> S' {^[x]:A}
S -> S' QUESTION


# This is the root nonterminal for declarative sentences.
S' nonterminal {} {1.0} {1.0} {} 10 1.0 {}
S' -> S'':singular,try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because
S' -> S'':plural,try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because

# for subordinate clauses
S' -> THAT S':try_remove_comma,remove_that
S' -> WHETHER S':try_remove_comma,remove_whether
S' -> WHETHER OR NOT S':try_remove_comma,remove_whether
S' -> IF S':try_remove_comma,remove_if
S' -> BECAUSE S':try_remove_comma,remove_because

# S' {... & (~)?[y1]:(f(y1) & g(y1)) & ... & (~)?[yn]:(f(yn) & g(yn))}
#  -> ADVP_R {... & f'}
#     (COMMA)
#     S' {... & (~)?[y1]:g(y1) & ... & (~)?[yn]:g(yn)}
# where f(y) = (~)?[z]:(h(z) & arg2(z)=y) and f' = (~)?[z]:h(z)
#    or f(y) = (~)?[z1]:(h1(z1) & arg2(z1)=y) & ... & (~)?[zn]:(hn(zn) & arg2(zn)=y) and f' = (~)?[z1]:h1(z1) & ... & (~)?[zn]:hn(zn)
#    or f(y) = (~)?[z1]:(h1(z1) & arg2(z1)=y) | ... | (~)?[zn]:(hn(zn) & arg2(zn)=y) and f' = (~)?[z1]:h1(z1) | ... | (~)?[zn]:hn(zn)
S' -> ADVP_R:try_remove_comma,try_remove_nullable_subject,require_no_that,require_no_whether,require_no_if,require_no_because COMMA S':try_remove_comma
S' -> ADVP_R:try_remove_comma,try_remove_nullable_subject,require_no_that,require_no_whether,require_no_if,require_no_because S':try_remove_comma

# S' {?[X]:(h(X) & ![x]:(X(x) => (true(x) => g(x))))}
#  -> PP {^[P]:?[X]:(h(X) & ![x]:(X(x) => (true(x) => P(x))))}
#     (COMMA)
#     S' {g(x)}
# S' {... & (~)?[y1]:(f(y1) & g(y1)) & ... & (~)?[yn]:(f(yn) & g(yn))}
#  -> PP {^[P]:(... & f')}
#     (COMMA)
#     S' {... & (~)?[y1]:g(y1) & ... & (~)?[yn]:g(yn)}
# S' {... & ![x]:(h(x) => (~)?[y1]:(f(y1,x) & g(y1)) & ... & (~)?[yn]:(f(yn,x) & g(yn)))}
#  -> PP {^[P]:(... & ![x]:(h(x) => f'(x)))}
#     (COMMA)
#     S' {... & (~)?[y1]:g(y1) & ... & (~)?[yn]:g(yn)}
# where f(y) = (~)?[z]:(h(z) & arg2(z)=y) and f' = (~)?[z]:(h(z) & P(z))
#    or f(y) = (~)?[z1]:(h1(z1) & arg2(z1)=y) & ... & (~)?[zn]:(hn(zn) & arg2(zn)=y) and f' = (~)?[z1]:(h1(z1) & P(z1)) & ... & (~)?[zn]:(hn(zn) & P(zn))
#    or f(y) = (~)?[z1]:(h1(z1) & arg2(z1)=y) | ... | (~)?[zn]:(hn(zn) & arg2(zn)=y) and f' = (~)?[z1]:(h1(z1) & P(z1)) | ... | (~)?[zn]:(hn(zn) & P(zn))
S' -> PP:try_remove_comma,try_remove_nullable_subject,require_no_that,require_no_whether,require_no_if,require_no_because S':try_remove_comma
S' -> PP:try_remove_comma,try_remove_nullable_subject,require_no_that,require_no_whether,require_no_if,require_no_because COMMA S':try_remove_comma

# S' {... & (~)?[y1]:(f(y1) & p(y1) & f1(y1)) & ... & (~)?[yn]:(f(yn) & p(yn) & fn(yn))}
#  -> ADJP_R/PP {^[P]:(... & ?[y]:(p(y) & f(y) & P(y)))}
#     S' {... & (~)?[y1]:f1(y1) & ... & (~)?[yn]:fn(yn)}
# where f(y) = (~)?[z]:(h(z) & arg2(z)=y)
#    or f(y) = (~)?[z1]:(h1(z1) & arg2(z1)=y) & ... & (~)?[zn]:(hn(zn) & arg2(zn)=y)
#    or f(y) = (~)?[z1]:(h1(z1) & arg2(z1)=y) | ... | (~)?[zn]:(hn(zn) & arg2(zn)=y)
# This rule removes the predicate `p` from the event corresponding to the verb
# (and so the verb is semantically empty) such as in "flawed was the argument"
# and "in the tree was the cat". (called preposing)
S' -> PP:try_remove_comma,try_remove_nullable_subject,require_no_that,require_no_whether,require_no_if,require_no_because S':try_remove_comma,add_nullable_subject
S' -> ADJP_R:try_remove_comma,try_remove_nullable_subject,require_no_that,require_no_whether,require_no_if,require_no_because S':try_remove_comma,add_nullable_subject

# S' {?[X]:(f(X) & ![x]:(X(x) => (true(x) => g(x))))}
#  -> S' {g(x)}
#     (COMMA)
#     PP {?[X]:(f(X) & ![x]:(X(x) => (true(x) => P(x))))}
# NOTE: We don't allow other adjuncts here to avoid the spurious ambiguity
# where the PP could also attach at VP.
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because PP:try_remove_comma,try_remove_nullable_subject
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because COMMA PP:try_remove_comma,try_remove_nullable_subject

# S' {A => B} -> IF/WHETHER S' {A} (COMMA) (THEN) S' {B}
# S' {^[x]:x=(A => B)} -> IF/WHETHER S' {A} (COMMA) (THEN) S' {^[x]:x=B}
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,add_if S':try_remove_comma
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,add_if COMMA S':try_remove_comma
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,add_if THEN S':try_remove_comma
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,add_if COMMA THEN S':try_remove_comma
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,add_whether S':try_remove_comma
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,add_whether COMMA S':try_remove_comma
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,add_if,add_subjunctive S':try_remove_comma
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,add_if,add_subjunctive COMMA S':try_remove_comma
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,add_if,add_subjunctive THEN S':try_remove_comma
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,add_if,add_subjunctive COMMA THEN S':try_remove_comma
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,add_whether,add_subjunctive S':try_remove_comma
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,add_whether,add_subjunctive COMMA S':try_remove_comma

# S' {A1 & ... & An} -> S' {A1} COMMA S' {A2 & ... & An}
# S' {A1 | ... | An} -> S' {A1} COMMA S' {A2 | ... | An}
# S' {~A1 & ... & ~An} -> S' {~A1} COMMA S' {~A2 & ... & ~An}
# In the NOR rule, the negation can appear in front of the scope ?[y], or in
# front of any parent scope.
S' -> S':try_remove_comma COMMA S':add_comma

# S' {A1 & A2} -> S' {A1} (COMMA) AND S' {A2}
S' -> S':try_remove_comma COMMA AND S':try_remove_comma
S' -> S':try_remove_comma AND S':try_remove_comma

# S' {A1 | A2} -> S' {A1} (COMMA) OR S' {A2}
S' -> S':try_remove_comma COMMA OR S':try_remove_comma
S' -> S':try_remove_comma OR S':try_remove_comma

# S' {A1 | A2} -> S' {A1} (COMMA) NOR S' {A2}
S' -> S':try_remove_comma COMMA NOR VP_R:add_req_aux,try_remove_comma
S' -> S':try_remove_comma NOR VP_R:add_req_aux,try_remove_comma

# S' {... & ?[y1]:(g1(y1) & ?[r]:(arg1(r)=y1 & reason(r) & ?[z]:(h(z) & arg2(r)=z))) & ... & ?[yn]:(gn(yn) & ?[r]:(arg1(r)=yn & reason(r) & ?[z]:(h(z) & arg2(r)=z)))}
#  -> S' {... & ?[y1]:g1(y1) & ... & ?[yn]:gn(yn)}
#     (COMMA) BECAUSE/FOR S' {f(...)}
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because COMMA S':try_remove_comma,add_because
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because S':try_remove_comma,add_because
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because COMMA FOR S':try_remove_comma
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because FOR S':try_remove_comma

# S' {... & ?[y1]:(?[r]:(arg1(r)=y1 & reason(r) & ?[z]:(h(z) & arg2(r)=z)) & g1(y1)) & ... & ?[yn]:(?[r]:(arg1(r)=yn & reason(r) & ?[z]:(h(z) & arg2(r)=z)) & gn(yn))}
#  -> BECAUSE/FOR S' {?[z]:h(z)}
#     (COMMA) S' {?[y1]:g1(y1) & ... & ?[yn]:gn(yn)}
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,add_because COMMA S':try_remove_comma
S' -> S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because,add_because S':try_remove_comma
S' -> FOR S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because COMMA S':try_remove_comma
S' -> FOR S':try_remove_comma,require_no_that,require_no_whether,require_no_if,require_no_because S':try_remove_comma


S'' nonterminal {has_not} {1.0, 1.0} {1.0, 1.0} {} 10 1.0 {}

# S'' {(~)?[x]:f(x)} -> THERE IS DP {^[P]:?[X]:(X=^[x]:f(x) & (~)?[x]:(X(x) & P(x)))}
# NOTE: This above rule is only really useful if we choose to represent "there
# is a cat" as something like ?[x]:(U(0,x) & cat(x)).
S'' -> THERE IS DP:try_remove_nullable_subject,require_no_lambda

# S'' {... & (~)?[y1]:(... & arg1/arg2(y1)=a & ...) & ... & (~)?[yn]:(... & arg1/arg2(yn)=a & ...}
#  -> DP {^[P]:?[X]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x)))}
#     VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
# S'' {... & (~)?[x]:(f(x) & (~)?[y1]:(... & arg1/arg2(y1)=x & ...) & ... & (~)?[yn]:(... & arg1/arg2(yn)=x & ...))} if x is not a set variable
#  -> DP {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)?[x]:(X(x) & P(x))))}
#     VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
# S'' {... & (~)![x]:(f(x) => ... & (~)?[y1]:(... & arg1/arg2(y1)=x & ...) & ... & (~)?[yn]:(... & arg1/arg2(yn)=x & ...))}
#  -> DP {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)![x]:(X(x) => P(x))))}
#     VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
# S'' {... & ?[X]:(f(X) & (~)![x]:(X(x) => ... & (~)?[y1]:(... & arg1/arg2(y1)=x & ...) & ... & (~)?[yn]:(... & arg1/arg2(yn)=x & ...)))}
#  -> DP {^[P]:(... & ?[X]:(f(X) & (~)![x]:(X(x) => P(x))))}
#     VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
# S'' {... & ?[X]:(f(X) & (~)?[y1]:(... & arg1/arg2(y1)=X & ...) & ... & (~)?[yn]:(... & arg1/arg2(yn)=X & ...))} if X is a set variable
#  -> DP {^[P]:(... & ?[X]:(f(X) & ![x]:(X(x) => P(x))))}
#     VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
# NOTE: The above three rules, during the inverse transformation, the scope of
# X and x can be positioned anywhere above the scope of y. However, to avoid
# producing semantically-equivalent logical forms, for each equivalence class
# of semantically-equivalent inverse logical forms, we only output a single
# logical form (for example, by choosing the logical form in the equivalence
# class in which the scope of X and x are maximal). Also, the above rule can be
# extended to other kinds of quantification over X, such as existential or weak
# universal quantifier. Also, note that f(X) and f(x) cannot depend on any
# variables other than those declared within f(X) and f(x). But note that in
# the example "a cat and dog are sleeping", f(X) includes the definition for
# "cat" and "dog". In the above three rules, the scope of y is the right-most
# and top-most scope of an event variable (a object with arguments).
# NOTE: This rule also handles open interrogatives but only when the unknown
# variable is in the logical form for the DP. In the logical forms of some
# interrogatives, X may be declared as a lambda variable.
# NOTE: The `arg2` version of the rule is for preposing.
# NOTE: In comparative constructions where sizes of sets are compared, this
# requires that the quantified variables are used in the same way in both
# consequents. That is, in:
#   ?[X]:(... & ?[R]:(f(size(X),size(R)) & ... & ![r]:(R(r) => ?[y]:(arg1/arg2/arg3(y)=r & ...))) & ... & ![x]:(X(x) => ?[y]:(arg1/arg2/arg3(y)=x & ...)))
# This rule requires that `arg1(y)=r` and `arg1(y)=x` appear in both
# consequents (or `arg2(y)=r` and `arg2(y)=x`, etc).
S'' -> DP:try_remove_nullable_subject,require_no_subordinate VP_R:try_remove_nullable_subject

# NOTE: The above note also applies to these rules.
# S'' {... & ~?[x]:(f(x) & ?[y1]:(... & arg1/arg2(y1)=x & ...) & ... & ?[yn]:(... & arg1/arg2(yn)=x & ...))}
#  -> DP {^[P]:(... & ?[X]:(X=^[x]:f(x) & ?[x]:(X(x) & P(x))))}
#     VP_R {... & ~?[y1]:(...) & ... & ~?[yn]:(...)}
# S'' {... & ~![x]:(f(x) => ... & ?[y1]:(... & arg1/arg2(y1)=x & ...) & ... & ?[yn]:(... & arg1/arg2(yn)=x & ...))}
#  -> DP {^[P]:(... & ?[X]:(X=^[x]:f(x) & ![x]:(X(x) => P(x))))}
#     VP_R {... & ~?[y1]:(...) & ... & ~?[yn]:(...)}
# S'' {... & ?[X]:(f(X) & ~![x]:(X(x) => ... & ?[y1]:(... & arg1/arg2(y1)=x & ...) & ... & ?[yn]:(... & arg1/arg2(yn)=x & ...)))}
#  -> DP {^[P]:(... & ?[X]:(f(X) & ![x]:(X(x) => P(x))))}
#     VP_R {... & ~?[y1]:(...) & ... & ~?[yn]:(...)}
# NOTE: This rule also handles open interrogatives but only when the unknown
# variable is in the logical form for the DP. In the logical forms of some
# interrogatives, X may be declared as a lambda variable.
# NOTE: The `arg2` version of the rule is for preposing.
# NOTE: In comparative constructions where sizes of sets are compared, this
# requires that the quantified variables are used in the same way in both
# consequents. That is, in:
#   ?[X]:(... & ?[R]:(f(size(X),size(R)) & ... & ![r]:(R(r) => ?[y]:(arg1/arg2/arg3(y)=r & ...))) & ... & ![x]:(X(x) => ?[y]:(arg1/arg2/arg3(y)=x & ...)))
# This rule requires that `arg1(y)=r` and `arg1(y)=x` appear in both
# consequents (or `arg2(y)=r` and `arg2(y)=x`, etc).
S'' -> DP:try_remove_nullable_subject,require_no_subordinate VP_R:try_remove_nullable_subject

# the subject is an open interrogative finite subordinate clause
# S'' {... & (~)?[y1]:(f(y1) & g1(y1)) & ... & (~)?[yn]:(f(yn) & gn(yn))}
#  -> S' {... & f'}
#     VP_R {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
# where f(y) = arg1(y)=^[x]:A and f' = ^[x]:A
# e.g. "what books she has are in the attic"
S'' -> S':try_remove_nullable_subject,require_no_subordinate,add_req_no_aux,add_subordinate VP_R:try_remove_nullable_subject

# open interrogative clauses with movement
# S'' {^[x]:(... ?[X]:(... & X(x) & ... & ?[r]:(... & arg1/arg2/arg3(r)=x)))} note that X is not quantified here; `X(x)` kind of plays the role of a quantifier
#  -> DP {^[P,x]:(... & ?[X]:(... & X(x) & P(x)))}
#     VP_R {... & ?[r]:(...)}
# S'' {^[X]:(... & ![x]:(X(x) => ?[r]:(... & arg1/arg2/arg3(r)=x)))}
#  -> DP {^[P,X]:(... & ![X]:(X(x) => P(x)))}
#     VP_R {... & ?[r]:(...)}
# S'' {^[x]:(... & ?[r]:(... & arg1/arg2/arg3(r)=x))}
#  -> DP {^[P,x]:(... & ?[X]:(^[x]:U(x,0) & ... & X(x) & P(x)))}
#     VP_R {... & ?[r]:(...)}
# NOTE: `r` does not have to be the head of the logical form.
# NOTE: `r` can also be any scope that is an ancestor of x.
# e.g. "which store did Jason run to?", "what store did Jason run to?", "who is she speaking with?"
S'' -> DP:try_remove_nullable_subject,try_remove_subordinate VP_R:try_remove_nullable_subject,try_add_req_aux,try_remove_subordinate # requires do-support unless subordinate
S'' -> DP:try_remove_nullable_subject,try_remove_subordinate VP_R:try_remove_nullable_subject,try_add_req_aux,try_remove_subordinate,add_to_infinitive # requires do-support unless subordinate

# open interrogative clauses with movement
# S'' {^[x]:(... ?[X]:(... & X(x) & ... & ?[r]:(p(r) & f(r) & arg1/arg2/arg3(r)=x)))} note that X is not quantified here; `X(x)` kind of plays the role of a quantifier
#  -> PP {^[x]:(... ?[X]:(... & X(x) & ... & ?[r]:(p(r) & arg1/arg2/arg3(r)=x)))}
#     VP_R {... & ?[r]:(p(r) & f(r))}
# S'' {^[X]:(... & ![x]:(X(x) => ?[r]:(p(r) & f(r) & arg1/arg2/arg3(r)=x)))}
#  -> PP {^[X]:(... ![x]:(X(x) => ?[r]:(p(r) & arg1/arg2/arg3(r)=x)))}
#     VP_R {... & ?[r]:(p(r) & f(r))}
# S'' {^[x]:(... & ?[r]:(p(r) & f(r) & arg1/arg2/arg3(r)=x))}
#  -> PP {^[x]:(... & ?[r]:(p(r) & arg1/arg2/arg3(r)=x))}
#     VP_R {... & ?[r]:(p(r) & f(r))}
# where `f(r)` contains the verb-specific terms for the event `r`.
# NOTE: `r` does not have to be the head of the logical form.
# e.g. "to which store did Jason run?", "with whom is she speaking?"
S'' -> PP:try_remove_nullable_subject,try_remove_subordinate,add_preposition VP_R:try_remove_nullable_subject,try_add_req_aux,try_remove_subordinate,add_preposition # requires do-support unless subordinate
S'' -> PP:try_remove_nullable_subject,try_remove_subordinate,add_preposition VP_R:try_remove_nullable_subject,try_add_req_aux,try_remove_subordinate,add_preposition,add_to_infinitive # requires do-support unless subordinate

# open interrogative clauses with movement
# S'' {^[x]:(... ?[r]:(?[d]:(degree(d) & arg1(d)=r & arg2(d)=x) & p(r) & f(r)))}
#  -> ADJP_R {^[P,x]:?[r]:(?[d]:(degree(d) & arg1(d)=r & arg2(d)=x) & p(r))}
#     VP_R {^[x]:(... ?[r]:f(r))}
# NOTE: `r` does not have to be the head of the logical form.
# This rule removes the predicate `p` from the event corresponding to the verb
# (and so the verb is semantically empty).
# e.g. "how big is the earth?"
S'' -> ADJP:try_remove_nullable_subject,try_remove_subordinate VP_R:try_remove_nullable_subject,try_add_req_aux,try_remove_subordinate # requires do-support unless subordinate
S'' -> ADJP:try_remove_nullable_subject,try_remove_subordinate VP_R:try_remove_nullable_subject,try_add_req_aux,try_remove_subordinate,add_to_infinitive # requires do-support unless subordinate

# subject-less infinitival closed interrogative clauses
# S'' {^[x]:x=A} -> VP_R {A}
# S'' {^[x]:(... & true(x) & (x=possibility(A1) | ... | x=possibility(An)))} -> VP_R {... & (A1 | ... | An)}
S'' -> VP_R:remove_subordinate,require_no_arg1,require_to_infinitive

# subject-less infinitival open interrogative clauses
# S'' {^[x]:A} -> VP_R {^[x]:A}
S'' -> VP_R:try_remove_subordinate,require_no_arg1,add_to_infinitive

# closed interrogative clauses, which require subject-auxiliary inversion
# (excluding closed interrogative clauses we handle at the nonterminal S)
# S'' {^[x]:x=A} -> VP_R {A}
# S'' {^[x]:(... & true(x) & (x=possibility(A1) | ... | x=possibility(An)))} -> VP_R {... & (A1 | ... | An)}
S'' -> VP_R:try_add_req_aux # requires do-support unless subordinate

# S'' {... & ?[x]:(arg1(x)=possibility(A) & ...)} -> THAT S' {A} VP_R {... & ?[x]:(...)}
# e.g. "that Constance is smart is not surprising"
S'' -> S':remove_nullable_subject,add_that VP_R:remove_nullable_subject
# e.g. "that it be signed is a requirement"
S'' -> S':remove_nullable_subject,add_that,add_subjunctive VP_R:remove_nullable_subject

# comparative constructions
# S'' {... & ?[x,r]:(?[g1]:(p(f1)(g1) & arg1(g1)=x & arg2(g1)=r) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x & arg2(gn)=r) & ... & ?[y]:(... & arg1(y)=x & ... & h(r) & ...))}
#  -> DP {^[P]:(... & ?[X]:(X=^[x]:(?[g1]:(p(f1)(g1) & arg1(g1)=x) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x) & ...) & ?[x]:(X(x) & P(x))))}
#     VP_R {... & ?[r]:(?[gn]:(p(fn)(gn) & arg2(gn)=r) & ... & ?[y]:(... & h(r) & ...))}
# where h(r) could either be `r=a` if r is a constant or it can define a new object like `U(i,r) & p(r) & ...`.
# S'' {... & ?[X,R]:(... & f(size(X),size(R)) & ... & F(X=^[x]:(![r]:(R(r) => ?[g1]:(p(f1)(g1) & arg1(g1)=x & arg2(g1)=r) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x & arg2(gn)=r)) & ...)) & ... & ![x]:(X(x) => ?[y]:(... & arg1(y)=x & ... & R=^[r]:(...) & ...)))}
#  -> DP {^[P]:(... & ?[X]:(... & f(size(X)) & ... & F(X=^[x]:(?[g1]:(p(f1)(g1) & arg1(g1)=x) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x))) & ... & ![x]:(X(x) => P(x))))}
#     VP_R {... & ?[R]:(f(size(R)) & ... & ![r]:(R(r) => ?[gn]:(p(fn)(gn) & arg2(gn)=r)) & ... & ?[y]:(... R=^[r]:(...) & ...))}
# S'' {... & ?[X,R]:(?[X1,R1]:(... & f(size(X1),size(R1)) & ... & F(X1=^[x]:(![r]:(R1(r) => ?[g1]:(p(f1)(g1) & arg1(g1)=x & arg2(g1)=r) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x & arg2(gn)=r)) & ...)) & ?[X2,R2]:(... & f(size(X2),size(R2)) & ... & F(X2=^[x]:(...)) & ... & X=^[S]:(S=X1 | ... | S=Xn) & R=^[S]:(S=R1 | ... | S=Rn))) & ... & ![S]:(X(S) => ![x]:(S(x) => ?[y]:(... & arg1(y)=x & ... & ![Ri]:(R(Ri) => Ri=^[r]:(...)) & ...))))}
#  -> DP {^[P]:(... & ?[X]:(... & f(size(X)) & ... & F(X=^[x]:(?[g1]:(p(f1)(g1) & arg1(g1)=x) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x))) & ... & ![x]:(X(x) => P(x))))}
#     VP_R {... & ?[Rn]:(f(size(Rn)) & ... & ![r]:(Rn(r) => ?[gn]:(p(fn)(gn) & arg2(gn)=r)) & ... & ?[y]:(... Rn=^[r]:(...) & ...))}
# NOTE: The predicate could also be a simple `p` rather than `p(f)`. The terms
# `f(size(X),size(R))` and `?[gi]:(...)` are optional (but there must be at
# least one). The term `f(size(X),size(R))` handles comparative constructions
# where sizes of sets are compared.
# e.g. "a brighter star could be seen with the telescope than without it", "more people came than last time", "more girls but fewer boys came to the event than last time"
S'' -> DP:try_remove_nullable_subject,require_no_subordinate VP_R:try_remove_nullable_subject

# S'' {A} -> VP_R {A}
S'' -> VP_R:remove_nullable_subject


VP_R nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# VP_R {... & (~)?[y1]:(g1(y1) & f(y1)) & ... & (~)?[yn]:(gn(yn) & f(yn))}
#  -> VP_R {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
#     ADVP_R/PP {^[P]:(... & f')}
# where f(y) = (~)?[z]:(h(z) & arg1/arg2(z)=y) and f' = (~)?[z]:(h(z) & P(z))
#    or f(y) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=y) & ... & (~)?[zn]:(hn(zn) & arg1/arg2(zn)=y) and f' = (~)?[z1]:(h1(z1) & P(z1)) & ... & (~)?[zn]:(hn(zn) & P(zn))
#    or f(y) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=y) | ... | (~)?[zn]:(hn(zn) & arg1/arg2(zn)=y) and f' = (~)?[z1]:(h1(z1) & P(z1)) | ... | (~)?[zn]:(hn(zn) & P(zn))
# Note that f(y) may also contain variables which are universally-quantified,
# above the scope of zi, either within the scope of yi (e.g. "it flew faster
# than every bird") or above it ("i have been to every restaurant"). In this
# case, the universal quantifiers are also moved into f'.
# NOTE: This rule also works if the yi's are ORed.
#
# An example of a sentence with coordination in both the verb and adverb is:
#  "she walked and sat under every tree and near every rock"
VP_R -> VP_R:try_remove_comma PP:try_remove_comma # for arg1
VP_R -> VP_R:try_remove_comma ADVP_R:try_remove_comma # for arg1
VP_R -> VP_R:try_remove_comma COMMA PP:try_remove_comma # for arg1
VP_R -> VP_R:try_remove_comma COMMA ADVP_R:try_remove_comma # for arg1
VP_R -> VP_R:try_remove_comma PP:try_remove_comma # for arg2
VP_R -> VP_R:try_remove_comma ADVP_R:try_remove_comma # for arg2
VP_R -> VP_R:try_remove_comma COMMA PP:try_remove_comma # for arg2
VP_R -> VP_R:try_remove_comma COMMA ADVP_R:try_remove_comma # for arg2

# VP_R {... & (~)?[y1]:(p(y1) & f1(y1) & f(y1)) & ... & (~)?[yn]:(p(yn) & fn(yn) & f(yn))}
#  -> VP_R {... & (~)?[y1]:f1(y1) & ... & (~)?[yn]:fn(yn)}
#     ADJP_R/PP {^[P]:(... & ?[y]:(p(y) & f(y) & P(y)))}
# This rule removes the predicate `p` from the event corresponding to the verb
# (and so the verb is semantically empty) such as in "the cat is blue" and "the
# cat is in the tree". `fi` contains verb-specific terms such as `present` as
# well as any adjuncts or other arguments of y whereas `f` contains everything
# else, such as the argument.
VP_R -> VP_R:try_remove_comma PP:try_remove_comma
VP_R -> VP_R:try_remove_comma ADJP_R:try_remove_comma

# for prepositional verbs (i.e. "look forward to", etc)
# VP_R {... & (~)?[y1]:(p(y1) & f1(y1) & f(y1)) & ... & (~)?[yn]:(p(yn) & fn(yn) & f(yn))}
#  -> VP_R {... & (~)?[y1]:(p(y1) & f1(y1)) & ... & (~)?[yn]:(p(yn) & fn(yn))}
#     PP {... & ?[y]:(p(y) & f(y))}
# where `p` is the predicate, `fi` contains verb-specific terms such as
# `present` as well as any adjuncts of y whereas `f` contains everything else,
# such as the arguments.
VP_R -> VP_R:try_remove_comma,add_preposition PP:try_remove_comma,add_preposition

# We need this rule for constructions like "she brought down the bed" and "she brought the bed down".
VP_R -> VP_R:try_remove_comma,add_particle PARTICLE_PLACEHOLDER

# VP_R {... & (~)?[y1]:(inverse(own)(y1) & arg2(y1)=a & ...) & ... & (~)?[yn]:(inverse(own)(yn) & arg2(yn)=a & ...}
#  -> VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
#     DP {^[P]:?[X]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x)))}
# VP_R {... & (~)?[x]:(f(x) & (~)?[y1]:(inverse(own)(y1) & arg2(y1)=x & ...) & ... & (~)?[yn]:(inverse(own)(yn) & arg2(yn)=x & ...))} if x is not a set variable
#  -> VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
#     DP {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)?[x]:(X(x) & P(x))))}
# VP_R {... & (~)![x]:(f(x) => ... & (~)?[y1]:(inverse(own)(y1) & arg2(y1)=x & ...) & ... & (~)?[yn]:(inverse(own)(yn) & arg2(yn)=x & ...))}
#  -> VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
#     DP {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)![x]:(X(x) => P(x))))}
# VP_R {... & ?[X]:(f(X) & (~)![x]:(X(x) => ... & (~)?[y1]:(inverse(own)(y1) & arg2(y1)=x & ...) & ... & (~)?[yn]:(inverse(own)(yn) & arg2(yn)=x & ...)))}
#  -> VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
#     DP {^[P]:(... & ?[X]:(f(X) & (~)![x]:(X(x) => P(x))))}
# VP_R {... & ?[X]:(f(X) & (~)?[y1]:(inverse(own)(y1) & arg2(y1)=X & ...) & ... & (~)?[yn]:(inverse(own)(yn) & arg2(yn)=X & ...))} if X is a set variable
#  -> VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
#     DP {^[P]:(... & ?[X]:(f(X) & ![x]:(X(x) => P(x))))}
# e.g. "the pencil is Emma's", "the pencils are the students'"
VP_R -> VP_R:try_remove_comma DP:add_genitive,singular,try_remove_comma
VP_R -> VP_R:try_remove_comma DP:add_genitive,plural,try_remove_comma

# VP_R {... & (~)?[y1]:(... & arg1/arg2/arg3(y1)=a & ...) & ... & (~)?[yn]:(... & arg1/arg2/arg3(yn)=a & ...)}
#  -> VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
#     DP/ADJP_R {^[P]:?[X]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x)))}
# VP_R {... & (~)?[x]:(f(x) & (~)?[y1]:(... & arg1/arg2/arg3(y1)=x & ...) & ... & (~)?[yn]:(... & arg1/arg2/arg3(yn)=x & ...))} if x is not a set variable
#  -> VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
#     DP/ADJP_R {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)?[x]:(X(x) & P(x))))}
# VP_R {... & (~)![x]:(f(x) => ... & (~)?[y1]:(... & arg1/arg2/arg3(y1)=x & ...) & ... & (~)?[yn]:(... & arg1/arg2/arg3(yn)=x & ...))}
#  -> VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
#     DP/ADJP_R {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)![x]:(X(x) => P(x))))}
# VP_R {... & ?[X]:(f(X) & (~)![x]:(X(x) => ... & (~)?[y1]:(... & arg1/arg2/arg3(y1)=x & ...) & ... & (~)?[yn]:(... & arg1/arg2/arg3(yn)=x & ...)))}
#  -> VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
#     DP/ADJP_R {^[P]:(... & ?[X]:(f(X) & (~)![x]:(X(x) => P(x))))}
# VP_R {... & ?[X]:(f(X) & (~)?[y1]:(... & arg1/arg2/arg3(y1)=X & ...) & ... & (~)?[yn]:(... & arg1/arg2/arg3(yn)=X & ...))} if X is a set variable
#  -> VP_R {... & (~)?[y1]:(...) & ... & (~)?[yn]:(...)}
#     DP/ADJP_R {^[P]:(... & ?[X]:(f(X) & ![x]:(X(x) => P(x))))}
# e.g. "it is not a cat nor is it a dog"
VP_R -> VP_R:try_remove_comma DP:try_remove_comma,require_no_inverse,remove_req_aux # for arg1 (subject-auxiliary inversion; e.g. "is it a boy?")
VP_R -> VP_R:try_remove_comma DP:try_remove_comma,require_no_inverse # for arg2
VP_R -> VP_R:try_remove_comma DP:try_remove_comma,require_no_inverse # for arg3 (NOTE: we could make this semantic and have only two args)
VP_R -> VP_R:try_remove_comma ADJP_R:try_remove_comma,require_no_inverse,remove_req_aux # for arg1 (subject-auxiliary inversion; e.g. "is he angry?")
VP_R -> VP_R:try_remove_comma ADJP_R:try_remove_comma,require_no_inverse # for arg2
VP_R -> VP_R:try_remove_comma ADJP_R:try_remove_comma,require_no_inverse # for arg3 (NOTE: we could make this semantic and have only two args)
VP_R -> VP_R:try_remove_comma BY DP:try_remove_comma,require_inverse # for arg2
VP_R -> VP_R:try_remove_comma BY DP:try_remove_comma,require_inverse # for arg3 (NOTE: we could make this semantic and have only two args)

# VP_R {... & (~)?[y1]:(g1(y1) & f(y1)) & ... & (~)?[yn]:(gn(yn) & f(yn))}
#  -> VP_R {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
#     (COMMA) (THAT) S' {... & f'}
# where f(y) = (~)?[z]:(h(z) & arg1/arg2(y)=z) and f' = (~)?[z]:h(z)
#    or f(y) = arg1/arg2(y)=possibility(A) and f' = A
# VP_R {... & ?[X]:(X=^[x]:(x=z1 | ... | x=zm) & ... & ![x]:(X(x) => (~)?[y1]:(g1(y1) & arg1/arg2(y1)=x) & ... & (~)?[yn]:(gn(yn) & arg1/arg2(yn)=x)))}
#  -> VP_R {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
#     (COMMA) (THAT) S' {... & (?[z1]:(...) & ... & ?[zm]:(...))}
# VP_R {... & ?[X]:(X=^[x]:(x=z1 | ... | x=zm) & ... & ?[x]:(X(x) & (~)?[y1]:(g1(y1) & arg1/arg2(y1)=x) & ... & (~)?[yn]:(gn(yn) & arg1/arg2(yn)=x)))}
#  -> VP_R {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
#     (COMMA) (THAT) S' {... & (?[z1]:(...) | ... | ?[zm]:(...))}
# where f(y) = (~)?[z]:(h(z) & arg1/arg2(y)=z) and f' = (~)?[z]:h(z)
# NOTE: z could also be universally quantified above the scope of yi
# NOTE: The arg1 version is for postposing/it-cleft constructions such as "it
# didn't worry him that she was early".
# e.g. "he wants to fly"
VP_R -> VP_R:try_remove_comma S':try_remove_comma,add_to_infinitive,add_nullable_subject
# e.g. "he insists she be here", "he insists that she be here"
VP_R -> VP_R:try_remove_comma S':try_remove_comma,add_subjunctive,add_nullable_subject
VP_R -> VP_R:try_remove_comma COMMA S':try_remove_comma,add_subjunctive,add_nullable_subject
VP_R -> VP_R:try_remove_comma S':try_remove_comma,add_subjunctive,add_nullable_subject,add_that
# e.g. "i think Emma returned the books yesterday", "i think that Emma returned the books yesterday"
VP_R -> VP_R:try_remove_comma S':try_remove_comma # TODO: remove grammatical features from S'
VP_R -> VP_R:try_remove_comma S':try_remove_comma,add_that # TODO: remove grammatical features from S'
# e.g. "he didn't like it that the barn was destroyed"
VP_R -> VP_R:try_remove_comma IT S':try_remove_comma,add_that # TODO: remove grammatical features from S'

# closed interrogative finite subordinate clause
# VP_R {... & (~)?[y1]:(g1(y1) & f(y1)) & ... & (~)?[yn]:(gn(yn) & f(yn))}
#  -> VP_R {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
#     (COMMA) IF/WHETHER S' {... & f'} (COMMA)
# where f(y) = arg2(y)=^[x]:A and f' = ^[x]:A
# VP_R {A => B} -> VP_R {B} (COMMA) IF/WHETHER S' {A} (COMMA)
# VP_R {^[x]:x=(A => B)} -> VP_R {^[x]:x=B} (COMMA) IF/WHETHER S' {A} (COMMA)
VP_R -> VP_R:try_remove_comma S':try_remove_comma,add_req_no_aux,add_whether
VP_R -> VP_R:try_remove_comma S':try_remove_comma,add_req_no_aux,add_if
VP_R -> VP_R:try_remove_comma COMMA S':try_remove_comma,add_req_no_aux,add_whether COMMA
VP_R -> VP_R:try_remove_comma COMMA S':try_remove_comma,add_req_no_aux,add_if COMMA
VP_R -> VP_R:try_remove_comma S':try_remove_comma,add_req_no_aux,add_whether,add_subjunctive
VP_R -> VP_R:try_remove_comma S':try_remove_comma,add_req_no_aux,add_if,add_subjunctive
VP_R -> VP_R:try_remove_comma COMMA S':try_remove_comma,add_req_no_aux,add_whether,add_subjunctive COMMA
VP_R -> VP_R:try_remove_comma COMMA S':try_remove_comma,add_req_no_aux,add_if,add_subjunctive COMMA

# open interrogative finite subordinate clause
# VP_R {... & (~)?[y1]:(g1(y1) & f(y1)) & ... & (~)?[yn]:(gn(yn) & f(yn))}
#  -> VP_R {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
#     S' {... & f'}
# where f(y) = arg1/arg2(y)=^[x]:A and f' = ^[x]:A
# NOTE: The `arg1` form is for subject-auxiliary inversion.
VP_R -> VP_R:try_remove_comma S':try_remove_comma,add_req_no_aux,add_subordinate

# postposed prepositional phrases
# VP_R {... & ?[x]:(... ?[y1]:(... & arg1/arg2/arg3(y1)=x & ...) & ... & ?[yn]:(... & arg1/arg2/arg3(yn)=x & ...) & ... & f(x))}
#  -> VP_R {... & ?[x]:(... ?[y1]:(... & arg1/arg2/arg3(y1)=x & ...) & ... & ?[yn]:(... & arg1/arg2/arg3(yn)=x & ...) & ...)}
#     PP {^[P]:(... & f')}
# where f(x) = (~)?[z]:(h(z) & arg1/arg2(z)=x) and f' = (~)?[z]:(h(z) & P(z))
#    or f(x) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=x) & ... & (~)?[zn]:(hn(zn) & arg1/arg2(zn)=x) and f' = (~)?[z1]:(h1(z1) & P(z1)) & ... & (~)?[zn]:(hn(zn) & P(zn))
#    or f(x) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=x) | ... | (~)?[zn]:(hn(zn) & arg1/arg2(zn)=x) and f' = (~)?[z1]:(h1(z1) & P(z1)) | ... | (~)?[zn]:(hn(zn) & P(zn))
# Note that f(x) may also contain variables which are universally-quantified,
# above the scope of zi, either within the scope of xi (e.g. "i lent the book
# to her with every fact about chemistry") or above it ("i lent a book to her
# from each student").
# In this case, the universal quantifiers are also moved into f'.
# NOTE: This rule also works if X is existentially-quantified.
# e.g. "i lent the book to Kim with all the information she needs"
VP_R -> VP_R:try_remove_comma PP:try_remove_comma

# postposed subordinate clauses
# VP_R {... & ?[x]:(f(x) & ... ?[y1]:(... & arg1/arg2/arg3(y1)=x & ...) & ... & ?[yn]:(... & arg1/arg2/arg3(yn)=x & ...) & ... & ?[g1]:(... & arg1/arg2/arg3(g1)=x) & ... & ?[gn]:(... & arg1/arg2/arg3(gn)=x))}
#  -> VP_R {... & ?[x]:(f(x) & ... ?[y1]:(... & arg1/arg2/arg3(y1)=x & ...) & ... & ?[yn]:(... & arg1/arg2/arg3(yn)=x & ...) & ... & ?[g1]:(... & arg1/arg2/arg3(g1)=x) & ...)}
#     (COMMA) (THAT) S' {?[g1]:(...) & ... & ?[gn]:(...)} (COMMA)
# e.g. "Kim lent a book to Ed that contained all the information he needed"
VP_R -> VP_R:try_remove_comma S':try_remove_comma,add_that,add_nullable_subject # TODO: remove grammatical features from S'
VP_R -> VP_R:try_remove_comma COMMA S':try_remove_comma,add_that,add_nullable_subject COMMA # TODO: remove grammatical features from S'

# postposed open interrogative finite subordinate clause (relative clauses)
# VP_R {... & ?[x]:(f(x) & ... ?[y1]:(... & arg1/arg2/arg3(y1)=x & ...) & ... & ?[yn]:(... & arg1/arg2/arg3(yn)=x & ...) & ... & A(x))}
#  -> VP_R {... & ?[x]:(f(x) & ... ?[y1]:(... & arg1/arg2/arg3(y1)=x & ...) & ... & ?[yn]:(... & arg1/arg2/arg3(yn)=x & ...) & ...)}
#     S' {^[x]:A(x)}
# NOTE: The above `x` could also be universally quantified.
# VP_R {... & ?[S]:(F(S) & ... & ![x]:(S(x) => ?[y1]:(... & arg1/arg2/arg3(y1)=x & ...) & ... & ?[yn]:(... & arg1/arg2/arg3(yn)=x & ...)) & ... & ![x]:(S(x) => A(x)))}
#  -> VP_R {... & ?[S]:(F(S) & ... & ![x]:(S(x) => ?[y1]:(... & arg1/arg2/arg3(y1)=x & ...) & ... & ?[yn]:(... & arg1/arg2/arg3(yn)=x & ...)) & ...)}
#     (COMMA) S' {^[x]:A(x)} (COMMA)
# NOTE: The first form of this rule requires no commas (the child S' is an
# integrated relative clause), whereas the second form may or may not have
# commas (the child S' is a supplementary relative clause).
# e.g. "a person walked into the room who looked like Emma"
VP_R -> VP_R:try_remove_comma S':try_remove_comma,add_req_no_aux,add_subordinate
VP_R -> VP_R:try_remove_comma COMMA S':try_remove_comma,add_req_no_aux,add_subordinate COMMA

# comparative constructions
# VP_R {... & ?[x,r]:(?[g1]:(p(f1)(g1) & arg1(g1)=x & arg2(g1)=r) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x & arg2(gn)=r) & ... & ?[y]:(... & arg1(y)=x & ... & h(r) & ...))}
#  -> VP_R {... & ?[x]:(?[g1]:(p(f1)(g1) & arg1(g1)=x) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x) & ... & ?[y]:(... & arg1(y)=x & ... ))}
#     P {p}
#     V_ADJUNCT {... & ?[r]:(?[gn]:(p(fn)(gn) & arg2(gn)=r) & ... & h(r))}
# where h(r) could either be `r=a` if r is a constant or it can define a new object like `U(i,r) & p(r) & ...`.
# VP_R {... & ?[X,R]:(... & f(size(X),size(R)) & ... & F(X=^[x]:(![r]:(R(r) => ?[g1]:(p(f1)(g1) & arg1(g1)=x & arg2(g1)=r) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x & arg2(gn)=r)) & ...)) & ... & ![x]:(X(x) => ?[y]:(... & arg1(y)=x & ... & R=^[r]:(...) & ...)))}
#  -> VP_R {... & ?[X]:(... & f(size(X)) & ... & F(X=^[x]:(?[g1]:(p(f1)(g1) & arg1(g1)=x) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x) & ...)) & ... & ![x]:(X(x) => ?[y]:(... & arg1(y)=x & ...)))}
#     P {p} (or `f`, whichever comes last)
#     V_ADJUNCT {... & ?[R]:(f(size(R)) & ... & ![r]:(R(r) => ?[gn]:(p(fn)(gn) & arg2(gn)=r)) & ... & R=^[r]:(...))}
# VP_R {... & ?[X,R]:(?[X1,R1]:(... & f(size(X1),size(R1)) & ... & F(X1=^[x]:(![r]:(R(r) => ?[g1]:(p(f1)(g1) & arg1(g1)=x & arg2(g1)=r) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x & arg2(gn)=r)) & ...)) & ?[X2,R2]:(... & f(size(X2),size(R2)) & ... & F(X2=^[x]:(...)) & ... & X=^[S]:(S=X1 | ... | S=Xn) & R=^[S]:(S=R1 | ... | S=Rn))) & ... & ![S]:(X(S) => ![x]:(S(x) => ?[y]:(... & arg1(y)=x & ... & ![Ri]:(R(Ri) => Ri=^[r]:(...)) & ...))))}
#  -> VP_R {... & ?[X]:(?[X1]:(... & f(size(X1)) & ... & F(X1=^[x]:(?[g1]:(p(f1)(g1) & arg1(g1)=x) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x) & ...)) & ?[X2]:(... & f(size(X2)) & ... & F(X2=^[x]:(...)) & ... & X=^[S]:(S=X1 | ... | S=Xn))) & ... & ![S]:(X(S) => ![x]:(S(x) => ?[y]:(... & arg1(y)=x & ...))))}
#     P {p} (or `f`, whichever comes last)
#     V_ADJUNCT {... & ?[Rn]:(f(size(Rn)) & ... & ![r]:(Rn(r) => ?[gn]:(p(fn)(gn) & arg2(gn)=r)) & ... & Rn=^[r]:(...) & ...)}
# NOTE: The predicate could also be a simple `p` rather than `p(f)`. The terms
# `f(size(X),size(R))` and `?[gi]:(...)` are optional (but there must be at
# least one). The term `f(size(X),size(R))` handles comparative constructions
# where sizes of sets are compared.
# e.g. "you can see a brighter star with the telescope than without it", "i saw more people at the party than last time", "there were more girls but fewer boys at the event than last time"
VP_R -> VP_R:try_remove_comma P V_ADJUNCT:try_remove_comma

# comparative constructions
# VP_R {... & ?[r]:(?[gn]:(p(fn)(gn) & arg2(gn)=r) & ... & ?[y]:(... & h(r) & ...))}
#  -> VP_R {... & ?[y]:(...)}
#     P {p}
#     V_ADJUNCT {... & ?[r]:(?[gn]:(p(fn)(gn) & arg2(gn)=r) & ... & h(r))}
# where h(r) could either be `r=a` if r is a constant or it can define a new object like `U(i,r) & p(r) & ...`.
# VP_R {... & ?[R]:(f(size(R)) & ... & ![r]:(R(r) => ?[gn]:(p(fn)(gn) & arg2(gn)=r)) & ... & ?[y]:(... R=^[r]:(...) & ...))}
#  -> VP_R {... & ?[y]:(...)}
#     P {p}
#     V_ADJUNCT {... & ?[R]:(f(size(R)) & ... & ![r]:(R(r) => ?[gn]:(p(fn)(gn) & arg2(gn)=r)) & ... & R=^[r]:(...))}
# NOTE: The predicate could also be a simple `p` rather than `p(f)`. The terms
# `f(size(R))` and `?[gi]:(...)` are optional (but there must be at least one).
# The term `f(size(R))` handles comparative constructions where sizes of sets
# are compared.
# e.g. "a brighter star could be seen with the telescope than without it", "more people came than last time", "more girls but fewer boys came to the event than last time"
VP_R -> VP_R:try_remove_comma P V_ADJUNCT:try_remove_comma

# for gapping and stripping
# VP_R {... & (~)?[y]:(empty_ref(0,y) & f(y))}
#  -> ADVP_R/PP {... & f'}
# VP_R {... & ![x]:(h(x) => (~)?[y]:(empty_ref(0,y) & f(y,x)))}
#  -> ADVP_R/PP {... & ![x]:(h(x) => f'(x))}
# where f(y) = (~)?[z]:(h(z) & arg1/arg2(z)=y) and f' = (~)?[z]:h(z)
#    or f(y) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=y) & ... & (~)?[zn]:(hn(zn) & arg1/arg2(zn)=y) and f' = (~)?[z1]:h1(z1) & ... & (~)?[zn]:hn(zn)
#    or f(y) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=y) | ... | (~)?[zn]:(hn(zn) & arg1/arg2(zn)=y) and f' = (~)?[z1]:h1(z1) | ... | (~)?[zn]:hn(zn)
# Note that f(y) may also contain variables which are universally-quantified
# (above the scope of yi). In this case, the universal quantifiers are also
# moved into f'.
VP_R -> PP:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma # for arg1
VP_R -> ADVP_R:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma # for arg1
VP_R -> COMMA PP:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma # for arg1
VP_R -> COMMA ADVP_R:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma # for arg1
VP_R -> PP:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma # for arg2
VP_R -> ADVP_R:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma # for arg2
VP_R -> COMMA PP:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma # for arg2
VP_R -> COMMA ADVP_R:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma # for arg2

# for gapping and stripping
# VP_R {... & ?[y]:(empty_ref(y) & arg2/arg3(y)=a}
#  -> DP {^[P]:?[X]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x)))}
# VP_R {... & (~)?[x]:(f(x) & ?[y]:(empty_ref(y) & arg2/arg3(y)=x))} if x is not a set variable
#  -> DP {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)?[x]:(X(x) & P(x))))}
# VP_R {... & (~)![x]:(f(x) => ... & ?[y]:(empty_ref(y) & arg2/arg3(y)=x))}
#  -> DP {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)![x]:(X(x) => P(x))))}
# VP_R {... & ?[X]:(f(X) & (~)![x]:(X(x) => ... & ?[y]:(empty_ref(y) & arg2/arg3(y)=x)))}
#  -> DP {^[P]:(... & ?[X]:(f(X) & (~)![x]:(X(x) => P(x))))}
# VP_R {... & ?[X]:(f(X) & ?[y]:(empty_ref(y) & arg2/arg3(y)=X))} if X is a set variable
#  -> DP {^[P]:(... & ?[X]:(f(X) & ![x]:(X(x) => P(x))))}
VP_R -> DP:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma # for arg2
VP_R -> DP:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma # for arg3
VP_R -> COMMA DP:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma # for arg2
VP_R -> COMMA DP:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma # for arg3
VP_R -> BY DP:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_inverse,try_remove_comma # for arg2
VP_R -> BY DP:require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_inverse,try_remove_comma # for arg3

# for gapping and stripping
# VP_R {... & (~)?[y]:(empty_ref(y) & f(y))}
#  -> S' {... & f'}
# where f(y) = (~)?[z]:(h(z) & arg2(y)=z) and f' = (~)?[z]:h(z)
#    or f(y) = arg2(y)=possibility(A) and f' = A
# VP_R {... & ?[X]:(X=^[x]:(x=z1 | ... | x=zm) & ... & ![x]:(X(x) => (~)?[y]:(empty_ref(y) & arg2(y)=x)))}
#  -> S' {... & (?[z1]:(...) & ... & ?[zm]:(...))}
# VP_R {... & ?[X]:(X=^[x]:(x=z1 | ... | x=zm) & ... & ?[x]:(X(x) & (~)?[y]:(empty_ref(y) & arg2(y)=x)))}
#  -> VP_R {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
#     S' {... & (?[z1]:(...) | ... | ?[zm]:(...))}
# where f(y) = (~)?[z]:(h(z) & arg2(y)=z) and f' = (~)?[z]:h(z)
# NOTE: z could also be universally quantified above the scope of yi
# e.g. "Mary wants to run, and John, swim"
VP_R -> S':require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma,add_to_infinitive,add_nullable_subject
VP_R -> COMMA S':require_empty_ref,require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,try_remove_comma,add_to_infinitive,add_nullable_subject

# VP_R {A1 & ... & An} -> VP_R {A1} COMMA VP_R {A2 & ... & An}
# VP_R {A1 | ... | An} -> VP_R {A1} COMMA VP_R {A2 | ... | An}
VP_R -> VP_R:try_remove_comma COMMA VP_R:add_comma

# VP_R {A1 & A2} -> VP_R {A1} (COMMA) AND VP_R {A2}
VP_R -> VP_R:try_remove_comma COMMA AND VP_R:try_remove_comma
VP_R -> VP_R:try_remove_comma AND VP_R:try_remove_comma

# VP_R {A1 | A2} -> VP_R {A1} (COMMA) OR VP_R {A2}
VP_R -> VP_R:try_remove_comma COMMA OR VP_R:try_remove_comma
VP_R -> VP_R:try_remove_comma OR VP_R:try_remove_comma

# VP_R {~A1 & ~A2} -> VP_R {A1} (COMMA) NOR VP_R {A2}
VP_R -> VP_R:try_remove_comma COMMA NOR VP_R:try_remove_comma,add_req_aux
VP_R -> VP_R:try_remove_comma NOR VP_R:try_remove_comma,add_req_aux

# TODO: we could require that here are no additional right adjuncts in the head scope
VP_R -> VP_L:try_remove_comma


VP_L nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# VP_L {... & (~)?[y1]:(f(y1) & g1(y1)) & ... & (~)?[yn]:(f(yn) & gn(yn))}
#  -> (COMMA) ADVP_R/PP {^[P]:(... & f')}
#     (COMMA) VP_L {... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn)}
# where f(y) = (~)?[z]:(h(z) & arg1/arg2(z)=y) and f' = (~)?[z]:(h(z) & P(z))
#    or f(y) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=y) & ... & (~)?[zn]:(hn(zn) & arg1/arg2(zn)=y) and f' = (~)?[z1]:(h1(z1) & P(z1)) & ... & (~)?[zn]:(hn(zn) & P(zn))
#    or f(y) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=y) | ... | (~)?[zn]:(hn(zn) & arg1/arg2(zn)=y) and f' = (~)?[z1]:(h1(z1) & P(z1)) | ... | (~)?[zn]:(hn(zn) & P(zn))
# Note that f(y) may also contain variables which are universally-quantified,
# above the scope of zi, either within the scope of yi (e.g. "it flew faster
# than every bird") or above it ("i have been at every restaurant"). In this
# case, the universal quantifiers are also moved into f'.
#
# An example of a sentence with coordination in both the verb and adverb is:
#  "she walked and sat under every tree and near every rock"
VP_L -> ADVP_L VP_L:require_no_req_aux
VP_L -> COMMA PP:require_no_req_aux COMMA VP_L

VP_L -> WILL VP_R:remove_future,add_infinitive,add_aux,remove_req_aux,require_no_subjunctive # future "tense"
VP_L -> HAVE VP_R:require_no_future,remove_perfect,add_past_participle,add_aux,remove_req_aux,require_no_subjunctive # perfect aspect
VP_L -> BE VP_R:require_no_future,require_no_perfect,remove_progressive,add_present_participle,add_aux,remove_req_aux # progressive aspect
VP_L -> DO VP_R:require_no_future,require_no_perfect,require_no_progressive,add_infinitive,add_aux,remove_req_aux,require_no_req_no_aux,require_no_subjunctive # do-support
VP_L -> NOT VP_R:require_aux_or_subjunctive,remove_not,remove_req_aux
VP_L -> BE VP_R:require_no_future,require_no_perfect,require_no_progressive,remove_inverse,add_past_participle,add_aux,remove_req_aux # passive voice
VP_L -> TO VP_R:add_infinitive,remove_to_infinitive,require_no_future,require_no_req_aux
VP_L -> MODAL VP_R:add_infinitive,remove_req_aux,require_no_subjunctive

# VP_L {?[x]:p(x)} -> V {p}
# NOTE: If subjunctive, and the resulting inflected verb has the same form as
# that without the subjunctive mood, this rule fails. This is to avoid spurious
# ambiguity where the verb can be interpreted as either being in the
# subjunctive mood or not (e.g. "it's vital that we keep them informed.").
VP_L -> V:require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,require_no_req_aux,require_no_empty_ref,require_no_to_infinitive

# VP_L {?[x]:T} -> BE
# This is the semantically empty "be"/"is"/"was"/"were" as in "the cat is blue" and "the cat is in the tree".
# NOTE: If subjunctive, and the resulting inflected verb has the same form as
# that without the subjunctive mood, this rule fails. This is to avoid spurious
# ambiguity where the verb can be interpreted as either being in the
# subjunctive mood or not (e.g. "it's vital that we keep them informed.").
VP_L -> BE:require_no_future,require_no_perfect,require_no_progressive,require_no_inverse,require_no_req_aux,require_no_empty_ref,require_no_to_infinitive

# for gapping and stripping
VP_L -> WILL:remove_future,remove_req_aux,require_only_empty_ref,require_no_subjunctive # future "tense"
VP_L -> HAVE:require_no_future,remove_perfect,remove_req_aux,require_only_empty_ref,require_no_subjunctive # perfect aspect
VP_L -> BE:require_no_future,require_no_perfect,remove_progressive,remove_req_aux,require_only_empty_ref # progressive aspect
VP_L -> DO:require_no_future,require_no_perfect,require_no_progressive,remove_req_aux,require_only_empty_ref,require_no_subjunctive # do-support
VP_L -> NOT:require_aux_or_subjunctive,remove_not,remove_req_aux,require_only_empty_ref
VP_L -> BE:require_no_future,require_no_perfect,require_no_progressive,remove_inverse,remove_req_aux # passive voice,require_only_empty_ref
VP_L -> MODAL:remove_req_aux,require_empty_ref,require_no_subjunctive

# VP_L {... & ?[y1]:(... & arg1(y1)=a & ...) & ... & ?[yn]:(... & arg1(yn)=a & ...}
#  -> DP {^[P]:?[X]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x)))}
#     VP_L {... & ?[y1]:(...) & ... & ?[yn]:(...)}
# VP_L {... & (~)?[x]:(f(x) & ?[y1]:(... & arg1(y1)=x & ...) & ... & ?[yn]:(... & arg1(yn)=x & ...))}
#  -> DP {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)?[x]:(X(x) & P(x))))}
#     VP_L {... & ?[y1]:(...) & ... & ?[yn]:(...)}
# VP_L {... & (~)![x]:(f(x) => ... & ?[y1]:(... & arg1(y1)=x & ...) & ... & ?[yn]:(... & arg1(yn)=x & ...))}
#  -> DP {^[P]:(... & ?[X]:(X=^[x]:f(x) & (~)![x]:(X(x) => P(x))))}
#     VP_L {... & ?[y1]:(...) & ... & ?[yn]:(...)}
# VP_L {... & ?[X]:(f(X) & (~)![x]:(X(x) => ... & ?[y1]:(... & arg1(y1)=x & ...) & ... & ?[yn]:(... & arg1(yn)=x & ...)))}
#  -> DP {^[P]:(... & ?[X]:(f(X) & (~)![x]:(X(x) => P(x))))}
#     VP_L {... & ?[y1]:(...) & ... & ?[yn]:(...)}
# e.g. "it is not a cat nor will it be a cat", "what did they do?"
VP_L -> DP VP_L:require_no_req_aux # for subject-auxiliary inversion

# VP_L {^[x]:(... & ?[y1]:(?[l]:(location(l) & arg1(l)=y1 & arg2(l)=x) & ...) & ... & ?[yn]:(?[l]:(location(l) & arg1(l)=y1 & arg2(l)=x) & ...))}
#  -> WHERE VP_L {... & ?[y1]:(...) & ... & ?[yn]:(...)}
VP_L -> WHERE VP_L

# VP_L {^[x]:(... & ?[y1]:(?[t]:(time(t) & arg1(t)=y1 & arg2(t)=x) & ...) & ... & ?[yn]:(?[t]:(time(t) & arg1(t)=y1 & arg2(t)=x) & ...))}
#  -> WHEN VP_L {... & ?[y1]:(...) & ... & ?[yn]:(...)}
VP_L -> WHEN VP_L

# VP_L {^[x]:(... & ?[y1]:(?[m]:(manner(m) & arg1(m)=y1 & arg2(m)=x) & ...) & ... & ?[yn]:(?[m]:(manner(m) & arg1(m)=y1 & arg2(m)=x) & ...))}
#  -> HOW VP_L {... & ?[y1]:(...) & ... & ?[yn]:(...)}
VP_L -> HOW VP_L

# VP_L {^[x]:(... & ?[y1]:(?[r]:(reason(r) & arg1(r)=y1 & arg2(r)=x) & ...) & ... & ?[yn]:(?[r]:(reason(r) & arg1(r)=y1 & arg2(r)=x) & ...))}
#  -> WHY VP_L {... & ?[y1]:(...) & ... & ?[yn]:(...)}
VP_L -> WHY VP_L


# TODO: should this nonterminal change the universal/existential quantifiers into a single kind of quantifier, to improve generalization for the NP nonterminal and further downstream?
DP nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# DP {A} -> A DP' {A}
DP -> DP':try_remove_comma,remove_adv

# DP {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)![x]:(S(x) => ![y]:(x(y) => P(y)))))} if xi are set-valued
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)![x]:(S(x) => P(x))))} if xi are individuals
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)?[x]:(S(x) & ![y]:(x(y) => P(y)))))} if xi are set-valued
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)?[x]:(S(x) & P(x))))} if xi are individuals
#  -> DP {^[P]:(... & ?[x1]:(f1(x1) & (~)P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & (~)![x]:(x1(x) => P(x))))} if x1 is a set
#     COMMA
#     DP {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)![x]:(S(x) => ![y]:(x(y) => P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)![x]:(S(x) => P(x))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)?[x]:(S(x) & ?[y]:(x(y) => P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)?[x]:(S(x) & P(x))))}
# NOTE: xi could also be constants, rather than existentially-quantified variables
# NOTE: if xi is a set containing a singleton, S would look like ^[x]:(... | x=^[y]:y=singleton | ...)
DP -> DP:try_remove_comma,try_remove_genitive COMMA DP:add_comma,remove_adv

# DP {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => ![y]:(x(y) => P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => P(x))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & ?[y]:(x(y) => P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & P(x))))}
#  -> DP {^[P]:(... & ?[x1]:(f1(x1) & (~)P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & (~)![x]:(x1(x) => P(x))))} if x1 is a set
#     (COMMA) AND
#     DP {^[P]:(... & ?[x2]:(f2(x2) & (~)P(x2)))}
#     or {^[P]:(... & ?[x2]:(f2(x2) & (~)![x]:(x2(x) => P(x))))} if x2 is a set
# NOTE: xi could also be constants, rather than existentially-quantified variables
DP -> DP:try_remove_comma,try_remove_genitive AND DP:try_remove_comma,remove_adv
DP -> DP:try_remove_comma,try_remove_genitive COMMA AND DP:try_remove_comma,remove_adv

# DP {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => ?[y]:(x(y) & P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => P(x))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & ?[y]:(x(y) => P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & P(x))))}
#  -> DP {^[P]:(... & ?[x1]:(f1(x1) & (~)P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & (~)![x]:(x1(x) => P(x))))} if x1 is a set
#     (COMMA) OR
#     DP {^[P]:(... & ?[x2]:(f2(x2) & (~)P(x2)))}
#     or {^[P]:(... & ?[x2]:(f2(x2) & (~)?[x]:(x2(x) & P(x))))} if x2 is a set
# NOTE: xi could also be constants, rather than existentially-quantified variables
DP -> DP:try_remove_comma,try_remove_genitive OR DP:try_remove_comma,remove_adv
DP -> DP:try_remove_comma,try_remove_genitive COMMA OR DP:try_remove_comma,remove_adv

# DP {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ~![x]:(X(x) => P(x))))} -> NO NP_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# DP {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ~?[x]:(X(x) & P(x))))} -> NO NP_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ~?[x]:(X(x) & P(x))))}
# DP {^[P]:(... & ?[X]:(f(X) & ~![x]:(X(x) => P(x))))} -> NOT DP {^[P]:?[X]:(f(X) & ![x]:(X(x) => P(x)))}
# DP {^[P]:(... & ?[X]:(f(X) & ~?[x]:(X(x) & P(x))))} -> NOT DP {^[P]:?[X]:(f(X) & ?[x]:(X(x) & P(x)))}
# this depends on whether the head quantifier is negated
DP -> NO NP_R:try_remove_comma,remove_adv
DP -> NOT DP:try_remove_comma,remove_adv

# DP {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))} -> EACH NP_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# this depends on whether the set is defined as S=^[x]:f(x) rather than with functions like `subset` or `half`;
# it also depends on whether the head predicate of the left conjunct is `this`, `that`, [TODO: add features for possessive]
DP -> EACH NP_R:try_remove_comma,require_no_adv

# DP {A} -> A NP_R {A}
#   e.g. "A group of students walks down the street."
DP -> A NP_R:concord_singular,try_remove_comma,remove_adv

# DP {^[P]:(... & ?[X]:(F(subset(X,^[x]:f(x))) & ![x]:(X(x) => P(x))))} -> SOME NP_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# DP {^[P]:(... & ?[X]:(F(subset(X,^[x]:f(x))) & ?[x]:(X(x) & P(x))))} -> SOME NP_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & P(x))))}
# this depends on whether the set is defined using `subset` rather than with functions like `half` or as S=^[x]:f(x);
DP -> SOME NP_R:try_remove_comma,remove_adv

# DP {A} -> DEF_DP {A}
DP -> DEF_DP:try_remove_comma,remove_adv

# DP {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))} -> ALL DEF_DP {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# this depends on whether the set is defined as S=^[x]:f(x) rather than with functions like `subset` or `half`;
# it also depends on whether the head predicate of the left conjunct is `this`, `that`, [TODO: add features for possessive]
DP -> ALL DEF_DP:try_remove_comma,remove_adv
DP -> ALL DP':try_remove_comma,remove_adv

# DP {^[P]:(... & ?[X]:(F(half(X,^[x]:f(x))) & ![x]:(X(x) => P(x))))} -> HALF DEF_DP {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# DP {^[P]:(... & ?[X]:(F(half(X,^[x]:f(x))) & ![x]:(X(x) => P(x))))} -> HALF A NP_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# this depends on whether the set is defined using `half` rather than with functions like `subset` or as S=^[x]:f(x);
# it also depends on whether the head predicate of the left conjunct is `this`, `that`, [TODO: add features for possessive]
DP -> HALF DEF_DP:try_remove_comma,remove_adv
DP -> HALF A NP_R:try_remove_comma,remove_adv

# DP {^[P]:(... & ?[X]:(F(f(X,A)) & (~)![x]:(X(x) => P(x))))} -> ADV {f} DP {^[P]:(... & ?[X]:(F(X=A) & (~)![x]:(X(x) => P(x))))}
# DP {^[P]:(... & ?[X]:(F(f(X,A)) & (~)?[x]:(X(x) & P(x))))} -> ADV {f} DP {^[P]:(... & ?[X]:(F(X=A) & (~)?[x]:(X(x) & P(x))))}
# NOTE: If A is an existentially-quantified variable, we replace all
# occurrences of A with X (such as in the construction "almost half the cats").
# this depends on whether `f` is `half`, `subset`, or `almost`
DP -> ADV DP:try_remove_comma,add_adv

# DP {^[P]:(... & ?[X]:(X=^[x]:f(x) & ![x]:(X(x) => P(x))))} -> VP_R {... & f(x)} if X is not a union
# DP {^[P]:(... & ?[X]:(X=^[x]:f(x) & ?[x]:(X(x) & P(x))))} -> VP_R {... & f(x)} if X is not a union
# DP {^[P]:(... & ?[X]:(X=^[x]:(x=x1 | ... | x=xn) & ![x]:(X(x) => P(x))))} -> VP_R {... & ?[x1]:(...) & ... & ?[xn]:(...)} if X is a union
# DP {^[P]:(... & ?[X]:(X=^[x]:(x=x1 | ... | x=xn) & ?[x]:(X(x) & P(x))))} -> VP_R {... & ?[x1]:(...) & ... & ?[xn]:(...)} if X is a union
DP -> VP_R:add_present_participle,try_remove_comma,remove_adv

# DP {^[P,x]:(... & ?[X]:(X=^[x]:f(x) & ... & X(x) & P(x)))}
#  -> WHICH/WHAT NP_R {^[P]:(... & ?[X]:(X=^[x]:f(x) & ... & ?[x]:(X(x) & P(x))))}
DP -> WHICH NP_R:try_remove_comma,remove_adv
DP -> WHAT NP_R:try_remove_comma,remove_adv

# DP {^[P]:(... & ?[X]:(X=^[x]:f(x) & ... & ?[x]:(X(x) & P(x))))} -> WHATEVER/WHICHEVER
# DP {^[P]:(... & ?[X]:(X=^[x]:f(x) & ... & ![x]:(X(x) => P(x))))} -> WHATEVER/WHICHEVER
DP -> WHICHEVER NP_R:try_remove_comma,remove_adv
DP -> WHATEVER NP_R:try_remove_comma,remove_adv


DEF_DP nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# DEF_DP {A} -> THE DP' {A}
DEF_DP -> THE DP'

# DP {^[P]:(... & ?[S]:(this(S) & F(S) & ![x]:(S(x) => P(x))))} -> THIS DP' {^[P]:(... & ?[S]:(F(S) & ![x]:(S(x) => P(x))))}
# DP {^[P]:(... & ?[S]:(this(S) & F(S) & ?[x]:(S(x) & P(x))))} -> THIS DP' {^[P]:(... & ?[S]:(F(S) & ?[x]:(S(x) & P(x))))}
# this depends on whether the head predicate of the left conjunct is `this`
DEF_DP -> THIS DP'

# DP {^[P]:(... & ?[S]:(that(S) & F(S) & ![x]:(S(x) => P(x))))} -> THIS DP' {^[P]:(... & ?[S]:(F(S) & ![x]:(S(x) => P(x))))}
# DP {^[P]:(... & ?[S]:(that(S) & F(S) & ?[x]:(S(x) & P(x))))} -> THIS DP' {^[P]:(... & ?[S]:(F(S) & ?[x]:(S(x) & P(x))))}
# this depends on whether the head predicate of the left conjunct is `that`
DEF_DP -> THAT DP'

# DEF_DP {^[P]:(... & ?[X]:(F(X=^[x]:(?[o]:(own(o) & arg2(o)=x & arg1(o)=a) & f(x))) & ![x]:(X(x) => P(x))))}
#  -> DP {^[P]:?[X]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x)))}
#     DP' {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# DEF_DP {^[P]:(... & ?[X]:(F(X=^[x]:(?[o]:(own(o) & arg2(o)=x & ?[y]:(g(y) & arg1(o)=y)) & f(x))) & ![x]:(X(x) => P(x))))}
#  -> DP {^[P]:(... & ?[X]:(X=^[x]:g(x) & ?[x]:(X(x) & P(x))))}
#     DP' {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# DEF_DP {^[P]:(... & ?[X]:(F(X=^[x]:(?[y]:(g(y) & ?[o]:(own(o) & arg2(o)=x & arg1(o)=y)) & f(x))) & ![x]:(X(x) => P(x))))}
#  -> DP {^[P]:(... & ?[X]:(X=^[x]:g(x) & ![x]:(X(x) => P(x))))}
#     DP' {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# DEF_DP {^[P]:(... & ?[X]:(F(X=^[x]:(![y]:(g(y) => ?[o]:(own(o) & arg2(o)=x & arg1(o)=y)) & f(x))) & ![x]:(X(x) => P(x))))}
#  -> DP {^[P]:(... & ?[X]:(X=^[x]:g(x) & ![x]:(X(x) => P(x))))}
#     DP' {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# NOTE: In the last two rules, if `g(y)` is just a set membership test `Y(y)`,
# then in the left child logical form, we replace `X=^[x]:g(x)` with the
# definition of `Y` (effectively renaming `Y` to `X`).
# NOTE: This rule also works if X is existentially-quantified.
DEF_DP -> DP:add_genitive,singular DP'
DEF_DP -> DP:add_genitive,plural DP'
# TODO: the above rule can also be used for `inverse(intended_for)` in addition to `own`

# DEF_DP {^[P]:(... & ?[S]:(F(S=^[x]:(arg1/arg2(x)=a & f(x))) & ![x]:(S(x) => P(x))))}
#  -> DP {^[P]:?[S]:(S=^[x]:(x=a) & ?[x]:(S(x) & P(x)))}
#     DP' {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
# DEF_DP {^[P]:(... & ?[S]:(F(S=^[x]:(?[y]:(g(y) & arg1/arg2(x)=y) & f(x))) & ![x]:(S(x) => P(x))))}
#  -> DP {^[P]:(... & ?[S]:(S=^[x]:g(x) & ?[x]:(S(x) & P(x))))}
#     DP' {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
# DEF_DP {^[P]:(... & ![y]:(g(y) => ... ?[S]:(F(S=^[x]:(arg1/arg2(x)=y & f(x))) & ![x]:(S(x) => P(x)))))}
#  -> DP {^[P]:(... & ?[S]:(S=^[x]:g(x) & ![x]:(S(x) => P(x))))}
#     DP' {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
# DEF_DP {^[P]:(... & ?[Y]:(G(Y) & ... & ![y]:(Y(y) => ?[S]:(F(S=^[x]:(arg1/arg2(x)=y & f(x))) & ![x]:(S(x) => P(x))))))}
#  -> DP {^[P]:(... & ?[S]:(G(S) & ![x]:(S(x) => P(x))))}
#     DP' {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
# NOTE: This rule also works if S is existentially-quantified.
#  e.g. "the arson's/termites' destruction of the barn(s)"
DEF_DP -> DP:add_genitive,singular DP' # for arg1
DEF_DP -> DP:add_genitive,singular DP' # for arg2
DEF_DP -> DP:add_genitive,plural DP' # for arg1
DEF_DP -> DP:add_genitive,plural DP' # for arg2

# DEF_DP {^[P]:(... ?[X]:(X=^[x]:(?[o]:(arg1(o)=a & own(o) & arg2(o)=x)) & ![x]:(X(x) => P(x))))}
#  -> DP {^[P]:(... ?[Y]:(Y=^[y]:(y=a) & ?[y]:(Y(y) & P(y))))}
# DEF_DP {^[P]:(... ?[y]:(f(y) & ... & ?[X]:(X=^[x]:(?[o]:(arg1(o)=y & own(o) & arg2(o)=x)) & ![x]:(X(x) => P(x)))))}
#  -> DP {^[P]:(... ?[Y]:(Y=^[y]:f(y) & ?[y]:(Y(y) => P(y))))}
# DEF_DP {^[P]:(... ?[Y]:(F(Y) & ... & ?[X]:(X=^[x]:(?[y]:(Y(y) & ?[o]:(arg1(o)=y & own(o) & arg2(o)=x))) & ![x]:(X(x) => P(x)))))}
#  -> DP {^[P]:(... ?[Y]:(F(Y) & ?[y]:(Y(y) & P(y))))}
# DEF_DP {^[P]:(... ?[Y]:(F(Y) & ... & ?[X]:(X=^[x]:(![y]:(Y(y) => ?[o]:(arg1(o)=y & own(o) & arg2(o)=x))) & ![x]:(X(x) => P(x)))))}
#  -> DP {^[P]:(... ?[Y]:(F(Y) & ![y]:(Y(y) => P(y))))}
# NOTE: This rule also works if X is existentially-quantified.
# e.g. "Jason's is better"
DEF_DP -> DP:require_no_genitive,add_genitive,singular



DP' nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# DP {^[P]:(... & ?[S]:(f(S) & g(S=^[x]:f(x)) & ...))} -> Q {f(S)} NP_R {^[P]:(... & ?[S]:(g(S=^[x]:f(x)) & ...))}
# this depends on whether the head predicate of the left conjunct f(S) is one that expresses information about the size of the set
DP' -> Q NP_R

# DP' {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))} -> NP_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => P(x))))}
# DP' {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & P(x))))} -> NP_R {^[P]:(... & ?[X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & P(x))))}
DP' -> NP_R


Q nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# Q {?[l]:(mod(f)(l) & ...)} -> ADV {mod} Q {?[l]:(f(l) & ...)} where f is the type predicate of `l`
#   [OR]
# Q {?[l]:(?[m]:(mod(m) & arg1(m)=l) & f(l) & ...)} -> ADV {mod} Q {?[l]:(f(l) & ...)} where f is the type predicate of `l`
#
# Q {?[a]:(mod(a) & arg1(a)=A & arg2(a)=B)} -> ADV {mod} Q {A=B}
#   [OR]
# Q {f(A,B) -> ADV {f} Q {A=B}
# The last two rules are for adverbs like "almost", "nearly", "more than", etc.
Q -> ADVP_L Q

# Q {size(x)=n} -> NUMBER {n}
Q -> NUMBER

# comparative constructions where sizes of sets are compared
# Q {?[R]:size(X)>size(R)} -> MORE
# e.g. "more people came than last time"
Q -> MORE

# comparative constructions where sizes of sets are compared
# Q {?[R]:size(X)<size(R)} -> LESS/FEWER
# e.g. "more people came than last time"
Q -> FEWER
Q -> LESS

Q -> MUCH
Q -> MANY
Q -> MOST
Q -> FEW
Q -> FEWEST
Q -> LEAST


# this noun phrase nonterminal is for right-side modifiers
NP_R nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# NP_R {A} -> NP_L {A}
NP_R -> NP_L:try_remove_comma

# appositives
# NP_R {^[P]:(... & ?[S]:(F(S=^[x]:(... & x=a)) & ...))}
#  -> NP_R {^[P]:(... & ?[S]:(F(S=^[x]:(...)) & ...))}
#     DP {^[P]:?[Y]:(Y=^[y]:(y=a) & ?[y]:(Y(y) & P(y)))}
# NP_R {^[P]:(... & ?[S]:(F(S=^[x]:(... & ?[y]:(f(y) & x=y))) & ...))}
#  -> NP_R {^[P]:(... & ?[S]:(F(S=^[x]:(...)) & ...))}
#     DP {^[P]:?[Y]:(Y=^[y]:f(y) & ?[y]:(Y(y) & P(y)))}
# e.g. "Kim Jones, President of the Union, ...", "the year 2024"
NP_R -> NP_R:try_remove_comma,try_remove_genitive DP:try_remove_comma
NP_R -> NP_R:try_remove_comma,try_remove_genitive COMMA DP:try_remove_comma COMMA
NP_R -> NP_R:try_remove_comma,try_remove_genitive OF DP:try_remove_comma

# NP_R {^[P]:(... & ?[S]:(F(S=^[x]:(arg1/arg2(x)=a & f(x))) & ![x]:(S(x) => P(x))))}
#  -> NP_R {^[P]:?[S]:(S=^[x]:(x=a) & ?[x]:(S(x) & P(x))}
#     PP {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
# NP_R {^[P]:(... & ?[S]:(F(S=^[x]:(?[y]:(g(y) & arg1/arg2(x)=y) & f(x))) & ![x]:(S(x) => P(x))))}
#  -> NP_R {^[P]:(... & ?[S]:(S=^[x]:g(x) & ?[x]:(S(x) & P(x))))}
#     PP {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
# NP_R {^[P]:(... & ![y]:(g(y) => ... ?[S]:(F(S=^[x]:(arg1/arg2(x)=y & f(x))) & ![x]:(S(x) => P(x)))))}
#  -> NP_R {^[P]:(... & ?[S]:(S=^[x]:g(x) & ![x]:(S(x) => P(x))))}
#     PP {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
# NP_R {^[P]:(... & ?[Y]:(G(Y) & ... & ![y]:(Y(y) => ?[S]:(F(S=^[x]:(arg1/arg2(x)=y & f(x))) & ![x]:(S(x) => P(x))))))}
#  -> NP_R {^[P]:(... & ?[S]:(G(S) & ![x]:(S(x) => P(x))))}
#     PP {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
# NOTE: This rule also works if S is existentially-quantified.
#  e.g. "destruction of the barn(s)", "destruction of the barn(s) by the termites"
NP_R -> NP_R:try_remove_comma,try_remove_genitive PP:try_remove_comma

# NP_R {^[P]:(... & ?[X]:(F(X=^[x]:(... & f(x))) & ![x]:(X(x) => P(x))))}
#  -> NP_R {^[P]:(... & ?[X]:(... & ![x]:(X(x) => P(x))))}
#     ADJP_R/PP {^[P]:(... & f')}
# where f(x) = (~)?[z]:(h(z) & arg1/arg2(z)=x) and f' = (~)?[z]:(h(z) & P(z))
#    or f(x) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=x) & ... & (~)?[zn]:(hn(zn) & arg1/arg2(zn)=x) and f' = (~)?[z1]:(h1(z1) & P(z1)) & ... & (~)?[zn]:(hn(zn) & P(zn))
#    or f(x) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=x) | ... | (~)?[zn]:(hn(zn) & arg1/arg2(zn)=x) and f' = (~)?[z1]:(h1(z1) & P(z1)) | ... | (~)?[zn]:(hn(zn) & P(zn))
# Note that f(x) may also contain variables which are universally-quantified,
# above the scope of zi, either within the scope of xi (e.g. "i like the house
# next to the trees") or above it ("a student from each class spoke to her").
# In this case, the universal quantifiers are also moved into f'.
# NOTE: This rule also works if X is existentially-quantified.
NP_R -> NP_R:try_remove_comma,try_remove_genitive PP:try_remove_comma
NP_R -> NP_R:try_remove_comma,try_remove_genitive ADJP_R:try_remove_comma

# comparative constructions
# NP_R {^[P]:(... & ?[X,r]:(... & F(X=^[x]:(?[g1]:(p(f1)(g1) & arg1(g1)=x & arg2(g1)=r) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x & arg2(gn)=r) & ... & h(r) & ...)) & ...))}
#  -> NP_R {^[P]:(... & ?[X]:(... & F(X=^[x]:(?[g1]:(p(f1)(g1) & arg1(g1)=x) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x) & ...)) & ...))}
#     P {p}
#     V_ADJUNCT {... & ?[r]:(?[gn]:(p(fn)(gn) & arg2(gn)=r) & ... & h(r))}
# where h(r) could either be `r=a` if r is a constant or it can define a new object like `U(i,r) & p(r) & ...`.
# NP_R {^[P]:(... & ?[X,R]:(... & f(size(X),size(R)) & ... & F(X=^[x]:(![r]:(R(r) => ?[g1]:(p(f1)(g1) & arg1(g1)=x & arg2(g1)=r) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x & arg2(gn)=r)) & ...)) & ...))}
#  -> NP_R {^[P]:(... & ?[X]:(... & f(size(X)) & ... & F(X=^[x]:(?[g1]:(p(f1)(g1) & arg1(g1)=x) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x) & ...)) & ...))}
#     P {p} (or `f`, whichever comes last)
#     V_ADJUNCT {... & ?[R]:(f(size(R)) & ... & ![r]:(R(r) => ?[gn]:(p(fn)(gn) & arg2(gn)=r)) & ...)}
# NP_R {^[P]:(... & ?[X,R]:(?[X1,R1]:(... & f(size(X1),size(R1)) & ... & F(X1=^[x]:(![r]:(R(r) => ?[g1]:(p(f1)(g1) & arg1(g1)=x & arg2(g1)=r) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x & arg2(gn)=r)) & ...)) & ?[X2,R2]:(... & f(size(X2),size(R2)) & ... & F(X2=^[x]:(...)) & ... & X=^[S]:(S=X1 | ... | S=Xn) & R=^[S]:(S=R1 | ... | S=Rn))) & ...))}
#  -> NP_R {^[P]:(... & ?[X]:(?[X1]:(... & f(size(X1)) & ... & F(X1=^[x]:(?[g1]:(p(f1)(g1) & arg1(g1)=x) & ... & ?[gn]:(p(fn)(gn) & arg1(gn)=x) & ...)) & ?[X2]:(... & f(size(X2)) & ... & F(X2=^[x]:(...)) & ... & X=^[S]:(S=X1 | ... | S=Xn))) & ...))}
#     P {p} (or `f`, whichever comes last)
#     V_ADJUNCT {... & ?[Rn]:(... & f(size(Rn)) & ... & ![r]:(Rn(r) => ?[gn]:(p(fn)(gn) & arg2(gn)=r)) & ...)}
# NOTE: The predicate could also be a simple `p` rather than `p(f)`. The terms
# `f(size(X),size(R))` and `?[gi]:(...)` are optional (but there must be at
# least one). The term `f(size(X),size(R))` handles comparative constructions
# where sizes of sets are compared.
# e.g. "brighter star than Vega", "more people than last time", "more girls but fewer boys than last time"
NP_R -> NP_R:try_remove_comma P V_ADJUNCT:try_remove_comma

# NP_R {^[P]:(... & ?[X]:(F(X=^[x]:(... & ?[g1]:(... & arg1/arg2/arg3(g1)=x) & ... & ?[gn]:(... & arg1/arg2/arg3(gn)=x))) & ...))}
#  -> NP_R {^[P]:(... & ?[X]:(F(X=^[x]:(...)) & ...))}
#     (COMMA) (THAT) S' {?[g1]:(...) & ... & ?[gn]:(...)} (COMMA)
# e.g. "the book (that) I gave Kim"
NP_R -> NP_R:try_remove_comma,try_remove_genitive S':try_remove_comma # TODO: remove grammatical features from S'
NP_R -> NP_R:try_remove_comma,try_remove_genitive S':try_remove_comma,add_that,add_nullable_subject # TODO: remove grammatical features from S'
NP_R -> NP_R:try_remove_comma,try_remove_genitive COMMA S':try_remove_comma,add_that,add_nullable_subject COMMA # TODO: remove grammatical features from S'

# NP_R {^[P]:(... & ?[S]:(F(S=^[x]:(?[y]:(g(y) & arg1/arg2(x)=y) & f(x))) & ![x]:(S(x) => P(x))))}
#  -> NP_R {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
#     (COMMA) (THAT) S' {... & ?[y]:g(y)} (COMMA)
# e.g. "the toys (that) you don't want"
# NP_R {^[P]:(... & ?[X]:(F(X=^[x]:(... & arg2(x)=^[g]:f(g))) & ...))}
#  -> NP_R {^[P]:(... & ?[l1]:(... & P(l1)) & ... & ?[ln]:(... & P(ln)))}
#     (THAT) S' {... & ?[g]:f(g)}
# e.g. "last time (that) i went to campus"
# NOTE: This second rule does not allow a comma.
NP_R -> NP_R:try_remove_comma,try_remove_genitive S':try_remove_comma # TODO: remove grammatical features from S'
NP_R -> NP_R:try_remove_comma,try_remove_genitive S':try_remove_comma,add_that,add_nullable_subject # TODO: remove grammatical features from S'
NP_R -> NP_R:try_remove_comma,try_remove_genitive COMMA S':try_remove_comma,add_that,add_nullable_subject COMMA # TODO: remove grammatical features from S'
# e.g. "the demand that she be here"
NP_R -> NP_R:try_remove_comma,try_remove_genitive S':try_remove_comma,add_that,add_subjunctive # TODO: remove grammatical features from S'
NP_R -> NP_R:try_remove_comma,try_remove_genitive COMMA S':try_remove_comma,add_that,add_subjunctive COMMA # TODO: remove grammatical features from S'

# closed interrogative finite subordinate clause
# NP_R {^[P]:(... & ?[X]:(X=^[x]:(... & f(x)) & ... ))}
#  -> NP_R {^[P]:(... & ?[X]:(X=^[x]:(...) & ... ))}
#     IF/WHETHER S' {... & f'}
# where f(y) = arg2(y)=^[x]:A and f' = ^[x]:A
# e.g. "the question whether he arrived or not"
NP_R -> NP_R:try_remove_comma S':try_remove_comma,add_req_no_aux,add_whether

# open interrogative finite subordinate clause (relative clauses)
# NP_R {^[P]:(... & ?[S]:(F(S=^[x]:(A(x) & f(x))) & ![x]:(S(x) => P(x))))}
#  -> NP_R {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
#     S' {^[x]:A(x)}
# NP_R {^[P]:(... & ?[S]:(F(S) & ![x]:(S(x) => A(x)) & ![x]:(S(x) => P(x))))}
#  -> NP_R {^[P]:(... & ?[S]:(F(S) & ![x]:(S(x) => P(x))))}
#     (COMMA) S' {^[x]:A(x)} (COMMA)
# NOTE: The first form of this rule requires no commas (the child S' is an
# integrated relative clause), whereas the second form may or may not have
# commas (the child S' is a supplementary relative clause).
# e.g. "the toys which you don't want", "the people whose house we are renting", "the state through which the Allegheny runs", "a problem with which to challenge the students"
NP_R -> NP_R:try_remove_comma S':try_remove_comma,add_req_no_aux,add_subordinate
NP_R -> NP_R:try_remove_comma COMMA S':try_remove_comma,add_req_no_aux,add_subordinate COMMA

# relative clauses where the relative phrase is a complement of a preposition
# NP_R {^[P]:(... & ?[S]:(F(S=^[x]:(A(?[y]:(g(y) & arg2(y)=x)) & f(x))) & ![x]:(S(x) => P(x))))}
#  -> NP_R {^[P]:(... & ?[S]:(F(S=^[x]:f(x)) & ![x]:(S(x) => P(x))))}
#     (THAT) S' {A(?[y]:(g(y) & ?[x]:(empty_ref(x) & arg2(y)=x)))}
# NP_R {^[P]:(... & ?[S]:(F(S) & ![x]:(S(x) => A(?[y]:(g(y) & arg2(y)=x))) & ![x]:(S(x) => P(x))))}
#  -> NP_R {^[P]:(... & ?[S]:(F(S) & ![x]:(S(x) => P(x))))}
#     (COMMA) THAT S' {A(?[y]:(g(y) & ?[x]:(empty_ref(x) & arg2(y)=x)))} (COMMA)
# NOTE: The first form of this rule requires no commas (the child S' is an
# integrated relative clause), whereas the second form may or may not have
# commas (the child S' is a supplementary relative clause).
# e.g. "the knife (that) he was trying to cut it with"
NP_R -> NP_R:try_remove_comma,try_remove_genitive S':try_remove_comma # TODO: remove grammatical features from S'
NP_R -> NP_R:try_remove_comma,try_remove_genitive S':try_remove_comma,add_that,add_nullable_subject # TODO: remove grammatical features from S'
NP_R -> NP_R:try_remove_comma,try_remove_genitive COMMA S':try_remove_comma,add_that,add_nullable_subject COMMA # TODO: remove grammatical features from S'

# NP_R {^[P]:(... & ?[X]:(F(X=^[x]:(... & ?[g1]:(... & arg1(g1)=x) & ... & ?[gn]:(... & arg1(gn)=x))) & ...))}
#  -> NP_R {^[P]:(... & ?[X]:(F(X=^[x]:(...)) & ...))}
#     VP_R {?[g1]:(...) & ... & ?[gn]:(...)}
# e.g. "the cat sleeping on the bed"
NP_R -> NP_R:try_remove_comma,try_remove_genitive VP_R:keep_present_participle,try_remove_comma

# NP_R {^[P]:(... & ?[X]:(F(X=^[x]:(... & ?[g1]:(p1(g1) & ... & arg2(g1)=x) & ... & ?[gn]:(pn(gn) & ... & arg2(gn)=x))) & ...))}
#  -> NP_R {^[P]:(... & ?[X]:(F(X=^[x]:(...)) & ...))}
#     VP_R {?[g1]:(inverse(p1)(g1) & ...) & ... & ?[gn]:(inverse(pn)(gn) & ...)}
# e.g. "the letter written by me"
NP_R -> NP_R:try_remove_comma,try_remove_genitive VP_R:invert_predicate,keep_past_participle,try_remove_comma

# NP_R {^[P]:(... & ?[X]:(F(X=^[x]:(... & ?[g1]:(... & arg1(g1)=x) & ... & ?[gn]:(... & arg1(gn)=x))) & ...))}
#  -> NP_R {^[P]:(... & ?[X]:(F(X=^[x]:(...)) & ...))}
#     VP_R {?[g1]:(...) & ... & ?[gn]:(...)}
# e.g. "the person to see the comet"
NP_R -> NP_R:try_remove_comma,try_remove_genitive VP_R:add_to_infinitive,try_remove_comma

# NP_R {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)![x]:(S(x) => ![y]:(x(y) => P(y)))))} if xi are set-valued
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)![x]:(S(x) => P(x))))} if xi are individuals
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)?[x]:(S(x) & ![y]:(x(y) => P(y)))))} if xi are set-valued
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)?[x]:(S(x) & P(x))))} if xi are individuals
#  -> NP_R {^[P]:(... & ?[x1]:(f1(x1) & (~)P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & (~)![x]:(x1(x) => P(x))))} if x1 is a set
#     COMMA
#     NP_R {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)![x]:(S(x) => ![y]:(x(y) => P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)![x]:(S(x) => P(x))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)?[x]:(S(x) & ?[y]:(x(y) => P(y)))))}
#     or {^[P]:(... & ?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)?[x]:(S(x) & P(x))))}
# NOTE: xi could also be constants, rather than existentially-quantified variables
# NOTE: if xi is a set containing a singleton, S would look like ^[x]:(... | x=^[y]:y=singleton | ...)
NP_R -> NP_R:try_remove_comma,try_remove_genitive COMMA NP_R:add_comma

# NP_R {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => ![y]:(x(y) => P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => P(x))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & ?[y]:(x(y) => P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & P(x))))}
#  -> NP_R {^[P]:(... & ?[x1]:(f1(x1) & (~)P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & (~)![x]:(x1(x) => P(x))))} if x1 is a set
#     (COMMA) AND
#     NP_R {^[P]:(... & ?[x2]:(f2(x2) & (~)P(x2)))}
#     or {^[P]:(... & ?[x2]:(f2(x2) & (~)![x]:(x2(x) => P(x))))} if x2 is a set
# NOTE: xi could also be constants, rather than existentially-quantified variables
NP_R -> NP_R:try_remove_comma,try_remove_genitive AND NP_R:try_remove_comma
NP_R -> NP_R:try_remove_comma,try_remove_genitive COMMA AND NP_R:try_remove_comma

# NP_R {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => ?[y]:(x(y) & P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => P(x))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & ?[y]:(x(y) => P(y)))))}
# or {^[P]:(... & ?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & P(x))))}
#  -> NP_R {^[P]:(... & ?[x1]:(f1(x1) & (~)P(x1)))}
#     or {^[P]:(... & ?[x1]:(f1(x1) & (~)![x]:(x1(x) => P(x))))} if x1 is a set
#     (COMMA) OR
#     NP_R {^[P]:(... & ?[x2]:(f2(x2) & (~)P(x2)))}
#     or {^[P]:(... & ?[x2]:(f2(x2) & (~)?[x]:(x2(x) & P(x))))} if x2 is a set
# NOTE: xi could also be constants, rather than existentially-quantified variables
NP_R -> NP_R:try_remove_comma,try_remove_genitive OR NP_R:try_remove_comma
NP_R -> NP_R:try_remove_comma,try_remove_genitive COMMA OR NP_R:try_remove_comma

# pronouns
# NP_R {A} -> PRO {A}
NP_R -> PRO:try_remove_comma,remove_adv


# pronouns
PRO nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# PRO {^[P]:?[X]:(^[x]:(x=me) & ?[x]:(X(x) & P(x)))} -> I/ME
PRO -> I
PRO -> ME

# PRO {^[P]:?[X]:(^[x]:(x=you) & ?[x]:(X(x) & P(x)))} -> YOU
PRO -> YOU

# PRO {^[P]:?[X]:(^[x]:(U(0,x) & female_ref(x)) & ?[x]:(X(x) & P(x)))} -> SHE/HER
PRO -> SHE
PRO -> HER

# PRO {^[P]:?[X]:(^[x]:(U(0,x) & male_ref(x)) & ?[x]:(X(x) & P(x)))} -> HE/HIM
PRO -> HE
PRO -> HIM

# PRO {^[P]:?[X]:(^[x]:(U(0,x) & ref(x)) & ?[x]:(X(x) & P(x)))} -> IT
PRO -> IT

# PRO {^[P]:?[X]:(plural_ref(X) & ?[x]:(X(x) & P(x)))} -> THEY/THEM
PRO -> THEY
PRO -> THEM

# PRO {^[P,x]:?[X]:(X=^[x]:U(0,x) & X(x) & P(x))} -> WHICH/WHAT/WHICHEVER/WHATEVER
PRO -> WHICH
PRO -> WHAT
PRO -> WHICHEVER
PRO -> WHATEVER

# PRO {^[P,x]:?[X]:(X=^[x]:(U(0,x) & animate(x)) & X(x) & P(x))} -> WHO/WHOM/WHOEVER/WHOMEVER
PRO -> WHO
PRO -> WHOM
PRO -> WHOEVER
PRO -> WHOMEVER

# PRO {^[P,x]:?[X]:(X=^[x]:(U(0,x) & location(x)) & X(x) & P(x))} -> WHERE/WHEREVER
PRO -> WHERE
PRO -> WHEREVER


# this noun phrase nonterminal is for left-side modifiers
NP_L nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# NP_L {^[P]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x))))} -> N {a}
# NP_L {^[P]:(X=^[x]:(U(0,x) & p(x)) & ?[x]:(X(x) & P(x))))} -> N {p}
# NP_L {^[P]:(X=^[x]:(U(0,x) & p(x)) & ![x]:(X(x) => P(x))))} -> N {p}
# This depends on whether `p` is an event (i.e. typically has arguments, even
# if it doesnt in this particular logical form).
NP_L -> N

# NP_L {^[P]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x))))} -> V {a}
# NP_L {^[P]:(X=^[x]:(U(0,x) & p(x)) & ?[x]:(X(x) & P(x))))} -> V {p}
# NP_L {^[P]:(X=^[x]:(U(0,x) & p(x)) & ![x]:(X(x) => P(x))))} -> V {p}
# This depends on whether `p` is an event (i.e. typically has arguments, even
# if it doesnt in this particular logical form).
NP_L -> V:add_tion

# NP_L {^[P]:(X=^[x]:(?[y]:(p(y) & arg1(p)=x)) & ?[x]:(X(x) & P(x))))} -> V {p}
# NP_L {^[P]:(X=^[x]:(?[y]:(p(y) & arg1(p)=x)) & ![x]:(X(x) => P(x))))} -> V {p}
NP_L -> V:add_er # this adds "ers" if the concord is plural, as well as any duplicated consonants if appropriate (i.e. "programmers")

# NP_L {^[P]:(... & ?[X]:(F(X=^[x]:(... & f(x))) & ... & ![x]:(X(x) => P(x))))}
#  -> ADJP_L {^[P]:(... & f')}
#     NP_L {^[P]:(... & ?[X]:(F(X=^[x]:(...) & ... & ![x]:(X(x) => P(x))))}
# where f(x) = (~)?[z]:(h(z) & arg1/arg2(z)=x) and f' = (~)?[z]:(h(z) & P(z))
#    or f(x) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=x) & ... & (~)?[zn]:(hn(zn) & arg1/arg2(zn)=x) and f' = (~)?[z1]:(h1(z1) & P(z1)) & ... & (~)?[zn]:(hn(zn) & P(zn))
#    or f(x) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=x) | ... | (~)?[zn]:(hn(zn) & arg1/arg2(zn)=x) and f' = (~)?[z1]:(h1(z1) & P(z1)) | ... | (~)?[zn]:(hn(zn) & P(zn))
# NOTE: This rule also works if X is existentially-quantified or used collectively.
NP_L -> ADJP_L:try_remove_genitive NP_L

# NP_L {^[P]:(... & ?[X]:(F(X=^[x]:(... & f(x))) & ... & ![x]:(X(x) => P(x))))}
#  -> ADJP_L {^[P]:(... & f')}
#     NP_L {^[P]:(... & ?[X]:(F(X=^[x]:(...) & ... & ![x]:(X(x) => P(x))))}
# where f(x) = (~)?[z]:(h(z) & arg1/arg2(z)=x) and f' = (~)?[z]:(h(z) & P(z))
#    or f(x) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=x) & ... & (~)?[zn]:(hn(zn) & arg1/arg2(zn)=x) and f' = (~)?[z1]:(h1(z1) & P(z1)) & ... & (~)?[zn]:(hn(zn) & P(zn))
#    or f(x) = (~)?[z1]:(h1(z1) & arg1/arg2(z1)=x) | ... | (~)?[zn]:(hn(zn) & arg1/arg2(zn)=x) and f' = (~)?[z1]:(h1(z1) & P(z1)) | ... | (~)?[zn]:(hn(zn) & P(zn))
# NOTE: This rule also works if X is existentially-quantified or used collectively.
NP_L -> ADJP_L:try_remove_genitive NP_L

# NP_L {^[P]:(... & ?[X]:(F(X) & ?[g1]:(... & P(arg1(g1)) & ... & greatest/least(f)(g1) & ... & arg2(g1)=X) & ... & ?[gn]:(... & P(arg1(gn)) & ... & greatest/least(f)(gn) & ... & arg2(gn)=X)))}
#  -> ADJP_L {^[P]:(?[g1]:(greatest/least(f)(g1) & P(g1)) & ... & ?[gn]:(greatest/least(f)(gn) & P(gn)))}
#     NP_L {^[P]:(... & ?[X]:(F(X) & ?[x]:(X(x) & P(x))))}
# e.g. "closest and brightest star"
NP_L -> ADJP_L:try_remove_genitive NP_L

# NP_L {^[P]:(... & ?[X]:(F(X=^[x]:(?[s]:(arg2(s)=a & ... & arg1(s)=x) & U(0,x)))) & ...)}
#  -> NP_L {^[P]:?[Y]:(Y=^[y]:(y=a) & ?[y]:(Y(y) & P(y)))}
#     NP_L {^[P]:(... & ?[X]:(F(X=^[x]:(?[s]:(... & arg1(s)=x) & U(0,x)))) & ...)}
# NP_L {^[P]:(... & ?[X]:(F(X=^[x]:(?[s]:(?[y]:(f(y) & arg2(s)=y) & ... & arg1(s)=x) & U(0,x)))) & ...)}
#  -> NP_L {^[P]:?[Y]:(Y=^[y]:f(y) & ?[y]:(Y(y) & P(y)))}
#     NP_L {^[P]:(... & ?[X]:(F(X=^[x]:(?[s]:(... & arg1(s)=x) & U(0,x)))) & ...)}
# e.g. "potion seller"
NP_L -> NP_L:try_remove_genitive NP_L

# NP_L {^[P]:(... & ?[X]:(F(X=^[x]:(?[c]:(consists_of(c) & arg1(c)=x & arg2(c)=a) & ...)) & ...))}
#  -> NP_L {^[P]:?[Y]:(Y=^[y]:(y=a) & ?[y]:(Y(y) & P(y)))}
#     NP_L {^[P]:(... & ?[X]:(F(X=^[x]:(...)) & ...))}
# NP_L {^[P]:(... & ?[X]:(F(X=^[x]:(?[c]:(consists_of(c) & ?[y]:(f(y) & arg1(c)=y) & arg2(c)=a) & ...)) & ...))}
#  -> NP_L {^[P]:?[Y]:(Y=^[y]:f(y) & ?[y]:(Y(y) & P(y)))}
#     NP_L {^[P]:(... & ?[X]:(F(X=^[x]:(...)) & ...))}
# e.g. "apple pie"
# TODO: what about "California Senator"
NP_L -> NP_L:try_remove_genitive NP_L # for `consists_of` (or maybe `contains`?)
NP_L -> NP_L:try_remove_genitive NP_L # for `purpose`
NP_L -> NP_L:try_remove_genitive NP_L # for `located`

# NP_L {^[P]:(... & ?[X]:(F(X=^[x]:(?[m1]:(g1(m1) & arg1/arg2(m1)=x) & ... & ?[mn]:(gn(mn) & arg1/arg2(mn)=x) & ...)) & ...))}
#  -> VP_L {?[m1]:g1(m1) & ... & ?[mn]:gn(mn)}
#     NP_L {^[P]:(... & ?[X]:(F(X=^[x]:(...)) & ...))}
# e.g. "recently published article", "melting marshmellows"
NP_L -> VP_L:try_remove_genitive,add_present_participle NP_L
NP_L -> VP_L:try_remove_genitive,add_past_participle NP_L

# NP_L {^[P]:(... & ?[X]:(X=^[x]:(x=a) & ?[x]:(X(x) & P(x))))} -> ENTITY_NAME {a}
# this depends on whether `a` is a constant vs a predicate, or a more complex formula
#NP_L -> ENTITY_NAME

# NP_L {^[P]:(... & ?[X]:(X=^[x]:(first_name(x)=n1) & ?[x]:(X(x) & P(x))))} -> NAME {first_name(x)=n1}
# NP_L {^[P]:(... & ?[X]:(X=^[x]:(first_name(x)=n1 & last_name(x)=n2) & ?[x]:(X(x) & P(x))))} -> NAME {first_name(x)=n1 & last_name(x)=n2}
# NP_L {^[P]:(... & ?[X]:(X=^[x]:(nickname(x,n1)) & ?[x]:(X(x) & P(x))))} -> NAME {nickname(x,n1)}
NP_L -> NAME


#ENTITY_NAME nonterminal {} {1.0} {1.0} {} 10 1.0 {}
#ENTITY_NAME -> STRING:get_nickname
#ENTITY_NAME -> STRING:get_first_name
#ENTITY_NAME -> STRING:get_first_name STRING:get_last_name

NAME nonterminal {} {1.0} {1.0} {} 10 1.0 {}
# NAME {nickname(x,s)} -> STRING {s}
NAME -> STRING:select_nickname
# NAME {first_name(x)=s} -> STRING {s}
NAME -> STRING:select_first_name
# NAME {first_name(x)=s1 & last_name(x)=s2} -> STRING {s1} STRING {s2}
NAME -> STRING:select_first_name STRING:select_last_name


PP nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# transitive prepositions
# PP {^[P]:(... & ?[x]:(p(x) & arg1/arg2/arg3(x)=a & P(x)))}
#  -> P {p}
#     DP {^[P]:?[Y]:(Y=^[y]:(y=a) & ?[y]:(Y(y) & P(y)))}
# PP {^[P]:(... & ?[x]:(p(x) & arg1/arg2/arg3(x)=possibility(A) & P(x)))}
#  -> P {p}
#     DP {^[P]:A'} where p is something that expresses possibility like `capable_of`, and A' has a `P(z)` term added to the head scope (it will also need to be changed into the set-centric form expected by DP)
# PP {^[P]:(... & ?[x]:(p(x) & ?[y]:(f(y) & arg1/arg2/arg3(x)=y) & P(x)))}
#  -> P {p}
#     DP {^[P]:?[Y]:(Y=^[y]:f(y) & ?[y]:(Y(y) & P(y)))}
# PP {^[P]:(... & ![y]:(f(y) => ?[x]:(p(x) & arg1/arg2/arg3(x)=y & P(x))))}
#  -> P {p}
#     DP {^[P]:?[Y]:(Y=^[y]:f(y) & ![y]:(Y(y) => P(y)))}
# PP {^[P]:(... & ?[Y]:(F(Y) & ... & ![y]:(Y(y) => ?[x]:(p(x) & arg1/arg2/arg3(x)=y & P(x)))))}
#  -> P {p}
#     DP {^[P]:?[Y]:(F(Y) & ![y]:(Y(y) => P(y)))}
# e.g. "house(s) next to the tree(s)"
PP -> P:require_no_preposition DP:try_remove_comma
# e.g. "friend of Mary's", "eyes of Mary's"
PP -> P:require_no_preposition DP:add_genitive,try_remove_comma
# for prepositional verbs (i.e. "look forward to", etc)
PP -> P_PLACEHOLDER:require_preposition DP:try_remove_comma

# for (intransitive) prepositional verbs (i.e. "look forward to", etc)
# PP {^[P]:(... & ?[x]:(p(x) & P(x)))}
#  -> P {p}
PP -> P_PLACEHOLDER:require_preposition DP:try_remove_comma

# PP {^[P]:(... & ?[x]:(p(x) & ?[y]:(f(y) & arg1/arg2(x)=y) & P(x)))}
#  -> P {p}
#     S' {... & ?[y]:f(y)}
# e.g. "before the meeting ended"
PP -> P:require_no_preposition S':try_remove_comma

# closed interrogative finite subordinate clause
# PP {^[P]:(... & (~)?[y1]:(g1(y1) & f(y1)) & ... & (~)?[yn]:(gn(yn) & f(yn)))}
#  -> P {^[P]:(... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn))}
#     P S' {... & f'}
# where f(y) = arg2(y)=^[x]:A and f' = ^[x]:A
# e.g. "he is worried about whether or not the game ended"
PP -> P S':try_remove_comma,add_req_no_aux,add_whether

# open interrogative finite subordinate clause
# PP {^[P]:(... & (~)?[y1]:(g1(y1) & f(y1)) & ... & (~)?[yn]:(gn(yn) & f(yn)))}
#  -> P {^[P]:(... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn))}
#     S' {... & f'}
# where f(y) = arg2(y)=^[x]:A and f' = ^[x]:A
# e.g. "he is worried about when she will arrive"
PP -> P S':try_remove_comma,add_req_no_aux,add_subordinate

# prepositional phrase complements
# PP {^[P]:(... & ?[x]:(p(x) & f(x) & P(x)))}
#  -> P {p}
#     PP {^[P]:(... & ?[x]:(p(x) & f(x) & P(x)))}
# e.g. "apart from Jill", "away from me", "since before the war"
PP -> P:require_no_preposition PP:add_preposition

# postpositions
# PP {^[P]:(... & ?[x]:(p(x) & arg1/arg2(x)=a & P(x)))}
#  -> DP {^[P]:?[Y]:(Y=^[y]:(y=a) & ?[y]:(Y(y) & P(y)))}
#     P {p}
# PP {^[P]:(... & ?[x]:(p(x) & arg1/arg2(x)=possibility(A) & P(x)))}
#  -> DP {^[P]:A'} where p is something that expresses possibility like `capable_of`, and A' has a `P(z)` term added to the head scope
#     P {p}
# PP {^[P]:(... & ?[x]:(p(x) & ?[y]:(f(y) & arg1/arg2(x)=y) & P(x)))}
#  -> DP {^[P]:?[Y]:(Y=^[y]:f(y) & ?[y]:(Y(y) & P(y)))}
#     P {p}
# PP {^[P]:(... & ![y]:(f(y) => ?[x]:(p(x) & arg1/arg2(x)=y & P(x))))}
#  -> DP {^[P]:?[Y]:(Y=^[y]:f(y) & ![y]:(Y(y) => P(y)))}
#     P {p}
# PP {^[P]:(... & ?[Y]:(F(Y) & ... & ![y]:(Y(y) => ?[x]:(p(x) & arg1/arg2(x)=y & P(x)))))}
#  -> DP {^[P]:?[Y]:(F(Y) & ![y]:(Y(y) => P(y)))}
#     P {p}
# e.g. "ten years ago"
PP -> DP:try_remove_comma POSTPOSITION:require_no_preposition

# PP {^[P]:(... & ~?[x]:(f(x) & P(x)))}
#  -> NOT PP {^[P]:(... & ?[x]:(f(x) & P(x)))}
PP -> NOT PP:try_remove_comma

# PP {^[P]:(... & (~)?[x]:((~)?[v1]:g1(v1) & ... & (~)?[vn]:gn(vn) & f(x) & P(x)))}
#  -> ADVP_L {^[P]:((~)?[v1]:(g1(v1) ^ P(v1)) & ... & (~)?[vn]:(gn(vn) & P(vn)))}
#     PP {^[P]:(... & (~)?[x]:(f(x) & P(x)))}
PP -> ADVP_L:try_remove_comma PP:try_remove_comma

# PP {^[P]:(... & ((~)?[x1]:f1(x1) & ... & (~)?[xn]:fn(xn)))}
#  -> PP {^[P]:(... & (~)?[x1]:f1(x1))}
#     COMMA
#     PP {^[P]:(... & ((~)?[x2]:f2(x2) & ... & (~)?[xn]:fn(xn)))}
# PP {^[P]:(... & ((~)?[x1]:f1(x1) | ... | (~)?[xn]:fn(xn)))}
#  -> PP {^[P]:(... & (~)?[x1]:f1(x1))}
#     COMMA
#     PP {^[P]:(... & ((~)?[x2]:f2(x2) | ... | (~)?[xn]:fn(xn)))}
PP -> PP:try_remove_comma COMMA PP:add_comma

# PP {^[P]:(... & ((~)?[x1]:f1(x1) & ... & (~)?[xn]:fn(xn)))}
#  -> PP {^[P]:(... & (~)?[x1]:f1(x1))}
#     (COMMA) AND
#     PP {^[P]:(... & ((~)?[x2]:f2(x2) & ... & (~)?[xn]:fn(xn)))}
PP -> PP:try_remove_comma AND PP:try_remove_comma
PP -> PP:try_remove_comma COMMA AND PP:try_remove_comma

# PP {^[P]:(... & ((~)?[x1]:f1(x1) | ... | (~)?[xn]:fn(xn)))}
#  -> PP {^[P]:(... & (~)?[x1]:f1(x1))}
#     (COMMA) OR
#     PP {^[P]:(... & ((~)?[x2]:f2(x2) | ... | (~)?[xn]:fn(xn)))}
PP -> PP:try_remove_comma OR PP:try_remove_comma
PP -> PP:try_remove_comma COMMA OR PP:try_remove_comma

# preposition stranding
# e.g. "what school did Jason run to?"
PP -> P:require_no_preposition,require_empty_ref


ADJP_R nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# ADJP_R {^[P]:(... & ?[g1]:(... & p1(g1) & ... & f1(g1)) & ... & ?[gn]:(... & pn(gn) & ... & fn(gn)))}
#  -> ADJP_R {^[P]:(... & ?[g1]:(...) & ... & ?[gn]:(...))}
#     PP {^[P]:(... & ?[g1]:(p1(g1) & f1') & ... ?[gn]:(pn(gn) & fn'))}
# where fi(g) = ?[x]:(... & arg2(g)=x) and fi' = ?[x]:(...)
# NOTE: `x` could also be universally-quantified, in which case it is passed to the PP.
# e.g. "afraid of dogs", "capable of swimming"
ADJP_R -> ADJP_R:try_remove_comma PP:try_remove_comma

# e.g. "amazed what an entrance she made"
# TODO: implement this
ADJP_R -> ADJP_R REL?

# ADJP_R {^[P]:(... & ?[g1]:(... & f1(g1)) & ... & ?[gn]:(... & fn(gn)))}
#  -> ADJP_R {^[P]:(... & ?[g1]:(...) & ... & ?[gn]:(...))}
#     S' {^[P]:(f1' & ... & fn')}
# where fi(g) = ?[x]:(h(x) & arg2(g)=x) and fi' = ?[x]:(h(x) & P(x))
#    or fi(g) = arg2(g)=possibility(A) and fi' = A
# e.g. "glad that you arrived"
ADJP_R -> ADJP_R:try_remove_comma S':try_remove_comma
ADJP_R -> ADJP_R:try_remove_comma S':try_remove_comma,add_that

# closed interrogative finite subordinate clause
# ADJP_R {^[P]:(... & (~)?[y1]:(g1(y1) & f(y1)) & ... & (~)?[yn]:(gn(yn) & f(yn)))}
#  -> ADJP_R {^[P]:(... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn))}
#     IF/WHETHER S' {... & f'}
# where f(y) = arg2(y)=^[x]:A and f' = ^[x]:A
# e.g. "i'm not sure whether he arrived or not"
ADJP_R -> ADJP_R:try_remove_comma S':try_remove_comma,add_req_no_aux,add_whether
ADJP_R -> ADJP_R:try_remove_comma S':try_remove_comma,add_req_no_aux,add_if

# open interrogative finite subordinate clause
# ADJP_R {^[P]:(... & (~)?[y1]:(g1(y1) & f(y1)) & ... & (~)?[yn]:(gn(yn) & f(yn)))}
#  -> ADJP_R {^[P]:(... & (~)?[y1]:g1(y1) & ... & (~)?[yn]:gn(yn))}
#     S' {... & f'}
# where f(y) = arg2(y)=^[x]:A and f' = ^[x]:A
# e.g. "i'm not sure when she arrived"
ADJP_R -> ADJP_R:try_remove_comma S':try_remove_comma,add_req_no_aux,add_subordinate

# ADJP_R {^[P]:(... & ?[g1]:(... & f1(g1)) & ... & ?[gn]:(... & fn(gn)))}
#  -> ADJP_R {^[P]:(... & ?[g1]:(...) & ... & ?[gn]:(...))}
#     DP {^[P]:(f1' & ... & fn')}
# where fi(g) = ?[x]:(h(x) & arg2(g)=x) and fi' = ?[x]:(h(x) & P(x))
# e.g. "worth three dollars"
ADJP_R -> ADJP_R:try_remove_comma DP:try_remove_comma

# ADJP_R {^[P]:?[g1]:(... & ?[h]:(f(h) & arg2(g1)=h)) & ... & ?[gn]:(... & ?[h]:(f(h) & arg2(gn)=h))}
#  -> ADJP_R {^[P]:?[g1]:(...) & ... & ?[gn]:(...)}
#     VP_R {?[g1]:(...) & ... & ?[gn]:(...)}
# e.g. "happy to help"
ADJP_R -> ADJP_R:try_remove_comma VP_R:try_remove_comma,add_to_infinitive

# comparative constructions
# ADJP_R {^[P]:(... & ?[r]:(... & ?[g1]:(p(f1)(g1) & ... & arg2(g1)=r) & ... & ?[gn]:(p(fn)(gn) & ... & arg2(gn)=r) & ... & h(r) & ...))}
#  -> ADJP_R {^[P]:(... & ?[g1]:(p(f1)(g1) & ...) & ... & ?[gn]:(p(fn)(gn) & ...) & ...)}
#     P {p}
#     V_ADJUNCT {... & ?[r]:(?[gn]:(p(fn)(gn) & arg2(gn)=r) & ... & h(r))}
# where h(r) could either be `r=a` if r is a constant or it can define a new object like `U(i,r) & p(r) & ...`.
# ADJP_R {^[P]:(... & ?[R]:(... & ![r]:(R(r) => ?[g1]:(p(f1)(g1) & ... & arg2(g1)=r) & ... & ?[gn]:(p(fn)(gn) & ... & arg2(gn)=r)) & ...))}
#  -> ADJP_R {^[P]:(... & ?[g1]:(p(f1)(g1) & ...) & ... & ?[gn]:(p(fn)(gn) & ...) & ...)}
#     P {p} (or `f`, whichever comes last)
#     V_ADJUNCT {... & ?[R]:(... & ![r]:(R(r) => ?[gn]:(p(fn)(gn) & arg2(gn)=r)) & ...)}
# NOTE: The predicate could also be a simple `p` rather than `p(f)`.
# e.g. "more powerful than my car", "brighter than Vega"
ADJP_R -> ADJP_R:try_remove_comma P V_ADJUNCT:try_remove_comma

# ADJP_R {^[P]:(A1 & ... & An)} -> ADJP_R {^[P]:A1} COMMA ADJP_R {^[P]:(A2 & ... & An)}
# ADJP_R {^[P]:(A1 | ... | An)} -> ADJP_R {^[P]:A1} COMMA ADJP_R {^[P]:(A2 | ... | An)}
ADJP_R -> ADJP_R:try_remove_comma COMMA ADJP_R:add_comma

# ADJP_R {^[P]:(A1 & ... & An)} -> ADJP_R {^[P]:A1} (COMMA) AND ADJP_R {^[P]:(A2 & ... & An)}
ADJP_R -> ADJP_R:try_remove_comma AND ADJP_R:try_remove_comma
ADJP_R -> ADJP_R:try_remove_comma COMMA AND ADJP_R:try_remove_comma

# ADJP_R {^[P]:(A1 | ... | An)} -> ADJP_R {^[P]:A1} (COMMA) OR ADJP_R {^[P]:(A2 | ... | An)}
ADJP_R -> ADJP_R:try_remove_comma OR ADJP_R:try_remove_comma
ADJP_R -> ADJP_R:try_remove_comma COMMA OR ADJP_R:try_remove_comma

# ADJP_R {^[P,x]:?[r]:(?[d]:(degree(d) & arg1(d)=r & arg2(d)=x) & ...)}
#  -> HOW ADJP_R {^[P]:?[r]:(...)}
ADJP_R -> HOW ADJP_R:try_remove_comma

# ADJP_R {A} -> ADJP_L {A}
ADJP_R -> ADJP_L:try_remove_comma


ADJP_L nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# ADJP_L {^[P]:?[g]:(f(g) & P(g))} -> ADJ {f}
ADJP_L -> ADJ

# ADJP_L {^[P]:?[g]:(greatest/least(f)(g) & P(g))} -> ADJ {f}
ADJP_L -> ADJ:add_superlative

# ADJP_L {^[P]:?[g]:(greatest/least(f)(g) & P(g))} -> ADJP_L {^[P]:?[g]:(f(g) & P(g))}
ADJP_L -> MOST ADJP_L # for `greatest` only
ADJP_L -> LEAST ADJP_L # for `least` only

# ADJP_L {^[P]:?[g]:(greater/less(f)(g) & P(g))} -> ADJ {f}
ADJP_L -> ADJ:add_comparative

# ADJP_L {^[P]:?[g]:(greater/less(f)(g) & P(g))} -> ADJP_L {^[P]:?[g]:(f(g) & P(g))}
ADJP_L -> MORE ADJP_L # for `greater` only
ADJP_L -> LESS ADJP_L # for `less` only

# ADJP_L {^[P]:(... & ~?[g1]:f1(g1) & ... & ~?[gn]:fn(gn))}
#  -> NOT ADJP_L {^[P]:(... & ?[g1]:f1(g1) & ... & ?[gn]:fn(gn))}
# e.g. "very tall"
ADJP_L -> NOT ADJP_L

# ADJP_L {^[P]:(... & (~)?[g1]:((~)?[x]:(... & arg1(x)=g1) & ... & P(g1)) & ... & (~)?[gn]:((~)?[x]:(... & arg1(x)=gn) & ... & P(gn)))}
#  -> ADVP_L {^[P]:(... & (~)?[x]:(... & P(x)))}
#     ADJP_L {^[P]:(... & (~)?[g1]:(... & P(g1)) & ... & (~)?[gn]:(... & P(gn)))}
# e.g. "very tall"
ADJP_L -> ADVP_L ADJP_L

# ADJP_L {^[P]:(... & (~)?[g1]:(... & f1(g1)) & ... & (~)?[gn]:(... & fn(gn)))}
#  -> DP {^[P]:(f1' & ... & fn')}
#     ADJP_L {^[P]:(... & (~)?[g1]:(...) & ... & (~)?[gn]:(...))}
# where fi(g) = ?[x]:(h(x) & arg2(g)=x) and fi' = ?[x]:(h(x) & P(x))
# e.g. "500 feet tall"
ADJP_L -> DP ADJP_L


ADVP_R nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# ADVP_R {^[P]:(... & (~)?[g1]:(... & p1(g1) & ... & f1(g1)) & ... & (~)?[gn]:(... & pn(gn) & ... & fn(gn)))}
#  -> ADVP_R {^[P]:(... & (~)?[g1]:(...) & ... & (~)?[gn]:(...))}
#     PP {^[P]:(... & (~)?[g1]:(p1(g1) & f1') & ... & (~)?[gn]:(pn(gn) & fn'))}
# where fi(g) = ?[x]:(... & arg2(g)=x) and fi' = ?[x]:(...)
# NOTE: `x` could also be universally-quantified, in which case it is passed to the PP.
# e.g. "differently than him", "equally as effective"
ADVP_R -> ADVP_R:try_remove_comma PP:try_remove_comma

# e.g. "so softly that no one heard"
# TODO: implement this
ADVP_R -> ADVP_R REL?

# comparative constructions
# ADVP_R {^[P]:(... & ?[r]:(... & ?[g1]:(p(f1)(g1) & ... & arg2(g1)=r) & ... & ?[gn]:(p(fn)(gn) & ... & arg2(gn)=r) & ... & h(r) & ...))}
#  -> ADVP_R {^[P]:(... & ?[g1]:(p(f1)(g1) & ...) & ... & ?[gn]:(p(fn)(gn) & ...) & ...)}
#     P {p}
#     V_ADJUNCT {... & ?[r]:(?[gn]:(p(fn)(gn) & arg2(gn)=r) & ... & h(r))}
# where h(r) could either be `r=a` if r is a constant or it can define a new object like `U(i,r) & p(r) & ...`.
# ADVP_R {^[P]:(... & ?[R]:(... & ![r]:(R(r) => ?[g1]:(p(f1)(g1) & ... & arg2(g1)=r) & ... & ?[gn]:(p(fn)(gn) & ... & arg2(gn)=r)) & ...))}
#  -> ADVP_R {^[P]:(... & ?[g1]:(p(f1)(g1) & ...) & ... & ?[gn]:(p(fn)(gn) & ...) & ...)}
#     P {p} (or `f`, whichever comes last)
#     V_ADJUNCT {... & ?[R]:(... & ![r]:(R(r) => ?[gn]:(p(fn)(gn) & arg2(gn)=r)) & ...)}
# NOTE: The predicate could also be a simple `p` rather than `p(f)`.
# e.g. "more persuasively than me"
ADVP_R -> ADVP_R:try_remove_comma P V_ADJUNCT:try_remove_comma

# comparative constructions
# ADVP_R {^[P]:(... & ?[g]:(p(f)(g) & ... & arg2(g)=a))}
#  -> ADVP_R {^[P]:(... & ?[g]:(p(f)(g) & ...))}
#     P {p}
#     V_ADJUNCT {?[g]:(p(f)(g) & arg2(g)=a)}
# ADVP_R {^[P]:(... & ?[g]:(p(f)(g) & ... & ?[y]:(h(y) & arg2(g)=y)))}
#  -> ADVP_R {^[P]:(... & ?[g]:(p(f)(g) & ...))}
#     P {p}
#     V_ADJUNCT {?[g]:(p(f)(g) & ?[y]:(h(y) & arg2(g)=y))}
# NOTE: The predicate could also be a simple `p` rather than `p(f)`.
# e.g. "more persuasively than me"
# TODO: implement V_ADJUNCT or move "P V_ADJUNCT" into a separate COMPARATIVE nonterminal
ADVP_R -> ADVP_R:try_remove_comma P V_ADJUNCT:try_remove_comma

# ADVP_R {^[P]:(A1 & ... & An)} -> ADVP_R {^[P]:A1} COMMA ADVP_R {^[P]:(A2 & ... & An)}
# ADVP_R {^[P]:(A1 | ... | An)} -> ADVP_R {^[P]:A1} COMMA ADVP_R {^[P]:(A2 | ... | An)}
ADVP_R -> ADVP_R:try_remove_comma COMMA ADVP_R:add_comma

# ADVP_R {^[P]:(A1 & ... & An)} -> ADVP_R {^[P]:A1} (COMMA) AND ADVP_R {^[P]:(A2 & ... & An)}
ADVP_R -> ADVP_R:try_remove_comma AND ADVP_R:try_remove_comma
ADVP_R -> ADVP_R:try_remove_comma COMMA AND ADVP_R:try_remove_comma

# ADVP_R {^[P]:(A1 | ... | An)} -> ADVP_R {^[P]:A1} (COMMA) OR ADVP_R {^[P]:(A2 | ... | An)}
ADVP_R -> ADVP_R:try_remove_comma OR ADVP_R:try_remove_comma
ADVP_R -> ADVP_R:try_remove_comma COMMA OR ADVP_R:try_remove_comma

ADVP_R -> ADVP_L:try_remove_comma


ADVP_L nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# ADVP_L {^[P]:?[g]:(f(g) & P(g))} -> ADV {f}
ADVP_L -> ADV

# ADVP_L {^[P]:?[g]:(f(g) & P(g))} -> ADJ {f}
ADVP_L -> ADJ:add_ly

# ADVP_L {^[P]:?[g]:(greatest/least(f)(g) & P(g))} -> ADV {f}
# e.g. "soonest", "most seriously"
ADVP_L -> ADV:add_superlative

# ADVP_L {^[P]:?[g]:(greatest/least(f)(g) & P(g))} -> ADVP_L {^[P]:?[g]:(f(g) & P(g))}
ADVP_L -> MOST ADVP_L:try_remove_comma # for `greatest` only
ADVP_L -> LEAST ADVP_L:try_remove_comma # for `least` only

# ADVP_L {^[P]:?[g]:(greater/less(f)(g) & P(g))} -> ADV {f}
# e.g. "sooner", "more seriously"
ADVP_L -> ADV:add_comparative

# ADVP_L {^[P]:?[g]:(greater/less(f)(g) & P(g))} -> ADVP_L {^[P]:?[g]:(f(g) & P(g))}
ADVP_L -> MORE ADVP_L:try_remove_comma # for `greater` only
ADVP_L -> LESS ADVP_L:try_remove_comma # for `less` only

# ADVP_L {^[P]:(... & ~?[g1]:f(g1) & ... & ~?[gn]:f(gn))}
#  -> NOT ADVP_L {^[P]:(... & ?[g1]:f(g1) & ... & ?[gn]:f(gn))}
# e.g. "very slowly"
ADVP_L -> NOT ADVP_L

# ADVP_L {^[P]:(... & (~)?[g1]:((~)?[x]:(... & arg1(x)=g1) & ... & P(g1)) & ... & (~)?[gn]:((~)?[x]:(... & arg1(x)=gn) & ... & P(gn)))}
#  -> ADVP_L {^[P]:(... & (~)?[x]:(... & P(x)))}
#     ADVP_L {^[P]:(... & (~)?[g1]:(... & P(g1)) & ... & (~)?[gn]:(... & P(gn)))}
# e.g. "very slowly"
ADVP_L -> ADVP_L ADVP_L

# ADVP_L {^[P]:(... & ?[g1]:(... & f1(g1)) & ... & ?[gn]:(... & fn(gn)))}
#  -> DP {^[P]:(f1' & ... & fn')}
#     ADVP_L {^[P]:(... & ?[g1]:(...) & ... & ?[gn]:(...))}
# where fi(g) = ?[x]:(h(x) & arg2(g)=x) and fi' = ?[x]:(h(x) & P(x))
# e.g. "12 minutes late"
ADVP_L -> DP ADVP_L


ALL nonterminal {} {1.0} {1.0} {} 10 1.0 {}
ALL -> "every"
ALL -> "each"
ALL -> "all"
