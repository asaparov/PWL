# We use neo-Davidsonian/event semantics to represent meaning in logical form.
# Thus, all verbs, nouns, adjectives, adverbs, etc are expressed as quantified
# variables. The "head" of any logical form is the right-most scope (not
# necessarily the deepest). For example:
#
#  "cats are mammals"
#  ![x]:(U(x) & cat(x) => ?[t]:(type(t) & present(t) & arg2(t)=mammal & arg1(t)=x))
# where `present` is relative to the current discourse time, so it could be
# defined as something like ![x]:(present(x) = time(x)(T)) where
# time(x) returns the set of times at which the event x is true, and T is the
# current time in the discourse model. Also, `U` is the current universe of
# discourse. `U` can either contain the entire universe, as a default,
# U=^[x]:T, or it could change dynamically according to the discourse model. We
# also might add an axiom like:
#     ![t,x,y]:((type(t) & arg1(t)=x & arg2(t)=y) = y(x))
#
# Generally, every event that corresponds to a verb is modified with
# information about the time at which the event occurs. We can do this with the
# following axioms:
#   ![x,t]:(progressive(x,t) = ?[r]:(r>0 & ![s]:(s>(t-r) & s<(t+r) => time(x)(t))))
#   ![x,t]:(perfect(x,t) = ![r]:(time(x)(r) => r<t))
#   ![x,t]:(perfect_progressive(x,t) = (perfect(x,t) & ?[r]:(r>0 & ![s]:(s>(t-r) & s<t => time(x)(t)))))
#   ![x]:(present(x) = time(x)(T))
#   ![x]:(present_progressive(x) = progressive(x,T))
#   ![x]:(present_perfect(x) = perfect(x,T))
#   ![x]:(present_perfect_progressive(x) = perfect_progressive(x,T))
#   ![x]:(past(x) = ?[t]:(t<T & time(x)(t)))
#   ![x]:(past_progressive(x) = ?[t]:(t<T & progressive(x,t)))
#   ![x]:(past_perfect(x) = ?[t]:(t<T & perfect(x,t)))
#   ![x]:(past_perfect_progressive(x) = ?[t]:(t<T & perfect_progressive(x,t)))
#   ![x]:(future(x) = ?[t]:(t>T & time(x)(t)))
#   ![x]:(future_progressive(x) = ?[t]:(t>T & progressive(x,t)))
#   ![x]:(future_perfect(x) = ?[t]:(t>T & perfect(x,t)))
#   ![x]:(future_perfect_progressive(x) = ?[t]:(t>T & perfect_progressive(x,t)))
# TODO: add time information to the below logical forms too
#
#  "4 cats sleep"
#  ?[X]:(subset(X,^[x]:(U(x) & cat(x))) & size(X)=4 & ![x]:(X(x) => ?[s]:(sleep(s) & present(s) & arg1(s)=x)))
#
#  "4 cats slept"
#  ?[X]:(subset(X,^[x]:(U(x) & cat(x))) & size(X)=4 & ![x]:(X(x) => ?[s]:(sleep(s) & past(s) & arg1(s)=x)))
#
#  "4 cats will have been sleeping"
#  ?[X]:(subset(X,^[x]:(U(x) & cat(x))) & size(X)=4 & ![x]:(X(x) => ?[s]:(sleep(s) & future_perfect_progressive(s) & arg1(s)=x)))
#
#  "there is a cat"
#  ?[x]:(U(x) & cat(x)) [OR] ?[c]:(U(x) & cat(x) & ?[l]:(position(l) & present(l) & arg2(l)=L & arg1(l)=x))
# where L is the current discourse location.
#
#  "3 teachers grade 6 exams"
#  ?[X]:(subset(X,^[x]:(U(x) & teacher(x))) & size(X)=3 & ?[Y]:(subset(Y,^[y]:(U(y) & exam(y))) & size(Y)=6 & ![x,y]:(X(x) & Y(y) => ?[g]:(grade(g) & present(g) & arg2(g)=y & arg1(g)=x))))
#  ?[X]:(subset(X,^[x]:(U(x) & teacher(x))) & size(X)=3 & ?[Y]:(subset(Y,^[y]:(U(y) & exam(y))) & size(Y)=6 & !W[x,y]:(X(x) & Y(y) => ?[g]:(grade(g) & present(g) & arg2(g)=y & arg1(g)=x))))
#  ?[X]:(subset(X,^[x]:(U(x) & teacher(x))) & size(X)=3 & ![x]:(X(x) => ?[Y]:(subset(Y,^[y]:(U(y) & exam(y))) & size(Y)=6 & ![y]:(Y(y) => ?[g]:(grade(g) & present(g) & arg2(g)=y & arg1(g)=x)))))
# where !W is the weak universal quantifier, which is defined as:
# !W[x1,...,xn]:(X1(x1) & ... & Xn(xn) => f(x1,...,xn)) =
#     ![x1]:(X1(x1) => ?[x2,...,xn]:(X2(x2) & ... & Xn(xn) & f(x1,...,xn)))
#   & ![x2]:(X2(x2) => ?[x1,x3,...,xn]:(X1(x1) & X3(x3) & ... & Xn(xn) & f(x1,...,xn)))
#   & ![x3]:(X3(x3) => ?[x1,...,x2,x4,...,xn]:(X1(x1) & ... & X2(x2) & X4(x4) & ... & Xn(xn) & f(x1,...,xn)))
#   & ![x4]:(X4(x4) => ?[x1,...,x3,x5,...,xn]:(X1(x1) & ... & X3(x3) & X5(x5) & ... & Xn(xn) & f(x1,...,xn)))
#   & ... & ![xn]:(Xn(xn) => ?[x1,...,x(n-1)]:(X1(x1) & ... & X(n-1)(x(n-1)) & f(x1,...,xn)))
#
#  "a dog likes every cat"
#  ?[d]:(U(d) & dog(d) & ![c]:(U(c) & cat(c) => ?[l]:(like(l) & present(l) & arg2(l)=c & arg1(l)=d)))
#  ![c]:(U(c) & cat(c) => ?[d]:(U(d) & dog(d) & ?[l]:(like(l) & present(l) & arg2(l)=c & arg1(l)=d)))
#
#  "a dog is liked by every cat"
#  ?[d]:(U(d) & dog(d) & ![c]:(U(c) & cat(c) => ?[l]:(inverse(like)(l) & present(l) & arg2(l)=c & arg1(l)=d)))
#  ![c]:(U(c) & cat(c) => ?[d]:(U(d) & dog(d) & ?[l]:(inverse(like)(l) & present(l) & arg2(l)=c & arg1(l)=d)))
# where we can have an axiom like:
#    ![e,t,x,y]:((inverse(t)(e) & arg1(e)=x & arg2(e)=y) = (t(e) & arg1(e)=y & arg2(e)=x))
# In fact, the passive voice is always realized in semantics using the
# `inverse` function.
#
#  "Noah entertained and was reviewed"
#  ?[X]:(?[e]:(entertain(e) & past(e) & ?[r]:(inverse(review)(r) & past(r) & X=^[x]:(x=e | x=r))) & ^[x]:(X(x) => arg1(x)=noah))
#
#  "not every cat is a tabby"
#  "not all cats are tabbies"
#  ~![c]:(U(c) & cat(c) => ?[t]:(type(t) & present(t) & arg2(t)=tabby & arg1(t)=c))
#
#  "every cat isn't a tabby"
#  "all cats aren't tabbies"
#  ~![c]:(U(c) & cat(c) => ?[t]:(type(t) & present(t) & arg2(t)=tabby & arg1(t)=c))
#  ![c]:(U(c) & cat(c) => ~?[t]:(type(t) & present(t) & arg2(t)=tabby & arg1(t)=c))
#
#  "a cat and dog are sleeping"
#  ?[X]:(?[c]:(U(c) & cat(c) & ?[d]:(U(d) & dog(d) & X=^[x]:(x=c | x=d))) & ![x]:(X(x) => ?[s]:(sleep(s) & present(s) & arg1(s)=x)))
#
#  "4 cats, 2 dogs, and a bird are sleeping"
#  ?[X]:(?[C]:(subset(C,^[x]:(U(x) & cat(x))) & size(C)=4 & ?[D]:(subset(D,^[x]:(U(x) & dog(x))) & size(D)=2 & ?[b]:(U(b) & bird(b) & X=^[x]:(x=C | x=D | x=^[y]:y=b)))) & ![Y]:(X(Y) => ![x]:(Y(x) => ?[s]:(sleep(s) & present(s) & arg1(s)=x))))
#
#  "a man and his dog were walking in the park"
#  ?[X]:(?[m]:(U(m) & man(m) & ?[d]:(U(d) & dog(d) & male(#1) & ?[o]:(own(o) & arg1(o)=#1 & arg2(o)=d) & X=^[x]:(x=m | x=d))) & ![x]:(X(x) => ?[w]:(walk(w) & past_progressive(w) & ?[p]:(U(p) & park(p) & arg2(w)=p) & arg1(w)=x)))
#
#  "10 girls and boys are in class"
#  ?[X]:(?[G]:(G=^[x]:(U(x) & girl(x)) & ?[B]:(B=^[x]:(U(x) & boy(x)) & X=^[x]:(x=G | x=B))) & ![Y]:(X(Y) => size(Y)=10) & ![Y]:(X(Y) => ![x]:(Y(x) => ?[p]:(position(p) & ?[c]:(U(c) & class(c) & arg2(p)=c) & arg1(p)=x))))
#  ?[X]:(?[G]:(G=^[x]:(U(x) & girl(x)) & ?[B]:(B=^[x]:(U(x) & boy(x)) & X=^[x]:(x=G | x=B))) & sum(X,^[Y]:size(Y))=10 & ![Y]:(X(Y) => ![x]:(Y(x) => ?[p]:(position(p) & present(p) & ?[c]:(U(c) & class(c) & arg2(p)=c) & arg1(p)=x))))
#
#  "Jane is the only doctor"
#  ?[o]:(only(o) & present(o) & arg2(o)=^[x]:(U(x) & doctor(x)) & arg1(o)=jane) [or maybe we should do] ?[o]:(only(o) & present(o) & ?[D]:(D=^[x]:(U(x) & doctor(x)) & arg2(o)=D) & arg1(o)=jane)
#
#  "i did not get much money"
#  ?[m]:(U(m) & money(m) & ?[l]:(large_amount(l) & arg1(l)=m) & ~[r]:(receive(r) & past(r) & arg2(r)=m & arg1(r)=me))
#
#  "i don't like Ralph's destroying the barn"
#  "i don't like Ralph's destruction of the barn"
#  ?[d]:(destroy(d) & progressive(d) & ?[b]:(U(b) & barn(b) & arg2(d)=b) & arg1(d)=ralph & ~?[l]:(like(l) & present(l) & arg2(l)=d & arg1(l)=me))
# note: we could require constant arguments (e.g. `ralph` and `me`) to be part of U in the discourse model
#
#  "i don't like the destruction of the barns by the teenagers"
#  ![x]:(U(x) & teenager(x) => ![y]:(U(y) & barn(y) => ?[d]:(destroy(d) & arg2(d)=y & arg1(d)=x & ~?[l]:(like(l) & arg2(l)=d & arg1(l)=me))))
#    [OR]
#  ?[X]:(X=^[x]:(U(x) & teenager(x)) & ?[Y]:(Y=^[y]:(U(y) & barn(y)) & ![x]:(X(x) => ![y]:(Y(y) => ?[d]:(destroy(d) & arg2(d)=y & arg1(d)=x & ~?[l]:(like(l) & arg2(l)=d & arg1(l)=me))))))
#
#  "the cat's purring is soothing"
#  ?[p]:(purr(p) & progressive(p) & ?[c]:(U(c) & cat(c) & arg1(p)=c) & ?[s]:(sooth(s) & progressive(s) & arg1(s)=p))
#
#  "Joan's pen is good"
#  ?[p]:(U(p) & pen(p) & ?[o]:(own(o) & arg2(o)=p & arg1(o)=joan) & ?[g]:(good(g) & present(g) & arg1(g)=p))
#
#  "Joan's pens are good"
#  ![x]:(U(x) & pen(x) & ?[o]:(own(o) & arg2(o)=x & arg1(o)=joan) => ?[g]:(good(g) & present(g) & arg1(g)=x))
#    [OR]
#  ?[X]:(X=^[p]:(U(p) & pen(p) & ?[o]:(own(o) & arg2(o)=p & arg1(o)=joan)) & ![x]:(X(x) => ?[g]:(good(g) & present(g) & arg1(g)=x)))
#
# TODO: move the below rules into the grammar
# S' {?[x]:f(x)} -> THERE IS DP {^[P]:?[x]:(f(x) & P(x))}
# NOTE: This above rule is only really useful if we choose to represent "there
# is a cat" as something like ?[x]:(U(x) & cat(x)).
# S' {... & ?[y]:(... & g(y)=a & ...)} -> DP {a} VP {... & ?[y]:(... & g(y)=x & ...)}
# S' {... & (~)![x]:(f(x) => ... & ?[y]:(... & g(y)=x & ...))} -> DP {^[P]:(~)![x]:(f(x) => P(x))} VP {... & ?[y]:(... & g(y)=x & ...)}
# S' {... & ?[X]:(f(X) & (~)![x]:(X(x) => ... & ?[y]:(... & g(y)=x & ...)))} -> DP {^[P]:?[X]:(f(X) & (~)![x]:(X(x) => P(x))} VP {... & ?[y]:(... & g(y)=x & ...)}
# where g is arg1 or arg2.
# NOTE: The above two rules, during the inverse transformation, the scope of X
# and x can be positioned anywhere above the scope of y. However, to avoid
# overgenerating semantically-equivalent logical forms, for each equivalence
# class of semantically-equivalent inverse logical forms, we only output a
# single logical form (for example, by choosing the logical form in the
# equivalence class in which the scope of X and x are maximal). Also, the above
# rule can be extended to other kinds of quantification over X, such as
# existential or weak universal quantifier. Also, note that f(X) and f(x)
# cannot depend on any variables other than those declared within f(X) and
# f(x). But note that in the example "a cat and dog are sleeping", f(X)
# includes the definition for "cat" and "dog". In the above two rules, g(x) is
# the right-most conjunct in that scope that has no unbound variables.
# S' {... & (~)![x]:(f(x) => ... & ?[y]:(... & g(x) & ...))} -> DP {^[P]:![x]:(f(x) => P(x))} VP {... & (~)?[y]:(... & g(x) & ...)}
# S' {... & ?[X]:(f(X) & (~)![x]:(X(x) => ... & ?[y]:(... & g(x) & ...)))} -> DP {^[P]:?[X]:(f(X) & ![x]:(X(x) => P(x))} VP {... & (~)?[y]:(... & g(x) & ...)}
# NOTE: The previous note also applies to the above two rules.
#  "the students' pens are good"
#  ?[X]:(?[Y]:(Y=^[y]:(U(y) & student(y)) & X=^[x]:(U(x) & pen(x) & ?[y]:(Y(y) & ?[o]:(own(o) & arg2(o)=x & arg1(o)=y)))) & ![x]:(X(x) => ?[g]:(good(g) & present(g) & arg1(g)=x)))
#
#  "i saw the trees by all the cats"
#  ?[X]:(X=^[x]:(U(x) & cat(x)) & ?[Y]:(Y=^[y]:(U(y) & tree(y) & ![x]:(X(x) => ?[n]:(near(n) & arg2(n)=y & arg1(n)=x))) & ![y]:(Y(y) => ?[s]:(see(s) & past(s) & arg2(s)=y & arg1(s)=me))))
#    [OR]
#  ![y]:(U(y) & tree(y) & ![x]:(U(x) & cat(x) => ?[n]:(near(n) & arg2(n)=y & arg1(n)=x)) => ?[s]:(see(s) & past(s) & arg2(s)=y & arg1(s)=me))
#
#  "he works a lot to earn money for school"
#  U(#1) & male(#1) & ?[w]:(work(w) & present(w) & ?[p]:(purpose(p) & ?[e]:(earn(e) & ?[m]:(U(m) & money(m) & arg2(e)=m) & arg2(p)=e) arg1(p)=w) & arg1(w)=#1)
#
#  "the ladder collapsed because it was old"
#  ?[l]:(U(l) & ladder(l) & ?[c]:(collapse(c) & past(c) & ?[r]:(reason(r) & ?[o]:(old(o) & past(o) & arg1(o)=#1 & arg2(r)=o) & arg1(r)=c) & arg1(c)=l))
#
#  "Mr. Bibby wrote the letter with a pencil"
#  ?[p]:(U(p) & pencil(p) & ?[l]:(U(l) & letter(l) & ?[w]:(write(w) & arg2(w)=l & arg1(w)=bibby)))
#
#  "the students wrote the letters with the pencils"
#  ?[S]:(S=^[s]:(U(s) & student(s)) & ?[L]:(L=^[l]:(U(l) & letter(l)) & ?[P]:(P=^[p]:(U(p) & pencil(p)) & !W[s,l,p]:(S(s) & L(l) & P(p) => ?[w]:(wrote(w) & past(w) & arg2(w)=l & ?[x]:(with(x) & arg2(x)=p & arg1(x)=w) & arg1(w)=s))))))
#
#  "she sat on the table"
#  U(#1) & female(#1) & ?[s]:(sit(s) & past(s) & ?[o]:(on_top_of(o) & ?[t]:(U(t) & table(t) & arg2(o)=t) & arg1(o)=s) & arg1(s)=#1)
#
#  "the birds hear each other"
#  ![X]:(X=^[x]:(U(x) & bird(x)) & ![x,y]:(X(x) & Y(x) & ~(x=y) => ?[h]:(hear(h) & arg2(h)=y & arg1(h)=x)))
#
#  "some relative of each villager and some relative of each townsman hate each other"
#  ?[a]:(U(a) & ![x]:(U(x) & villager(x) => ?[r]:(related_to(r) & arg2(r)=x & arg1(r)=a)) & ?[b]:(U(b) & ![x]:(U(x) & townsman(x) => ?[r]:(related_to(r) & arg2(r)=x & arg1(r)=b)) & ?[X]:(X=^[x]:(x=a | x=b) & ![x,y]:(X(x) & Y(x) & ~(x=y) => ?[h]:(hate(h) & arg2(h)=y & arg1(h)=x)))))
#
#  "in either case, i am going"
#  ?[X]:(subset(X,^[x]:(U(x) & case(x))) & size(X)=2 & ![x]:(X(x) => (true(x) => ?[g]:(go(g) & progressive(g) & arg1(g)=me))))
#
#  "if it rains, the grass will be wet"
#  ?[r]:(rain(r) & present(r) & arg1(r)=#1) => ?[g]:(U(g) & grass(g) & ?[w]:(wet(w) & future(w) & arg1(w)=g))
#
#  "he ran with difficulty"
#  U(#1) & male(#1) & ?[r]:(run(r) & past(r) & ?[d]:(difficult(d) & arg1(d)=r) & arg1(r)=#1)
#
#  "he stood in silence"
#  U(#1) & male(#1) & ?[s]:(stand(s) & past(s) & ?[x]:(silently(x) & arg1(x)=s) & arg1(s)=#1)
# where we could define ![x]:(silently(x) = ?[s]:(is_silent(s) & arg1(s)=arg1(x) & ![t]:(time(x)(t) => time(s)(t))))
#
#  "she helped me with my homework"
#  U(#1) & female(#1) & ?[h]:(help(h) & past(h) & arg2(h)=me & ?[x]:(U(x) & homework(x) & ?[o]:(own(o) & arg2(o)=x & arg1(o)=me) & ?[w]:(with(w) & arg2(w)=x & arg1(w)=h)) & arg1(h)=#1)
#
#  "he stayed for two weeks"
#  U(#1) & male(#1) & ?[s]:(stay(s) & past(s) & ?[d]:(duration(d) & arg2(d)=(2*week) & arg1(d)=s) & arg1(s)=#1)
#
#  "it is under the bush"
#  U(#1) & ?[u]:(is_under(u) & ?[b]:(U(b) & bush(b) & arg2(u)=b) & arg1(u)=#1)
#
#  "the party is at seven o'clock"
#  ?[p]:(U(p) & party(p) & start_time(p)=(7:00pm))
#    [OR]
#  ?[p]:(U(p) & party(p) & ?[s]:(start_time(s) & arg2(s)=(7:00pm) & arg1(s)=p))
# where we could define ![x,t]:((start_time(x)=t) = ![s]:(time(x)(s) => t<=s))
# TODO: how do we represent date/time constants?
#
#  "she will leave after she has had breakfast"
#  U(#1) & female(#1) & ?[l]:(leave(l) & future(l) & ?[a]:(after(a) & ?[e]:(eat(e) & U(#2) & female(#2) & ?[b]:(U(b) & breakfast(b) & arg2(e)=b) & arg1(e)=#2 & arg2(a)=e) & arg1(a)=l) & arg1(l)=#1)
# where we could define ![a,x,y]:((after(a) & arg1(a)=x & arg2(a)=y) = ~?[s,t]:(time(x)(s) & time(y)(t) & s<t))
#
#  "the ball rotated quickly and heated up slowly"
#  ?[b]:(U(b) & ball(b) & ?[r]:(rotate(r) & past(r) & ?[q]:(quickly(q) & arg1(q)=r) & ?[h]:(heat_up(h) & past(h) & ?[s]:(slowly(s) & arg1(s)=h) & ?[X]:(X=^[x]:(x=r | x=h) & ![x]:(X(x) => arg1(x)=b)))))
#
#  "the ball rotated and heated up slowly"
#  ?[b]:(U(b) & ball(b) & ?[r]:(rotate(r) & past(r) & ?[h]:(heat_up(h) & past(h) & ?[X]:(X=^[x]:(x=r | x=h) & ![x]:(X(x) => ?[s]:(slowly(s) & arg1(s)=x) & arg1(x)=b)))))
#
#  "Emma and Noah met."
#  ?[X]:(X=^[x]:(x=emma | x=noah) & ?[m]:(collective_meet(m) & past(m) & arg1(m)=X))
#
#  "Emma and Noah lifted the stone."
#  ?[X]:(X=^[x]:(x=emma | x=noah) & ?[s]:(U(s) & stone(s) & ?[l]:(lift(l) & past(l) & arg2(l)=s & arg1(l)=X)))
# Here, "Emma and Noah" has a *collective* interpretation, which also occurs in
# many other sentences in English.


# This is the root nonterminal for declarative sentences.
S nonterminal {} {1.0} {1.0} {} 10 1.0 {}
S -> S':singular
S -> S':plural

S -> ADVP (COMMA) S
S -> S (COMMA) ADVP
S -> S COMMA S
S -> S COMMA AND S
S -> S AND S
S -> S COMMA OR S
S -> S OR S

# S {f(because(A,B))} -> S {f(A)} (COMMA) BECAUSE/FOR S {B} where A is the head
S -> S COMMA BECAUSE S
S -> S BECAUSE S
S -> S COMMA FOR S
S -> S FOR S


S' nonterminal {has_not} {1.0, 1.0} {1.0, 1.0} {} 10 1.0 {}

# S' {g(a)} -> DP {a} VP {g(x)}
# S' {~g(a)} -> DP {a} VP {~g(x)}
# S' {![x]:(f(x) => g(h(x)))} -> DP {![x]:(f(x) => h(x))} VP {g(x)}
# S' {~![x]:(f(x) => g(h(x)))} -> DP {~![x]:(f(x) => h(x))} VP {g(x)}
# note: h is optional here (it could be the identity ^[x]:x)
# S' {?[X1]:(F1(X1,^[x]:f1(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & ![x1]:(X1(x1) => ... => ![xn]:(Xn(xn) => g(h1(x1),h2(x2,...,xn)))...))...)}
#  -> DP {?[X1]:(F1(X1,^[x]:f1(x)) & ![x1]:(X1(x1) => h1(x1)))}
#     VP {?[X2]:(F2(X2,^[x]:f2(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & ![x2]:(X2(x2) => ... => ![xn]:(Xn(xn) => g(x1,h2(x2,...,xn)))...))...)}
# S' {?[X1]:(F1(X1,^[x]:f1(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & ~![x1]:(X1(x1) => ... => ![xn]:(Xn(xn) => g(h1(x1),h2(x2,...,xn)))...))...)}
#  -> DP {?[X1]:(F1(X1,^[x]:f1(x)) & ~![x1]:(X1(x1) => h1(x1)))}
#     VP {?[X2]:(F2(X2,^[x]:f2(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & ![x2]:(X2(x2) => ... => ![xn]:(Xn(xn) => g(x1,h2(x2,...,xn)))...))...)}
# S' {?[X1]:(F1(X1,^[x]:f1(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & ?[x1]:(X1(x1) & ... => ![xn]:(Xn(xn) => g(h1(x1),h2(x2,...,xn)))...))...)}
#  -> DP {?[X1]:(F1(X1,^[x]:f1(x)) & ?[x1]:(X1(x1) & h1(x1)))}
#     VP {?[X2]:(F2(X2,^[x]:f2(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & ![x2]:(X2(x2) => ... => ![xn]:(Xn(xn) => g(x1,h2(x2,...,xn)))...))...)}
# S' {?[X1]:(F1(X1,^[x]:f1(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & ~?[x1]:(X1(x1) & ... => ![xn]:(Xn(xn) => g(h1(x1),h2(x2,...,xn)))...))...)}
#  -> DP {?[X1]:(F1(X1,^[x]:f1(x)) & ~?[x1]:(X1(x1) & h1(x)))}
#     VP {?[X2]:(F2(X2,^[x]:f2(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & ![x2]:(X2(x2) => ... => ![xn]:(Xn(xn) => g(x1,h2(x2,...,xn)))...))...)}
# where F1,...,Fn are set-defining functions like subset or =
# note: h1 and h2 are optional (they could be the identity ^[x]:x)
# TODO: add a version of these two rules for weak universal quantification
S' -> DP:remove_set_universal VP:select_set_consequent
# S' {~![x]:(f(x) => g(h(x)))} -> DP {![x]:(f(x) => h(x))} VP {~g(x)}
# note: h is optional here (it could be the identity ^[x]:x)
# S' {?[x]:(f(x) & g(h(x)))} -> DP {?[x]:(f(x) & h(x))} VP:{g(x)}
# S' {?[X1]:(F1(X1,^[x]:f1(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & ~![x1]:(X1(x1) => ... => ![xn]:(Xn(xn) => g(h1(x1),h2(x2,...,xn)))...))...)}
#  -> DP {?[X1]:(F1(X1,^[x]:f1(x)) & ![x1]:(X1(x1) => h1(x1)))}
#     VP {?[X2]:(F2(X2,^[x]:f2(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & ~![x2]:(X2(x2) => ... => ![xn]:(Xn(xn) => g(x1,h2(x2,...,xn)))...))...)}
# S' {?[X1]:(F1(X1,^[x]:f1(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & ~?[x1]:(X1(x1) & ... => ![xn]:(Xn(xn) => g(h1(x1),h2(x2,...,xn)))...))...)}
#  -> DP {?[X1]:(F1(X1,^[x]:f1(x)) & ?[x1]:(X1(x1) & h1(x1)))}
#     VP {?[X2]:(F2(X2,^[x]:f2(x)) & ... & ?[Xn]:(Fn(Xn,^[x]:fn(x)) & ~![x2]:(X2(x2) => ... => ![xn]:(Xn(xn) => g(x1,h2(x2,...,xn)))...))...)}
S' -> DP:not_remove_set_universal VP:select_set_consequent

# S' {?[x]:f(x)} -> THERE IS DP {?[x]:f(x)}
# S' {~?[x]:f(x)} -> THERE IS DP {~?[x]:f(x)}
S' -> THERE:null IS:null DP:identity


VP nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# VP {?[X1]:(F1(X1) & ... & ?[Xn]:(Fn(Xn) & (~)![x1,...,xn]:(X1(x1) & ... & Xn(xn) => g(h(x2,...,xn), x1)))...)}
#  -> VP {?[X2]:(F2(X2) & ... & ?[Xn]:(Fn(Xn) & (~)![x2,...,xn]:(X2(x2) & ... & Xn(xn) => h(x2,...,xn)))...)} # all sets and variables that are not required by h are removed
#     PP {?[X1]:(F1(X1) & ![x1]:(X1(x1) => g(z,x1)))} # any other sets and variables required by g are also kept
# note: x1,...,xn could also be individuals rather than sets
# this rule should not be selected if there are any sets/variables that are shared by both g and h
VP -> VP PP

# VP {?[X1]:(F1(X1) & ... & ?[Xn]:(Fn(Xn) & (~)![x1,...,xn]:(X1(x1) & ... & Xn(xn) => g(h1(x1,...,xm),hn(xn))))...)}
#  -> VP {?[X1]:(F1(X1) & ... & ?[Xm]:(Fm(Xm) & (~)![x1,...,xm]:(X1(x1) & ... & Xm(xm) => g(h1(x1,...,xm),xn)))...)} # all sets and variables that are not required by hn(xn) are removed
#     PP {?[Xn]:(Fn(Xn) & ![xn]:(Xn(xn) => g(x1,...,xm,hn(xn)))))} # any other sets and variables required by g are also kept
# note: x1,...,xn could also be individuals rather than sets
# this rule should not be selected if there are any sets/variables that are shared by both g and h
VP -> VP PP

# VP {(~)f1(x1,...,xk) & ... & (~)fn(x1,...,xk)}
#  -> VP {(~)f1(x1,...,xk)}
#     COMMA
#     VP {(~)f2(x1,...,xk) & ... & (~)fn(x1,...,xk)}
# VP {?[X1,...,Xj]:(... & ![x1,...,xj]:(X1(x1) & ... & Xj(xj) => (~)f1(x1,...xj) & ... & (~)fn(x1,...xj)))}
#  -> VP {?[X1,...,Xj]:(... & ![x1,...,xj]:(X1(x1) & ... & Xj(xj) => (~)f1(x1,...xj)))} # the sets and variables unused by f1 are removed
#     COMMA
#     VP {?[X1,...,Xj]:(... & ![x1,...,xj]:(X1(x1) & ... & Xj(xj) => (~)f2(x1,...xj) & ... & (~)fn(x1,...xj)))} # the sets and variables unused by f2,...,fn are removed
# VP {(~)f1(x1,...,xk) | ... | (~)fn(x1,...,xk)}
#  -> VP {(~)f1(x1,...,xk)}
#     COMMA
#     VP {(~)f2(x1,...,xk) | ... | (~)fn(x1,...,xk)}
# VP {?[X1,...,Xj]:(... & ![x1,...,xj]:(X1(x1) & ... & Xj(xj) => (~)f1(x1,...xj) | ... | (~)fn(x1,...xj)))}
#  -> VP {?[X1,...,Xj]:(... & ![x1,...,xj]:(X1(x1) & ... & Xj(xj) => (~)f1(x1,...xj)))} # the sets and variables unused by f1 are removed
#     COMMA
#     VP {?[X1,...,Xj]:(... & ![x1,...,xj]:(X1(x1) & ... & Xj(xj) => (~)f2(x1,...xj) | ... | (~)fn(x1,...xj)))} # the sets and variables unused by f2,...,fn are removed
VP -> VP COMMA:null VP

# VP {(~)f1(x1,...,xk) & (~)f2(x1,...,xk)}
#  -> VP {(~)f1(x1,...,xk)}
#     (COMMA) AND
#     VP {(~)f2(x1,...,xk)}
# VP {?[X1,...,Xj]:(... & ![x1,...,xj]:(X1(x1) & ... & Xj(xj) => (~)f1(x1,...xj) & (~)f2(x1,...xj)))}
#  -> VP {?[X1,...,Xj]:(... & ![x1,...,xj]:(X1(x1) & ... & Xj(xj) => (~)f1(x1,...xj)))} # the sets and variables unused by f1 are removed
#     (COMMA) AND
#     VP {?[X1,...,Xj]:(... & ![x1,...,xj]:(X1(x1) & ... & Xj(xj) => (~)f2(x1,...xj)))} # the sets and variables unused by f2 are removed
VP -> VP AND VP
VP -> VP COMMA:null AND VP

# VP {(~)f1(x1,...,xk) | (~)f2(x1,...,xk)}
#  -> VP {(~)f1(x1,...,xk)}
#     (COMMA) OR
#     VP {(~)f2(x1,...,xk)}
# VP {?[X1,...,Xj]:(... & ![x1,...,xj]:(X1(x1) & ... & Xj(xj) => (~)f1(x1,...xj) | (~)f2(x1,...xj)))}
#  -> VP {?[X1,...,Xj]:(... & ![x1,...,xj]:(X1(x1) & ... & Xj(xj) => (~)f1(x1,...xj)))} # the sets and variables unused by f1 are removed
#     (COMMA) OR
#     VP {?[X1,...,Xj]:(... & ![x1,...,xj]:(X1(x1) & ... & Xj(xj) => (~)f2(x1,...xj)))} # the sets and variables unused by f2 are removed
VP -> VP OR VP
VP -> VP COMMA:null OR VP

# VP {~f1(x1,...,xk) & ~f2(x1,...,xk)}
#  -> VP {~f1(x1,...,xk)}
#     (COMMA) NOR
#     VP {f2(x1,...,xk)}
# VP {?[X1,...,Xj]:(... & ![x1,...,xj]:(X1(x1) & ... & Xj(xj) => ~f1(x1,...xj) & ~f2(x1,...xj)))}
#  -> VP {?[X1,...,Xj]:(... & ![x1,...,xj]:(X1(x1) & ... & Xj(xj) => ~f1(x1,...xj)))} # the sets and variables unused by f1 are removed
#     (COMMA) NOR
#     VP {?[X1,...,Xj]:(... & ![x1,...,xj]:(X1(x1) & ... & Xj(xj) => f2(x1,...xj)))} # the sets and variables unused by f2 are removed
# this depends on whether f1 and f2 are negated
VP -> VP NOR VP # TODO: the second VP requires do-support
VP -> VP COMMA:null NOR VP # TODO: the second VP requires do-support


# TODO: should this nonterminal change the universal/existential quantifiers into a single kind of quantifier, to improve generalization for the NP nonterminal and further downstream?
DP nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# DP {A} -> A NP {A}
DP -> DP'

# DP {?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)![x]:(S(x) => ![y]:(x(y) => h(y))))} if xi are set-valued
# or {?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)![x]:(S(x) => h(x)))} if xi are individuals
# or {?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)?[x]:(S(x) & ?[y]:(x(y) & h(y))))} if xi are set-valued
# or {?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)?[x]:(S(x) & h(x)))} if xi are individuals
#  -> DP {?[x1]:(f1(x1) & (~)h(x1))} or {?[x1]:(f1(x1) & (~)![x]:(x1(x) => h(x)))} if x1 is a set
#     COMMA
#     DP {?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)![x]:(S(x) => ![y]:(x(y) => h(y))))}
#     or {?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)![x]:(S(x) => h(x)))}
#     or {?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)?[x]:(S(x) & ?[y]:(x(y) & h(y))))}
#     or {?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)?[x]:(S(x) & h(x)))}
# note: xi could also be constants, rather than existentially-quantified variables
# note: if xi is a set containing a singleton, S would look like ^[x]:(... | x=^[y]:y=singleton | ...)
DP -> DP COMMA:null DP:comma

# DP {?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => ![y]:(x(y) => h(y))))}
# or {?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => h(x)))}
#  -> DP {?[x1]:(f1(x1) & (~)h(x1))} or {?[x1]:(f1(x1) & (~)![x]:(x1(x) => h(x)))} if x1 is a set
#     (COMMA) AND
#     DP {?[x2]:(f2(x2) & (~)h(x2))} or {?[x2]:(f2(x2) & (~)![x]:(x2(x) => h(x)))} if x2 is a set
# note: xi could also be constants, rather than existentially-quantified variables
DP -> DP AND:null DP
DP -> DP COMMA:null AND:null DP

# DP {?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & ?[y]:(x(y) & h(y))))}
# or {?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & h(x)))}
#  -> DP {?[x1]:(f1(x1) & (~)h(x1))} or {?[x1]:(f1(x1) & (~)?[x]:(x1(x) & h(x)))} if x1 is a set
#     (COMMA) OR
#     DP {?[x2]:(f2(x2) & (~)h(x2))} or {?[x2]:(f2(x2) & (~)?[x]:(x2(x) & h(x)))} if x2 is a set
# note: xi could also be constants, rather than existentially-quantified variables
DP -> DP OR:null DP
DP -> DP COMMA:null OR:null DP

# DP {~![x]:(f(x) -> h(x))} -> NO NP {![x]:(f(x) -> h(x))}
# DP {~?[x]:(f(x) & h(x))} -> NO NP {?[x]:(f(x) & h(x))}
# DP {![X]:(f(X) & ~![x]:(X(x) => h(x)))} -> NO NP {![X]:(f(X) & ![x]:(X(x) => h(x)))}
# DP {![X]:(f(X) & ~?[x]:(X(x) & h(x)))} -> NO NP {![X]:(f(X) & ?[x]:(X(x) & h(x)))}
# this depends on whether the head quantifier is negated
DP -> NO NP
DP -> NOT DP

# DP {a} -> NAME {a}
# this depends on whether `a` is a constant vs a predicate, or a more complex formula
DP -> NAME

# DP {A & h(a,c)} => ADV {h(x,c)} DP {A & a}
# DP {A & h(c,a)} => ADV {h(c,x)} DP {A & a}
# where e.g. h could be multiply and c could be 2, which can be expressed as "twice the ..."
DP -> ADV DP:adv

# DP {![X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => h(x)))} -> EACH NP {![X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => h(x)))}
# DP {![X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & h(x)))} -> EACH NP {![X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & h(x)))}
# this depends on whether the set is defined as S=^[x]:f(x) rather than with functions like `subset` or `half`;
# it also depends on whether the head predicate of the left conjunct is `this`, `that`, [TODO: add features for possessive]
DP -> EACH:no_adv NP

# DP {A} -> A NP {A}
#   e.g. "A group of students walks down the street."
DP -> A:null NP:concord_singular

# DP {![X]:(F(subset(X,^[x]:f(x))) & ![x]:(X(x) => h(x)))} -> SOME NP {![X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => h(x)))}
# DP {![X]:(F(subset(X,^[x]:f(x))) & ?[x]:(X(x) & h(x)))} -> SOME NP {![X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & h(x)))}
# this depends on whether the set is defined using `subset` rather than with functions like `half` or as S=^[x]:f(x);
DP -> SOME NP

# DP {A} -> DEF_DP {A}
DP -> DEF_DP

# DP {![X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => h(x)))} -> ALL DEF_NP {![X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => h(x)))}
# DP {![X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & h(x)))} -> ALL DEF_NP {![X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & h(x)))}
# this depends on whether the set is defined as S=^[x]:f(x) rather than with functions like `subset` or `half`;
# it also depends on whether the head predicate of the left conjunct is `this`, `that`, [TODO: add features for possessive]
DP -> ALL DEF_DP
DP -> ALL DP'

# DP {![X]:(F(half(X,^[x]:f(x))) & ![x]:(X(x) => h(x)))} -> HALF DEF_NP {![X]:(F(X=^[x]:f(x)) & ![x]:(X(x) => h(x)))}
# DP {![X]:(F(half(X,^[x]:f(x))) & ?[x]:(X(x) & h(x)))} -> HALF DEF_NP {![X]:(F(X=^[x]:f(x)) & ?[x]:(X(x) & h(x)))}
# this depends on whether the set is defined using `half` rather than with functions like `subset` or as S=^[x]:f(x);
# it also depends on whether the head predicate of the left conjunct is `this`, `that`, [TODO: add features for possessive]
DP -> HALF DEF_DP
DP -> HALF A NP


DEF_DP nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# DEF_DP {A} -> THE NP {A}
DEF_DP -> THE DP'

# DP {![x]:(this(x) & f(x) => h(x))} -> THIS NP {![x]:(f(x) => h(x))}
# DP {?[x]:(this(x) & h(x))} -> THIS NP {?[x]:h(x)}
# DP {?[S]:(this(S) & F(S) & ![x]:(S(x) => h(x)))} -> THIS NP {?[S]:(F(S) & ![x]:(S(x) => h(x)))}
# DP {?[S]:(this(S) & F(S) & ?[x]:(S(x) & h(x)))} -> THIS NP {?[S]:(F(S) & ?[x]:(S(x) & h(x)))}
# this depends on whether the head predicate of the left conjunct is `this`
DEF_DP -> THIS DP'

# DP {![x]:(that(x) & f(x) => h(x))} -> THIS NP {![x]:(f(x) => h(x))}
# DP {?[x]:(that(x) & h(x))} -> THIS NP {?[x]:h(x)}
# DP {?[S]:(that(S) & F(S) & ![x]:(S(x) => h(x)))} -> THIS NP {?[S]:(F(S) & ![x]:(S(x) => h(x)))}
# DP {?[S]:(that(S) & F(S) & ?[x]:(S(x) & h(x)))} -> THIS NP {?[S]:(F(S) & ?[x]:(S(x) & h(x)))}
# this depends on whether the head predicate of the left conjunct is `that`
DEF_DP -> THAT DP'

# DEF_DP {?[x]:(belongs(x,a) & f(x))} -> DP {a} DP' {?[x]:f(x)}
# DEF_DP {?[x]:(?[y]:(g(y) & belongs(x,h(y))) & f(x))} -> DP {?[y]:(g(y) & h(y))} DP' {?[x]:f(x)}
# DEF_DP {?[S]:(![x]:(S(x) => belongs(x,a)) & f(S))} -> DP {a} DP' {?[S]:f(S)}
# DEF_DP {?[S]:(?[y]:(g(y) & ![x]:(S(x) => belongs(x,h(y)))) & f(S))} -> DP {?[y]:(g(y) & h(y))} DP' {?[S]:f(S)}
# DEF_DP {?[S]:(?[T]:(g(T) & ![x]:(S(x) => ![y]:(T(y) => belongs(x,h(y))))) & f(S))} -> DP {?[T]:(g(T) & ![y]:(T(y) => h(y)))} DP' {?[S]:f(S)}
# TODO: this is wrong; as written, this is stating for every x in S={x:f(x)} and every y in T={y:g(y)}, y owns x. but we want T to be the set {y:g(y) & some x owns y}
# note: in the above, the head predicate could also be `intended` rather than `belongs`
DEF_DP -> DP:poss DP'

# DEF_DP {?[x]:(f(x) & h(x))} -> DP {?[x]:(f(x) & x)} DP' {h(x)}
# DEF_DP {![x]:(f(x) => h(x))} -> DP {![x]:(f(x) => x)} DP' {h(x)}
# DEF_DP {?[S]:(f(S) & ![x]:(S(x) => h(x)))} -> DP {?[S]:(f(S) & ![x]:(S(x) => x))} DP' {h(x)}
# DEF_DP {?[S]:(f(S) & ?[x]:(S(x) & h(x)))} -> DP {?[S]:(f(S) & ?[x]:(S(x) & x))} DP' {h(x)}
# this depends on whether there is a predicate inside the Q, and its arguments (which argument is `x` in?) and arity
DEF_DP -> DP:poss DP'

# DEF_DP {?[x]:(f(x) & h(a,x))} -> DP {a} DP' {?[x]:(f(x) & h(y,x))}
# DEF_DP {?[x]:(f(x) & h(x,a))} -> DP {a} DP' {?[x]:(f(x) & h(x,y))}
# DEF_DP {![x]:(f(x) => h(a,x))} -> DP {a} DP' {![x]:(f(x) => h(y,x))}
# DEF_DP {![x]:(f(x) => h(x,a))} -> DP {a} DP' {![x]:(f(x) => h(x,y))}
# DEF_DP {?[x]:(f(x) & ?[y]:(g(y) & h(y,x)))} -> DP {?[y]:(g(y) & y)} DP' {?[x]:(f(x) & h(y,x))}
# DEF_DP {?[x]:(f(x) & ?[y]:(g(y) & h(x,y)))} -> DP {?[y]:(g(y) & y)} DP' {?[x]:(f(x) & h(x,y))}
# DEF_DP {![x]:(f(x) => ?[y]:(g(y) & h(y,x)))} -> DP {?[y]:(g(y) & y)} DP' {![x]:(f(x) => h(y,x))}
# DEF_DP {![x]:(f(x) => ?[y]:(g(y) & h(x,y)))} -> DP {?[y]:(g(y) & y)} DP' {![x]:(f(x) => h(x,y))}
# DEF_DP {?[x]:(f(x) & ![y]:(g(y) => h(y,x)))} -> DP {![y]:(g(y) => y)} DP' {?[x]:(f(x) & h(y,x))}
# DEF_DP {?[x]:(f(x) & ![y]:(g(y) => h(x,y)))} -> DP {![y]:(g(y) => y)} DP' {?[x]:(f(x) & h(x,y))}
# DEF_DP {![x]:(f(x) => ![y]:(g(y) => h(y,x)))} -> DP {![y]:(g(y) => y)} DP' {![x]:(f(x) => h(y,x))}
# DEF_DP {![x]:(f(x) => ![y]:(g(y) => h(x,y)))} -> DP {![y]:(g(y) => y)} DP' {![x]:(f(x) => h(x,y))}
# DEF_DP {?[S]:(f(S) & ![x]:(S(x) => h(a,x)))} -> DP {a} DP' {?[S]:(f(S) & ![x]:(S(x) => h(y,x)))}
# DEF_DP {?[S]:(f(S) & ![x]:(S(x) => h(x,y)))} -> DP {a} DP' {?[S]:(f(S) & ![x]:(S(x) => h(x,y)))}
# DEF_DP {?[S]:(f(S) & ?[x]:(S(x) & h(a,x)))} -> DP {a} DP' {?[S]:(f(S) & ?[x]:(S(x) & h(y,x)))}
# DEF_DP {?[S]:(f(S) & ?[x]:(S(x) & h(x,y)))} -> DP {a} DP' {?[S]:(f(S) & ?[x]:(S(x) & h(x,y)))}
# ...there are many more (where in the last four examples, `a` could be an existentially or universally-quantified variable, or a variable quantified over a set)
# this depends on whether there is a predicate in the head, and its arguments (which argument is `x` in?) and arity
DEF_DP -> DP:poss DP'


DP' nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# DP {?[S]:(f(S) & F(S) & ![x]:(S(x) => h(x)))} -> Q {f(S)} NP {?[S]:(F(S) & ![x]:(S(x) => h(x)))}
# this depends on whether the head predicate of the left conjunct is one that expresses information about the size of the set
DP' -> Q NP

# DEF_DP {A} -> THE NP {A}
DP' -> NP


Q nonterminal {} {1.0} {1.0} {} 10 1.0 {}
Q -> NUMBER
Q -> MUCH
Q -> MANY
Q -> MORE
Q -> MOST
Q -> FEW
Q -> FEWER
Q -> FEWEST
Q -> LESS
Q -> LEAST


# TODO: add appositives
# this noun phrase nonterminal is for right-side modifiers
NP nonterminal {} {1.0} {1.0} {} 10 1.0 {}

# NP {A} -> NP' {A}
NP -> NP'

# NP {?[x]:(f(x) & h(x))} -> NP {h(x)} PP {?[x]:(f(x) & x)}
# NP {?[X1]:(F1(X1) & ... & ?[Xn]:(Fn(Xn) & (~)![x1]:(X1(x1) => ... ![xn]:(Xn(xn) => g(h1(x1),h2(x2,...,xn))))))}
#  -> NP {?[X2]:(F2(X2) & ... & ?[Xn]:(Fn(Xn) & (~)![x2]:(X2(x2) => ... ![xn]:(Xn(xn) => g(x1,h2(x2,...,xn))))))}
#     PP {?[X1]:(F1(X1) & ![x1]:(X1(x1) => h1(x1)))}
# NP {?[X1]:(F1(X1) & ... & ?[Xn]:(Fn(Xn) & (~)?[x1]:(X1(x1) => ... ![xn]:(Xn(xn) => g(h1(x1),h2(x2,...,xn))))))}
#  -> NP {?[X2]:(F2(X2) & ... & ?[Xn]:(Fn(Xn) & (~)![x2]:(X2(x2) => ... ![xn]:(Xn(xn) => g(x1,h2(x2,...,xn))))))}
#     PP {?[X1]:(F1(X1) & ?[x1]:(X1(x1) => h1(x1)))}
#  e.g. "destruction of the barn(s)", "destruction of the barn(s) by the termites"
NP -> NP PP

# NP {?[S]:(?[T]:(F(T) & G(S,^[x]:(u(x) & v(x,T)))) & ![x]:(S(x) => h(x)))} -> NP {?[S]:(G(S,^[x]:u(x)) & ![x]:(S(x) => h(x)))} PP {?[T]:(F(T) & v(x,T))}
#  e.g. "tree(s) by all the cats"
# note: S and T could be existentially or universally-quantified individuals rather than set-valued, as well; they could also be constants
NP -> NP PP

NP -> NP REL
NP -> NP COMMA:null REL COMMA:null
NP -> NP VP:keep_present_participle
NP -> NP VP:flip_predicate_keep_past_participle

# NP {?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)![x]:(S(x) => ![y]:(x(y) => h(y))))} if xi are set-valued
# or {?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)![x]:(S(x) => h(x)))} if xi are individuals
# or {?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)?[x]:(S(x) & ?[y]:(x(y) & h(y))))} if xi are set-valued
# or {?[S]:(?[x1]:(f1(x1) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x1 | ... | x=xn))...) & (~)?[x]:(S(x) & h(x)))} if xi are individuals
#  -> NP {?[x1]:(f1(x1) & (~)h(x1))} or {?[x1]:(f1(x1) & (~)![x]:(x1(x) => h(x)))} if x1 is a set
#     COMMA
#     NP {?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)![x]:(S(x) => ![y]:(x(y) => h(y))))}
#     or {?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)![x]:(S(x) => h(x)))}
#     or {?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)?[x]:(S(x) & ?[y]:(x(y) & h(y))))}
#     or {?[S]:(?[x2]:(f2(x2) & ... & ?[xn]:(fn(xn) & S=^[x]:(x=x2 | ... | x=xn))...) & (~)?[x]:(S(x) & h(x)))}
# note: xi could also be constants, rather than existentially-quantified variables
# note: if xi is a set containing a singleton, S would look like ^[x]:(... | x=^[y]:y=singleton | ...)
NP -> NP COMMA:null NP:comma

# NP {?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => ![y]:(x(y) => h(y))))}
# or {?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)![x]:(S(x) => h(x)))}
#  -> NP {?[x1]:(f1(x1) & (~)h(x1))} or {?[x1]:(f1(x1) & (~)![x]:(x1(x) => h(x)))} if x1 is a set
#     (COMMA) AND
#     NP {?[x2]:(f2(x2) & (~)h(x2))} or {?[x2]:(f2(x2) & (~)![x]:(x2(x) => h(x)))} if x2 is a set
# note: xi could also be constants, rather than existentially-quantified variables
NP -> NP AND:null NP
NP -> NP COMMA:null AND:null NP

# NP {?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & ?[y]:(x(y) & h(y))))}
# or {?[S]:(?[x1]:(f1(x1) & ?[x2]:(f2(x2) & S=^[x]:(x=x1 | x=x2))) & (~)?[x]:(S(x) & h(x)))}
#  -> NP {?[x1]:(f1(x1) & (~)h(x1))} or {?[x1]:(f1(x1) & (~)?[x]:(x1(x) & h(x)))} if x1 is a set
#     (COMMA) AND
#     NP {?[x2]:(f2(x2) & (~)h(x2))} or {?[x2]:(f2(x2) & (~)?[x]:(x2(x) & h(x)))} if x2 is a set
# note: xi could also be constants, rather than existentially-quantified variables
NP -> NP OR:null NP
NP -> NP COMMA:null OR:null NP


# this noun phrase nonterminal is for left-side modifiers
NP' nonterminal {} {1.0} {1.0} {} 10 1.0 {}
NP' -> N
NP' -> ADJP NP'


PP nonterminal {} {1.0} {1.0} {} 10 1.0 {}
PP -> P DP
PP -> PP COMMA:null PP
PP -> PP AND PP
PP -> PP COMMA:null AND PP
PP -> PP OR PP
PP -> PP COMMA:null OR PP


ALL nonterminal {} {1.0} {1.0} {} 10 1.0 {}
ALL -> "every"
ALL -> "each"
ALL -> "all"
