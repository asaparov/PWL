#ifndef HDP_PARSER_H_
#define HDP_PARSER_H_

#include "higher_order_logic.h"
#include "array_view.h"
#include "morphology_en.h"
#include "article.h"
#include "built_in_predicates.h"
#include "console.h"
#include <grammar/parser.h>
#include <grammar/hdp_grammar_io.h>

thread_local hol_term HOL_ZERO(hol_term_type::CONSTANT, (unsigned int) built_in_predicates::ZERO);
thread_local hol_term HOL_EMPTY(hol_term_type::CONSTANT, (unsigned int) built_in_predicates::EMPTY);
thread_local hol_term HOL_UNKNOWN(hol_term_type::CONSTANT, (unsigned int) built_in_predicates::UNKNOWN);
thread_local hol_term HOL_GAP(hol_term_type::CONSTANT, (unsigned int) built_in_predicates::GAP);
thread_local hol_term HOL_NAME(hol_term_type::CONSTANT, (unsigned int) built_in_predicates::NAME);
thread_local hol_term HOL_EXIST(hol_term_type::CONSTANT, (unsigned int) built_in_predicates::EXIST);
thread_local hol_term HOL_SAME(hol_term_type::CONSTANT, (unsigned int) built_in_predicates::SAME);

enum class grammatical_conjunction : uint_fast8_t {
	NONE = 0,
	THAT,
	IF,
	WHETHER,
	BECAUSE,
	FOR,
	ANY
};

constexpr unsigned int auxiliary_flag_count = 5;
enum class auxiliary_flag : uint_fast8_t {
	NONE = (1 << 0),
	REQ_AUX = (1 << 1),
	REQ_NO_AUX = (1 << 2),
	AUX = (1 << 3),
	REQ_SUBJECT = (1 << 4),

	ANY = (1 << auxiliary_flag_count) - 1
};

static constexpr auxiliary_flag operator ~(auxiliary_flag flag) {
	return (auxiliary_flag) ((uint_fast8_t) auxiliary_flag::ANY & ~((uint_fast8_t) flag));
}

static constexpr auxiliary_flag operator | (auxiliary_flag first, auxiliary_flag second) {
	return (auxiliary_flag) ((uint_fast8_t) first | (uint_fast8_t) second);
}

enum class grammatical_flag : uint_fast16_t {
	IS_ADJUNCT,
	NULLABLE_SUBJECT,
	SUBORDINATE,
	PREPOSITION,
	PARTICLE,
	NEGATIVE,
	ADV,
	TION,
	LY,
	GENITIVE,
	COMMA,
	WH_MINUS,
	HAS_ARG2,
	MODIFIES_EVENT,
	MEASURE,
	EMPTY_VERB,
	PASSIVE,
	BE,
	COUNT
};

enum class grammatical_flag_value : uint_fast8_t {
	FALSE = 0,
	TRUE,
	ANY
};

enum class correlator : uint_fast8_t {
	NONE = 0,
	BOTH,
	EITHER,
	NEITHER,
	ANY
};

enum class coordination : uint_fast8_t {
	NONE = 0,
	AND,
	OR,
	NOR,

	ANY,
	NOT_NONE
};

template<typename Stream>
static inline bool print_comma(bool& first, Stream& out) {
	if (first) {
		first = false;
		return true;
	} else {
		return print(',', out);
	}
}

template<typename Stream>
static inline bool print_feature(const char* feature_name, bool& first, grammatical_num number, Stream& out) {
	switch (number) {
	case grammatical_num::SINGULAR:
		return print_comma(first, out) && core::print(feature_name, out) && core::print(":sg", out);
	case grammatical_num::PLURAL:
		return print_comma(first, out) && core::print(feature_name, out) && core::print(":pl", out);
	case grammatical_num::SINGULAR_OR_NONE:
		return print_comma(first, out) && core::print(feature_name, out) && core::print(":sg?", out);
	case grammatical_num::PLURAL_OR_NONE:
		return print_comma(first, out) && core::print(feature_name, out) && core::print(":pl?", out);
	case grammatical_num::ANY:
		return print_comma(first, out) && core::print(feature_name, out) && core::print(":*", out);
	case grammatical_num::NONE:
		return true;
	}
	fprintf(stderr, "print_feature ERROR: Unrecognized grammatical_num.\n");
	return false;
}

template<typename Stream>
static inline bool print_feature(bool& first, grammatical_comparison comp, Stream& out) {
	switch (comp) {
	case grammatical_comparison::COMPARATIVE:
		return print_comma(first, out) && core::print("comp", out);
	case grammatical_comparison::SUPERLATIVE:
		return print_comma(first, out) && core::print("sup", out);
	case grammatical_comparison::ANY:
		return print_comma(first, out) && core::print("{comp,sup}", out);
	case grammatical_comparison::NONE:
		return true;
	}
	fprintf(stderr, "print_feature ERROR: Unrecognized grammatical_comparison.\n");
	return false;
}

template<typename Stream>
static inline bool print_feature(bool& first, grammatical_conjunction number, Stream& out) {
	switch (number) {
	case grammatical_conjunction::THAT:
		return print_comma(first, out) && core::print("cnj:that", out);
	case grammatical_conjunction::IF:
		return print_comma(first, out) && core::print("cnj:if", out);
	case grammatical_conjunction::WHETHER:
		return print_comma(first, out) && core::print("cnj:whether", out);
	case grammatical_conjunction::BECAUSE:
		return print_comma(first, out) && core::print("cnj:because", out);
	case grammatical_conjunction::FOR:
		return print_comma(first, out) && core::print("cnj:for", out);
	case grammatical_conjunction::ANY:
		return print_comma(first, out) && core::print("cnj:*", out);
	case grammatical_conjunction::NONE:
		return true;
	}
	fprintf(stderr, "print_feature ERROR: Unrecognized grammatical_conjunction.\n");
	return false;
}

template<typename Stream>
static inline bool print_feature(bool& first, auxiliary_flag aux, Stream& out) {
	if ((uint_fast8_t) aux == 0)
		return false;
	else if (aux == auxiliary_flag::NONE)
		return true;

	if (!print_comma(first, out))
		return false;

	auxiliary_flag flags[auxiliary_flag_count];
	unsigned int flag_count = 0;
	for (unsigned int i = 1; i < auxiliary_flag_count; i++)
		if (((1 << i) & (uint_fast8_t) aux) != 0) flags[flag_count++] = (auxiliary_flag) (1 << i);

	if (flag_count > 1 && !print('{', out)) return false;
	for (unsigned int i = 0; i < flag_count; i++) {
		if (i > 0 && !print(',', out)) return false;
		switch (flags[i]) {
		case auxiliary_flag::REQ_AUX:
			if (!print("req_aux", out)) return false;
			break;
		case auxiliary_flag::REQ_NO_AUX:
			if (!print("req_no_aux", out)) return false;
			break;
		case auxiliary_flag::AUX:
			if (!print("aux", out)) return false;
			break;
		case auxiliary_flag::REQ_SUBJECT:
			if (!print("req_subject", out)) return false;
			break;
		case auxiliary_flag::NONE:
		case auxiliary_flag::ANY:
			fprintf(stderr, "print_feature ERROR: This should be unreachable.\n");
			return false;
		}
	}
	if (flag_count > 1 && !print('}', out)) return false;

	return true;
}

template<typename Stream>
static inline bool print_feature(bool& first, grammatical_mood inf, Stream& out) {
	switch (inf) {
	case grammatical_mood::INDICATIVE:
		return true;
	case grammatical_mood::PAST_PARTICIPLE:
		return print_comma(first, out) && core::print("past_ptc", out);
	case grammatical_mood::PRESENT_PARTICIPLE:
		return print_comma(first, out) && core::print("pres_ptc", out);
	case grammatical_mood::SUBJUNCTIVE:
		return print_comma(first, out) && core::print("subjunctive", out);
	case grammatical_mood::BARE_INFINITIVE:
		return print_comma(first, out) && core::print("bare_inf", out);
	case grammatical_mood::TO_INFINITIVE:
		return print_comma(first, out) && core::print("to_inf", out);
	case grammatical_mood::ANY:
		return print_comma(first, out) && core::print("mood:*", out);
	case grammatical_mood::NOT_TO_INFINITIVE:
		return print_comma(first, out) && core::print("~to_inf", out);
	case grammatical_mood::NOT_SUBJUNCTIVE:
		return print_comma(first, out) && core::print("~subjunctive", out);
	case grammatical_mood::NOT_TO_INF_OR_SUBJ:
		return print_comma(first, out) && core::print("~{to_inf,subj}", out);
	}
	fprintf(stderr, "print_feature ERROR: Unrecognized grammatical_mood.\n");
	return false;
}

template<typename Stream>
static inline bool print_feature_name(grammatical_flag flag, Stream& out) {
	switch (flag) {
	case grammatical_flag::IS_ADJUNCT:
		return core::print("adj", out);
	case grammatical_flag::NULLABLE_SUBJECT:
		return core::print("nullable_subj", out);
	case grammatical_flag::SUBORDINATE:
		return core::print("subord", out);
	case grammatical_flag::PREPOSITION:
		return core::print("prep", out);
	case grammatical_flag::PARTICLE:
		return core::print("particle", out);
	case grammatical_flag::NEGATIVE:
		return core::print("negative", out);
	case grammatical_flag::ADV:
		return core::print("adv", out);
	case grammatical_flag::TION:
		return core::print("tion", out);
	case grammatical_flag::LY:
		return core::print("ly", out);
	case grammatical_flag::GENITIVE:
		return core::print("gen", out);
	case grammatical_flag::COMMA:
		return core::print("comma", out);
	case grammatical_flag::WH_MINUS:
		return core::print("wh-", out);
	case grammatical_flag::HAS_ARG2:
		return core::print("arg2", out);
	case grammatical_flag::MODIFIES_EVENT:
		return core::print("modifies_event", out);
	case grammatical_flag::MEASURE:
		return core::print("measure", out);
	case grammatical_flag::EMPTY_VERB:
		return core::print("empty_verb", out);
	case grammatical_flag::PASSIVE:
		return core::print("passive", out);
	case grammatical_flag::BE:
		return core::print("be", out);
	case grammatical_flag::COUNT: break;
	}
	fprintf(stderr, "print_feature_name ERROR: Unrecognized grammatical_flag.\n");
	return false;
}

template<typename Stream>
static inline bool print_feature(bool& first, grammatical_flag flag, grammatical_flag_value value, Stream& out) {
	switch (value) {
	case grammatical_flag_value::TRUE:
		return print_comma(first, out) && print_feature_name(flag, out);
	case grammatical_flag_value::ANY:
		return print_comma(first, out) && print_feature_name(flag, out) && print('*', out);
	case grammatical_flag_value::FALSE:
		return true;
	}
	fprintf(stderr, "print_feature ERROR: Unrecognized grammatical_flag_value.\n");
	return false;
}

template<typename Stream>
static inline bool print_feature(const char* prefix, bool& first, correlator corr, Stream& out) {
	switch (corr) {
	case correlator::BOTH:
		return print_comma(first, out) && core::print(prefix, out) && core::print(":both", out);
	case correlator::EITHER:
		return print_comma(first, out) && core::print(prefix, out) && core::print(":either", out);
	case correlator::NEITHER:
		return print_comma(first, out) && core::print(prefix, out) && core::print(":neither", out);
	case correlator::ANY:
		return print_comma(first, out) && core::print(prefix, out) && core::print(":*", out);
	case correlator::NONE:
		return true;
	}
	fprintf(stderr, "print_feature ERROR: Unrecognized correlator.\n");
	return false;
}

template<typename Stream>
static inline bool print_feature(const char* prefix, bool& first, coordination coord, Stream& out) {
	switch (coord) {
	case coordination::AND:
		return print_comma(first, out) && core::print(prefix, out) && core::print(":and", out);
	case coordination::OR:
		return print_comma(first, out) && core::print(prefix, out) && core::print(":or", out);
	case coordination::NOR:
		return print_comma(first, out) && core::print(prefix, out) && core::print(":nor", out);
	case coordination::ANY:
		return print_comma(first, out) && core::print(prefix, out) && core::print(":*", out);
	case coordination::NOT_NONE:
		return print_comma(first, out) && core::print(prefix, out) && core::print(":~none", out);
	case coordination::NONE:
		return true;
	}
	fprintf(stderr, "print_feature ERROR: Unrecognized coordination.\n");
	return false;
}

template<typename GrammaticalFlagType>
static inline bool intersect(GrammaticalFlagType& out, GrammaticalFlagType first, GrammaticalFlagType second)
{
	if (first == GrammaticalFlagType::ANY) {
		out = second;
		return true;
	} else if (second == GrammaticalFlagType::ANY) {
		out = first;
		return true;
	} else if (first != second) {
		return false;
	} else {
		out = first;
		return true;
	}
}

template<typename GrammaticalFlagType>
static inline bool has_intersection(GrammaticalFlagType first, GrammaticalFlagType second)
{
	GrammaticalFlagType dummy;
	return intersect(dummy, first, second);
}

static inline bool intersect(coordination& out, coordination first, coordination second)
{
	if (first == coordination::ANY) {
		out = second;
		return true;
	} else if (second == coordination::ANY) {
		out = first;
		return true;
	} else if (first == coordination::NOT_NONE) {
		if (second == coordination::NONE) {
			return false;
		} else {
			out = second;
			return true;
		}
	} else if (second == coordination::NOT_NONE) {
		if (first == coordination::NONE) {
			return false;
		} else {
			out = first;
			return true;
		}
	} else if (first == second) {
		out = first;
		return true;
	} else {
		return false;
	}
}

static inline bool intersect(auxiliary_flag& out, auxiliary_flag first, auxiliary_flag second)
{
	uint_fast8_t result = (uint_fast8_t) auxiliary_flag::ANY & ((uint_fast8_t) first & (uint_fast8_t) second);
	if (result == 0) return false;
	out = (auxiliary_flag) result;
	return true;
}

struct grammatical_flags {
	grammatical_num index_number;
	grammatical_num concord_number;
	grammatical_comparison comp;
	grammatical_conjunction cnj;
	grammatical_flag_value flags[(uint_fast8_t) grammatical_flag::COUNT] = { grammatical_flag_value::FALSE };
	correlator corr;
	correlator correlated_by;
	coordination coord;
	auxiliary_flag aux;
	grammatical_mood mood;
	bool aux_or_subjunctive_or_inf_or_to_inf;
	bool is_first_token_capital;

	grammatical_flags() :
			index_number(grammatical_num::NONE), concord_number(grammatical_num::NONE),
			comp(grammatical_comparison::NONE), cnj(grammatical_conjunction::NONE),
			corr(correlator::NONE), correlated_by(correlator::NONE), coord(coordination::NONE),
			aux(auxiliary_flag::NONE), mood(grammatical_mood::INDICATIVE),
			aux_or_subjunctive_or_inf_or_to_inf(false), is_first_token_capital(false) { }

	grammatical_flags(const grammatical_flags& src) {
		init(src);
	}

	inline void operator = (const grammatical_flags& src) {
		init(src);
	}

	static inline unsigned int hash(const grammatical_flags& key) {
		return default_hash(key.index_number)
			 ^ (3 * default_hash(key.concord_number))
			 ^ (7 * default_hash(key.comp))
			 ^ (31 * default_hash(key.cnj))
			 ^ (53 * default_hash(key.corr))
			 ^ (97 * default_hash(key.correlated_by))
			 ^ (193 * default_hash(key.coord))
			 ^ (389 * default_hash(key.flags, (uint_fast8_t) grammatical_flag::COUNT))
			 ^ (769 * default_hash(key.aux))
			 ^ (1543 * default_hash(key.mood))
			 ^ (3079 * default_hash(key.aux_or_subjunctive_or_inf_or_to_inf))
			 ^ (6151 * default_hash(key.is_first_token_capital));
	}

	static inline void swap(grammatical_flags& first, grammatical_flags& second) {
		core::swap(first.index_number, second.index_number);
		core::swap(first.concord_number, second.concord_number);
		core::swap(first.comp, second.comp);
		core::swap(first.cnj, second.cnj);
		core::swap(first.corr, second.corr);
		core::swap(first.correlated_by, second.correlated_by);
		core::swap(first.coord, second.coord);
		core::swap(first.aux, second.aux);
		core::swap(first.mood, second.mood);
		core::swap(first.aux_or_subjunctive_or_inf_or_to_inf, second.aux_or_subjunctive_or_inf_or_to_inf);
		core::swap(first.is_first_token_capital, second.is_first_token_capital);
		for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
			core::swap(first.flags[i], second.flags[i]);
	}

	inline bool intersect_aux_or_subjunctive_or_inf_or_to_inf(bool first, bool second) {
		if (first && second) {
			if (aux == auxiliary_flag::AUX || mood == grammatical_mood::SUBJUNCTIVE || mood == grammatical_mood::BARE_INFINITIVE || mood == grammatical_mood::TO_INFINITIVE)
				aux_or_subjunctive_or_inf_or_to_inf = false;
			if (!has_intersection(aux, auxiliary_flag::AUX) && !has_intersection(mood, grammatical_mood::SUBJUNCTIVE)
			 && !has_intersection(mood, grammatical_mood::BARE_INFINITIVE) && !has_intersection(mood, grammatical_mood::TO_INFINITIVE))
				return false;
			aux_or_subjunctive_or_inf_or_to_inf = true;
		} else {
			aux_or_subjunctive_or_inf_or_to_inf = false;
		}
		return true;
	}

private:
	inline void init(const grammatical_flags& src) {
		index_number = src.index_number;
		concord_number = src.concord_number;
		comp = src.comp;
		cnj = src.cnj;
		for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
			flags[i] = src.flags[i];
		corr = src.corr;
		correlated_by = src.correlated_by;
		coord = src.coord;
		aux = src.aux;
		mood = src.mood;
		aux_or_subjunctive_or_inf_or_to_inf = src.aux_or_subjunctive_or_inf_or_to_inf;
		is_first_token_capital = src.is_first_token_capital;
	}
};

inline bool intersect(grammatical_flags& dst,
		const grammatical_flags& first,
		const grammatical_flags& second)
{
	if (!intersect(dst.index_number, first.index_number, second.index_number)
	 || !intersect(dst.concord_number, first.concord_number, second.concord_number)
	 || !intersect(dst.comp, first.comp, second.comp)
	 || !intersect(dst.cnj, first.cnj, second.cnj)
	 || !intersect(dst.corr, first.corr, second.corr)
	 || !intersect(dst.correlated_by, first.correlated_by, second.correlated_by)
	 || !intersect(dst.coord, first.coord, second.coord)
	 || !intersect(dst.aux, first.aux, second.aux)
	 || !intersect(dst.mood, first.mood, second.mood))
		return false;
	dst.is_first_token_capital = (first.is_first_token_capital || second.is_first_token_capital);
	for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
		if (!intersect(dst.flags[i], first.flags[i], second.flags[i])) return false;
	return dst.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.aux_or_subjunctive_or_inf_or_to_inf, second.aux_or_subjunctive_or_inf_or_to_inf);
}

template<typename K, typename V>
struct static_pair {
	K key;
	V value;
};

template<typename Formula>
struct flagged_logical_form
{
	grammatical_flags flags;
	Formula* root;

	flagged_logical_form() { }

	flagged_logical_form(Formula& src) : root(&src) {
		src.reference_count++;
	}

	flagged_logical_form(const flagged_logical_form<Formula>& src) : flags(src.flags), root(src.root) {
		src.root->reference_count++;
	}

	~flagged_logical_form() { free_helper(); }

	inline void operator = (const flagged_logical_form<Formula>& src) {
		flags = src.flags;
		root = src.root;
		root->reference_count++;
	}

	static inline bool is_empty(const flagged_logical_form<Formula>& src) {
		return src.root == nullptr;
	}

	static inline unsigned int hash(const flagged_logical_form<Formula>& src) {
		return hasher<Formula>::hash(*src.root) ^ grammatical_flags::hash(src.flags);
	}

	static inline void move(
			const flagged_logical_form<Formula>& src,
			flagged_logical_form<Formula>& dst)
	{
		dst.root = src.root;
		dst.flags = src.flags;
	}

	static inline void swap(
			flagged_logical_form<Formula>& first,
			flagged_logical_form<Formula>& second)
	{
		core::swap(first.root, second.root);
		core::swap(first.flags, second.flags);
	}

	static inline void free(flagged_logical_form<Formula>& lf) {
		lf.free_helper();
	}

	inline void recompute_hash() { }

	enum class feature {
		EMPTY = 0,
		CONSTANT,
		PREDICATE,
		PREDICATE_ONLY,
		HEAD_PREDICATE,
		UNAMBIGUOUS_PREDICATE_ONLY,
		SET_DEFINITION,
		SET_PREDICATE,
		LEFT_ARG,
		HAS_ARG2,
		MODIFIES_EVENT,
		MEASURE
	};

	enum class function_type {
		EMPTY = 0,
		IDENTITY,
		IDENTITY_PREDICATIVE,
		IDENTITY_ROOT,
		SELECT_RIGHT_CONJUNCT,
		REMOVE_RIGHT_CONJUNCT,
		SELECT_LEFT_CONJUNCT,
		SELECT_LEFT_CONJUNCT_AND_NEGATION,
		REMOVE_LEFT_CONJUNCT,
		REMOVE_LEFT_CONJUNCT_AND_NEGATION,
		REMOVE_SECOND_LEFT_CONJUNCT,
		SELECT_LEFT_CONJUNCT_IN_SET,
		REMOVE_LEFT_CONJUNCT_IN_SET,
		SELECT_SECOND_LEFT_CONJUNCT_IN_SET,
		SELECT_RIGHT_CONJUNCT_IN_SET,
		REMOVE_RIGHT_CONJUNCT_IN_SET,
		REMOVE_RIGHT_CONJUNCT_IN_SET_WITHOUT_PREDICATIVE,
		SELECT_RIGHT_SUBSET_IN_SET,
		SELECT_ONLY_RIGHT_CONJUNCT_IN_SET_PREDICATIVE,
		REQUIRE_NO_INVERSE,
		REQUIRE_LEFT_PREDICATE_SAME,
		REQUIRE_NO_PREDICATE_SAME,
		REQUIRE_LEFT_PREDICATE_INVERSE,
		REQUIRE_LEFT_PREDICATE_INVERSE_HAS,
		REQUIRE_LEFT_PREDICATE_EXIST,
		REQUIRE_LEFT_GREATEST,
		REQUIRE_NO_LEFT_PREDICATE_EXIST,
		REQUIRE_RIGHT_PREDICATE_IN_SET,
		REMOVE_INVERSE,
		REMOVE_GREATEST,
		REMOVE_RIGHT_TRACE,
		SELECT_RIGHT_ARG1_WITHOUT_HEAD,
		SELECT_RIGHT_ARG2_WITHOUT_HEAD,
		SELECT_RIGHT_ARG3_WITHOUT_HEAD,
		SELECT_RIGHT_ARG1_OF_WITHOUT_HEAD,
		SELECT_RIGHT_ARG2_OF_WITHOUT_HEAD,
		SELECT_RIGHT_ARG3_OF_WITHOUT_HEAD,
		SELECT_RIGHT_ARG1_WITHOUT_HEAD_PREDICATIVE,
		SELECT_RIGHT_ARG2_WITHOUT_HEAD_PREDICATIVE,
		SELECT_RIGHT_ARG3_WITHOUT_HEAD_PREDICATIVE,
		SELECT_RIGHT_SET_ARG1_WITHOUT_HEAD_PREDICATIVE,
		SELECT_RIGHT_SET_ARG2_WITHOUT_HEAD_PREDICATIVE,
		SELECT_RIGHT_SET_ARG3_WITHOUT_HEAD_PREDICATIVE,
		SELECT_SINGLETON_ARG1_IN_SET_WITHOUT_HEAD_PREDICATIVE,
		SELECT_SINGLETON_ARG2_IN_SET_WITHOUT_HEAD_PREDICATIVE,
		SELECT_SINGLETON_ARG3_IN_SET_WITHOUT_HEAD_PREDICATIVE,
		SELECT_SINGLETON_ARG1_OF_IN_SET_WITHOUT_HEAD_PREDICATIVE,
		SELECT_SINGLETON_ARG2_OF_IN_SET_WITHOUT_HEAD_PREDICATIVE,
		SELECT_SINGLETON_ARG3_OF_IN_SET_WITHOUT_HEAD_PREDICATIVE,
		SELECT_SINGLETON_ARG1_IN_SET_WITHOUT_HEAD_OUTER_SCOPE_PREDICATIVE,
		SELECT_SINGLETON_ARG2_IN_SET_WITHOUT_HEAD_OUTER_SCOPE_PREDICATIVE,
		SELECT_SINGLETON_ARG3_IN_SET_WITHOUT_HEAD_OUTER_SCOPE_PREDICATIVE,
		SELECT_SINGLETON_ARG1_OF_IN_SET_WITHOUT_HEAD_OUTER_SCOPE_PREDICATIVE,
		SELECT_SINGLETON_ARG2_OF_IN_SET_WITHOUT_HEAD_OUTER_SCOPE_PREDICATIVE,
		SELECT_SINGLETON_ARG3_OF_IN_SET_WITHOUT_HEAD_OUTER_SCOPE_PREDICATIVE,
		REQUIRE_PAST,
		REMOVE_FUTURE,
		REQUIRE_NO_FUTURE,
		REMOVE_PERFECT,
		REQUIRE_NO_PERFECT,
		REMOVE_PROGRESSIVE,
		REMOVE_PRESENT_PROGRESSIVE,
		REMOVE_PAST_PROGRESSIVE,
		REQUIRE_NO_PROGRESSIVE,
		REMOVE_ASPECT,
		TRY_REMOVE_ASPECT,
		REMOVE_NOT,
		REQUIRE_NO_EMPTY_REF,
		PREDICATE_ONLY,
		PREDICATE,
		PREDICATE_AND_TENSE,
		EMPTY_AND_TENSE,
		REQUIRE_PREDICATIVE_UNIVERSAL,
		REQUIRE_PREDICATIVE_EXISTENTIAL,
		REPLACE_PREDICATIVE_LAMBDA_WITH_EXISTENTIAL,
		REPLACE_PREDICATIVE_UNIVERSAL_WITH_EXISTENTIAL,
		REMOVE_PREDICATIVE_NOT,
		SELECT_PREDICATE_IN_SET,
		SELECT_CONSTANT_IN_SET,
		SELECT_STRING_IN_SET,
		SELECT_NAME_IN_SET,
		SELECT_NUMBER_IN_SET,
		MARK_WIDE_SCOPE,
		REQUIRE_WIDE_SCOPE,
		REMOVE_WIDE_SCOPE,
		REQUIRE_NARROW_SCOPE,
		REQUIRE_CONSTANT_IN_SET,
		REQUIRE_NO_CONSTANT_IN_SET,
		REQUIRE_STRING_OR_NUMBER_IN_SET,
		REQUIRE_NAME_IN_SET,
		REQUIRE_MEASURE_IN_SET,
		REQUIRE_SINGLETON,
		REQUIRE_NO_STRING_OR_NUMBER_OR_NAME_IN_SET,
		SELECT_SECOND_LEFT_SET_CONJUNCT,
		SELECT_SECOND_LEFT_SET_CONJUNCT_ROOT,
		REMOVE_SECOND_LEFT_SET_CONJUNCT,
		SIZE,
		RIGHT_ARG1,
		SET_SIZE,
		REQUIRE_LEFT_ARG1,
		REQUIRE_LAMBDA,
		REQUIRE_NO_LAMBDA,
		REMOVE_LEFT_PREDICATE,
		FACTOR,
		FACTOR_PREDICATIVE,
		SELECT_LEFT_PREDICATE_AND_TENSE,
		SET_PREDICATE_EMPTY,
		SET_LEFT_PREDICATE_EMPTY,
		REQUIRE_NO_PREDICATE_EMPTY,
		REQUIRE_CONJUNCTION,
		REQUIRE_BINARY_CONJUNCTION,
		REQUIRE_DISJUNCTION,
		REQUIRE_NEGATIVE_CONJUNCTION,
		REQUIRE_HEAD_CONJUNCTION,
		REQUIRE_HEAD_BINARY_CONJUNCTION,
		REQUIRE_HEAD_DISJUNCTION,
		REQUIRE_HEAD_NEGATIVE_CONJUNCTION,
		REQUIRE_NO_HEAD_ARRAY,
		SELECT_LEFT_OPERAND,
		REMOVE_LEFT_OPERAND,
		SELECT_LEFT_HEAD_OPERAND,
		REMOVE_LEFT_HEAD_OPERAND,
		REPLACE_PREDICATIVE_SUBSET_WITH_EQUALITY,
		REQUIRE_PREDICATE_OF_LAMBDA,
		SELECT_LAMBDA,
		REMOVE_LAMBDA,
		SELECT_FUNCTION_WITH_SUBSTITUTION,
		SELECT_FUNCTION_WITH_EMPTY_SUBSTITUTION,
		SELECT_FUNCTION_WITHOUT_SUBSTITUTION,
		SELECT_ANTECEDENT,
		SELECT_CONSEQUENT,
		REQUIRE_REF_IN_SET,
		REQUIRE_PLURAL_REF_IN_SET,
		REQUIRE_ANIMATE_IN_SET,
		REQUIRE_ONE_OR_TWO_CONJUNCTS,

		/* functions on strings */
		REQUIRE_CAPITALIZED,

		/* functions that modify grammatical features */
		ADD_SINGULAR,
		ADD_PLURAL,
		TRY_ADD_SINGULAR,
		TRY_ADD_PLURAL,
		REQUIRE_SINGULAR,
		REQUIRE_PLURAL,
		TRY_REMOVE_NUMBER,
		ADD_CONCORD_SINGULAR,
		ADD_CONCORD_PLURAL,
		ADD_THAT,
		REMOVE_THAT,
		REQUIRE_NO_THAT,
		ADD_WHETHER,
		REMOVE_WHETHER,
		ADD_IF,
		REMOVE_IF,
		ADD_BECAUSE,
		REMOVE_BECAUSE,
		ADD_FOR,
		REMOVE_FOR,
		REQUIRE_NO_CONJUNCTION,
		ADD_IS_ADJUNCT,
		TRY_REMOVE_IS_ADJUNCT,
		REQUIRE_NOT_ADJUNCT,
		ADD_NULLABLE_SUBJECT,
		REMOVE_NULLABLE_SUBJECT,
		TRY_REMOVE_NULLABLE_SUBJECT,
		ADD_SUBORDINATE,
		REMOVE_SUBORDINATE,
		TRY_REMOVE_SUBORDINATE,
		REQUIRE_NO_SUBORDINATE,
		ADD_PREPOSITION,
		REQUIRE_PREPOSITION,
		REQUIRE_NO_PREPOSITION,
		ADD_PARTICLE,
		ADD_AUX,
		TRY_REMOVE_AUX,
		ADD_REQ_AUX,
		TRY_ADD_REQ_AUX,
		REQUIRE_NO_REQ_AUX,
		REMOVE_REQ_AUX,
		TRY_REMOVE_REQ_AUX,
		ADD_REQ_NO_AUX,
		REQUIRE_NO_REQ_NO_AUX,
		REQUIRE_NO_REQ_SUBJECT,
		REMOVE_REQ_SUBJECT,
		TRY_REMOVE_REQ_SUBJECT,
		ADD_INFINITIVE,
		ADD_TO_INFINITIVE,
		REMOVE_TO_INFINITIVE,
		REQUIRE_TO_INFINITIVE,
		REQUIRE_NO_TO_INFINITIVE,
		ADD_SUBJUNCTIVE,
		REQUIRE_NO_SUBJUNCTIVE,
		REQUIRE_AUX_OR_SUBJUNCTIVE_OR_INFINITIVE_OR_TO_INFINITIVE,
		ADD_BOTH,
		ADD_EITHER,
		ADD_NEITHER,
		REMOVE_BOTH,
		REMOVE_EITHER,
		REMOVE_NEITHER,
		TRY_REMOVE_CORRELATOR,
		REQUIRE_NO_CORRELATOR,
		REQUIRE_NO_CORRELATOR_PREDICATIVE,
		ADD_CORRELATED_BY_BOTH,
		ADD_CORRELATED_BY_EITHER,
		ADD_CORRELATED_BY_NEITHER,
		TRY_REMOVE_CORRELATED,
		REQUIRE_NOT_CORRELATED,
		ADD_PAST_PARTICIPLE,
		ADD_PRESENT_PARTICIPLE,
		TRY_REMOVE_PARTICIPLE,
		REQUIRE_PAST_PARTICIPLE,
		REQUIRE_PRESENT_PARTICIPLE,
		ADD_NEGATIVE,
		ADD_NEGATIVE_PREDICATIVE,
		REQUIRE_NEGATIVE,
		ADD_ADV,
		REMOVE_ADV,
		TRY_REMOVE_ADV,
		REQUIRE_NO_ADV,
		ADD_TION,
		ADD_LY,
		ADD_GENITIVE,
		TRY_REMOVE_GENITIVE,
		REQUIRE_NO_GENITIVE,
		ADD_COMMA,
		REMOVE_COMMA,
		REQUIRE_NO_COMMA,
		ADD_WH_MINUS,
		REMOVE_WH_MINUS,
		TRY_REMOVE_WH_MINUS,
		REQUIRE_NO_WH_MINUS,
		HAS_ARG2,
		TRY_HAS_ARG2,
		HAS_ARG2_IN_SET,
		TRY_HAS_ARG2_IN_SET,
		TRY_ADD_HAS_ARG2,
		ADD_MODIFIES_EVENT,
		TRY_REMOVE_MODIFIES_EVENT,
		ADD_MEASURE,
		TRY_REMOVE_MEASURE,
		REQUIRE_NO_MEASURE,
		ADD_EMPTY_VERB,
		TRY_REMOVE_EMPTY_VERB,
		REMOVE_EMPTY_VERB,
		REQUIRE_NO_EMPTY_VERB,
		ADD_PASSIVE,
		REMOVE_PASSIVE,
		REQUIRE_NO_PASSIVE,
		ADD_BE,
		REMOVE_BE,
		TRY_REMOVE_BE,
		REQUIRE_NO_BE,
		ADD_AND,
		ADD_OR,
		ADD_NOR,
		REMOVE_AND,
		REMOVE_OR,
		REMOVE_NOR,
		REMOVE_COORD,
		ADD_COMPARATIVE,
		ADD_SUPERLATIVE,
		REQUIRE_SUPERLATIVE,
		REQUIRE_NO_SUPERLATIVE
	};

	static const static_pair<feature, const char*> FEATURE_NAMES[];
	static const static_pair<function_type, const char*> FUNCTION_NAMES[];

	struct function {
		function_type type;

		constexpr function(const function_type& type) : type(type) { }

		static inline unsigned int hash(const function& f) {
			return default_hash(f.type);
		}

		static inline bool is_empty(const function& f) {
			return f.type == function_type::EMPTY;
		}

		static inline void set_empty(function& f) {
			f.type = function_type::EMPTY;
		}

		inline bool operator == (const function& other) const {
			return type == other.type;
		}

		inline bool operator != (const function& other) const {
			return type != other.type;
		}

		inline bool operator < (const function& other) const {
			return type < other.type;
		}
	};

	template<typename Stream>
	static bool print(const feature& f, Stream& out) {
		for (unsigned int i = 0; i < array_length(FEATURE_NAMES); i++) {
			if (FEATURE_NAMES[i].key == f)
				return core::print(FEATURE_NAMES[i].value, out);
		}
		fprintf(stderr, "flagged_logical_form.print ERROR: Unrecognized semantic feature.\n");
		return false;
	}

	static bool interpret(feature& f, const string& name) {
		for (unsigned int i = 0; i < array_length(FEATURE_NAMES); i++) {
			if (name == FEATURE_NAMES[i].value) {
				f = FEATURE_NAMES[i].key;
				return true;
			}
		}
		core::print("flagged_logical_form.parse ERROR: Unrecognized semantic feature name '", stderr);
		core::print(name, stderr); core::print("'.\n", stderr);
		return false;
	}

	template<typename Stream>
	static bool print(const function& f, Stream& out) {
		for (unsigned int i = 0; i < array_length(FUNCTION_NAMES); i++) {
			if (FUNCTION_NAMES[i].key == f.type)
				return core::print(FUNCTION_NAMES[i].value, out);
		}
		fprintf(stderr, "flagged_logical_form.print ERROR: Unrecognized semantic transformation function.\n");
		return false;
	}

	static bool interpret(function& f, const string& name) {
		for (unsigned int i = 0; i < array_length(FUNCTION_NAMES); i++) {
			if (name == FUNCTION_NAMES[i].value) {
				f = FUNCTION_NAMES[i].key;
				return true;
			}
		}
		core::print("flagged_logical_form.interpret ERROR: Unrecognized semantic transformation function name '", stderr);
		core::print(name, stderr); core::print("'.\n", stderr);
		return false;
	}

	static bool is_feature_pruneable(feature f)
	{
		switch (f) {
		case feature::CONSTANT:
		case feature::PREDICATE:
		case feature::PREDICATE_ONLY:
		case feature::HEAD_PREDICATE:
		case feature::UNAMBIGUOUS_PREDICATE_ONLY:
		case feature::SET_DEFINITION:
		case feature::SET_PREDICATE:
		case feature::LEFT_ARG:
		case feature::HAS_ARG2:
		case feature::MODIFIES_EVENT:
		case feature::MEASURE:
			return true;
		case feature::EMPTY: break;
		}
		fprintf(stderr, "flagged_logical_form.is_feature_pruneable ERROR: Unrecognized semantic feature.\n");
		exit(EXIT_FAILURE);
	}

	static constexpr function default_function() {
		return function(function_type::EMPTY);
	}

private:
	inline void free_helper() {
		core::free(*root);
		if (root->reference_count == 0)
			core::free(root);
	}
};

template<typename Formula>
const static_pair<typename flagged_logical_form<Formula>::feature, const char*> flagged_logical_form<Formula>::FEATURE_NAMES[] = {
	{feature::EMPTY, "empty"},
	{feature::CONSTANT, "constant"},
	{feature::PREDICATE, "predicate"},
	{feature::PREDICATE_ONLY, "predicate_only"},
	{feature::HEAD_PREDICATE, "head_predicate"},
	{feature::UNAMBIGUOUS_PREDICATE_ONLY, "unambiguous_predicate_only"},
	{feature::SET_DEFINITION, "set_definition"},
	{feature::SET_PREDICATE, "set_predicate"},
	{feature::LEFT_ARG, "left_arg"},
	{feature::HAS_ARG2, "has_arg2"},
	{feature::MODIFIES_EVENT, "modifies_event"},
	{feature::MEASURE, "measure"}
};

template<typename Formula>
const static_pair<typename flagged_logical_form<Formula>::function_type, const char*> flagged_logical_form<Formula>::FUNCTION_NAMES[] = {
	{function_type::EMPTY, "empty"},
	{function_type::IDENTITY, "identity"},
	{function_type::IDENTITY_PREDICATIVE, "identity_predicative"},
	{function_type::IDENTITY_ROOT, "identity_root"},
	{function_type::SELECT_RIGHT_CONJUNCT, "select_right_conjunct"},
	{function_type::REMOVE_RIGHT_CONJUNCT, "remove_right_conjunct"},
	{function_type::SELECT_LEFT_CONJUNCT, "select_left_conjunct"},
	{function_type::SELECT_LEFT_CONJUNCT_AND_NEGATION, "select_left_conjunct_and_negation"},
	{function_type::REMOVE_LEFT_CONJUNCT, "remove_left_conjunct"},
	{function_type::REMOVE_LEFT_CONJUNCT_AND_NEGATION, "remove_left_conjunct_and_negation"},
	{function_type::REMOVE_SECOND_LEFT_CONJUNCT, "remove_second_left_conjunct"},
	{function_type::SELECT_LEFT_CONJUNCT_IN_SET, "select_left_conjunct_in_set"},
	{function_type::REMOVE_LEFT_CONJUNCT_IN_SET, "remove_left_conjunct_in_set"},
	{function_type::SELECT_SECOND_LEFT_CONJUNCT_IN_SET, "select_second_left_conjunct_in_set"},
	{function_type::SELECT_RIGHT_CONJUNCT_IN_SET, "select_right_conjunct_in_set"},
	{function_type::REMOVE_RIGHT_CONJUNCT_IN_SET, "remove_right_conjunct_in_set"},
	{function_type::REMOVE_RIGHT_CONJUNCT_IN_SET_WITHOUT_PREDICATIVE, "remove_right_conjunct_in_set_without_predicative"},
	{function_type::SELECT_RIGHT_SUBSET_IN_SET, "select_right_subset_in_set"},
	{function_type::SELECT_ONLY_RIGHT_CONJUNCT_IN_SET_PREDICATIVE, "select_only_right_conjunct_in_set_predicative"},
	{function_type::REQUIRE_NO_INVERSE, "require_no_inverse"},
	{function_type::REQUIRE_LEFT_PREDICATE_SAME, "require_left_predicate_same"},
	{function_type::REQUIRE_NO_PREDICATE_SAME, "require_no_predicate_same"},
	{function_type::REQUIRE_LEFT_PREDICATE_INVERSE, "require_left_predicate_inverse"},
	{function_type::REQUIRE_LEFT_PREDICATE_INVERSE_HAS, "require_left_predicate_inverse_has"},
	{function_type::REQUIRE_LEFT_PREDICATE_EXIST, "require_left_predicate_exist"},
	{function_type::REQUIRE_LEFT_GREATEST, "require_left_greatest"},
	{function_type::REQUIRE_NO_LEFT_PREDICATE_EXIST, "require_no_left_predicate_exist"},
	{function_type::REQUIRE_RIGHT_PREDICATE_IN_SET, "require_right_predicate_in_set"},
	{function_type::REMOVE_INVERSE, "remove_inverse"},
	{function_type::REMOVE_GREATEST, "remove_greatest"},
	{function_type::REMOVE_RIGHT_TRACE, "remove_right_trace"},
	{function_type::SELECT_RIGHT_ARG1_WITHOUT_HEAD, "select_right_arg1_without_head"},
	{function_type::SELECT_RIGHT_ARG2_WITHOUT_HEAD, "select_right_arg2_without_head"},
	{function_type::SELECT_RIGHT_ARG3_WITHOUT_HEAD, "select_right_arg3_without_head"},
	{function_type::SELECT_RIGHT_ARG1_OF_WITHOUT_HEAD, "select_right_arg1_of_without_head"},
	{function_type::SELECT_RIGHT_ARG2_OF_WITHOUT_HEAD, "select_right_arg2_of_without_head"},
	{function_type::SELECT_RIGHT_ARG3_OF_WITHOUT_HEAD, "select_right_arg3_of_without_head"},
	{function_type::SELECT_RIGHT_ARG1_WITHOUT_HEAD_PREDICATIVE, "select_right_arg1_without_head_predicative"},
	{function_type::SELECT_RIGHT_ARG2_WITHOUT_HEAD_PREDICATIVE, "select_right_arg2_without_head_predicative"},
	{function_type::SELECT_RIGHT_ARG3_WITHOUT_HEAD_PREDICATIVE, "select_right_arg3_without_head_predicative"},
	{function_type::SELECT_RIGHT_SET_ARG1_WITHOUT_HEAD_PREDICATIVE, "select_right_set_arg1_without_head_predicative"},
	{function_type::SELECT_RIGHT_SET_ARG2_WITHOUT_HEAD_PREDICATIVE, "select_right_set_arg2_without_head_predicative"},
	{function_type::SELECT_RIGHT_SET_ARG3_WITHOUT_HEAD_PREDICATIVE, "select_right_set_arg3_without_head_predicative"},
	{function_type::SELECT_SINGLETON_ARG1_IN_SET_WITHOUT_HEAD_PREDICATIVE, "select_singleton_arg1_in_set_without_head_predicative"},
	{function_type::SELECT_SINGLETON_ARG2_IN_SET_WITHOUT_HEAD_PREDICATIVE, "select_singleton_arg2_in_set_without_head_predicative"},
	{function_type::SELECT_SINGLETON_ARG3_IN_SET_WITHOUT_HEAD_PREDICATIVE, "select_singleton_arg3_in_set_without_head_predicative"},
	{function_type::SELECT_SINGLETON_ARG1_OF_IN_SET_WITHOUT_HEAD_PREDICATIVE, "select_singleton_arg1_of_in_set_without_head_predicative"},
	{function_type::SELECT_SINGLETON_ARG2_OF_IN_SET_WITHOUT_HEAD_PREDICATIVE, "select_singleton_arg2_of_in_set_without_head_predicative"},
	{function_type::SELECT_SINGLETON_ARG3_OF_IN_SET_WITHOUT_HEAD_PREDICATIVE, "select_singleton_arg3_of_in_set_without_head_predicative"},
	{function_type::SELECT_SINGLETON_ARG1_IN_SET_WITHOUT_HEAD_OUTER_SCOPE_PREDICATIVE, "select_singleton_arg1_in_set_without_head_outer_scope_predicative"},
	{function_type::SELECT_SINGLETON_ARG2_IN_SET_WITHOUT_HEAD_OUTER_SCOPE_PREDICATIVE, "select_singleton_arg2_in_set_without_head_outer_scope_predicative"},
	{function_type::SELECT_SINGLETON_ARG3_IN_SET_WITHOUT_HEAD_OUTER_SCOPE_PREDICATIVE, "select_singleton_arg3_in_set_without_head_outer_scope_predicative"},
	{function_type::SELECT_SINGLETON_ARG1_OF_IN_SET_WITHOUT_HEAD_OUTER_SCOPE_PREDICATIVE, "select_singleton_arg1_of_in_set_without_head_outer_scope_predicative"},
	{function_type::SELECT_SINGLETON_ARG2_OF_IN_SET_WITHOUT_HEAD_OUTER_SCOPE_PREDICATIVE, "select_singleton_arg2_of_in_set_without_head_outer_scope_predicative"},
	{function_type::SELECT_SINGLETON_ARG3_OF_IN_SET_WITHOUT_HEAD_OUTER_SCOPE_PREDICATIVE, "select_singleton_arg3_of_in_set_without_head_outer_scope_predicative"},
	{function_type::REQUIRE_PAST, "require_past"},
	{function_type::REMOVE_FUTURE, "remove_future"},
	{function_type::REQUIRE_NO_FUTURE, "require_no_future"},
	{function_type::REMOVE_PERFECT, "remove_perfect"},
	{function_type::REQUIRE_NO_PERFECT, "require_no_perfect"},
	{function_type::REMOVE_PROGRESSIVE, "remove_progressive"},
	{function_type::REMOVE_PRESENT_PROGRESSIVE, "remove_present_progressive"},
	{function_type::REMOVE_PAST_PROGRESSIVE, "remove_past_progressive"},
	{function_type::REQUIRE_NO_PROGRESSIVE, "require_no_progressive"},
	{function_type::REMOVE_ASPECT, "remove_aspect"},
	{function_type::TRY_REMOVE_ASPECT, "try_remove_aspect"},
	{function_type::REMOVE_NOT, "remove_not"},
	{function_type::REQUIRE_NO_EMPTY_REF, "require_no_empty_ref"},
	{function_type::PREDICATE_ONLY, "predicate_only"},
	{function_type::PREDICATE, "predicate"},
	{function_type::PREDICATE_AND_TENSE, "predicate_and_tense"},
	{function_type::EMPTY_AND_TENSE, "empty_and_tense"},
	{function_type::REQUIRE_PREDICATIVE_UNIVERSAL, "require_predicative_universal"},
	{function_type::REQUIRE_PREDICATIVE_EXISTENTIAL, "require_predicative_existential"},
	{function_type::REPLACE_PREDICATIVE_LAMBDA_WITH_EXISTENTIAL, "replace_predicative_lambda_with_existential"},
	{function_type::REPLACE_PREDICATIVE_UNIVERSAL_WITH_EXISTENTIAL, "replace_predicative_universal_with_existential"},
	{function_type::REMOVE_PREDICATIVE_NOT, "remove_predicative_not"},
	{function_type::SELECT_PREDICATE_IN_SET, "select_predicate_in_set"},
	{function_type::SELECT_CONSTANT_IN_SET, "select_constant_in_set"},
	{function_type::SELECT_STRING_IN_SET, "select_string_in_set"},
	{function_type::SELECT_NAME_IN_SET, "select_name_in_set"},
	{function_type::SELECT_NUMBER_IN_SET, "select_number_in_set"},
	{function_type::MARK_WIDE_SCOPE, "mark_wide_scope"},
	{function_type::REQUIRE_WIDE_SCOPE, "require_wide_scope"},
	{function_type::REQUIRE_NARROW_SCOPE, "require_narrow_scope"},
	{function_type::REMOVE_WIDE_SCOPE, "remove_wide_scope"},
	{function_type::REQUIRE_CONSTANT_IN_SET, "require_constant_in_set"},
	{function_type::REQUIRE_NO_CONSTANT_IN_SET, "require_no_constant_in_set"},
	{function_type::REQUIRE_STRING_OR_NUMBER_IN_SET, "require_string_or_number_in_set"},
	{function_type::REQUIRE_NAME_IN_SET, "require_name_in_set"},
	{function_type::REQUIRE_MEASURE_IN_SET, "require_measure_in_set"},
	{function_type::REQUIRE_SINGLETON, "require_singleton"},
	{function_type::REQUIRE_NO_STRING_OR_NUMBER_OR_NAME_IN_SET, "require_no_string_or_number_or_name_in_set"},
	{function_type::SELECT_SECOND_LEFT_SET_CONJUNCT, "select_second_left_set_conjunct"},
	{function_type::SELECT_SECOND_LEFT_SET_CONJUNCT_ROOT, "select_second_left_set_conjunct_root"},
	{function_type::REMOVE_SECOND_LEFT_SET_CONJUNCT, "remove_second_left_set_conjunct"},
	{function_type::SIZE, "size"},
	{function_type::RIGHT_ARG1, "right_arg1"},
	{function_type::SET_SIZE, "set_size"},
	{function_type::REQUIRE_LEFT_ARG1, "require_left_arg1"},
	{function_type::REQUIRE_LAMBDA, "require_lambda"},
	{function_type::REQUIRE_NO_LAMBDA, "require_no_lambda"},
	{function_type::REMOVE_LEFT_PREDICATE, "remove_left_predicate"},
	{function_type::FACTOR, "factor"},
	{function_type::FACTOR_PREDICATIVE, "factor_predicative"},
	{function_type::SELECT_LEFT_PREDICATE_AND_TENSE, "select_left_predicate_and_tense"},
	{function_type::SET_PREDICATE_EMPTY, "set_predicate_empty"},
	{function_type::SET_LEFT_PREDICATE_EMPTY, "set_left_predicate_empty"},
	{function_type::REQUIRE_NO_PREDICATE_EMPTY, "require_no_predicate_empty"},
	{function_type::REQUIRE_CONJUNCTION, "require_conjunction"},
	{function_type::REQUIRE_BINARY_CONJUNCTION, "require_binary_conjunction"},
	{function_type::REQUIRE_DISJUNCTION, "require_disjunction"},
	{function_type::REQUIRE_NEGATIVE_CONJUNCTION, "require_negative_conjunction"},
	{function_type::REQUIRE_HEAD_CONJUNCTION, "require_head_conjunction"},
	{function_type::REQUIRE_HEAD_BINARY_CONJUNCTION, "require_head_binary_conjunction"},
	{function_type::REQUIRE_HEAD_DISJUNCTION, "require_head_disjunction"},
	{function_type::REQUIRE_HEAD_NEGATIVE_CONJUNCTION, "require_head_negative_conjunction"},
	{function_type::REQUIRE_NO_HEAD_ARRAY, "require_no_head_array"},
	{function_type::SELECT_LEFT_OPERAND, "select_left_operand"},
	{function_type::REMOVE_LEFT_OPERAND, "remove_left_operand"},
	{function_type::SELECT_LEFT_HEAD_OPERAND, "select_left_head_operand"},
	{function_type::REMOVE_LEFT_HEAD_OPERAND, "remove_left_head_operand"},
	{function_type::REPLACE_PREDICATIVE_SUBSET_WITH_EQUALITY, "replace_predicative_subset_with_equality"},
	{function_type::REQUIRE_PREDICATE_OF_LAMBDA, "require_predicate_of_lambda"},
	{function_type::SELECT_LAMBDA, "select_lambda"},
	{function_type::REMOVE_LAMBDA, "remove_lambda"},
	{function_type::SELECT_FUNCTION_WITH_SUBSTITUTION, "select_function_with_substitution"},
	{function_type::SELECT_FUNCTION_WITH_EMPTY_SUBSTITUTION, "select_function_with_empty_substitution"},
	{function_type::SELECT_FUNCTION_WITHOUT_SUBSTITUTION, "select_function_without_substitution"},
	{function_type::SELECT_ANTECEDENT, "select_antecedent"},
	{function_type::SELECT_CONSEQUENT, "select_consequent"},
	{function_type::REQUIRE_REF_IN_SET, "require_ref_in_set"},
	{function_type::REQUIRE_PLURAL_REF_IN_SET, "require_plural_ref_in_set"},
	{function_type::REQUIRE_ANIMATE_IN_SET, "require_animate_in_set"},
	{function_type::REQUIRE_ONE_OR_TWO_CONJUNCTS, "require_one_or_two_conjuncts"},
	{function_type::REQUIRE_CAPITALIZED, "require_capitalized"},
	{function_type::ADD_SINGULAR, "add_singular"},
	{function_type::ADD_PLURAL, "add_plural"},
	{function_type::TRY_ADD_SINGULAR, "try_add_singular"},
	{function_type::TRY_ADD_PLURAL, "try_add_plural"},
	{function_type::REQUIRE_SINGULAR, "require_singular"},
	{function_type::REQUIRE_PLURAL, "require_plural"},
	{function_type::TRY_REMOVE_NUMBER, "try_remove_number"},
	{function_type::ADD_CONCORD_SINGULAR, "add_concord_singular"},
	{function_type::ADD_CONCORD_PLURAL, "add_concord_plural"},
	{function_type::ADD_THAT, "add_that"},
	{function_type::REMOVE_THAT, "remove_that"},
	{function_type::REQUIRE_NO_THAT, "require_no_that"},
	{function_type::ADD_WHETHER, "add_whether"},
	{function_type::REMOVE_WHETHER, "remove_whether"},
	{function_type::ADD_IF, "add_if"},
	{function_type::REMOVE_IF, "remove_if"},
	{function_type::ADD_BECAUSE, "add_because"},
	{function_type::REMOVE_BECAUSE, "remove_because"},
	{function_type::ADD_FOR, "add_for"},
	{function_type::REMOVE_FOR, "remove_for"},
	{function_type::REQUIRE_NO_CONJUNCTION, "require_no_conjunction"},
	{function_type::ADD_IS_ADJUNCT, "add_is_adjunct"},
	{function_type::TRY_REMOVE_IS_ADJUNCT, "try_remove_is_adjunct"},
	{function_type::REQUIRE_NOT_ADJUNCT, "require_not_adjunct"},
	{function_type::ADD_NULLABLE_SUBJECT, "add_nullable_subject"},
	{function_type::REMOVE_NULLABLE_SUBJECT, "remove_nullable_subject"},
	{function_type::TRY_REMOVE_NULLABLE_SUBJECT, "try_remove_nullable_subject"},
	{function_type::ADD_SUBORDINATE, "add_subordinate"},
	{function_type::REMOVE_SUBORDINATE, "remove_subordinate"},
	{function_type::TRY_REMOVE_SUBORDINATE, "try_remove_subordinate"},
	{function_type::REQUIRE_NO_SUBORDINATE, "require_no_subordinate"},
	{function_type::ADD_PREPOSITION, "add_preposition"},
	{function_type::REQUIRE_PREPOSITION, "require_preposition"},
	{function_type::REQUIRE_NO_PREPOSITION, "require_no_preposition"},
	{function_type::ADD_PARTICLE, "add_particle"},
	{function_type::ADD_AUX, "add_aux"},
	{function_type::TRY_REMOVE_AUX, "try_remove_aux"},
	{function_type::ADD_REQ_AUX, "add_req_aux"},
	{function_type::TRY_ADD_REQ_AUX, "try_add_req_aux"},
	{function_type::REQUIRE_NO_REQ_AUX, "require_no_req_aux"},
	{function_type::REMOVE_REQ_AUX, "remove_req_aux"},
	{function_type::TRY_REMOVE_REQ_AUX, "try_remove_req_aux"},
	{function_type::ADD_REQ_NO_AUX, "add_req_no_aux"},
	{function_type::REQUIRE_NO_REQ_NO_AUX, "require_no_req_no_aux"},
	{function_type::REQUIRE_NO_REQ_SUBJECT, "require_no_req_subject"},
	{function_type::REMOVE_REQ_SUBJECT, "remove_req_subject"},
	{function_type::TRY_REMOVE_REQ_SUBJECT, "try_remove_req_subject"},
	{function_type::ADD_INFINITIVE, "add_infinitive"},
	{function_type::ADD_TO_INFINITIVE, "add_to_infinitive"},
	{function_type::REMOVE_TO_INFINITIVE, "remove_to_infinitive"},
	{function_type::REQUIRE_TO_INFINITIVE, "require_to_infinitive"},
	{function_type::REQUIRE_NO_TO_INFINITIVE, "require_no_to_infinitive"},
	{function_type::ADD_SUBJUNCTIVE, "add_subjunctive"},
	{function_type::REQUIRE_NO_SUBJUNCTIVE, "require_no_subjunctive"},
	{function_type::REQUIRE_AUX_OR_SUBJUNCTIVE_OR_INFINITIVE_OR_TO_INFINITIVE, "require_aux_or_subjunctive_or_infinitive_or_to_infinitive"},
	{function_type::ADD_BOTH, "add_both"},
	{function_type::ADD_EITHER, "add_either"},
	{function_type::ADD_NEITHER, "add_neither"},
	{function_type::REMOVE_BOTH, "remove_both"},
	{function_type::REMOVE_EITHER, "remove_either"},
	{function_type::REMOVE_NEITHER, "remove_neither"},
	{function_type::TRY_REMOVE_CORRELATOR, "try_remove_correlator"},
	{function_type::REQUIRE_NO_CORRELATOR, "require_no_correlator"},
	{function_type::REQUIRE_NO_CORRELATOR_PREDICATIVE, "require_no_correlator_predicative"},
	{function_type::ADD_CORRELATED_BY_BOTH, "add_correlated_by_both"},
	{function_type::ADD_CORRELATED_BY_EITHER, "add_correlated_by_either"},
	{function_type::ADD_CORRELATED_BY_NEITHER, "add_correlated_by_neither"},
	{function_type::TRY_REMOVE_CORRELATED, "try_remove_correlated"},
	{function_type::REQUIRE_NOT_CORRELATED, "require_not_correlated"},
	{function_type::ADD_PAST_PARTICIPLE, "add_past_participle"},
	{function_type::ADD_PRESENT_PARTICIPLE, "add_present_participle"},
	{function_type::TRY_REMOVE_PARTICIPLE, "try_remove_participle"},
	{function_type::REQUIRE_PAST_PARTICIPLE, "require_past_participle"},
	{function_type::REQUIRE_PRESENT_PARTICIPLE, "require_present_participle"},
	{function_type::ADD_NEGATIVE, "add_negative"},
	{function_type::ADD_NEGATIVE_PREDICATIVE, "add_negative_predicative"},
	{function_type::REQUIRE_NEGATIVE, "require_negative"},
	{function_type::ADD_ADV, "add_adv"},
	{function_type::REMOVE_ADV, "remove_adv"},
	{function_type::TRY_REMOVE_ADV, "try_remove_adv"},
	{function_type::REQUIRE_NO_ADV, "require_no_adv"},
	{function_type::ADD_TION, "add_tion"},
	{function_type::ADD_LY, "add_ly"},
	{function_type::ADD_GENITIVE, "add_genitive"},
	{function_type::TRY_REMOVE_GENITIVE, "try_remove_genitive"},
	{function_type::REQUIRE_NO_GENITIVE, "require_no_genitive"},
	{function_type::ADD_COMMA, "add_comma"},
	{function_type::REMOVE_COMMA, "remove_comma"},
	{function_type::REQUIRE_NO_COMMA, "require_no_comma"},
	{function_type::ADD_WH_MINUS, "add_wh_minus"},
	{function_type::REMOVE_WH_MINUS, "remove_wh_minus"},
	{function_type::TRY_REMOVE_WH_MINUS, "try_remove_wh_minus"},
	{function_type::REQUIRE_NO_WH_MINUS, "require_no_wh_minus"},
	{function_type::HAS_ARG2, "has_arg2"},
	{function_type::TRY_HAS_ARG2, "try_has_arg2"},
	{function_type::HAS_ARG2_IN_SET, "has_arg2_in_set"},
	{function_type::TRY_HAS_ARG2_IN_SET, "try_has_arg2_in_set"},
	{function_type::TRY_ADD_HAS_ARG2, "try_add_has_arg2"},
	{function_type::ADD_MODIFIES_EVENT, "add_modifies_event"},
	{function_type::TRY_REMOVE_MODIFIES_EVENT, "try_remove_modifies_event"},
	{function_type::ADD_MEASURE, "add_measure"},
	{function_type::TRY_REMOVE_MEASURE, "try_remove_measure"},
	{function_type::REQUIRE_NO_MEASURE, "require_no_measure"},
	{function_type::ADD_EMPTY_VERB, "add_empty_verb"},
	{function_type::TRY_REMOVE_EMPTY_VERB, "try_remove_empty_verb"},
	{function_type::REMOVE_EMPTY_VERB, "remove_empty_verb"},
	{function_type::REQUIRE_NO_EMPTY_VERB, "require_no_empty_verb"},
	{function_type::ADD_PASSIVE, "add_passive"},
	{function_type::REMOVE_PASSIVE, "remove_passive"},
	{function_type::REQUIRE_NO_PASSIVE, "require_no_passive"},
	{function_type::ADD_BE, "add_be"},
	{function_type::REMOVE_BE, "remove_be"},
	{function_type::TRY_REMOVE_BE, "try_remove_be"},
	{function_type::REQUIRE_NO_BE, "require_no_be"},
	{function_type::ADD_AND, "add_and"},
	{function_type::ADD_OR, "add_or"},
	{function_type::ADD_NOR, "add_nor"},
	{function_type::REMOVE_AND, "remove_and"},
	{function_type::REMOVE_OR, "remove_or"},
	{function_type::REMOVE_NOR, "remove_nor"},
	{function_type::REMOVE_COORD, "remove_coord"},
	{function_type::ADD_COMPARATIVE, "add_comparative"},
	{function_type::ADD_SUPERLATIVE, "add_superlative"},
	{function_type::REQUIRE_SUPERLATIVE, "require_superlative"},
	{function_type::REQUIRE_NO_SUPERLATIVE, "require_no_superlative"}
};

inline void initialize_any(grammatical_flags& flags) {
	flags.concord_number = grammatical_num::ANY;
	flags.index_number = grammatical_num::ANY;
	flags.comp = grammatical_comparison::ANY;
	flags.cnj = grammatical_conjunction::ANY;
	flags.corr = correlator::ANY;
	flags.correlated_by = correlator::ANY;
	flags.coord = coordination::ANY;
	flags.aux = auxiliary_flag::ANY;
	flags.mood = grammatical_mood::ANY;
	flags.aux_or_subjunctive_or_inf_or_to_inf = false;
	flags.is_first_token_capital = false;
	for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
		flags.flags[i] = grammatical_flag_value::ANY;
}

template<typename Formula>
inline bool initialize_any(flagged_logical_form<Formula>& lf) {
	lf.root = (Formula*) malloc(sizeof(Formula));
	if (lf.root == nullptr) {
		fprintf(stderr, "initialize_any ERROR: Out of memory.\n");
		return false;
	}
	initialize_any(*lf.root);
	initialize_any(lf.flags);
	return true;
}

inline bool operator == (
		const grammatical_flags& first,
		const grammatical_flags& second)
{
	if (first.index_number != second.index_number
	 || first.concord_number != second.concord_number
	 || first.comp != second.comp
	 || first.cnj != second.cnj
	 || first.corr != second.corr
	 || first.correlated_by != second.correlated_by
	 || first.coord != second.coord
	 || first.aux != second.aux
	 || first.mood != second.mood
	 || first.aux_or_subjunctive_or_inf_or_to_inf != second.aux_or_subjunctive_or_inf_or_to_inf
	 || first.is_first_token_capital != second.is_first_token_capital)
		return false;
	for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
		if (first.flags[i] != second.flags[i]) return false;
	return true;
}

inline bool is_subset(
		const grammatical_flags& first,
		const grammatical_flags& second)
{
	grammatical_flags dst;
	if (!intersect(dst, first, second))
		return false;
	dst.is_first_token_capital = first.is_first_token_capital;
	return (dst == first);
}

template<typename Formula>
inline bool operator == (
		const flagged_logical_form<Formula>& first,
		const flagged_logical_form<Formula>& second)
{
	/* `first` may be uninitialized, but `second` must be initialized */
	if (first.root == nullptr)
		return false;
	return (first.flags == second.flags)
		&& ((first.root == second.root) || (*first.root == *second.root));
}

inline bool operator != (
		const grammatical_flags& first,
		const grammatical_flags& second)
{
	if (first.index_number != second.index_number
	 || first.concord_number != second.concord_number
	 || first.comp != second.comp
	 || first.cnj != second.cnj
	 || first.corr != second.corr
	 || first.correlated_by != second.correlated_by
	 || first.coord != second.coord
	 || first.aux != second.aux
	 || first.mood != second.mood
	 || first.aux_or_subjunctive_or_inf_or_to_inf != second.aux_or_subjunctive_or_inf_or_to_inf
	 || first.is_first_token_capital != second.is_first_token_capital)
		return true;
	for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
		if (first.flags[i] != second.flags[i]) return true;
	return false;
}

template<typename Formula>
inline bool operator != (
		const flagged_logical_form<Formula>& first,
		const flagged_logical_form<Formula>& second)
{
	return (first.flags != second.flags)
		|| ((first.root != second.root) && (*first.root != *second.root));
}

template<typename Formula>
inline bool equivalent(Formula* first, Formula* second)
{
	Formula* first_logical_form = relabel_variables(first);
	if (first_logical_form == nullptr)
		return false;

	Formula* second_logical_form = relabel_variables(second);
	if (second_logical_form == nullptr) {
		free(*first_logical_form); if (first_logical_form->reference_count == 0) free(first_logical_form);
		return false;
	}

/* TODO: for debugging; remove this */
#if defined(DEBUG_PARSER)
print("first_logical_form:  ", stderr); print(*first_logical_form, stderr, *debug_terminal_printer); print('\n', stderr);
print("second_logical_form: ", stderr); print(*second_logical_form, stderr, *debug_terminal_printer); print('\n', stderr);
#endif
	bool result = (first_logical_form == second_logical_form || *first_logical_form == *second_logical_form);
	free(*first_logical_form); if (first_logical_form->reference_count == 0) free(first_logical_form);
	free(*second_logical_form); if (second_logical_form->reference_count == 0) free(second_logical_form);
	return result;
}

template<typename Formula>
inline bool equivalent(
		const flagged_logical_form<Formula>& first,
		const flagged_logical_form<Formula>& second)
{
	return equivalent(first.root, second.root);
}

template<typename Stream>
inline bool print(const grammatical_flags& flags, Stream& out)
{
	static grammatical_flags ZERO_FLAGS;
	if (flags == ZERO_FLAGS) return true;

	bool first = true;
	if (!print('[', out)
	 || !print_feature("index", first, flags.index_number, out)
	 || !print_feature("concord", first, flags.concord_number, out)
	 || !print_feature(first, flags.comp, out)
	 || !print_feature(first, flags.cnj, out)
	 || !print_feature("corr", first, flags.corr, out)
	 || !print_feature("corr_by", first, flags.correlated_by, out)
	 || !print_feature("coord", first, flags.coord, out)
	 || !print_feature(first, flags.aux, out)
	 || !print_feature(first, flags.mood, out))
		return false;

	if (flags.aux_or_subjunctive_or_inf_or_to_inf) {
		if ((!first && !print(',', out)) || !print("aux_or_subjunctive_or_inf_or_to_inf", out)) return false;
	}

	if (flags.is_first_token_capital) {
		if ((!first && !print(',', out)) || !print("cap", out)) return false;
	}

	for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
		if (!print_feature(first, (grammatical_flag) i, flags.flags[i], out)) return false;
	return print(']', out);
}

template<typename Formula, typename Stream, typename... Printer>
inline bool print(
		const flagged_logical_form<Formula>& lf,
		Stream& out, Printer&&... printer)
{
	return print(*lf.root, out, std::forward<Printer>(printer)...) && print(lf.flags, out);
}

/* TODO: take into account the semantic prior during parsing */
template<bool Complete>
constexpr double log_probability(const flagged_logical_form<hol_term>& lf) {
	return 0.0;
}

inline bool parse_flag(
		char* str, unsigned int length,
		grammatical_flags& flags,
		hash_map<string, unsigned int>& names,
		position current)
{
	if (compare_strings("index:sg", str, length)) {
		flags.index_number = grammatical_num::SINGULAR;
	} else if (compare_strings("index:pl", str, length)) {
		flags.index_number = grammatical_num::PLURAL;
	} else if (compare_strings("index:*", str, length)) {
		flags.index_number = grammatical_num::ANY;
	} else if (compare_strings("concord:sg", str, length)) {
		flags.concord_number = grammatical_num::SINGULAR;
	} else if (compare_strings("concord:pl", str, length)) {
		flags.concord_number = grammatical_num::PLURAL;
	} else if (compare_strings("concord:*", str, length)) {
		flags.concord_number = grammatical_num::ANY;
	} else if (compare_strings("arg2", str, length)) {
		flags.flags[(unsigned int) grammatical_flag::HAS_ARG2] = grammatical_flag_value::TRUE;
	} else if (compare_strings("measure", str, length)) {
		flags.flags[(unsigned int) grammatical_flag::MEASURE] = grammatical_flag_value::TRUE;
	} else if (compare_strings("cmp", str, length)) {
		flags.comp = grammatical_comparison::COMPARATIVE;
	} else if (compare_strings("sup", str, length)) {
		flags.comp = grammatical_comparison::SUPERLATIVE;
	} else {
		read_error("Unrecognized grammatical flag label", current);
		return false;
	}
	return true;
}

bool parse(char* str, unsigned int length,
		grammatical_flags& flags,
		hash_map<string, unsigned int>& names,
		position start = position(1, 1))
{
	position current = start;
	unsigned int token_start = 0;
	for (unsigned int i = 0; i < length; i++) {
		if (str[i] == ',') {
			if (!parse_flag(str + token_start, i - token_start, flags, names, current))
				return false;
			token_start = i + 1;
		}

		if (str[i] == '\r' && i + 1 < length && str[i + 1] == '\n')
			i++;
		if (str[i] == '\r' || str[i] == '\n') {
			current.line++;
			current.column = 1;
		} else {
			current.column++;
		}
	}

	return parse_flag(str + token_start, length - token_start, flags, names, current);
}

template<typename Formula>
inline bool parse(char* str, unsigned int length,
		flagged_logical_form<Formula>& logical_form,
		hash_map<string, unsigned int>& names,
		position start = position(1, 1))
{
	static grammatical_flags ZERO_FLAGS;
	logical_form.flags = ZERO_FLAGS;

	/* first check if there are any grammatical flag labels */
	if (str[length - 1] == ']') {
		/* find the corresponding '[' */
		unsigned int index = last_index_of('[', str, length - 1);
		if (index != static_cast<unsigned int>(-1)) {
			/* appropriately shift the `start` position */
			position current = start;
			for (unsigned int i = 0; i < index + 1; i++) {
				if (str[i] == '\r' && i + 1 < length && str[i + 1] == '\n')
					i++;
				if (str[i] == '\r' || str[i] == '\n') {
					current.line++;
					current.column = 1;
				} else {
					current.column++;
				}
			}

			if (!parse(str + index + 1, length - index - 2, logical_form.flags, names, current))
				return false;
			length = index;
		}
	}

	logical_form.root = (Formula*) malloc(sizeof(Formula));
	if (logical_form.root == nullptr) {
		fprintf(stderr, "parse ERROR: Insufficient memory for `logical_form.root`.\n");
		return false;
	}

	memory_stream& in = *((memory_stream*) alloca(sizeof(memory_stream)));
	in.buffer = str;
	in.length = length;
	in.position = 0; in.shift = {0};
	if (!parse(in, *logical_form.root, names, start)) {
		free(logical_form.root);
		return false;
	}
	return true;
}

typedef sequence_distribution<token_distribution<double>> terminal_prior_type;
template<typename Formula> using hdp_grammar_type =
	hdp_grammar<rule_list_prior<terminal_prior<terminal_prior_type>, flagged_logical_form<Formula>>, flagged_logical_form<Formula>>;

template<typename Formula, typename Stream>
void print_nonterminal_hdps(hdp_grammar_type<Formula>& G, Stream& out,
		const string_map_scribe& terminal_printer, const string_map_scribe& nonterminal_printer)
{
	auto printers = make_pair<const string_map_scribe&, const string_map_scribe&>(terminal_printer, nonterminal_printer);
	for (unsigned int i = 0; i < G.nonterminals.length; i++) {
		if (G.nonterminals[i].rule_distribution.observations.sum == 0) continue;
		print(G.nonterminals[i].rule_distribution.type, out); print(' ', out);
		print(G.nonterminals[i].name, out); fprintf(out, " (%u) HDP: ", G.nonterminals[i].id);
		print(G.nonterminals[i].rule_distribution.sampler, out, terminal_printer, printers); print('\n', out);
		print(G.nonterminals[i].rule_distribution.h.alpha, G.nonterminals[i].rule_distribution.feature_count + 1, out); print('\n', out);
	}
}

template<typename Formula>
inline bool init(sequence& seq, const sentence<rooted_syntax_node<flagged_logical_form<Formula>>>& src)
{
	seq.tokens = (unsigned int*) malloc(sizeof(unsigned int) * src.length);
	if (seq.tokens == NULL) {
		fprintf(stderr, "init ERROR: Insufficient memory for `sequence.tokens`.\n");
		return false;
	}
	for (unsigned int i = 0; i < src.length; i++)
		seq.tokens[i] = src.tokens[i].id;
	seq.length = src.length;
	return true;
}

struct number_parser_en
{
	static constexpr static_pair<int, const char*> ONES_NAMES[] = {
		{1, "one"},
		{2, "two"},
		{3, "three"},
		{4, "four"},
		{5, "five"},
		{6, "six"},
		{7, "seven"},
		{8, "eight"},
		{9, "nine"}
	};

	static constexpr static_pair<int, const char*> TEENS_NAMES[] = {
		{10, "ten"},
		{11, "eleven"},
		{12, "twelve"},
		{13, "thirteen"},
		{14, "fourteen"},
		{15, "fifteen"},
		{16, "sixteen"},
		{17, "seventeen"},
		{18, "eighteen"},
		{19, "nineteen"}
	};

	static constexpr static_pair<int, const char*> TENS_NAMES[] = {
		{20, "twenty"},
		{30, "thirty"},
		{40, "fourty"},
		{50, "fifty"},
		{60, "sixty"},
		{70, "seventy"},
		{80, "eighty"},
		{90, "ninety"}
	};

	static constexpr static_pair<int, const char*> LARGE_NUMBER_NAMES[] = {
		{1000000000, "billion"},
		{1000000, "million"},
		{1000, "thousand"}
	};

	unsigned int ones_name_ids[array_length(ONES_NAMES)];
	unsigned int teens_name_ids[array_length(TEENS_NAMES)];
	unsigned int tens_name_ids[array_length(TENS_NAMES)];
	unsigned int large_name_ids[array_length(LARGE_NUMBER_NAMES)];
	unsigned int zero_id, hundred_id, hyphen_id;

	number_parser_en(hash_map<string, unsigned int>& names) {
		for (unsigned int i = 0; i < array_length(ONES_NAMES); i++) {
			if (!get_token(ONES_NAMES[i].value, ones_name_ids[i], names))
				exit(EXIT_FAILURE);
		} for (unsigned int i = 0; i < array_length(TEENS_NAMES); i++) {
			if (!get_token(TEENS_NAMES[i].value, teens_name_ids[i], names))
				exit(EXIT_FAILURE);
		} for (unsigned int i = 0; i < array_length(TENS_NAMES); i++) {
			if (!get_token(TENS_NAMES[i].value, tens_name_ids[i], names))
				exit(EXIT_FAILURE);
		} for (unsigned int i = 0; i < array_length(LARGE_NUMBER_NAMES); i++) {
			if (!get_token(LARGE_NUMBER_NAMES[i].value, large_name_ids[i], names))
				exit(EXIT_FAILURE);
		}
		if (!get_token("zero", zero_id, names)
		 || !get_token("hundred", hundred_id, names)
		 || !get_token("-", hyphen_id, names))
			exit(EXIT_FAILURE);
	}
};

constexpr static_pair<int, const char*> number_parser_en::ONES_NAMES[];
constexpr static_pair<int, const char*> number_parser_en::TEENS_NAMES[];
constexpr static_pair<int, const char*> number_parser_en::TENS_NAMES[];
constexpr static_pair<int, const char*> number_parser_en::LARGE_NUMBER_NAMES[];

template<typename Formula>
bool get_unrecognized_terminals(
	array<pair<unsigned int, unsigned int>>& terminal_indices,
	const syntax_node<flagged_logical_form<Formula>>& syntax,
	const flagged_logical_form<Formula>& logical_form,
	unsigned int& left)
{
	const rule<flagged_logical_form<Formula>>& r = syntax.right;
	if (r.is_terminal()) {
		if (is_ambiguous(*logical_form.root)
		 && !terminal_indices.add({left, r.t.length}))
			return false;
		left += r.t.length;
		return true;
	}

	for (unsigned int i = 0; i < r.nt.length; i++) {
		flagged_logical_form<Formula>& transformed = *((flagged_logical_form<Formula>*) alloca(sizeof(flagged_logical_form<Formula>)));
		if (syntax.children[i] == nullptr) continue;
		if (!apply(r.nt.transformations[i], logical_form, transformed)) {
/* TODO: for debugging; remove this */
apply(r.nt.transformations[i], logical_form, transformed);
			return false;
		} else if (!get_unrecognized_terminals(terminal_indices, *syntax.children[i], transformed, left)) {
			free(transformed);
			return false;
		}
		free(transformed);
	}
	return true;
}

struct ambiguous_to_unknown_converter { };

template<hol_term_type Type, typename std::enable_if<Type == hol_term_type::ANY_CONSTANT_EXCEPT>::type* = nullptr>
inline hol_term* apply(hol_term* src, ambiguous_to_unknown_converter& converter) {
	HOL_UNKNOWN.reference_count++;
	return &HOL_UNKNOWN;
}

inline hol_term* ambiguous_to_unknown(hol_term* src)
{
	ambiguous_to_unknown_converter converter;
	hol_term* dst = apply(src, converter);
	if (dst == src)
		dst->reference_count++;
	return dst;
}

struct same_to_equals_converter { };

inline bool process_event_conjunct(
		unsigned int variable, hol_term* conjunct,
		hol_term*& arg1, hol_term*& arg2,
		hol_term*& arg1_of, hol_term*& arg2_of,
		hol_term*& predicate)
{
	if (conjunct->type == hol_term_type::EQUALS && conjunct->binary.left->type == hol_term_type::UNARY_APPLICATION
			&& conjunct->binary.left->binary.left->type == hol_term_type::CONSTANT
			&& conjunct->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG1
			&& conjunct->binary.left->binary.right->type == hol_term_type::VARIABLE
			&& conjunct->binary.left->binary.right->variable == variable)
	{
		arg1 = conjunct->binary.right;
	} else if (conjunct->type == hol_term_type::EQUALS && conjunct->binary.left->type == hol_term_type::UNARY_APPLICATION
			&& conjunct->binary.left->binary.left->type == hol_term_type::CONSTANT
			&& conjunct->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG2
			&& conjunct->binary.left->binary.right->type == hol_term_type::VARIABLE
			&& conjunct->binary.left->binary.right->variable == variable)
	{
		arg2 = conjunct->binary.right;
	} else if (conjunct->type == hol_term_type::EQUALS && conjunct->binary.left->type == hol_term_type::UNARY_APPLICATION
			&& conjunct->binary.left->binary.left->type == hol_term_type::CONSTANT
			&& conjunct->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG1_OF
			&& conjunct->binary.right->type == hol_term_type::VARIABLE
			&& conjunct->binary.right->variable == variable)
	{
		arg1_of = conjunct->binary.left->binary.right;
	} else if (conjunct->type == hol_term_type::EQUALS && conjunct->binary.left->type == hol_term_type::UNARY_APPLICATION
			&& conjunct->binary.left->binary.left->type == hol_term_type::CONSTANT
			&& conjunct->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG2_OF
			&& conjunct->binary.right->type == hol_term_type::VARIABLE
			&& conjunct->binary.right->variable == variable)
	{
		arg2_of = conjunct->binary.left->binary.right;
	} else if (conjunct->type == hol_term_type::UNARY_APPLICATION
			&& conjunct->binary.right->type == hol_term_type::VARIABLE && conjunct->binary.right->variable == variable)
	{
		if (conjunct->binary.left->type == hol_term_type::CONSTANT && is_tense_predicate(conjunct->binary.left->constant))
			return true;
		if (predicate != nullptr) return false;
		predicate = conjunct->binary.left;
	} else {
		return false;
	}
	return true;
}

template<hol_term_type Type, typename std::enable_if<Type == hol_term_type::EXISTS>::type* = nullptr>
inline hol_term* apply(hol_term* src, same_to_equals_converter& converter) {
	hol_term* operand = src->quantifier.operand;
	if (operand->type != hol_term_type::AND || operand->array.length != 4)
		return default_apply<Type>(src, converter);

	hol_term* arg1 = nullptr; hol_term* arg1_of = nullptr;
	hol_term* arg2 = nullptr; hol_term* arg2_of = nullptr;
	hol_term* predicate = nullptr;
	for (unsigned int i = 0; i < operand->array.length; i++) {
		if (!process_event_conjunct(src->quantifier.variable, operand->array.operands[i], arg1, arg2, arg1_of, arg2_of, predicate))
			return default_apply<Type>(src, converter);
	}

	if (arg1 == nullptr || arg2 == nullptr || arg1_of != nullptr || arg2_of != nullptr
	 || predicate->type != hol_term_type::CONSTANT || predicate->constant != (unsigned int) built_in_predicates::SAME)
		return default_apply<Type>(src, converter);

	hol_term* new_term = hol_term::new_equals(arg1, arg2);
	if (new_term == nullptr)
		return nullptr;
	arg1->reference_count++;
	arg2->reference_count++;
	return new_term;
}

inline hol_term* same_to_equals(hol_term* src)
{
	same_to_equals_converter converter;
	hol_term* dst = apply(src, converter);
	if (dst == src)
		dst->reference_count++;
	return dst;
}

struct exists_remover { };

template<hol_term_type Type, typename std::enable_if<Type == hol_term_type::EXISTS>::type* = nullptr>
inline hol_term* apply(hol_term* src, exists_remover& converter) {
	hol_term* operand = src->quantifier.operand;
	if (operand->type != hol_term_type::AND || operand->array.length != 3)
		return default_apply<Type>(src, converter);

	hol_term* arg1 = nullptr; hol_term* arg1_of = nullptr;
	hol_term* arg2 = nullptr; hol_term* arg2_of = nullptr;
	hol_term* predicate = nullptr;
	for (unsigned int i = 0; i < operand->array.length; i++) {
		if (!process_event_conjunct(src->quantifier.variable, operand->array.operands[i], arg1, arg2, arg1_of, arg2_of, predicate))
			return default_apply<Type>(src, converter);
	}

	if (arg1 == nullptr || arg2 != nullptr || arg1_of != nullptr || arg2_of != nullptr
	 || predicate->type != hol_term_type::CONSTANT || predicate->constant != (unsigned int) built_in_predicates::EXIST)
		return default_apply<Type>(src, converter);

	HOL_TRUE.reference_count++;
	return &HOL_TRUE;
}

inline hol_term* remove_exists(hol_term* src)
{
	exists_remover converter;
	hol_term* dst = apply(src, converter);
	if (dst == src)
		dst->reference_count++;
	return dst;
}

struct arg_of_to_arg_converter { };

template<hol_term_type Type, typename std::enable_if<Type == hol_term_type::EQUALS>::type* = nullptr>
inline hol_term* apply(hol_term* src, arg_of_to_arg_converter& converter) {
	if (src->binary.left->type == hol_term_type::UNARY_APPLICATION
	 && src->binary.left->binary.left->type == hol_term_type::CONSTANT)
	{
		unsigned int index = index_of(src->binary.left->binary.left->constant, ARGS_OF, array_length(ARGS_OF));
		if (index < array_length(ARGS_OF)) {
			hol_term* left = apply(src->binary.left->binary.right, converter);
			if (left == nullptr) return nullptr;
			hol_term* right = apply(src->binary.right, converter);
			if (right == nullptr) {
				if (left != src->binary.left->binary.right) { free(*left); if (left->reference_count == 0) free(left); }
				return nullptr;
			}

			hol_term* new_term = hol_term::new_equals(hol_term::new_apply(hol_term::new_constant(ARGS[index]), right), left);
			if (new_term == nullptr) {
				if (left != src->binary.left->binary.right) { free(*left); if (left->reference_count == 0) free(left); }
				if (right != src->binary.right) { free(*right); if (right->reference_count == 0) free(right); }
				return nullptr;
			}
			if (left == src->binary.left->binary.right) left->reference_count++;
			if (right == src->binary.right) right->reference_count++;
			return new_term;
		}
	} if (src->binary.right->type == hol_term_type::UNARY_APPLICATION
	   && src->binary.right->binary.left->type == hol_term_type::CONSTANT)
	{
		unsigned int index = index_of(src->binary.right->binary.left->constant, ARGS_OF, array_length(ARGS_OF));
		if (index < array_length(ARGS_OF)) {
			hol_term* right = apply(src->binary.right->binary.right, converter);
			if (right == nullptr) return nullptr;
			hol_term* left = apply(src->binary.left, converter);
			if (left == nullptr) {
				if (right != src->binary.right->binary.right) { free(*right); if (right->reference_count == 0) free(right); }
				return nullptr;
			}

			hol_term* new_term = hol_term::new_equals(right, hol_term::new_apply(hol_term::new_constant(ARGS[index]), left));
			if (new_term == nullptr) {
				if (right != src->binary.right->binary.right) { free(*right); if (right->reference_count == 0) free(right); }
				if (left != src->binary.left) { free(*left); if (left->reference_count == 0) free(left); }
				return nullptr;
			}
			if (right == src->binary.right->binary.right) right->reference_count++;
			if (left == src->binary.left) left->reference_count++;
			return new_term;
		}
	}
	return default_apply<Type>(src, converter);
}

inline hol_term* arg_of_to_arg(hol_term* src)
{
	arg_of_to_arg_converter converter;
	hol_term* dst = apply(src, converter);
	if (dst == src)
		dst->reference_count++;
	return dst;
}

struct tense_remover { };

template<hol_term_type Type, typename std::enable_if<Type == hol_term_type::UNARY_APPLICATION>::type* = nullptr>
inline hol_term* apply(hol_term* src, tense_remover& remover) {
	if (src->binary.left->type == hol_term_type::CONSTANT)
	{
		if (is_tense_predicate(src->binary.left->constant)) {
			HOL_TRUE.reference_count++;
			return &HOL_TRUE;
		}
	}
	return default_apply<Type>(src, remover);
}

inline hol_term* remove_tense(hol_term* src)
{
	tense_remover remover;
	hol_term* dst = apply(src, remover);
	if (dst == src)
		dst->reference_count++;
	return dst;
}

struct object_remover { };

template<hol_term_type Type, typename std::enable_if<Type == hol_term_type::UNARY_APPLICATION>::type* = nullptr>
inline hol_term* apply(hol_term* src, object_remover& remover) {
	if (src->binary.left->type == hol_term_type::CONSTANT
	 && (src->binary.left->constant == (unsigned int) built_in_predicates::OBJECT
	  || src->binary.left->constant == (unsigned int) built_in_predicates::ANIMATE))
	{
		HOL_TRUE.reference_count++;
		return &HOL_TRUE;
	}
	return default_apply<Type>(src, remover);
}

inline hol_term* remove_object(hol_term* src)
{
	object_remover remover;
	hol_term* dst = apply(src, remover);
	if (dst == src)
		dst->reference_count++;
	return dst;
}

struct inverse_remover { };

template<hol_term_type Type, typename std::enable_if<Type == hol_term_type::EXISTS>::type* = nullptr>
inline hol_term* apply(hol_term* src, inverse_remover& converter) {
	hol_term* operand = src->quantifier.operand;
	if (operand->type != hol_term_type::AND)
		return default_apply<Type>(src, converter);

	pair<hol_term*, unsigned int> arg1 = {nullptr, 0};
	pair<hol_term*, unsigned int> arg1_of = {nullptr, 0};
	pair<hol_term*, unsigned int> arg2 = {nullptr, 0};
	pair<hol_term*, unsigned int> arg2_of = {nullptr, 0};
	pair<hol_term*, unsigned int> predicate = {nullptr, 0};
	for (unsigned int i = 0; i < operand->array.length; i++) {
		bool found_arg1 = (arg1.key != nullptr);
		bool found_arg2 = (arg2.key != nullptr);
		bool found_arg1_of = (arg1_of.key != nullptr);
		bool found_arg2_of = (arg2_of.key != nullptr);
		bool found_predicate = (predicate.key != 0);
		if (process_event_conjunct(src->quantifier.variable, operand->array.operands[i], arg1.key, arg2.key, arg1_of.key, arg2_of.key, predicate.key)) {
			if (!found_arg1 && arg1.key != nullptr) arg1.value = i;
			if (!found_arg2 && arg2.key != nullptr) arg2.value = i;
			if (!found_arg1_of && arg1_of.key != nullptr) arg1_of.value = i;
			if (!found_arg2_of && arg2_of.key != nullptr) arg2_of.value = i;
			if (!found_predicate && predicate.key != nullptr) predicate.value = i;
		}
	}

	if (predicate.key == nullptr || predicate.key->type != hol_term_type::UNARY_APPLICATION
	 || predicate.key->binary.left->type != hol_term_type::CONSTANT
	 || predicate.key->binary.left->constant != (unsigned int) built_in_predicates::INVERSE)
		return default_apply<Type>(src, converter);

	hol_term** new_operands = (hol_term**) malloc(sizeof(hol_term*) * operand->array.length);
	if (new_operands == nullptr) {
		fprintf(stderr, "apply ERROR: Insufficient memory for `new_operands` array when removing inverse events.\n");
		return nullptr;
	}
	for (unsigned int i = 0; i < operand->array.length; i++) {
		hol_term* new_operand;
		if (i == predicate.value) {
			new_operand = hol_term::new_apply(predicate.key->binary.right, operand->array.operands[i]->binary.right);
			if (new_operand == nullptr) {
				for (unsigned int j = 0; j < i; j++) { free(*new_operands[j]); if (new_operands[j]->reference_count == 0) free(new_operands[j]); }
				free(new_operands); return nullptr;
			}
			predicate.key->binary.right->reference_count++;
			operand->array.operands[i]->binary.right->reference_count++;
		} else if (i == arg1.value) {
			new_operand = hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value, operand->array.operands[i]->binary.left->binary.right), arg1.key);
			if (new_operand == nullptr) {
				for (unsigned int j = 0; j < i; j++) { free(*new_operands[j]); if (new_operands[j]->reference_count == 0) free(new_operands[j]); }
				free(new_operands); return nullptr;
			}
			hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value.reference_count++;
			operand->array.operands[i]->binary.left->binary.right->reference_count++;
			arg1.key->reference_count++;
		} else if (i == arg2.value) {
			new_operand = hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG1>::value, operand->array.operands[i]->binary.left->binary.right), arg2.key);
			if (new_operand == nullptr) {
				for (unsigned int j = 0; j < i; j++) { free(*new_operands[j]); if (new_operands[j]->reference_count == 0) free(new_operands[j]); }
				free(new_operands); return nullptr;
			}
			hol_term::constants<(unsigned int) built_in_predicates::ARG1>::value.reference_count++;
			operand->array.operands[i]->binary.left->binary.right->reference_count++;
			arg2.key->reference_count++;
		} else if (i == arg1_of.value) {
			new_operand = hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG2_OF>::value, arg1_of.key), operand->array.operands[i]->binary.right);
			if (new_operand == nullptr) {
				for (unsigned int j = 0; j < i; j++) { free(*new_operands[j]); if (new_operands[j]->reference_count == 0) free(new_operands[j]); }
				free(new_operands); return nullptr;
			}
			hol_term::constants<(unsigned int) built_in_predicates::ARG2_OF>::value.reference_count++;
			arg1_of.key->reference_count++;
			operand->array.operands[i]->binary.right->reference_count++;
		} else if (i == arg2_of.value) {
			new_operand = hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG1_OF>::value, arg2_of.key), operand->array.operands[i]->binary.right);
			if (new_operand == nullptr) {
				for (unsigned int j = 0; j < i; j++) { free(*new_operands[j]); if (new_operands[j]->reference_count == 0) free(new_operands[j]); }
				free(new_operands); return nullptr;
			}
			hol_term::constants<(unsigned int) built_in_predicates::ARG1_OF>::value.reference_count++;
			arg2_of.key->reference_count++;
			operand->array.operands[i]->binary.right->reference_count++;
		} else {
			new_operand = apply(operand->array.operands[i], converter);
			if (new_operand == operand->array.operands[i])
				new_operand->reference_count++;
		}
		new_operands[i] = new_operand;
	}

	hol_term* new_term = hol_term::new_exists(src->quantifier.variable, hol_term::new_and(make_array_view(new_operands, operand->array.length)));
	if (new_term == nullptr) {
		for (unsigned int j = 0; j < operand->array.length; j++) { free(*new_operands[j]); if (new_operands[j]->reference_count == 0) free(new_operands[j]); }
		free(new_operands); return nullptr;
	}
	free(new_operands);
	return new_term;
}

inline hol_term* remove_inverse(hol_term* src)
{
	inverse_remover converter;
	hol_term* dst = apply(src, converter);
	if (dst == src)
		dst->reference_count++;
	return dst;
}

struct named_entity_collector {
	array<string>& named_entities;
};

template<hol_term_type Type>
inline bool visit(const hol_term& term, named_entity_collector& visitor) {
	if (Type == hol_term_type::EXISTS) {
		hol_term* operand = term.quantifier.operand;
		if (operand->type != hol_term_type::AND)
			return true;

		hol_term* arg1 = nullptr; hol_term* arg1_of = nullptr;
		hol_term* arg2 = nullptr; hol_term* arg2_of = nullptr;
		hol_term* predicate = nullptr;
		for (unsigned int i = 0; i < operand->array.length; i++) {
			if (!process_event_conjunct(term.quantifier.variable, operand->array.operands[i], arg1, arg2, arg1_of, arg2_of, predicate))
				return true;
		}

		if (arg2 == nullptr || predicate->type != hol_term_type::CONSTANT
		 || predicate->constant != (unsigned int) built_in_predicates::NAME || arg2->type != hol_term_type::STRING)
			return true;

		if (!visitor.named_entities.ensure_capacity(visitor.named_entities.length + 1)
		 || !init(visitor.named_entities[visitor.named_entities.length], arg2->str))
			return false;
		visitor.named_entities.length++;
	}
	return true;
}

inline bool get_named_entities(const hol_term& src, array<string>& named_entities) {
	named_entity_collector visitor = {named_entities};
	return visit(src, visitor);
}

struct set_operation_normalizer {
	array<unsigned int> variable_stack;

	set_operation_normalizer() : variable_stack(8) { }
};

template<hol_term_type Type, typename std::enable_if<Type == hol_term_type::UNARY_APPLICATION>::type* = nullptr>
inline hol_term* apply(hol_term* src, set_operation_normalizer& normalizer) {
	if (src->binary.left->type == hol_term_type::CONSTANT
	 && src->binary.left->constant == (unsigned int) built_in_predicates::SIZE
	 && src->binary.right->type == hol_term_type::CONSTANT)
	{
		unsigned int max_variable = normalizer.variable_stack[0];
		for (unsigned int i = 1; i < normalizer.variable_stack.length; i++)
			max_variable = max(max_variable, normalizer.variable_stack[i]);
		hol_term* new_term = hol_term::new_apply(src->binary.left, hol_term::new_lambda(max_variable + 1, hol_term::new_apply(src->binary.left, hol_term::new_variable(max_variable + 1))));
		if (new_term == nullptr)
			return nullptr;
		src->binary.left->reference_count += 2;
		return new_term;
	}
	return default_apply<Type>(src, normalizer);
}

template<hol_term_type Type, typename std::enable_if<Type == hol_term_type::BINARY_APPLICATION>::type* = nullptr>
inline hol_term* apply(hol_term* src, set_operation_normalizer& normalizer) {
	if (src->ternary.first->type == hol_term_type::CONSTANT
	 && src->ternary.first->constant == (unsigned int) built_in_predicates::SUBSET)
	{
		hol_term* antecedent;
		hol_term* consequent;

		unsigned int variable;
		if (src->ternary.second->type == hol_term_type::LAMBDA) {
			variable = src->ternary.second->quantifier.variable;

			/* check that the variable is not used in the consequent */
			if (src->ternary.third->type == hol_term_type::LAMBDA
			 && src->ternary.third->quantifier.variable != variable)
			{
				array<unsigned int> variables(8);
				if (!get_bound_variables(*src->ternary.third->quantifier.operand, variables))
					return nullptr;
				if (variables.contains(variable)) {
					/* we can't use the antecedent variable, so check if we can use the consequent variable */
					variable = src->ternary.third->quantifier.variable;
					if (!get_bound_variables(*src->ternary.second->quantifier.operand, variables))
						return nullptr;
					if (variables.contains(variable)) {
						/* we can't use either variable, so let's use a new one */
						variable = normalizer.variable_stack[0];
						for (unsigned int i = 1; i < normalizer.variable_stack.length; i++)
							variable = max(variable, normalizer.variable_stack[i]);
						for (unsigned int i = 0; i < variables.length; i++)
							variable = max(variable, variables[i]);
					}
				}
			}
		} else if (src->ternary.third->type == hol_term_type::LAMBDA) {
			variable = src->ternary.third->quantifier.variable;
		} else {
			/* neither antecedent or consequent are lambda expressions, so just use a new variable */
			variable = normalizer.variable_stack[0];
			for (unsigned int i = 1; i < normalizer.variable_stack.length; i++)
				variable = max(variable, normalizer.variable_stack[i]);
		}

		hol_term* dst_var = hol_term::new_variable(variable);
		if (dst_var == nullptr)
			return nullptr;

		if (src->ternary.second->type == hol_term_type::LAMBDA) {
			antecedent = src->ternary.second->quantifier.operand;
			if (src->ternary.second->quantifier.variable != variable) {
				hol_term* src_var = hol_term::new_variable(src->ternary.second->quantifier.variable);
				if (src_var == nullptr) {
					free(*dst_var); free(dst_var);
					return nullptr;
				}
				antecedent = substitute(antecedent, src_var, dst_var);
				free(*src_var); free(src_var);
				if (antecedent == nullptr) {
					free(*dst_var); free(dst_var);
					return nullptr;
				}
			} else {
				antecedent->reference_count++;
			}
		} else {
			antecedent = hol_term::new_apply(src->ternary.second, dst_var);
			src->ternary.second->reference_count++;
			dst_var->reference_count++;
		}

		if (src->ternary.third->type == hol_term_type::LAMBDA) {
			consequent = src->ternary.third->quantifier.operand;
			if (src->ternary.third->quantifier.variable != variable) {
				hol_term* src_var = hol_term::new_variable(src->ternary.third->quantifier.variable);
				if (src_var == nullptr) {
					free(*dst_var); free(dst_var);
					return nullptr;
				}
				consequent = substitute(consequent, src_var, dst_var);
				free(*src_var); free(src_var);
				if (consequent == nullptr) {
					free(*dst_var); free(dst_var);
					return nullptr;
				}
			} else {
				consequent->reference_count++;
			}
		} else {
			consequent = hol_term::new_apply(src->ternary.third, dst_var);
			src->ternary.third->reference_count++;
			dst_var->reference_count++;
		}

		free(*dst_var); if (dst_var->reference_count == 0) free(dst_var);
		hol_term* new_term = hol_term::new_for_all(variable, hol_term::new_if_then(antecedent, consequent));
		if (new_term == nullptr) {
			free(*antecedent); if (antecedent->reference_count == 0) free(antecedent);
			free(*consequent); if (consequent->reference_count == 0) free(consequent);
			return nullptr;
		}
		return new_term;
	}
	return default_apply<Type>(src, normalizer);
}

template<hol_term_type Type, typename std::enable_if<Type == hol_term_type::EXISTS || Type == hol_term_type::FOR_ALL || Type == hol_term_type::LAMBDA>::type* = nullptr>
inline hol_term* apply(hol_term* src, set_operation_normalizer& normalizer)
{
	normalizer.variable_stack.add(src->quantifier.variable);
	hol_term* result = default_apply<Type>(src, normalizer);

#if !defined(NDEBUG)
	if (normalizer.variable_stack.length == 0) {
		fprintf(stderr, "apply ERROR: Quantified term is not well-formed while normalizing set operations.\n");
		return result;
	}
#endif
	normalizer.variable_stack.length--;
	return result;
}

inline hol_term* normalize_set_operations(hol_term* src)
{
	set_operation_normalizer normalizer;
	hol_term* dst = apply(src, normalizer);
	if (dst == src)
		dst->reference_count++;
	return dst;
}

struct equality_quantifier_normalizer { };

template<hol_term_type Type, typename std::enable_if<Type == hol_term_type::EXISTS>::type* = nullptr>
inline hol_term* apply(hol_term* src, equality_quantifier_normalizer& normalizer) {
	hol_term* operand = src->quantifier.operand;
	if (operand->type != hol_term_type::AND) {
		hol_term* other = nullptr;
		if (operand->type == hol_term_type::EQUALS) {
			if (operand->binary.left->type == hol_term_type::VARIABLE && operand->binary.left->variable == src->quantifier.variable
			 && (operand->binary.right->type == hol_term_type::CONSTANT || operand->binary.right->type == hol_term_type::VARIABLE))
			{
				other = operand->binary.right;
			} else if (operand->binary.right->type == hol_term_type::VARIABLE && operand->binary.right->variable == src->quantifier.variable
					&& (operand->binary.left->type == hol_term_type::CONSTANT || operand->binary.left->type == hol_term_type::VARIABLE))
			{
				other = operand->binary.left;
			}
		}
		if (other != nullptr) {
			HOL_TRUE.reference_count++;
			return &HOL_TRUE;
		} else {
			return default_apply<Type>(src, normalizer);
		}
	} else {
		hol_term* var = nullptr;
		hol_term* substitution = nullptr;
		array<hol_term*> new_conjuncts(operand->array.length);
		for (unsigned int i = 0; i < operand->array.length; i++) {
			hol_term* conjunct = operand->array.operands[i];

			hol_term* other = nullptr;
			if (substitution == nullptr && conjunct->type == hol_term_type::EQUALS) {
				if (conjunct->binary.left->type == hol_term_type::VARIABLE && conjunct->binary.left->variable == src->quantifier.variable
				 && (conjunct->binary.right->type == hol_term_type::CONSTANT || conjunct->binary.right->type == hol_term_type::VARIABLE))
				{
					var = conjunct->binary.left;
					other = conjunct->binary.right;
				} else if (conjunct->binary.right->type == hol_term_type::VARIABLE && conjunct->binary.right->variable == src->quantifier.variable
						&& (conjunct->binary.left->type == hol_term_type::CONSTANT || conjunct->binary.left->type == hol_term_type::VARIABLE))
				{
					var = conjunct->binary.right;
					other = conjunct->binary.left;
				}
			}
			if (other == nullptr) {
				new_conjuncts[new_conjuncts.length] = apply(operand->array.operands[i], normalizer);
				if (new_conjuncts[new_conjuncts.length] == operand->array.operands[i])
					new_conjuncts[new_conjuncts.length]->reference_count++;
				new_conjuncts.length++;
			} else {
				if (other->type == hol_term_type::VARIABLE && other->variable == src->quantifier.variable)
					continue;
				substitution = other;
			}
		}

		if (new_conjuncts.length == 0) {
			HOL_TRUE.reference_count++;
			return &HOL_TRUE;
		}

		if (substitution == nullptr) {
			bool same_as_src = (new_conjuncts.length == operand->array.length);
			for (unsigned int i = 0; same_as_src && i < new_conjuncts.length; i++)
				if (new_conjuncts[i] != operand->array.operands[i]) same_as_src = false;
			if (same_as_src) {
				for (unsigned int i = 0; i < new_conjuncts.length; i++)
					free(*new_conjuncts[i]);
				return src;
			} else {
				hol_term* dst;
				if (new_conjuncts.length == 1) {
					dst = hol_term::new_exists(src->quantifier.variable, new_conjuncts[0]);
				} else {
					dst = hol_term::new_exists(src->quantifier.variable, hol_term::new_and(make_array_view(new_conjuncts.data, new_conjuncts.length)));
				}
				if (dst == nullptr) {
					free_all(new_conjuncts);
					return nullptr;
				}
				return dst;
			}
		}

		for (unsigned int i = 0; i < new_conjuncts.length; i++) {
			hol_term* substituted = substitute(new_conjuncts[i], var, substitution);
			if (substituted == nullptr) {
				free_all(new_conjuncts);
				return nullptr;
			}
			free(*new_conjuncts[i]); if (new_conjuncts[i]->reference_count == 0) free(new_conjuncts[i]);
			new_conjuncts[i] = substituted;
		}

		hol_term* dst;
		if (new_conjuncts.length == 1) {
			dst = new_conjuncts[0];
		} else {
			dst = hol_term::new_and(make_array_view(new_conjuncts.data, new_conjuncts.length));
		}
		if (dst == nullptr) {
			free_all(new_conjuncts);
			return nullptr;
		}
		return dst;
	}
}

inline hol_term* normalize_quantifiers_with_equality(hol_term* src)
{
	equality_quantifier_normalizer normalizer;
	hol_term* dst = apply(src, normalizer);
	if (dst == src)
		dst->reference_count++;
	return dst;
}

template<typename Semantics>
inline bool populate_inflected_terminals(
		rule<Semantics>& terminal,
		const unsigned int* sentence,
		unsigned int& position)
{
	if (terminal.t.inflected != nullptr)
		return true;

	terminal.t.inflected = (unsigned int*) malloc(sizeof(unsigned int) * terminal.t.length);
	if (terminal.t.inflected == nullptr) {
		fprintf(stderr, "populate_inflected_terminals ERROR: Out of memory.\n");
		return false;
	}
	for (unsigned int i = 0; i < terminal.t.length; i++)
		terminal.t.inflected[i] = sentence[position + i];
	terminal.t.inflected_length = terminal.t.length;
	position += terminal.t.length;
	return true;
}

template<typename Semantics>
bool populate_inflected_terminals(
		syntax_node<Semantics>& node,
		const unsigned int* sentence,
		unsigned int nonterminal,
		unsigned int& position)
{
	if (node.is_terminal())
		return populate_inflected_terminals(node.right, sentence, position);

	for (unsigned int i = 0; i < node.right.nt.length; i++) {
		if (!populate_inflected_terminals(*node.children[i], sentence, node.right.nt.nonterminals[i], position))
			return false;
	}
	return true;
}

template<typename Semantics>
inline bool populate_inflected_terminals(
		syntax_node<Semantics>& node,
		const unsigned int* sentence,
		unsigned int nonterminal = 1)
{
	unsigned int position = 0;
	return populate_inflected_terminals(node, sentence, nonterminal, position);
}

inline bool preprocess_sentence(
		sequence& seq, unsigned int LPAREN_ID, unsigned int RPAREN_ID,
		unsigned int COMMA_ID, unsigned int A_ID, unsigned int AN_ID,
		unsigned int* forbidden_tokens, unsigned int forbidden_token_count,
		hash_map<string, unsigned int>& names, string_map_scribe& terminal_printer)
{
	/* make sure there aren't any forbidden tokens */
	for (unsigned int i = 0; i < seq.length; i++) {
		if (index_of(seq[i], forbidden_tokens, forbidden_token_count) < forbidden_token_count)
			return false;
	}

	/* remove any comma that follows a number, and is succeeded by a three digit number */
	unsigned int curr = 0;
	for (unsigned int i = 0; i < seq.length; i++) {
		bool is_number = true;
		const string* str = terminal_printer.map[seq[i]];
		if (str->length > 3) { seq[curr++] = seq[i]; continue; }
		for (unsigned int j = 0; is_number && j < str->length; j++)
			if (!isdigit(str->data[j])) is_number = false;
		if (!is_number) { seq[curr++] = seq[i]; continue; }

		if (i + 1 == seq.length || seq[i + 1] != COMMA_ID) {
			seq[curr++] = seq[i];
			continue;
		}

		unsigned int next = i + 2;
		while (is_number) {
			const string* str = terminal_printer.map[seq[next]];
			if (str->length != 3) { is_number = false; break; }
			for (unsigned int j = 0; is_number && j < str->length; j++)
				if (!isdigit(str->data[j])) is_number = false;
			if (!is_number) break;

			next++;
			if (next == seq.length || seq[next] != COMMA_ID)
				/* we've found a valid comma-separated number */
				break;
			next++;
		}
		if (!is_number) { seq[curr++] = seq[i]; continue; }

		/* get the token of the non-comma separated number */
		string new_number(3 * ((next - i + 1) / 2));
		new_number.length = 0;
		for (unsigned int j = i; j < next; j += 2) {
			const string* str = terminal_printer.map[seq[j]];
			for (unsigned int k = 0; k < str->length; k++)
				new_number[new_number.length++] = str->data[k];
		}
		const string* old_keys = names.table.keys;
		unsigned int old_size = names.table.size;
		if (!get_token(new_number, seq[curr], names))
			return false;
		if (old_keys != names.table.keys || old_size != names.table.size) {
			free(terminal_printer.map);
			terminal_printer.map = invert(names);
			terminal_printer.length = names.table.size + 1;
			if (terminal_printer.map == nullptr)
				return false;
		}
		curr++;
		i = next - 1;
	}
	seq.length = curr;

	/* remove parentheses, and any comma that succeeds a right parenthesis */
	curr = 0;
	unsigned int parens = 0;
	for (unsigned int i = 0; i < seq.length; i++) {
		if (seq[i] == LPAREN_ID) {
			parens++;
		} else if (seq[i] == RPAREN_ID) {
			parens--;
		} else {
			if (parens == 0 && !(i > 0 && seq[i] == COMMA_ID && seq[i - 1] == RPAREN_ID))
				seq[curr++] = (seq[i] == AN_ID) ? A_ID : seq[i];
		}
	}
	seq.length = curr;
	return true;
}


/* forward declarations for `yield` */

template<bool First, typename Formula, typename PartOfSpeechType>
bool morphology_inflect(
		const morphology_en&, const sequence&, PartOfSpeechType,
		const flagged_logical_form<Formula>&, array<sequence>&);


struct generated_utterance {
	unsigned int*& tokens;
	unsigned int& length;
	unsigned int capacity;

	generated_utterance(sequence& seq) : tokens(seq.tokens), length(seq.length), capacity(16) {
		tokens = (unsigned int*) malloc(sizeof(unsigned int) * capacity);
		if (tokens == nullptr) {
			fprintf(stderr, "hdp_parser.generated_utterance ERROR: Out of memory.\n");
			exit(EXIT_FAILURE);
		}
		length = 0;
	}

	static inline void free(generated_utterance& utterance) {
		core::free(utterance.tokens);
	}
};

template<typename Semantics, typename Distribution>
inline bool yield(
		const rule<Semantics>& terminal,
		const Distribution& rule_distribution,
		const Semantics& logical_form,
		generated_utterance& utterance,
		const morphology_en& morph)
{
	array<sequence> inflections(8);
	sequence root(terminal.t.terminals, terminal.t.length);
	if ((utterance.length == 0 && !morphology_inflect<true>(morph, root, rule_distribution.get_part_of_speech(), logical_form, inflections))
	 || (utterance.length != 0 && !morphology_inflect<false>(morph, root, rule_distribution.get_part_of_speech(), logical_form, inflections))
	 || inflections.length == 0)
		return false;

	if (!ensure_capacity(utterance.tokens, utterance.capacity, utterance.length + inflections[0].length)) {
		for (sequence& inflection : inflections) free(inflection);
		return false;
	}
	memcpy(utterance.tokens + utterance.length, inflections[0].tokens, sizeof(inflections[0].tokens[0]) * inflections[0].length);
	utterance.length += inflections[0].length;
	for (sequence& inflection : inflections) free(inflection);
	return true;
}

enum class binding_state : uint_fast8_t {
	NOT_BOUND = 0,
	EXISTENTIAL,
	UNIVERSAL
};

struct anaphora_binder {
	const array_map<const hol_term*, const hol_term*>& assignments;
	array_map<unsigned int, hol_term*> variable_map;
	unsigned int variable_offset;

	pair<binding_state, bool>* binding_states;
	bool polarity;

	anaphora_binder(const array_map<const hol_term*, const hol_term*>& assignments, unsigned int variable_offset) :
			assignments(assignments), variable_map(8), variable_offset(variable_offset), polarity(true)
	{
		binding_states = (pair<binding_state, bool>*) calloc(assignments.size, sizeof(pair<binding_state, bool>));
		if (binding_states == nullptr)
			throw std::bad_alloc();
	}

	~anaphora_binder() {
		free(binding_states);
	}
};

template<hol_term_type Type>
inline hol_term* apply(hol_term* src, anaphora_binder& binder)
{
	pair<bool, bool>* old_binding_states = (pair<bool, bool>*) malloc(sizeof(pair<bool, bool>) * binder.assignments.size);
	if (old_binding_states == nullptr)
		return nullptr;
	for (unsigned int i = 0; i < binder.assignments.size; i++) {
		old_binding_states[i].key = (binder.binding_states[i].key != binding_state::NOT_BOUND);
		old_binding_states[i].value = binder.binding_states[i].value;
	}

	hol_term* result = nullptr;
	if (Type == hol_term_type::EXISTS || Type == hol_term_type::FOR_ALL || Type == hol_term_type::LAMBDA) {
		unsigned int index = index_of(src, binder.assignments.keys, binder.assignments.size);
		if (index < binder.assignments.size) {
			/* this is an anaphora scope */
			hol_term* new_variable = hol_term::new_variable(binder.variable_offset + index);
			if (new_variable == nullptr) {
				free(old_binding_states);
				return nullptr;
			} else if (!binder.variable_map.put(src->quantifier.variable, new_variable)) {
				free(old_binding_states);
				free(*new_variable); free(new_variable);
				return nullptr;
			}

			if (src->quantifier.operand->type != hol_term_type::AND) {
				fprintf(stderr, "apply ERROR: Expected anaphora scope operand to be a conjunction.\n");
				free(old_binding_states);
				return nullptr;
			}

			hol_term** new_operands = (hol_term**) malloc(sizeof(hol_term*) * src->quantifier.operand->array.length);
			unsigned int new_operand_count = 0;
			for (unsigned int i = 0; i < src->quantifier.operand->array.length; i++) {
				hol_term* operand = src->quantifier.operand->array.operands[i];
				if (operand->type == hol_term_type::UNARY_APPLICATION
				 && operand->binary.left->type == hol_term_type::CONSTANT
				 && (operand->binary.left->constant == (unsigned int) built_in_predicates::PLURAL_REF
				  || operand->binary.left->constant == (unsigned int) built_in_predicates::REF))
				{
					continue;
				}

				new_operands[new_operand_count] = apply(src->quantifier.operand->array.operands[i], binder);
				if (new_operands[new_operand_count] == nullptr) {
					for (unsigned int i = 0; i < new_operand_count; i++) {
						free(*new_operands[i]);
						if (new_operands[i]->reference_count == 0)
							free(new_operands[i]);
					}
					free(old_binding_states);
					return nullptr;
				}
				if (new_operands[new_operand_count] == src->quantifier.operand->array.operands[i])
					new_operands[new_operand_count]->reference_count++;
				new_operand_count++;
			}

			if (new_operand_count == 1) {
				result = new_operands[0];
				free(new_operands);
			} else {
				if (!new_hol_term(result)) {
					for (unsigned int i = 0; i < new_operand_count; i++) {
						free(*new_operands[i]);
						if (new_operands[i]->reference_count == 0)
							free(new_operands[i]);
					}
					free(old_binding_states);
					return nullptr;
				}
				result->type = hol_term_type::AND;
				result->reference_count = 1;
				result->array.operands = new_operands;
				result->array.length = new_operand_count;
			}

			binder.variable_map.size--;
			free(*new_variable); if (new_variable->reference_count == 0) free(new_variable);
			binder.binding_states[index].value = true;
		} else {
			index = index_of(src, binder.assignments.values, binder.assignments.size);
			if (index < binder.assignments.size) {
				/* this is a referent scope */
				hol_term* new_variable = hol_term::new_variable(binder.variable_offset + index);
				if (new_variable == nullptr) {
					free(old_binding_states);
					return nullptr;
				} else if (!binder.variable_map.put(src->quantifier.variable, new_variable)) {
					free(old_binding_states);
					free(*new_variable); free(new_variable);
					return nullptr;
				}

				result = apply(src->quantifier.operand, binder);
				if (result == nullptr) {
					free(old_binding_states);
					return nullptr;
				}

				binder.variable_map.size--;
				free(*new_variable); if (new_variable->reference_count == 0) free(new_variable);
				if (Type == hol_term_type::EXISTS) {
					binder.binding_states[index].key = (binder.polarity ? binding_state::EXISTENTIAL : binding_state::UNIVERSAL);
				} else {
					binder.binding_states[index].key = (binder.polarity ? binding_state::UNIVERSAL : binding_state::EXISTENTIAL);
				}
			}
		}
	} else if (Type == hol_term_type::VARIABLE) {
		bool contains;
		hol_term* new_variable = binder.variable_map.get(src->variable, contains);
		if (contains) {
			result = new_variable;
			new_variable->reference_count++;
		}
	} else if (Type == hol_term_type::NOT) {
		binder.polarity = !binder.polarity;
		result = default_apply<Type>(src, binder);
		if (result == nullptr) {
			free(old_binding_states);
			return nullptr;
		}
		binder.polarity = !binder.polarity;
	} else if (Type == hol_term_type::IF_THEN) {
		binder.polarity = !binder.polarity;
		hol_term* left = apply(src->binary.left, binder);
		if (left == nullptr) {
			free(old_binding_states);
			return nullptr;
		}
		binder.polarity = !binder.polarity;

		hol_term* right = apply(src->binary.right, binder);
		if (right == nullptr) {
			free(old_binding_states);
			if (left != src->binary.left) { free(*left); if (left->reference_count == 0) free(left); }
			return nullptr;
		}

		if (left == src->binary.left && right == src->binary.right) {
			result = src;
		} else {
			result = hol_term::new_if_then(left, right);
			if (result == nullptr) {
				free(old_binding_states);
				if (left != src->binary.left) { free(*left); if (left->reference_count == 0) free(left); }
				if (right != src->binary.right) { free(*right); if (right->reference_count == 0) free(right); }
				return nullptr;
			}
			if (left == src->binary.left) left->reference_count++;
			if (right == src->binary.right) right->reference_count++;
		}
	}

	if (result == nullptr) {
		result = default_apply<Type>(src, binder);
		if (result == nullptr) {
			free(old_binding_states);
			return nullptr;
		}
	}

	/* check if this is the most recent common ancestor scope of an anaphora and its referent */
	for (unsigned int i = 0; i < binder.assignments.size; i++) {
		if (!old_binding_states[i].key && !old_binding_states[i].value
		 && binder.binding_states[i].key != binding_state::NOT_BOUND
		 && binder.binding_states[i].value)
		{
			hol_term* new_scope;
			if (binder.binding_states[i].key == binding_state::EXISTENTIAL) {
				new_scope = hol_term::new_exists(binder.variable_offset + i, result);
			} else {
				new_scope = hol_term::new_for_all(binder.variable_offset + i, result);
			}
			if (new_scope == nullptr) {
				free(old_binding_states);
				if (result != src) { free(*result); if (result->reference_count == 0) free(result); }
				return nullptr;
			}
			if (result == src) result->reference_count++;
			result = new_scope;

			binder.binding_states[i].key = binding_state::NOT_BOUND;
			binder.binding_states[i].value = false;
		}
	}
	free(old_binding_states);
	return result;
}

inline hol_term* bind_anaphora(hol_term* src,
		const array_map<const hol_term*, const hol_term*>& anaphora_assignments,
		unsigned int new_variable_offset)
{
	anaphora_binder binder(anaphora_assignments, new_variable_offset);
	hol_term* dst = apply(src, binder);
	if (dst == nullptr) {
		for (auto entry : binder.variable_map) {
			free(*entry.value);
			if (entry.value->reference_count == 0)
				free(entry.value);
		}
	}
	if (dst == src)
		dst->reference_count++;
	return dst;
}

struct referent_iterator
{
	hol_term* logical_form;
	unsigned int max_variable;

	/* an array map of referents and their parent scopes */
	array_map<const hol_term*, const hol_term*> referents;

	array_map<const hol_term*, unsigned int> anaphora;

	static inline void free(referent_iterator& iterator) {
		core::free(iterator.anaphora);
		core::free(iterator.referents);
	}
};

inline bool init(referent_iterator& iterator, hol_term* logical_form) {
	if (!array_map_init(iterator.referents, 16)) {
		return false;
	} else if (!array_map_init(iterator.anaphora, 8)) {
		free(iterator.referents);
		return false;
	} else if (!max_bound_variable(*logical_form, iterator.max_variable)) {
		free(iterator.anaphora);
		free(iterator.referents);
		return false;
	}
	iterator.logical_form = logical_form;
	return true;
}

struct referent_iterator_state {
	const referent_iterator* iterator;
	unsigned int* indices;
	double log_probability;

	referent_iterator_state(const referent_iterator* iterator, double log_probability) :
			iterator(iterator), log_probability(log_probability)
	{
		indices = (unsigned int*) malloc(sizeof(unsigned int) * iterator->anaphora.size);
		if (indices == nullptr)
			throw std::bad_alloc();
	}

	referent_iterator_state(const referent_iterator_state& other) :
			iterator(other.iterator), log_probability(other.log_probability)
	{
		indices = (unsigned int*) malloc(sizeof(unsigned int) * iterator->anaphora.size);
		if (indices == nullptr)
			throw std::bad_alloc();
		for (unsigned int i = 0; i < iterator->anaphora.size; i++)
			indices[i] = other.indices[i];
	}

	~referent_iterator_state() {
		free(indices);
	}

	referent_iterator_state& operator = (referent_iterator_state const& other) = delete;
};

inline bool operator == (const referent_iterator_state& first, const referent_iterator_state& second) {
	if (first.iterator != second.iterator)
		return false;
	for (unsigned int i = 0; i < first.iterator->anaphora.size; i++) {
		if (first.indices[i] != second.indices[i])
			return false;
	}
	return true;
}

inline bool operator < (const referent_iterator_state& first, const referent_iterator_state& second) {
	return first.log_probability < second.log_probability;
}

bool process_referent_iterator(
		const referent_iterator_state& state,
		std::set<referent_iterator_state>& queue,
		hol_term** resolved_logical_forms,
		double* resolved_log_probabilities,
		unsigned int& resolved_logical_form_count)
{
	/* check that the anaphora don't point referents that share the same parent */
	bool has_illegal_anaphora = false;
	for (unsigned int i = 0; !has_illegal_anaphora && i < state.iterator->anaphora.size; i++) {
		bool contains;
		const hol_term* anaphora = state.iterator->anaphora.keys[i];
		unsigned int anaphora_start = state.iterator->anaphora.values[i];
		const hol_term* anaphora_parent = state.iterator->referents.get(anaphora, contains);
		if (!contains) continue;

		const hol_term* referent_parent = state.iterator->referents.values[anaphora_start - state.indices[i] - 1];
		if (anaphora_parent == referent_parent)
			has_illegal_anaphora = true;
	}

	/* check that no anaphora refers to another anaphora */
	for (unsigned int i = 0; !has_illegal_anaphora && i < state.iterator->anaphora.size; i++) {
		unsigned int anaphora_start = state.iterator->anaphora.values[i];
		const hol_term* referent = state.iterator->referents.keys[anaphora_start - state.indices[i] - 1];
		if (state.iterator->anaphora.contains(referent))
			has_illegal_anaphora = true;
	}

	if (!has_illegal_anaphora) {
		/* consider the case where there are no anaphora */
		if (state.iterator->anaphora.size == 0) {
			resolved_logical_forms[resolved_logical_form_count] = state.iterator->logical_form;
			resolved_log_probabilities[resolved_logical_form_count++] = state.log_probability;
			state.iterator->logical_form->reference_count++;
			return true;
		}

		/* resolve the logical form with the current anaphora assignment */
		array_map<const hol_term*, const hol_term*> assignment(state.iterator->anaphora.size);
		for (unsigned int i = 0; i < state.iterator->anaphora.size; i++) {
			unsigned int anaphora_start = state.iterator->anaphora.values[i];
			assignment.keys[i] = state.iterator->anaphora.keys[i];
			assignment.values[i] = state.iterator->referents.keys[anaphora_start - state.indices[i] - 1];
		}
		assignment.size = state.iterator->anaphora.size;

		hol_term* resolved_logical_form = bind_anaphora(state.iterator->logical_form, assignment, state.iterator->max_variable + 1);
		if (resolved_logical_form != nullptr) {
			resolved_logical_forms[resolved_logical_form_count] = resolved_logical_form;
			resolved_log_probabilities[resolved_logical_form_count++] = state.log_probability;
		}
	}

	for (unsigned int i = 0; i < state.iterator->anaphora.size; i++) {
		unsigned int anaphora_start = state.iterator->anaphora.values[i];
		if (state.indices[i] + 1 >= anaphora_start)
			/* there are no more referents for this anaphora to bind to */
			continue;

		referent_iterator_state new_state(state.iterator, state.log_probability - 1.0);
		for (unsigned int j = 0; j < state.iterator->anaphora.size; j++)
			new_state.indices[j] = state.indices[i];
		new_state.indices[i]++;

		queue.insert(new_state);
	}
	return true;
}

bool get_referents(const hol_term* logical_form,
		referent_iterator& iterator,
		array_map<unsigned int, const hol_term*>& bound_variables)
{
	if (logical_form->type == hol_term_type::EXISTS) {
		if (!iterator.referents.put(logical_form, nullptr))
			return false;
	}

	switch (logical_form->type) {
	case hol_term_type::VARIABLE:
	case hol_term_type::CONSTANT:
	case hol_term_type::PARAMETER:
	case hol_term_type::NUMBER:
	case hol_term_type::STRING:
	case hol_term_type::UINT_LIST:
	case hol_term_type::TRUE:
	case hol_term_type::FALSE:
		return true;
	case hol_term_type::EQUALS:
		if (logical_form->binary.left->type == hol_term_type::UNARY_APPLICATION
		 && logical_form->binary.left->binary.left->type == hol_term_type::CONSTANT
		 && (logical_form->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG1
		  || logical_form->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG2
		  || logical_form->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG3)
		 && logical_form->binary.left->binary.right->type == hol_term_type::VARIABLE)
		{
			const hol_term* scope = bound_variables.get(logical_form->binary.left->binary.right->variable);
			unsigned int index = iterator.referents.index_of(scope);
			if (index < iterator.referents.size) {
				shift_left(iterator.referents.keys + index, iterator.referents.size - index - 1);
				shift_left(iterator.referents.values + index, iterator.referents.size - index - 1);
				iterator.referents.size--;
				for (unsigned int i = 0; i < iterator.anaphora.size; i++) {
					if (iterator.anaphora.values[i] > index) {
						iterator.anaphora.values[i]--;
						if (iterator.anaphora.values[i] == 0)
							iterator.anaphora.remove_at(i--);
					}
				}
			}

			if (logical_form->binary.right->type == hol_term_type::VARIABLE) {
				/* `logical_form->binary.left->binary.right->variable` is the parent scope of `logical_form->binary.right->variable` */
				const hol_term* child_scope = bound_variables.get(logical_form->binary.right->variable);
				index = iterator.referents.index_of(child_scope);
				if (index < iterator.referents.size)
					iterator.referents.values[index] = scope;
			}
		} else if (logical_form->binary.left->type == hol_term_type::UNARY_APPLICATION
				&& logical_form->binary.left->binary.left->type == hol_term_type::CONSTANT
				&& (logical_form->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG1_OF
				 || logical_form->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG2_OF
				 || logical_form->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG3_OF)
				&& logical_form->binary.right->type == hol_term_type::VARIABLE)
		{
			const hol_term* scope = bound_variables.get(logical_form->binary.right->variable);
			unsigned int index = iterator.referents.index_of(scope);
			if (index < iterator.referents.size) {
				shift_left(iterator.referents.keys + index, iterator.referents.size - index - 1);
				shift_left(iterator.referents.values + index, iterator.referents.size - index - 1);
				iterator.referents.size--;
				for (unsigned int i = 0; i < iterator.anaphora.size; i++) {
					if (iterator.anaphora.values[i] > index) {
						iterator.anaphora.values[i]--;
						if (iterator.anaphora.values[i] == 0)
							iterator.anaphora.remove_at(i--);
					}
				}
			}

			if (logical_form->binary.left->binary.right->type == hol_term_type::VARIABLE) {
				/* `logical_form->binary.right->variable` is the parent scope of `logical_form->binary.left->binary.right->variable` */
				const hol_term* child_scope = bound_variables.get(logical_form->binary.left->binary.right->variable);
				index = iterator.referents.index_of(child_scope);
				if (index < iterator.referents.size)
					iterator.referents.values[index] = scope;
			}
		} else {
			return get_referents(logical_form->binary.left, iterator, bound_variables)
				&& get_referents(logical_form->binary.right, iterator, bound_variables);
		}
		return true;
	case hol_term_type::NOT:
		if (!get_referents(logical_form->unary.operand, iterator, bound_variables))
			return false;
		return true;
	case hol_term_type::AND:
	case hol_term_type::OR:
	case hol_term_type::IFF:
		for (unsigned int i = 0; i < logical_form->array.length; i++) {
			if (!get_referents(logical_form->array.operands[i], iterator, bound_variables))
				return false;
		}
		return true;
	case hol_term_type::FOR_ALL:
	case hol_term_type::EXISTS:
	case hol_term_type::LAMBDA:
		if (!bound_variables.put(logical_form->quantifier.variable, logical_form)
		 || !get_referents(logical_form->quantifier.operand, iterator, bound_variables))
			return false;
		bound_variables.size--;
		return true;
	case hol_term_type::IF_THEN:
	case hol_term_type::UNARY_APPLICATION:
		if (logical_form->type == hol_term_type::UNARY_APPLICATION
		 && logical_form->binary.left->type == hol_term_type::CONSTANT
		 && (logical_form->binary.left->constant == (unsigned int) built_in_predicates::REF
		  || logical_form->binary.left->constant == (unsigned int) built_in_predicates::PLURAL_REF)
		 && logical_form->binary.right->type == hol_term_type::VARIABLE)
		{
			if (iterator.referents.size > 1
			 && !iterator.anaphora.put(bound_variables.get(logical_form->binary.right->variable), iterator.referents.size - 1))
				return false;
		} else {
			return get_referents(logical_form->binary.left, iterator, bound_variables)
				&& get_referents(logical_form->binary.right, iterator, bound_variables);
		}
		return true;
	case hol_term_type::BINARY_APPLICATION:
		if (!get_referents(logical_form->ternary.first, iterator, bound_variables)
		 || !get_referents(logical_form->ternary.second, iterator, bound_variables)
		 || !get_referents(logical_form->ternary.third, iterator, bound_variables))
			return false;
		return true;
	case hol_term_type::VARIABLE_PREIMAGE:
	case hol_term_type::ANY:
	case hol_term_type::ANY_RIGHT:
	case hol_term_type::ANY_ARRAY:
	case hol_term_type::ANY_QUANTIFIER:
	case hol_term_type::ANY_CONSTANT:
	case hol_term_type::ANY_CONSTANT_EXCEPT:
	case hol_term_type::ANY_RIGHT_ONLY:
		return true;
	}
	fprintf(stderr, "get_referents ERROR: Unrecognized hol_term_type.\n");
	return false;
}

template<typename Formula>
struct hdp_parser
{
	typedef flagged_logical_form<Formula> logical_form_type;
	typedef sentence<rooted_syntax_node<flagged_logical_form<Formula>>> SentenceType;

	morphology_en morph;
	hdp_grammar_type<Formula> G;
	string_map_scribe terminal_printer;

	unsigned int LPAREN_ID;
	unsigned int RPAREN_ID;
	unsigned int COMMA_ID;
	unsigned int A_ID;
	unsigned int AN_ID;
	unsigned int ASTERISK_ID;
	unsigned int NONTERMINAL_NP_ID;
	unsigned int NONTERMINAL_V_ID;

	static constexpr const char* FORBIDDEN_TOKEN_STRS[] = { "{", "}", "[", "]", "<", ">", ":" };
	static constexpr unsigned int FORBIDDEN_TOKEN_COUNT = array_length(FORBIDDEN_TOKEN_STRS);

	unsigned int forbidden_token_ids[FORBIDDEN_TOKEN_COUNT];

	number_parser_en number_parser;

	hdp_parser(unsigned int unknown_id,
			hash_map<string, unsigned int>& names,
			const char* morphology_filepath,
			const char* grammar_filepath) : number_parser(names)
	{
		terminal_printer.map = nullptr;
		terminal_printer.length = 0;

		if (!get_token("(", LPAREN_ID, names) || !get_token(")", RPAREN_ID, names)
		 || !get_token(",", COMMA_ID, names) || !get_token("a", A_ID, names)
		 || !get_token("an", AN_ID, names) || !get_token("*", ASTERISK_ID, names))
			throw std::runtime_error("`get_token` failed.");

		for (unsigned int i = 0; i < FORBIDDEN_TOKEN_COUNT; i++)
			if (!get_token(FORBIDDEN_TOKEN_STRS[i], forbidden_token_ids[i], names))
				throw std::runtime_error("`get_token` failed.");

		printf("Loading morphology data...\n"); fflush(stdout);
		if (!morph.initialize(names)
		 || !morphology_read(morph, names, morphology_filepath))
		{
			fflush(stdout); fprintf(stderr, "\nERROR: Unable to initialize morphology model.\n");
			throw std::runtime_error("Unable to initialize morphology model.");
		}
		printf("Done loading morphology data.\n");

		printf("Loading grammar...\n"); fflush(stdout);
		if (!read_grammar(G, names, grammar_filepath)) {
			fflush(stdout); fprintf(stderr, "\nERROR: Unable to read grammar at '%s'.\n", grammar_filepath);
			throw std::runtime_error("Unable to read grammar file.");
		}
		printf("Done loading grammar.\n");

		bool contains;
		NONTERMINAL_NP_ID = G.nonterminal_names.get("NP", contains);
		if (!contains) {
			fflush(stdout); fprintf(stderr, "\nERROR: Grammar is missing nonterminal `NP`.\n");
			throw std::runtime_error("Grammar is missing nonterminal `NP`.");
		}

		NONTERMINAL_V_ID = G.nonterminal_names.get("V", contains);
		if (!contains) NONTERMINAL_V_ID = 0;
	}

	~hdp_parser() { free_helper(); }

	static inline void free(hdp_parser<Formula>& p) {
		p.free_helper();
		core::free(p.morph);
		core::free(p.G);
	}

	bool invert_name_map(hash_map<string, unsigned int>& names) {
		if (!init_capitalization_map(morph, names))
			return false;
		if (terminal_printer.map != NULL) core::free(terminal_printer.map);
		terminal_printer.map = invert(names);
		if (terminal_printer.map == NULL) return false;
		terminal_printer.length = names.table.size + 1;
		return true;
	}

	inline const string& map_to_string(unsigned int id) const {
		return *terminal_printer.map[id];
	}

	bool train(
			const array<array_map<SentenceType, flagged_logical_form<Formula>>>& data,
			hash_map<string, unsigned int>& names,
			unsigned int iteration_count)
	{
		if (!init_capitalization_map(morph, names))
			return false;
		terminal_printer.map = invert(names);
		terminal_printer.length = names.table.size + 1;
		const string** nonterminal_name_map = invert(G.nonterminal_names);
		if (terminal_printer.map == NULL || nonterminal_name_map == NULL) {
			if (terminal_printer.map != NULL) core::free(terminal_printer.map);
			terminal_printer.map = NULL;
			return false;
		}
		string_map_scribe nonterminal_printer = { nonterminal_name_map, G.nonterminal_names.table.size + 1 };
/* TODO: for debugging; remove this */
debug_terminal_printer = &terminal_printer;
debug_nonterminal_printer = &nonterminal_printer;
detect_duplicate_logical_forms = true;
		/* construct the initial derivation trees (running the parser with an empty grammar) */
		rooted_syntax_node<logical_form_type>** syntax = (rooted_syntax_node<logical_form_type>**)
				calloc(data.length, sizeof(rooted_syntax_node<logical_form_type>*));
		unsigned int* order = (unsigned int*) malloc(sizeof(unsigned int) * data.length);
		if (syntax == NULL || order == NULL) {
			fprintf(stderr, "hdp_parser.train ERROR: Out of memory.\n");
			cleanup(data, nonterminal_name_map, syntax, order);
			return false;
		}
		for (unsigned int i = 0; i < data.length; i++) {
			syntax[i] = (rooted_syntax_node<logical_form_type>*) calloc(data[i].size, sizeof(rooted_syntax_node<logical_form_type>));
			if (syntax[i] == NULL) {
				fprintf(stderr, "hdp_parser.train ERROR: Out of memory.\n");
				cleanup(data, nonterminal_name_map, syntax, order);
				return false;
			}
		}
		for (unsigned int i = 0; i < data.length; i++) order[i] = i;
#if defined(SHUFFLE_TRAINING_EXAMPLES)
		shuffle(order, (unsigned int) data.length);
#else
		reverse(order, (unsigned int) data.length);
#endif
		for (unsigned int i = 0; i < data.length; i++) {
			unsigned int id = order[i];
			for (unsigned int j = 0; j < data[id].size; j++) {
				/* TODO: add a discourse model instead of treating each sentence in each passage as independent */
				const logical_form_type& logical_form = data[id].values[j];
				if (!is_empty(data[id].keys[j].derivation)) {
					/* this sentence has a fully specified derivation tree */
					logical_form_type any(HOL_ANY);
					initialize_any(any.flags);
					bool test_equivalence = (data[id].keys[j].derivation.root != NONTERMINAL_V_ID);
					if (!is_parseable(*data[id].keys[j].derivation.tree, logical_form, G, morph, any, nonterminal_printer, terminal_printer, *this, data[id].keys[j].derivation.root, test_equivalence))
					{
						fprintf(stderr, "hdp_parser.train ERROR: Derivation for example %u, sentence %u is not parseable: '", id, j);
						print(data[id].keys[j], stderr, terminal_printer); print("'\n", stderr);
						print(logical_form, stderr, terminal_printer); print("\n", stderr);
						cleanup(data, nonterminal_name_map, syntax, order);
						return false;
					}
					syntax[id][j] = data[id].keys[j].derivation;
				} else {
					sequence& seq = *((sequence*) alloca(sizeof(sequence)));
					if (!init(seq, data[id].keys[j])) {
						cleanup(data, nonterminal_name_map, syntax, order);
						return false;
					} else if (!preprocess_sentence(seq, LPAREN_ID, RPAREN_ID, COMMA_ID, A_ID, AN_ID, forbidden_token_ids, FORBIDDEN_TOKEN_COUNT, names, terminal_printer)) {
						cleanup(data, nonterminal_name_map, syntax, order);
						core::free(seq); return false;
					}
					auto sentence = tokenized_sentence<logical_form_type>(seq);
					core::free(seq);
					syntax[id][j].tree = (syntax_node<logical_form_type>*) malloc(sizeof(syntax_node<logical_form_type>));
					/* NOTE: sample can set syntax[id] to null */
					if (syntax[id][j].tree == NULL || !sample(syntax[id][j].tree, G, logical_form, sentence, morph, *this, syntax[id][j].root) || syntax[id][j].tree == NULL)
					{
						fprintf(stderr, "hdp_parser.train ERROR: Unable to sample derivation for example %u, sentence %u: '", id, j);
						print(data[id].keys[j], stderr, terminal_printer); print("'\n", stderr);
						print(logical_form, stderr, terminal_printer); print("\n", stderr);
						cleanup(data, nonterminal_name_map, syntax, order);
						return false;
					}

					print(logical_form, stdout, terminal_printer); print('\n', stdout);
					print(*syntax[id][j].tree, stdout, nonterminal_printer, terminal_printer, syntax[id][j].root); print("\n\n", stdout);
					fflush(stdout);
				}

				if (!add_tree(syntax[id][j].root, *syntax[id][j].tree, logical_form, G)) {
					cleanup(data, nonterminal_name_map, syntax, order);
					return false;
				}
			}
		}

		/* perform MCMC */
		for (unsigned int t = 0; t < iteration_count; t++) {
			shuffle(order, (unsigned int) data.length);
			for (unsigned int i = 0; i < data.length; i++) {
				unsigned int id = order[i];
				for (unsigned int j = 0; j < data[id].size; j++) {
					if (!is_empty(data[id].keys[j].derivation))
						/* do not resample training examples labeled with derivation trees */
						continue;
					const logical_form_type& logical_form = data[id].values[j];
					sequence& seq = *((sequence*) alloca(sizeof(sequence)));
					unsigned int old_names_size = names.table.size;
					if (!init(seq, data[id].keys[j])) {
						cleanup(data, nonterminal_name_map, syntax, order);
						return false;
					} else if (!preprocess_sentence(seq, LPAREN_ID, RPAREN_ID, COMMA_ID, A_ID, AN_ID, forbidden_token_ids, FORBIDDEN_TOKEN_COUNT, names, terminal_printer)) {
						cleanup(data, nonterminal_name_map, syntax, order);
						core::free(seq); return false;
					} if (names.table.size != old_names_size) {
						core::free(terminal_printer.map);
						terminal_printer.map = invert(names);
						terminal_printer.length = names.table.size + 1;
						if (terminal_printer.map == nullptr) {
							cleanup(data, nonterminal_name_map, syntax, order);
							core::free(seq); return false;
						}
						terminal_printer = { terminal_printer.map, names.table.size + 1 };
					}
					auto sentence = tokenized_sentence<logical_form_type>(seq);
					core::free(seq);
					resample(syntax[id][j].tree, G, logical_form, sentence, morph, *this, syntax[id][j].root);
				}
			}
			sample_grammar(G);
			/*fprintf(stdout, "Unnormalized log posterior probability: %lf\n",
					log_probability(G, syntax, data, *this));

			if (t % 1 == 0) {
				fprintf(stdout, "[iteration %u]\n", t);
				print_nonterminal_hdps(G, stdout, terminal_printer, nonterminal_printer);
				fflush(stdout);
			}*/
		}

		/* cleanup */
		cleanup(data, nonterminal_name_map, syntax, order);
		return true;
	}

	template<unsigned int K>
	inline bool resolve_coreference(Formula** logical_forms, double* log_probabilities, unsigned int& parse_count)
	{
		if (parse_count == 0)
			return true;
		referent_iterator* iterators = (referent_iterator*) malloc(sizeof(referent_iterator) * parse_count);
		if (iterators == nullptr)
			return false;
		for (unsigned int i = 0; i < parse_count; i++) {
			if (!init(iterators[i], logical_forms[i])) {
				for (unsigned int j = 0; j < i; j++)
					core::free(iterators[j]);
				core::free(iterators);
				return false;
			}

			array_map<unsigned int, const hol_term*> bound_variables(8);
			if (!get_referents(logical_forms[i], iterators[i], bound_variables)) {
				for (unsigned int j = 0; j < i + 1; j++)
					core::free(iterators[j]);
				core::free(iterators);
				return false;
			}
		}

		std::set<referent_iterator_state> queue;
		for (unsigned int i = 0; i < parse_count; i++) {
			referent_iterator_state initial_state(&iterators[i], log_probabilities[i]);
			for (unsigned int j = 0; j < iterators[i].anaphora.size; j++)
				initial_state.indices[j] = 0;
			queue.insert(initial_state);
		}

		Formula* resolved_formulas[K];
		double resolved_log_probabilities[K];
		unsigned int resolved_formula_count = 0;
		while (!queue.empty()) {
			auto last = queue.cend(); last--;
			referent_iterator_state state = *last;
			queue.erase(last);

			process_referent_iterator(state, queue, resolved_formulas, resolved_log_probabilities, resolved_formula_count);
			if (resolved_formula_count == K)
				break;
		}

		for (unsigned int i = 0; i < parse_count; i++) {
			core::free(*logical_forms[i]); if (logical_forms[i]->reference_count == 0) core::free(logical_forms[i]);
		} for (unsigned int i = 0; i < resolved_formula_count; i++) {
			logical_forms[i] = resolved_formulas[i];
			log_probabilities[i] = resolved_log_probabilities[i];
		}
		parse_count = resolved_formula_count;
		return true;
	}

	template<unsigned int K, typename TheoryType>
	bool parse(const SentenceType& s,
			Formula** logical_forms, double* log_probabilities,
			unsigned int& parse_count, const TheoryType& T,
			array<array<sentence_token>>& unrecognized,
			hash_map<string, unsigned int>& names)
	{
		static_assert(K > 0, "`K` must be at least 1.");
#if !defined(NDEBUG)
		if (terminal_printer.map == NULL) {
			fprintf(stderr, "hdp_parser.parse ERROR: `hdp_parser.invert_name_map` must be called before `hdp_parser.parse`.\n");
			return false;
		}
#endif

		logical_form_type logical_form(HOL_ANY);
		syntax_node<logical_form_type>* parsed_syntax =
				(syntax_node<logical_form_type>*) alloca(K * sizeof(syntax_node<logical_form_type>));
		logical_form_type* logical_form_output =
				(logical_form_type*) alloca(K * sizeof(logical_form_type));
		sequence& seq = *((sequence*) alloca(sizeof(sequence)));
		if (!init(seq, s)) {
			return false;
		} else if (!preprocess_sentence(seq, LPAREN_ID, RPAREN_ID, COMMA_ID, A_ID, AN_ID, forbidden_token_ids, FORBIDDEN_TOKEN_COUNT, names, terminal_printer)) {
			core::free(seq);
			return false;
		}
		auto sentence = tokenized_sentence<logical_form_type>(seq);

/* TODO: for debugging; remove this */
const string** nonterminal_name_map = invert(G.nonterminal_names);
string_map_scribe nonterminal_printer = { nonterminal_name_map, G.nonterminal_names.table.size + 1 };
debug_terminal_printer = &terminal_printer;
debug_nonterminal_printer = &nonterminal_printer;
debug_flag = true;
		if (!::parse<false, false, K>(parsed_syntax, parse_count,
				logical_form, logical_form_output, G, sentence, morph, *this))
		{
/* TODO: for debugging; remove this */
core::free(nonterminal_name_map);
			core::free(seq);
			return false;
		}

		array<pair<unsigned int, unsigned int>> ambiguous_terminal_indices(8);
		for (unsigned int i = 0; i < parse_count; i++) {
/* TODO: for debugging; remove this */
print(CONSOLE_BOLD "Parse result ", stdout); print(i, stdout); print(":\n" CONSOLE_RESET, stdout);
print(logical_form_output[i], stdout, terminal_printer); print('\n', stdout);
print(parsed_syntax[i], stdout, nonterminal_printer, terminal_printer, logical_form_output[i]); print("\n\n", stdout); fflush(stdout);
			double log_likelihood = log_probability(G, parsed_syntax[i], logical_form_output[i], *this);
			/* TODO: compute this prior */
			double log_prior = 0.0; //log_probability<true>(T, logical_form_output[i]);
			log_probabilities[i] = log_likelihood + log_prior;

			if (i == 0) {
				unsigned int left = 0;
				if (!get_unrecognized_terminals(ambiguous_terminal_indices, parsed_syntax[i], logical_form_output[i], left)
				 || !unrecognized.ensure_capacity(ambiguous_terminal_indices.length))
				{
					fprintf(stderr, "hdp_parser.parse ERROR: Unable to retrieve unrecognized terminals. This"
							" is likely due to a bug in a transformation function in the derivation tree.\n");
					for (unsigned int j = 0; j < i; j++) {
						core::free(*logical_forms[j]); core::free(logical_forms[j]);
					} for (unsigned int j = 0; j < parse_count; j++) {
						core::free(parsed_syntax[j]);
						core::free(logical_form_output[j]);
					}
/* TODO: for debugging; remove this */
core::free(nonterminal_name_map);
					core::free(seq);
					return false;
				}

#if !defined(NDEBUG)
				if (!populate_inflected_terminals(parsed_syntax[i], seq.tokens)
				 || !is_parseable(parsed_syntax[i], logical_form_output[i], G, morph, logical_form_output[i], nonterminal_printer, terminal_printer, *this))
					fprintf(stderr, "hdp_parser.parse WARNING: Top logical form output is not parseable. This"
							" is likely due to a bug in a transformation function in the derivation tree.\n");
#endif
			}

			logical_forms[i] = ambiguous_to_unknown(logical_form_output[i].root);
			if (logical_forms[i] == NULL) {
				fprintf(stderr, "hdp_parser.parse ERROR: Out of memory.\n");
				for (unsigned int j = 0; j < i; j++) {
					core::free(*logical_forms[j]); core::free(logical_forms[j]);
				} for (unsigned int j = 0; j < parse_count; j++) {
					core::free(parsed_syntax[j]);
					core::free(logical_form_output[j]);
				}
/* TODO: for debugging; remove this */
core::free(nonterminal_name_map);
				core::free(seq);
				return false;
			}
		}
		core::free(seq);
/* TODO: for debugging; remove this */
core::free(nonterminal_name_map);

		for (pair<unsigned int, unsigned int> index : ambiguous_terminal_indices) {
			array<sentence_token>& next_unknown_string = unrecognized[unrecognized.length];
			if (!array_init(next_unknown_string, index.value)) {
				for (array<sentence_token>& str : unrecognized) core::free(str);
				unrecognized.clear();
				for (unsigned int j = 0; j < parse_count; j++) {
					core::free(*logical_forms[j]); core::free(logical_forms[j]);
					core::free(parsed_syntax[j]);
					core::free(logical_form_output[j]);
				}
				return false;
			}
			unrecognized.length++;

			for (unsigned int i = 0; i < index.value; i++)
				next_unknown_string[i] = { s.tokens[index.key + i] };
			next_unknown_string.length = index.value;
		}

		for (unsigned int j = 0; j < parse_count; j++) {
			core::free(parsed_syntax[j]);
			core::free(logical_form_output[j]);
		}

		/* perform coreference resolution */
		if (!resolve_coreference<K>(logical_forms, log_probabilities, parse_count)) {
			for (array<sentence_token>& str : unrecognized) core::free(str);
			unrecognized.clear();
			for (unsigned int j = 0; j < parse_count; j++) {
				core::free(*logical_forms[j]); core::free(logical_forms[j]);
			}
			return false;
		}

		return true;
	}

	bool add_definition(const SentenceType& s, Formula* definition,
			unsigned int new_constant, hash_map<string, unsigned int>& names)
	{
#if !defined(NDEBUG)
		if (terminal_printer.map == NULL) {
			fprintf(stderr, "hdp_parser.parse ERROR: `hdp_parser.invert_name_map` must be called before `hdp_parser.add_definition`.\n");
			return false;
		}
#endif

		/* first replace `unknown` in `definition` with `new_constant` */
		hol_term* constant = hol_term::new_constant(new_constant);
		if (constant == nullptr)
			return false;
		hol_term* new_definition = substitute(definition, &HOL_UNKNOWN, constant);
		core::free(*constant); if (constant->reference_count == 0) core::free(constant);
		if (new_definition == nullptr)
			return false;

		const logical_form_type logical_form(*new_definition);
		core::free(*new_definition); if (new_definition->reference_count == 0) core::free(new_definition);
		sequence& seq = *((sequence*) alloca(sizeof(sequence)));
		if (!init(seq, s)) {
			return false;
		} else if (!preprocess_sentence(seq, LPAREN_ID, RPAREN_ID, COMMA_ID, A_ID, AN_ID, forbidden_token_ids, FORBIDDEN_TOKEN_COUNT, names, terminal_printer)) {
			core::free(seq);
			return false;
		}
		auto sentence = tokenized_sentence<logical_form_type>(seq);
		core::free(seq);

		const string** nonterminal_name_map = invert(G.nonterminal_names);
		if (nonterminal_name_map == nullptr)
			return false;
		string_map_scribe nonterminal_printer = { nonterminal_name_map, G.nonterminal_names.table.size + 1 };
		auto printer = get_printer(terminal_printer);
debug_terminal_printer = &printer;
debug_nonterminal_printer = &nonterminal_printer;

		syntax_node<logical_form_type>* syntax = (syntax_node<logical_form_type>*) malloc(sizeof(syntax_node<logical_form_type>));
		/* NOTE: sample can set syntax.tree to null */
		print("Training with new labeled sentence:\n", stdout);
		print("  Sentence: '", stdout); print(s, stdout, printer); print("'\n", stdout);
		print("  Logical form: ", stdout); print(logical_form, stdout, printer); print("\n", stdout);
		if (syntax == NULL || !sample(syntax, G, logical_form, sentence, morph, *this) || syntax == NULL)
		{
			fprintf(stderr, "hdp_parser.add_definition ERROR: Unable to sample derivation for new sentence.\n");
			core::free(nonterminal_name_map); return false;
		}
		print(*syntax, stdout, nonterminal_printer, printer, 1); print("\n\n", stdout);
		fflush(stdout);
		core::free(nonterminal_name_map);

		if (!add_tree(1, *syntax, logical_form, G)) {
			core::free(*syntax); core::free(syntax);
			return false;
		}
		core::free(*syntax); core::free(syntax);

		/* TODO: do some MCMC iterations */
		return true;
	}

	template<unsigned int K>
	inline bool generate(
			syntax_node<logical_form_type>* generated_derivations,
			double* log_likelihoods,
			unsigned int& generated_derivation_count,
			Formula* logical_form,
			hash_map<string, unsigned int>& names)
	{
#if !defined(NDEBUG)
		if (terminal_printer.map == NULL) {
			fprintf(stderr, "hdp_parser.parse ERROR: `hdp_parser.invert_name_map` must be called before `hdp_parser.add_definition`.\n");
			return false;
		}
#endif

const string** nonterminal_name_map = invert(G.nonterminal_names);
string_map_scribe nonterminal_printer = { nonterminal_name_map, G.nonterminal_names.table.size + 1 };
debug_terminal_printer = &terminal_printer;
debug_nonterminal_printer = &nonterminal_printer;
		const logical_form_type root_logical_form(*logical_form);
		bool result = ::generate<K>(generated_derivations, generated_derivation_count, root_logical_form, G, morph, names);
core::free(nonterminal_name_map);
		if (names.table.size >= terminal_printer.length) {
			core::free(terminal_printer.map);
			terminal_printer.map = invert(names);
			if (terminal_printer.map == nullptr) {
				for (unsigned int i = 0; i < generated_derivation_count; i++)
					core::free(generated_derivations[i]);
				return false;
			}
			terminal_printer.length = names.table.size + 1;
		}
		for (unsigned int i = 0; i < generated_derivation_count; i++) {
			double log_likelihood = log_probability(G, generated_derivations[i], root_logical_form, *this);
			log_likelihoods[i] = log_likelihood;
		}
		return result;
	}

	inline bool yield(
			const syntax_node<logical_form_type>& derivation,
			Formula* logical_form, sequence& output_sentence,
			unsigned int nonterminal = 1)
	{
		generated_utterance utterance(output_sentence);
		const logical_form_type root_logical_form(*logical_form);
		return ::yield(G, derivation, nonterminal, root_logical_form, get_printer(terminal_printer), utterance, morph);
	}

	inline bool yield_search_query(
			const syntax_node<logical_form_type>& derivation,
			Formula* logical_form, sequence& output_sentence) const
	{
		if (logical_form->type != hol_term_type::LAMBDA) {
			fprintf(stderr, "hdp_parser.yield_search_query ERROR: `logical_form` is not a lambda expression.");
			return false;
		}

		const logical_form_type root_logical_form(*logical_form);
		generated_utterance utterance(output_sentence);
		bool is_interrogative;
		return yield_search_query(derivation, 1, root_logical_form, terminal_printer, utterance, morph, logical_form->quantifier.variable, is_interrogative);
	}

	template<typename Printer>
	constexpr Printer& get_printer(Printer& constant_printer) const {
		return constant_printer;
	}

	const string_map_scribe& get_printer() const {
		return terminal_printer;
	}

	const string** reverse_string_map() const {
		return terminal_printer.map;
	}

private:
	template<typename Semantics, typename Printer>
	bool yield_search_query(
			const syntax_node<Semantics>& node,
			unsigned int nonterminal,
			const Semantics& logical_form,
			Printer& printer,
			generated_utterance& utterance,
			const morphology_en& morph,
			unsigned int query_variable,
			bool& is_interrogative) const
	{
		if (node.is_terminal()) {
			is_interrogative = false;
			hol_term* term = logical_form.root;
			while (term->type == hol_term_type::LAMBDA) {
				if (term->quantifier.variable == query_variable) {
					is_interrogative = true;
					break;
				}
				term = term->quantifier.operand;
			}

			return ::yield(node.right, G.nonterminals[nonterminal - 1].rule_distribution, logical_form, utterance, morph);
		}

		for (unsigned int i = 0; i < node.right.nt.length; i++) {
			Semantics transformed;
			if (!apply(node.right.nt.transformations[i], logical_form, transformed)) {
				print("yield ERROR: Unable to apply semantic transformation '", stderr);
				print(node.right.nt.transformations[i], stderr); print("' to logical form:\n", stderr);
				print(logical_form, stderr, printer); print('\n', stderr); return false;
			}

			/* check if the interrogative phrase is in this child subtree */
			bool could_child_be_interrogative = false;
			hol_term* term = transformed.root;
			while (term->type == hol_term_type::LAMBDA) {
				if (term->quantifier.variable == query_variable) {
					could_child_be_interrogative = true;
					break;
				}
				term = term->quantifier.operand;
			}

			if (could_child_be_interrogative) {
				bool is_child_interrogative = false;
				unsigned int old_length = utterance.length;
				if (!yield_search_query(*node.children[i], node.right.nt.nonterminals[i], transformed, printer, utterance, morph, query_variable, is_child_interrogative))
					return false;
				if (node.right.nt.nonterminals[i] == NONTERMINAL_NP_ID && is_child_interrogative) {
					/* we found the interrogative noun phrase, so replace it with `*` */
					utterance.tokens[old_length] = ASTERISK_ID;
					utterance.length = old_length + 1;
					is_interrogative = false;
				} else if (is_child_interrogative) {
					is_interrogative = true;
				}
			} else {
				if (!::yield(G, *node.children[i], node.right.nt.nonterminals[i], transformed, printer, utterance, morph))
					return false;
			}
		}
		return true;
	}

	void cleanup(
			const array<array_map<SentenceType, flagged_logical_form<Formula>>>& data,
			const string** nonterminal_name_map, rooted_syntax_node<logical_form_type>** syntax, unsigned int* order)
	{
		if (syntax != NULL) {
			for (unsigned int k = 0; k < data.length; k++) {
				if (syntax[k] == NULL) continue;
				for (unsigned int l = 0; l < data[k].size; l++)
					if (!is_empty(syntax[k][l])) core::free(syntax[k][l]);
				core::free(syntax[k]);
			}
			core::free(syntax);
		}
		if (order != NULL) core::free(order);
		if (terminal_printer.map != NULL) core::free(terminal_printer.map);
		if (nonterminal_name_map != NULL) core::free(nonterminal_name_map);
		terminal_printer.map = NULL;
	}

	inline void free_helper() {
		if (terminal_printer.map != nullptr)
			core::free(terminal_printer.map);
	}
};

template<typename Formula>
constexpr const char* hdp_parser<Formula>::FORBIDDEN_TOKEN_STRS[];

template<typename Formula>
bool init(hdp_parser<Formula>& dst, const hdp_parser<Formula>& src)
{
	dst.LPAREN_ID = src.LPAREN_ID;
	dst.RPAREN_ID = src.RPAREN_ID;
	dst.COMMA_ID = src.COMMA_ID;
	dst.A_ID = src.A_ID;
	dst.AN_ID = src.AN_ID;
	dst.ASTERISK_ID = src.ASTERISK_ID;
	dst.NONTERMINAL_NP_ID = src.NONTERMINAL_NP_ID;
	dst.NONTERMINAL_V_ID = src.NONTERMINAL_V_ID;
	for (unsigned int i = 0; i < array_length(src.forbidden_token_ids); i++)
		dst.forbidden_token_ids[i] = src.forbidden_token_ids[i];
	dst.number_parser = src.number_parser;

	dst.terminal_printer.map = nullptr;
	dst.terminal_printer.length = 0;

	if (!init(dst.morph, src.morph)) {
		return false;
	} else if (!copy(src.G, dst.G)) {
		free(dst.morph);
		return false;
	}
	return true;
}

/* Computes the log joint probability of the grammar and given derivations */
template<typename Formula>
double log_probability(
	hdp_grammar_type<Formula>& G,
	const rooted_syntax_node<flagged_logical_form<Formula>>* const* syntax,
	const array<array_map<typename hdp_parser<Formula>::SentenceType, flagged_logical_form<Formula>>>& data,
	const hdp_parser<Formula>& parser)
{
	typedef flagged_logical_form<Formula> logical_form_type;

	double score = 0.0;
	for (unsigned int i = 0; i < G.nonterminals.length; i++)
		score += log_probability(G.nonterminals[i].rule_distribution);
	for (unsigned int i = 0; i < data.length; i++) {
		for (unsigned int j = 0; j < data[i].size; j++) {
			const logical_form_type& logical_form = data[i].values[j];
			score += log_probability(G, *syntax[i][j].tree, logical_form, parser, syntax[i][j].root);
		}
	}
	return score;
}

template<typename Formula>
inline bool is_ambiguous(const flagged_logical_form<Formula>& exp) {
	return is_ambiguous(*exp.root);
}

template<typename BuiltInPredicates>
struct hol_tense_constants {
	hol_term* constants;

	hol_tense_constants() {
		constants = hol_term::new_any_constant(make_array_view(TENSE_PREDICATES, array_length(TENSE_PREDICATES)));
	}

	~hol_tense_constants() {
		free(*constants); if (constants->reference_count == 0) free(constants);
	}

	static inline hol_tense_constants<BuiltInPredicates>& get() {
		static thread_local hol_tense_constants<BuiltInPredicates> constants;
		return constants;
	}
};

template<typename BuiltInPredicates>
struct hol_non_head_constants {
	static const unsigned int CONSTANTS[];
	static constexpr unsigned int CONSTANT_COUNT = array_length(CONSTANTS);

	hol_term* constants;

	hol_non_head_constants() {
		constants = hol_term::new_any_constant(make_array_view(CONSTANTS, CONSTANT_COUNT));
	}

	~hol_non_head_constants() {
		free(*constants);
		if (constants->reference_count == 0)
			free(constants);
	}

	static inline hol_non_head_constants<BuiltInPredicates>& get() {
		static thread_local hol_non_head_constants<BuiltInPredicates> constants;
		return constants;
	}

	static inline hol_term** get_terms() {
		return &get().constants;
	}

	static inline void increment_terms() {
		get().constants->reference_count++;
	}

	static inline constexpr unsigned int count() {
		return 1;
	}
};

template<typename BuiltInPredicates>
const unsigned int hol_non_head_constants<BuiltInPredicates>::CONSTANTS[] =  {
	(unsigned int) BuiltInPredicates::UNKNOWN,
	(unsigned int) BuiltInPredicates::ARG1,
	(unsigned int) BuiltInPredicates::ARG2,
	(unsigned int) BuiltInPredicates::ARG3,
	(unsigned int) BuiltInPredicates::ARG1_OF,
	(unsigned int) BuiltInPredicates::ARG2_OF,
	(unsigned int) BuiltInPredicates::ARG3_OF,
	(unsigned int) BuiltInPredicates::SIZE,
	(unsigned int) BuiltInPredicates::PRESENT,
	(unsigned int) BuiltInPredicates::PRESENT_PROGRESSIVE,
	(unsigned int) BuiltInPredicates::PRESENT_PERFECT,
	(unsigned int) BuiltInPredicates::PRESENT_PERFECT_PROGRESSIVE,
	(unsigned int) BuiltInPredicates::PAST,
	(unsigned int) BuiltInPredicates::PAST_PROGRESSIVE,
	(unsigned int) BuiltInPredicates::PAST_PERFECT,
	(unsigned int) BuiltInPredicates::PAST_PERFECT_PROGRESSIVE,
	(unsigned int) BuiltInPredicates::FUTURE,
	(unsigned int) BuiltInPredicates::FUTURE_PROGRESSIVE,
	(unsigned int) BuiltInPredicates::FUTURE_PERFECT,
	(unsigned int) BuiltInPredicates::FUTURE_PERFECT_PROGRESSIVE,
	(unsigned int) BuiltInPredicates::WIDE_SCOPE
};

template<typename BuiltInPredicates>
inline bool is_built_in(unsigned int constant) {
	return index_of(constant, hol_non_head_constants<BuiltInPredicates>::CONSTANTS, array_length(hol_non_head_constants<BuiltInPredicates>::CONSTANTS)) < array_length(hol_non_head_constants<BuiltInPredicates>::CONSTANTS);
}

template<typename BuiltInPredicates>
inline hol_term* get_predicate_of_literal(
		hol_term* src, unsigned int scope_variable)
{
	if (src->type == hol_term_type::UNARY_APPLICATION
	 && src->binary.right->type == hol_term_type::VARIABLE
	 && src->binary.right->variable == scope_variable
	 && src->binary.left->type == hol_term_type::CONSTANT
	 && !is_built_in<BuiltInPredicates>(src->binary.left->constant))
	{
		return src;
	}
	return nullptr;
}

inline hol_term* get_variable_definition_of_literal(
		hol_term* src, unsigned int scope_variable)
{
	if (src->type == hol_term_type::UNARY_APPLICATION
	 && src->binary.left->type == hol_term_type::VARIABLE
	 && src->binary.left->variable == scope_variable)
	{
		return src;
	}
	return nullptr;
}

enum class head_position {
	NONE = 0,
	LEFT,
	RIGHT,
	ANY
};

struct head_index {
	head_position position;
	unsigned int index;

	inline bool compare(int conjunct_index) const {
		if (position == head_position::LEFT && conjunct_index >= 0) {
			return index == (unsigned int) conjunct_index;
		} else if (position == head_position::RIGHT && conjunct_index < 0) {
			return index == (unsigned int) (-conjunct_index) - 1;
		}
		return false;
	}
};

template<typename BuiltInPredicates, unsigned int ScopePredicate>
hol_term* get_scope(hol_term* conjunct, unsigned int head_variable) {
	if (conjunct->type != hol_term_type::EXISTS)
		return nullptr;
	unsigned int scope_variable = conjunct->quantifier.variable;
	hol_term* operand = conjunct->quantifier.operand;
	if (operand->type != hol_term_type::AND)
		return nullptr;

	if (operand->array.length != 3)
		return nullptr;
	if (operand->array.operands[0]->type != hol_term_type::UNARY_APPLICATION
	 || operand->array.operands[0]->binary.left->type != hol_term_type::CONSTANT
	 || operand->array.operands[0]->binary.left->constant != ScopePredicate
	 || operand->array.operands[0]->binary.right->type != hol_term_type::VARIABLE
	 || operand->array.operands[0]->binary.right->constant != scope_variable)
		return nullptr;
	if (operand->array.operands[1]->type != hol_term_type::EQUALS
	 || operand->array.operands[1]->binary.left->type != hol_term_type::UNARY_APPLICATION
	 || operand->array.operands[1]->binary.left->binary.left->type != hol_term_type::CONSTANT
	 || operand->array.operands[1]->binary.left->binary.left->constant != (unsigned int) BuiltInPredicates::ARG1_OF
	 || operand->array.operands[1]->binary.left->binary.right->type != hol_term_type::VARIABLE
	 || operand->array.operands[1]->binary.left->binary.right->variable != head_variable
	 || operand->array.operands[1]->binary.right->type != hol_term_type::VARIABLE
	 || operand->array.operands[1]->binary.right->constant != scope_variable)
		return nullptr;
	if (operand->array.operands[2]->type != hol_term_type::EQUALS
	 || operand->array.operands[2]->binary.left->type != hol_term_type::UNARY_APPLICATION
	 || operand->array.operands[2]->binary.left->binary.left->type != hol_term_type::CONSTANT
	 || operand->array.operands[2]->binary.left->binary.left->constant != (unsigned int) BuiltInPredicates::ARG2
	 || operand->array.operands[2]->binary.left->binary.right->type != hol_term_type::VARIABLE
	 || operand->array.operands[2]->binary.left->binary.right->variable != scope_variable)
		return nullptr;
	return conjunct;
}

template<typename BuiltInPredicates, unsigned int ScopePredicate>
bool is_scope(hol_term* conjunct, unsigned int head_variable) {
	unsigned int scope_variable;
	if (conjunct->type == hol_term_type::EXISTS) {
		scope_variable = conjunct->quantifier.variable;
	} else if ((conjunct->type == hol_term_type::ANY || conjunct->type == hol_term_type::ANY_RIGHT) && conjunct->any.included != nullptr && conjunct->any.included->type == hol_term_type::EXISTS) {
		scope_variable = conjunct->any.included->quantifier.variable;
	} else {
		array<unsigned int> variables(8);
		get_variables<true>(*conjunct, variables);
		scope_variable = head_variable;
		for (unsigned int variable : variables)
			scope_variable = max(scope_variable, variable);
		scope_variable++;
	}

	hol_term* scope_var = hol_term::new_variable(scope_variable);
	if (scope_var == nullptr)
		return false;

	hol_term* expected_scope = hol_term::new_exists(scope_variable, hol_term::new_and(
		hol_term::new_apply(&hol_term::constants<ScopePredicate>::value, scope_var),
		hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) BuiltInPredicates::ARG1_OF>::value, hol_term::new_variable(head_variable)), scope_var),
		hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) BuiltInPredicates::ARG2>::value, scope_var), &HOL_ANY)
	));
	if (expected_scope == nullptr) {
		free(*scope_var); free(scope_var);
		return false;
	}
	hol_term::constants<ScopePredicate>::value.reference_count++;
	scope_var->reference_count += 3 - 1;
	hol_term::constants<(unsigned int) BuiltInPredicates::ARG1_OF>::value.reference_count++;
	hol_term::constants<(unsigned int) BuiltInPredicates::ARG2>::value.reference_count++;
	HOL_ANY.reference_count++;

	bool result = has_intersection<built_in_predicates>(expected_scope, conjunct);
	free(*expected_scope); if (expected_scope->reference_count == 0) free(expected_scope);
	return result;
}

template<typename BuiltInPredicates, unsigned int ScopePredicate>
inline hol_term* find_scope(unsigned int head_variable, hol_term* conjunction, head_index& predicate_index)
{
	hol_term* predicate = nullptr;
	predicate_index.position = head_position::NONE;
	if (conjunction->type == hol_term_type::ANY_ARRAY) {
		for (unsigned int i = 0; i < conjunction->any_array.left.length; i++) {
			predicate = get_scope<BuiltInPredicates, ScopePredicate>(conjunction->any_array.left.operands[i], head_variable);
			if (predicate != nullptr) {
				predicate_index = {head_position::LEFT, i};
				break;
			} else if (is_scope<BuiltInPredicates, ScopePredicate>(conjunction->any_array.left.operands[i], head_variable)) {
				predicate_index = {head_position::LEFT, i};
			}
		} for (unsigned int i = 0; predicate == nullptr && i < conjunction->any_array.right.length; i++) {
			predicate = get_scope<BuiltInPredicates, ScopePredicate>(conjunction->any_array.right.operands[i], head_variable);
			if (predicate != nullptr) {
				predicate_index = {head_position::RIGHT, conjunction->any_array.right.length - i - 1};
				break;
			} else if (is_scope<BuiltInPredicates, ScopePredicate>(conjunction->any_array.right.operands[i], head_variable)) {
				predicate_index = {head_position::RIGHT, conjunction->any_array.right.length - i - 1};
			}
		} for (unsigned int i = 0; predicate == nullptr && i < conjunction->any_array.any.length; i++) {
			predicate = get_scope<BuiltInPredicates, ScopePredicate>(conjunction->any_array.any.operands[i], head_variable);
			if (predicate != nullptr) {
				predicate_index = {head_position::ANY, i};
				break;
			} else if (is_scope<BuiltInPredicates, ScopePredicate>(conjunction->any_array.any.operands[i], head_variable)) {
				predicate_index = {head_position::ANY, i};
			}
		}
	} else if (conjunction->type == hol_term_type::AND) {
		predicate_index = {head_position::NONE, 0};
		for (unsigned int i = 0; i < conjunction->array.length; i++) {
			predicate = get_scope<BuiltInPredicates, ScopePredicate>(conjunction->array.operands[i], head_variable);
			if (predicate != nullptr) {
				predicate_index = {head_position::LEFT, i};
				break;
			} else if (predicate == nullptr && is_scope<BuiltInPredicates, ScopePredicate>(conjunction->array.operands[i], head_variable)) {
				predicate_index = {head_position::LEFT, i};
			}
		}
	} else {
		/* this conjunct could be singleton */
		predicate = get_scope<BuiltInPredicates, ScopePredicate>(conjunction, head_variable);
		if (predicate != nullptr) {
			predicate_index = {head_position::LEFT, 0};
		} else if (predicate == nullptr && is_scope<BuiltInPredicates, ScopePredicate>(conjunction, head_variable)) {
			predicate_index = {head_position::LEFT, 0};
		}
	}
	return predicate;
}

template<typename BuiltInPredicates>
inline hol_term* find_predicate(unsigned int head_variable, hol_term* conjunction, head_index& predicate_index)
{
	predicate_index.position = head_position::NONE;
	hol_term* expected_predicate = hol_term::new_apply(
			hol_term::new_any(nullptr, hol_non_head_constants<BuiltInPredicates>::get_terms(), hol_non_head_constants<BuiltInPredicates>::count()),
			hol_term::new_variable(head_variable));
	if (expected_predicate == nullptr)
		return nullptr;
	hol_non_head_constants<built_in_predicates>::increment_terms();

	hol_term* predicate = nullptr;
	head_index first_predicate_index = predicate_index;
	if (conjunction->type == hol_term_type::ANY_ARRAY) {
		for (unsigned int i = 0; i < conjunction->any_array.left.length; i++) {
			predicate = get_predicate_of_literal<BuiltInPredicates>(conjunction->any_array.left.operands[i], head_variable);
			if (predicate != nullptr) {
				predicate_index = {head_position::LEFT, i};
				break;
			} else if (has_intersection<BuiltInPredicates>(conjunction->any_array.left.operands[i], expected_predicate) && first_predicate_index.position == head_position::NONE) {
				first_predicate_index = {head_position::LEFT, i};
			}
		} for (unsigned int i = 0; predicate == nullptr && i < conjunction->any_array.right.length; i++) {
			predicate = get_predicate_of_literal<BuiltInPredicates>(conjunction->any_array.right.operands[i], head_variable);
			if (predicate != nullptr) {
				predicate_index = {head_position::RIGHT, conjunction->any_array.right.length - i - 1};
				break;
			} else if (has_intersection<BuiltInPredicates>(conjunction->any_array.right.operands[i], expected_predicate) && first_predicate_index.position == head_position::NONE) {
				first_predicate_index = {head_position::RIGHT, conjunction->any_array.right.length - i - 1};
			}
		} for (unsigned int i = 0; predicate == nullptr && i < conjunction->any_array.any.length; i++) {
			predicate = get_predicate_of_literal<BuiltInPredicates>(conjunction->any_array.any.operands[i], head_variable);
			if (predicate != nullptr) {
				predicate_index = {head_position::ANY, i};
				break;
			} else if (has_intersection<BuiltInPredicates>(conjunction->any_array.any.operands[i], expected_predicate) && first_predicate_index.position == head_position::NONE) {
				first_predicate_index = {head_position::ANY, i};
			}
		}
	} else if (conjunction->type == hol_term_type::AND) {
		predicate_index = {head_position::NONE, 0};
		for (unsigned int i = 0; i < conjunction->array.length; i++) {
			predicate = get_predicate_of_literal<BuiltInPredicates>(conjunction->array.operands[i], head_variable);
			if (predicate != nullptr) {
				predicate_index = {head_position::LEFT, i};
				break;
			} else if (has_intersection<BuiltInPredicates>(conjunction->array.operands[i], expected_predicate) && first_predicate_index.position == head_position::NONE) {
				first_predicate_index = {head_position::LEFT, i};
			}
		}
	} else {
		/* this conjunct could be singleton */
		predicate = get_predicate_of_literal<BuiltInPredicates>(conjunction, head_variable);
		if (predicate != nullptr) {
			predicate_index = {head_position::LEFT, 0};
		} else if (has_intersection<BuiltInPredicates>(conjunction, expected_predicate) && first_predicate_index.position == head_position::NONE) {
			first_predicate_index = {head_position::LEFT, 0};
		}
	}
	free(*expected_predicate); free(expected_predicate);
	if (predicate == nullptr)
		predicate_index = first_predicate_index;
	return predicate;
}

template<typename BuiltInPredicates>
inline hol_term* find_variable_definition(unsigned int head_variable, hol_term* conjunction, head_index& definition_index)
{
	hol_term* expected_definition = hol_term::new_equals(
			hol_term::new_variable(head_variable), &HOL_ANY);
	if (expected_definition == nullptr)
		return nullptr;
	HOL_ANY.reference_count++;

	hol_term* variable_definition = nullptr;
	definition_index.position = head_position::NONE;
	if (conjunction->type == hol_term_type::ANY_ARRAY) {
		for (unsigned int i = 0; i < conjunction->any_array.left.length; i++) {
			variable_definition = get_variable_definition_of_literal(conjunction->any_array.left.operands[i], head_variable);
			if (variable_definition != nullptr) {
				definition_index = {head_position::LEFT, i};
				break;
			} else if (has_intersection<BuiltInPredicates>(conjunction->any_array.left.operands[i], expected_definition)) {
				definition_index = {head_position::LEFT, i};
			}
		} for (unsigned int i = 0; i < conjunction->any_array.right.length; i++) {
			variable_definition = get_variable_definition_of_literal(conjunction->any_array.right.operands[i], head_variable);
			if (variable_definition != nullptr) {
				definition_index = {head_position::RIGHT, conjunction->any_array.right.length - i - 1};
				break;
			} else if (has_intersection<BuiltInPredicates>(conjunction->any_array.right.operands[i], expected_definition)) {
				definition_index = {head_position::RIGHT, conjunction->any_array.right.length - i - 1};
			}
		} for (unsigned int i = 0; i < conjunction->any_array.any.length; i++) {
			variable_definition = get_variable_definition_of_literal(conjunction->any_array.any.operands[i], head_variable);
			if (variable_definition != nullptr) {
				definition_index = {head_position::ANY, i};
				break;
			} else if (has_intersection<BuiltInPredicates>(conjunction->any_array.any.operands[i], expected_definition)) {
				definition_index = {head_position::ANY, i};
			}
		}
	} else if (conjunction->type == hol_term_type::AND) {
		definition_index = {head_position::NONE, 0};
		for (unsigned int i = 0; i < conjunction->array.length; i++) {
			variable_definition = get_variable_definition_of_literal(conjunction->array.operands[i], head_variable);
			if (variable_definition != nullptr) {
				definition_index = {head_position::LEFT, i};
				break;
			} else if (variable_definition == nullptr && has_intersection<BuiltInPredicates>(conjunction->array.operands[i], expected_definition)) {
				definition_index = {head_position::LEFT, i};
			}
		}
	} else {
		/* this conjunct could be singleton */
		variable_definition = get_variable_definition_of_literal(conjunction, head_variable);
		if (variable_definition != nullptr) {
			definition_index = {head_position::LEFT, 0};
		} else if (variable_definition == nullptr && has_intersection<BuiltInPredicates>(conjunction, expected_definition)) {
			definition_index = {head_position::LEFT, 0};
		}
	}
	free(*expected_definition); free(expected_definition);
	return variable_definition;
}

template<typename BuiltInPredicates, bool AllowVariableDefinitions = false, bool IncludeNegation = true, bool IncludeAny = true>
inline void find_head(
		hol_term* src, hol_term*& head,
		head_index& predicate_index)
{
	head = nullptr;
	if (IncludeAny && (src->type == hol_term_type::ANY || src->type == hol_term_type::ANY_RIGHT)) {
		if (src->any.included == nullptr) {
			head = src;
		} else {
			find_head<BuiltInPredicates>(src->any.included, head, predicate_index);
			if (head != nullptr)
				head = src;
		}
	} else if (src->type == hol_term_type::EXISTS) {
		head = src;
		unsigned int head_variable = src->quantifier.variable;

		/* make sure this scope has no term `arg1(*)=x` or `arg2(*)=x` where `x` is the scope variable */
		hol_term wildcard;
		wildcard.any.included = hol_term::new_equals(hol_term::new_apply(
				hol_term::new_any_constant(
					(unsigned int) BuiltInPredicates::ARG1, (unsigned int) BuiltInPredicates::ARG2, (unsigned int) BuiltInPredicates::ARG3,
					(unsigned int) BuiltInPredicates::ARG1_OF, (unsigned int) BuiltInPredicates::ARG2_OF, (unsigned int) BuiltInPredicates::ARG3_OF),
				&HOL_ANY), hol_term::new_variable(head_variable));
		if (wildcard.any.included == nullptr) return;
		HOL_ANY.reference_count++;
		bool not_head = has_intersection<BuiltInPredicates>(head->quantifier.operand, &wildcard);
		free(*wildcard.any.included); free(wildcard.any.included);
		wildcard.any.included = nullptr;
		if (not_head) { head = nullptr; return; }

		/* find the predicate */
		find_predicate<BuiltInPredicates>(head_variable, head->quantifier.operand, predicate_index);
		if (predicate_index.position == head_position::NONE) {
			if (AllowVariableDefinitions)
				find_variable_definition<BuiltInPredicates>(head_variable, head->quantifier.operand, predicate_index);

			if (!AllowVariableDefinitions || predicate_index.position == head_position::NONE) {
				head = nullptr;
				return;
			}
		}
	} else if (IncludeNegation && src->type == hol_term_type::NOT) {
		find_head<BuiltInPredicates, AllowVariableDefinitions, IncludeNegation, false>(src->unary.operand, head, predicate_index);
		if (head != nullptr)
			head = src;
	}
}

template<typename BuiltInPredicates, int_fast8_t ConjunctIndex, bool AllowVariableDefinitions = false, bool IncludeNegation = true>
inline void find_head_ignore_conjunct(
		hol_term* src, hol_term*& head,
		head_index& predicate_index)
{
	head = nullptr;
	if (src->type == hol_term_type::ANY || src->type == hol_term_type::ANY_RIGHT) {
		if (src->any.included == nullptr) {
			head = src;
		} else {
			find_head_ignore_conjunct<BuiltInPredicates, ConjunctIndex>(src->any.included, head, predicate_index);
			if (head != nullptr)
				head = src;
		}
	} else if (src->type == hol_term_type::EXISTS) {
		head = src;
		unsigned int head_variable = src->quantifier.variable;

		/* make sure this scope has no term `arg1(*)=x` or `arg2(*)=x` where `x` is the scope variable */
		hol_term wildcard;
		wildcard.any.included = hol_term::new_equals(hol_term::new_apply(
				hol_term::new_any_constant(
					(unsigned int) BuiltInPredicates::ARG1, (unsigned int) BuiltInPredicates::ARG2, (unsigned int) BuiltInPredicates::ARG3,
					(unsigned int) BuiltInPredicates::ARG1_OF, (unsigned int) BuiltInPredicates::ARG2_OF, (unsigned int) BuiltInPredicates::ARG3_OF),
				&HOL_ANY), hol_term::new_variable(head_variable));
		if (wildcard.any.included == nullptr) return;
		HOL_ANY.reference_count++;
		hol_term* operand = head->quantifier.operand;
		bool not_head = false;
		if (operand->type == hol_term_type::AND) {
			unsigned int ignore_index = (ConjunctIndex < 0 ? operand->array.length + ConjunctIndex : ConjunctIndex);
			not_head = operand->array.operands[ignore_index]->type != hol_term_type::EQUALS
					&& operand->array.operands[ignore_index]->type != hol_term_type::ANY
					&& operand->array.operands[ignore_index]->type != hol_term_type::ANY_RIGHT;
			for (unsigned int i = 0; !not_head && i < operand->array.length; i++) {
				if (i == ignore_index) continue;
				not_head = has_intersection<BuiltInPredicates>(operand->array.operands[i], &wildcard);
			}
		} else if (operand->type == hol_term_type::ANY_ARRAY) {
			for (unsigned int i = 0; !not_head && i < operand->any_array.left.length; i++) {
				if (ConjunctIndex >= 0 && i == (unsigned) ConjunctIndex) {
					not_head = operand->any_array.left.operands[i]->type != hol_term_type::EQUALS
							&& operand->any_array.left.operands[i]->type != hol_term_type::ANY
							&& operand->any_array.left.operands[i]->type != hol_term_type::ANY_RIGHT;
					continue;
				}
				not_head = has_intersection<BuiltInPredicates>(operand->any_array.left.operands[i], &wildcard);
			} for (unsigned int i = 0; !not_head && i < operand->any_array.right.length; i++) {
				if (operand->any_array.right.length >= -ConjunctIndex && i == operand->any_array.right.length + ConjunctIndex) {
					not_head = operand->any_array.right.operands[i]->type != hol_term_type::EQUALS
							&& operand->any_array.right.operands[i]->type != hol_term_type::ANY
							&& operand->any_array.right.operands[i]->type != hol_term_type::ANY_RIGHT;
					continue;
				}
				not_head = has_intersection<BuiltInPredicates>(operand->any_array.right.operands[i], &wildcard);
			} for (unsigned int i = 0; !not_head && i < operand->any_array.any.length; i++) {
				not_head = has_intersection<BuiltInPredicates>(operand->any_array.any.operands[i], &wildcard);
			}
		} else if (operand->type != hol_term_type::ANY && operand->type != hol_term_type::ANY_RIGHT) {
			not_head = operand->type != hol_term_type::EQUALS
					&& operand->type != hol_term_type::ANY
					&& operand->type != hol_term_type::ANY_RIGHT;
		}
		free(*wildcard.any.included); free(wildcard.any.included);
		wildcard.any.included = nullptr;
		if (not_head) { head = nullptr; return; }

		/* find the predicate */
		find_predicate<BuiltInPredicates>(head_variable, head->quantifier.operand, predicate_index);
		if (predicate_index.position == head_position::NONE) {
			if (AllowVariableDefinitions)
				find_variable_definition<BuiltInPredicates>(head_variable, head->quantifier.operand, predicate_index);

			if (!AllowVariableDefinitions || predicate_index.position == head_position::NONE) {
				head = nullptr;
				return;
			}
		}
	} else if (IncludeNegation && src->type == hol_term_type::NOT) {
		find_head_ignore_conjunct<BuiltInPredicates, ConjunctIndex>(src->unary.operand, head, predicate_index);
		if (head != nullptr)
			head = src;
	}
}

template<typename BuiltInPredicates>
inline void find_head_or_universal(
		hol_term* src, hol_term*& head,
		head_index& predicate_index)
{
	if ((src->type == hol_term_type::ANY || src->type == hol_term_type::ANY_RIGHT) && src->any.included != nullptr) {
		find_head_or_universal<BuiltInPredicates>(src->any.included, head, predicate_index);
		if (head != nullptr) return;
	}

	if (src->type == hol_term_type::FOR_ALL
	 || (src->type == hol_term_type::ANY_QUANTIFIER && has_intersection(src->any_quantifier.quantifier, hol_quantifier_type::FOR_ALL)))
	{
		head = src;
		return;
	} else if (src->type == hol_term_type::ANY || src->type == hol_term_type::ANY_RIGHT) {
		/* check if all universal quantifiers are excluded */
		bool is_excluded = false;
		for (unsigned int i = 0; i < src->any.excluded_tree_count; i++) {
			hol_term* excluded_tree = src->any.excluded_trees[i];
			if (excluded_tree->type == hol_term_type::ANY_QUANTIFIER && *excluded_tree->any_quantifier.operand == HOL_ANY && has_intersection(excluded_tree->any_quantifier.quantifier, hol_quantifier_type::FOR_ALL)) {
				is_excluded = true;
				break;
			} else if ((excluded_tree->type == hol_term_type::ANY || excluded_tree->type == hol_term_type::ANY_RIGHT) && excluded_tree->any.excluded_tree_count == 0) {
				if (excluded_tree->any.included == nullptr) {
					is_excluded = true;
					break;
				} else if (excluded_tree->any.included->type == hol_term_type::ANY_QUANTIFIER
						&& *excluded_tree->any.included->any_quantifier.operand == HOL_ANY
						&& has_intersection(excluded_tree->any.included->any_quantifier.quantifier, hol_quantifier_type::FOR_ALL))
				{
					is_excluded = true;
					break;
				}
			}
		}
		if (!is_excluded) {
			head = src;
			return;
		}
	}

	find_head<BuiltInPredicates>(src, head, predicate_index);
}

template<unsigned int Constant, typename FindHeadFunction>
struct head_or_unary_application_finder {
	FindHeadFunction find_head;

	head_or_unary_application_finder(FindHeadFunction find_head) : find_head(find_head) { }

	inline void operator () (
			hol_term* src, hol_term*& head,
			head_index& predicate_index)
	{
		if (src->type == hol_term_type::UNARY_APPLICATION && src->binary.left->type == hol_term_type::CONSTANT && src->binary.left->constant == Constant) {
			head = src;
		} else {
			find_head(src, head, predicate_index);
		}
	}
};

template<unsigned int Constant, typename FindHeadFunction>
head_or_unary_application_finder<Constant, FindHeadFunction> make_head_or_unary_application_finder(FindHeadFunction find_head) {
	return head_or_unary_application_finder<Constant, FindHeadFunction>(find_head);
}

template<typename BuiltInPredicates>
struct predicative_head_finder {
	unsigned int lambda_variable;

	predicative_head_finder(unsigned int lambda_variable) : lambda_variable(lambda_variable) { }

	inline void operator () (
			hol_term* src, hol_term*& head,
			head_index& predicate_index)
	{
		apply<true>(src, head, predicate_index);
	}

	inline bool operator == (const predicative_head_finder<BuiltInPredicates>& other) const {
		return lambda_variable == other.lambda_variable;
	}

	template<typename T>
	constexpr inline bool operator == (const T& other) const {
		return false;
	}

private:
	template<bool First>
	void apply(
			hol_term* src, hol_term*& head,
			head_index& predicate_index)
	{
		if (src->type == hol_term_type::ANY || src->type == hol_term_type::ANY_RIGHT) {
			if (src->any.included == nullptr) {
				head = src;
			} else if (src->any.included->type == hol_term_type::UNARY_APPLICATION && src->any.included->binary.left->type == hol_term_type::VARIABLE
					&& src->any.included->binary.left->variable == lambda_variable && src->any.included->binary.right->type == hol_term_type::VARIABLE)
			{
				head = src;
				predicate_index = {head_position::LEFT, 0};
			} else {
				apply<First>(src->any.included, head, predicate_index);
				if (head != nullptr)
					head = src;
			}
		} else if (src->type == hol_term_type::EXISTS) {
			unsigned int set_variable = src->quantifier.variable;
			hol_term* operand = src->quantifier.operand;
			hol_term* right = nullptr; hol_term* second_right = nullptr;
			if (operand->type == hol_term_type::ANY) {
				head = nullptr;
				return;
			} else if (operand->type == hol_term_type::ANY_ARRAY && (operand->any_array.oper == hol_term_type::ANY_ARRAY || operand->any_array.oper == hol_term_type::AND)) {
				if (operand->any_array.right.length == 0) {
					head = nullptr;
					return;
				}
				right = operand->any_array.right.operands[operand->any_array.right.length - 1];
				if (operand->any_array.right.length >= 2)
					second_right = operand->any_array.right.operands[operand->any_array.right.length - 2];
			} else if (operand->type == hol_term_type::AND) {
				if (operand->array.length == 1) {
					head = nullptr;
					return;
				}
				right = operand->array.operands[operand->array.length - 1];
				second_right = operand->array.operands[operand->array.length - 2];
			} else {
				head = nullptr;
				return;
			}

			while (right->type == hol_term_type::NOT)
				right = right->unary.operand;

			bool right_is_any = false;
			if (right->type == hol_term_type::ANY_RIGHT && right->any.included != nullptr) {
				right = right->any.included;
				right_is_any = true;
			} if (right->type == hol_term_type::UNARY_APPLICATION && right->binary.left->type == hol_term_type::CONSTANT && right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
				right = right->binary.right;
			} if (right->type == hol_term_type::ANY_RIGHT && right->any.included != nullptr) {
				right = right->any.included;
				right_is_any = true;
			}

			while (right->type == hol_term_type::NOT)
				right = right->unary.operand;

			hol_term* inner_right;
			unsigned int quantified_variable = 0;
			predicate_index = {head_position::LEFT, 0};
			if (right->type == hol_term_type::UNARY_APPLICATION && right->binary.left->type == hol_term_type::VARIABLE
			 && right->binary.left->variable == lambda_variable && right->binary.right->type == hol_term_type::VARIABLE
			 && second_right != nullptr && second_right->type == hol_term_type::UNARY_APPLICATION && second_right->binary.left->type == hol_term_type::VARIABLE
			 && second_right->binary.left->variable == set_variable && second_right->binary.right->type == hol_term_type::VARIABLE
			 && second_right->binary.right->variable == right->binary.right->variable)
			{
				head = src;
				return;
			} else if (right->type == hol_term_type::FOR_ALL && right->quantifier.operand->type == hol_term_type::IF_THEN
					&& right->quantifier.operand->binary.left->type == hol_term_type::UNARY_APPLICATION && right->quantifier.operand->binary.left->binary.left->type == hol_term_type::VARIABLE
					&& right->quantifier.operand->binary.left->binary.left->variable == set_variable)
			{
				quantified_variable = right->quantifier.variable;
				inner_right = right->quantifier.operand->binary.right;
			} else if (right->type == hol_term_type::EXISTS && right->quantifier.operand->type == hol_term_type::AND && right->quantifier.operand->array.length == 2
					&& right->quantifier.operand->array.operands[0]->type == hol_term_type::UNARY_APPLICATION && right->quantifier.operand->array.operands[0]->binary.left->type == hol_term_type::VARIABLE
					&& right->quantifier.operand->array.operands[0]->binary.left->variable == set_variable)
			{
				quantified_variable = right->quantifier.variable;
				inner_right = right->quantifier.operand->array.operands[1];
			} else if (right->type == hol_term_type::ANY_QUANTIFIER && has_intersection(right->any_quantifier.quantifier, hol_quantifier_type::FOR_ALL_OR_EXISTS)) {
				inner_right = right->any_quantifier.operand;
			} else if (right_is_any) {
				inner_right = right;
			} else {
				head = nullptr;
				return;
			}

			if (inner_right->type == hol_term_type::ANY_RIGHT && inner_right->any.included != nullptr)
				inner_right = inner_right->any.included;
			else if (inner_right->type == hol_term_type::UNARY_APPLICATION && inner_right->binary.left->type == hol_term_type::CONSTANT && inner_right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE)
				inner_right = inner_right->binary.right;

			if (inner_right->type == hol_term_type::UNARY_APPLICATION
			 && inner_right->binary.left->type == hol_term_type::VARIABLE && inner_right->binary.left->variable == lambda_variable
			 && inner_right->binary.right->type == hol_term_type::VARIABLE && (quantified_variable == 0 || inner_right->binary.right->variable == quantified_variable))
			{
				head = src;
			} else {
				head = nullptr;
				return;
			}
		} else if (First && src->type == hol_term_type::UNARY_APPLICATION && src->binary.left->type == hol_term_type::VARIABLE
				&& src->binary.left->variable == lambda_variable && src->binary.right->type == hol_term_type::VARIABLE)
		{
			head = src;
		} else if (src->type == hol_term_type::NOT && First) {
			apply<false>(src->unary.operand, head, predicate_index);
			if (head != nullptr)
				head = src;
		} else {
			head = nullptr;
		}
	}
};

template<typename FindHead>
struct array_finder {
	FindHead& find_head;

	array_finder(FindHead& find_head) : find_head(find_head) { }

	inline void operator () (
			hol_term* src, hol_term*& head,
			head_index& predicate_index)
	{
		if (src->type == hol_term_type::ANY || src->type == hol_term_type::ANY_RIGHT) {
			if (src->any.included == nullptr) {
				head = src;
			} else {
				/* check if the "array" is a singleton */
				find_head(src, head, predicate_index);
			}
		} else if (src->type == hol_term_type::AND || src->type == hol_term_type::OR) {
			find_head(src->array.operands[0], head, predicate_index);
			if (head != nullptr)
				head = src;
		} else if (src->type == hol_term_type::ANY_ARRAY && (src->any_array.oper == hol_term_type::ANY_ARRAY || src->any_array.oper == hol_term_type::AND || src->any_array.oper == hol_term_type::OR)) {
			find_head(src->any_array.all, head, predicate_index);
			if (head != nullptr)
				head = src;
		} else {
			/* check if the "array" is a singleton */
			find_head(src, head, predicate_index);
		}
	}

	inline bool operator == (const array_finder<FindHead>& other) const {
		return find_head == other.find_head;
	}

	template<typename T>
	constexpr inline bool operator == (const T& other) const {
		return false;
	}
};

template<typename FindHead>
inline array_finder<FindHead> make_array_finder(FindHead& find_head) {
	return array_finder<FindHead>(find_head);
}

inline void find_root(hol_term* src, hol_term*& head, head_index& predicate_index) {
	head = src;
}

inline void find_zero(hol_term* src, hol_term*& head, head_index& predicate_index) {
	if (src == &HOL_ZERO) {
		head = src;
	} else {
		head = nullptr;
	}
}

struct node_finder {
	hol_term* node;

	node_finder(hol_term* node) : node(node) { }

	inline void operator () (
			hol_term* src, hol_term*& head,
			head_index& predicate_index)
	{
		if (src == node) {
			head = src;
		} else {
			head = nullptr;
		}
	}

	inline bool operator == (const node_finder& other) const {
		return node == other.node;
	}

	template<typename T>
	constexpr inline bool operator == (const T& other) const {
		return false;
	}
};

bool prune_independent_siblings(
		array<unsigned int>& keep_variables,
		array<hol_term*>& siblings)
{
	array<unsigned int>* sibling_variables = (array<unsigned int>*) malloc(max((size_t) 1, sizeof(array<unsigned int>) * siblings.length));
	for (unsigned int i = 0; i < siblings.length; i++) {
		if (!array_init(sibling_variables[i], 8)) {
			for (unsigned int j = 0; j < i; j++) free(sibling_variables[j]);
			free(sibling_variables);
			return false;
		}
		get_free_variables(*siblings[i], sibling_variables[i]);
		if (sibling_variables[i].length > 1)
			insertion_sort(sibling_variables[i]);
	}

	unsigned int old_arg_variable_count;
	do {
		old_arg_variable_count = keep_variables.length;
		for (unsigned int i = 0; i < siblings.length; i++) {
			if (has_intersection(sibling_variables[i], keep_variables)) {
				array<unsigned int> union_variables(sibling_variables[i].length + keep_variables.length);
				set_union(union_variables, keep_variables, sibling_variables[i]);
				swap(union_variables, keep_variables);
			}
		}
	} while (old_arg_variable_count != keep_variables.length);

	/* remove terms from `siblings` that are unneeded */
	for (unsigned int i = 0; i < siblings.length; i++) {
		if (!has_intersection(sibling_variables[i], keep_variables)) {
			free(sibling_variables[i]);
			move(sibling_variables[siblings.length - 1], sibling_variables[i]);
			siblings.remove(i--);
		} else {
			free(sibling_variables[i]);
		}
	}
	free(sibling_variables);
	return true;
}

template<bool InArray, bool IncrementMaxVariable, typename MakeDstFunction>
inline hol_term* try_make_dst(hol_term* head,
		unsigned int& max_variable,
		head_index predicate_index,
		bool& remove_wide_scope_marker,
		array<hol_term*>& siblings,
		MakeDstFunction make_dst)
{
	unsigned int head_variable = 0;
	if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) {
		if (predicate_index.position == head_position::NONE) {
			if (head->any.included != nullptr)
				max_bound_variable(*head->any.included, max_variable);
			if (IncrementMaxVariable || max_variable == 0)
				max_variable++;
			head_variable = max_variable;
		} else {
			hol_term* inner = head->any.included;
			while (inner->type == hol_term_type::NOT)
				inner = inner->unary.operand;
			if (inner->type == hol_term_type::EXISTS)
				head_variable = inner->quantifier.variable;
		}
	} else {
		hol_term* inner = head;
		while (inner->type == hol_term_type::NOT)
			inner = inner->unary.operand;
		if (inner->type == hol_term_type::EXISTS) {
			head_variable = inner->quantifier.variable;
		} else {
			max_bound_variable(*inner, max_variable);
			if (IncrementMaxVariable || max_variable == 0)
				max_variable++;
			head_variable = max_variable;
		}
	}
	return make_dst(head, head_variable, predicate_index, InArray, remove_wide_scope_marker, siblings);
}

template<typename TryFindHeadFunction, typename MakeDstFunction>
inline bool apply_head_to_array(
		hol_array_term& src,
		hol_term**& dst,
		unsigned int& max_variable,
		bool& remove_wide_scope_marker,
		array<hol_term*>& siblings,
		TryFindHeadFunction try_find_head,
		MakeDstFunction make_dst)
{
	dst = nullptr;
	hol_term** heads = (hol_term**) malloc(sizeof(hol_term*) * src.length);
	if (heads == nullptr) {
		fprintf(stderr, "apply_head_to_array ERROR: Insufficient memory for `heads`.\n");
		return false;
	}
	head_index* predicate_indices = (head_index*) calloc(src.length, sizeof(head_index));
	if (predicate_indices == nullptr) {
		fprintf(stderr, "apply_head_to_array ERROR: Insufficient memory for `predicate_indices`.\n");
		free(heads); return false;
	}
	bool success = true;
	for (unsigned int i = 0; i < src.length; i++) {
		try_find_head(src.operands[i], heads[i], predicate_indices[i]);
		if (heads[i] == nullptr) {
			success = false;
			break;
		}
	}

	if (!success) {
		free(heads);
		free(predicate_indices);
		return true;
	}

	dst = (hol_term**) calloc(src.length, sizeof(hol_term*));
	if (dst == nullptr) {
		fprintf(stderr, "apply_head_to_array ERROR: Insufficient memory for `dst`.\n");
		free(heads); free(predicate_indices); return false;
	}
	for (unsigned int i = 0; i < src.length; i++) {
		dst[i] = try_make_dst<true, false>(heads[i], max_variable, predicate_indices[i], remove_wide_scope_marker, siblings, make_dst);
		if (dst[i] == nullptr) {
			success = false;
			break;
		}
	}

	free(heads);
	free(predicate_indices);
	if (!success) {
		for (unsigned int i = 0; i < src.length; i++) {
			if (dst[i] == nullptr) break;
			free(*dst[i]); if (dst[i]->reference_count == 0) free(dst[i]);
		}
		free(dst);
		dst = nullptr;
		return false;
	}
	return true;
}

inline unsigned int get_head_variable(const hol_term* head) {
	if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr
	 && (head->any.included->type == hol_term_type::EXISTS || head->any.included->type == hol_term_type::NOT))
		head = head->any.included;
	while (head->type == hol_term_type::NOT)
		head = head->unary.operand;
	if (head->type == hol_term_type::EXISTS)
		return head->quantifier.variable;
	return 0;
}

template<bool KeepIndependentSiblings, bool IsRoot = true, typename TryFindHeadFunction, typename MakeDstFunction, typename ApplyFunction>
inline bool apply_head(
		hol_term* src, hol_term*& dst,
		array<unsigned int>& dst_variables,
		array<hol_term*>& siblings,
		unsigned int max_variable,
		bool& removed_quantifier,
		bool& remove_negations,
		bool& remove_wide_scope_marker,
		TryFindHeadFunction try_find_head,
		MakeDstFunction make_dst,
		ApplyFunction apply)
{
	if (!apply(src)) return false;

	/* check if the current scope is the head */
	hol_term* head;
	head_index predicate_index = {head_position::NONE, 0};
	try_find_head(src, head, predicate_index);
	if (head != nullptr) {
		dst = try_make_dst<false, true>(head, max_variable, predicate_index, remove_wide_scope_marker, siblings, make_dst);
		if (dst == nullptr) return false;

		get_free_variables(*dst, dst_variables);
		if (dst_variables.length > 1) insertion_sort(dst_variables);
		if (!prune_independent_siblings(dst_variables, siblings)) {
			free(*dst); if (dst->reference_count == 0) free(dst);
			return false;
		}
		removed_quantifier = false;
		return true;
	}

	if (src->type == hol_term_type::AND || src->type == hol_term_type::OR) {
		hol_term** new_dst;
		if (!apply_head_to_array(src->array, new_dst, max_variable, remove_wide_scope_marker, siblings, try_find_head, make_dst))
			return false;
		if (new_dst != nullptr) {
			for (unsigned int i = 0; i < src->array.length; i++)
				get_free_variables(*new_dst[i], dst_variables);
			if (dst_variables.length > 1) insertion_sort(dst_variables);
			if (!prune_independent_siblings(dst_variables, siblings)) {
				for (unsigned int i = 0; i < src->array.length; i++) {
					free(*new_dst[i]); if (new_dst[i]->reference_count == 0) free(new_dst[i]);
				}
				free(new_dst);
				return false;
			}

			removed_quantifier = false;
			if (src->type == hol_term_type::AND) {
				dst = hol_term::new_and(make_array_view(new_dst, src->array.length));
			} else {
				dst = hol_term::new_or(make_array_view(new_dst, src->array.length));
			}
			if (dst == nullptr) {
				for (unsigned int i = 0; i < src->array.length; i++) {
					free(*new_dst[i]); if (new_dst[i]->reference_count == 0) free(new_dst[i]);
				}
				free(new_dst);
				return false;
			}
			free(new_dst);
			return true;
		}
	} else if (src->type == hol_term_type::ANY_ARRAY && (src->any_array.oper == hol_term_type::ANY_ARRAY || src->any_array.oper == hol_term_type::AND || src->any_array.oper == hol_term_type::OR)) {
		hol_term* all;
		try_find_head(src->any_array.all, all, predicate_index);
		if (all != nullptr) {
			/* check if the head variable is already defined in any conjunct */
			unsigned int head_variable = 0;
			for (unsigned int i = 0; head_variable == 0 && i < src->any_array.left.length; i++)
				head_variable = get_head_variable(src->any_array.left.operands[i]);
			for (unsigned int i = 0; head_variable == 0 && i < src->any_array.right.length; i++)
				head_variable = get_head_variable(src->any_array.right.operands[i]);
			for (unsigned int i = 0; head_variable == 0 && i < src->any_array.any.length; i++)
				head_variable = get_head_variable(src->any_array.any.operands[i]);

			hol_term* new_all;
			if (head_variable != 0) {
				max_variable = head_variable;
				new_all = try_make_dst<true, false>(all, max_variable, predicate_index, remove_wide_scope_marker, siblings, make_dst);
			} else {
				new_all = try_make_dst<true, true>(all, max_variable, predicate_index, remove_wide_scope_marker, siblings, make_dst);
			}
			if (new_all == nullptr) return false;

			hol_term** new_left; hol_term** new_right; hol_term** new_any;
			if (!apply_head_to_array(src->any_array.left, new_left, max_variable, remove_wide_scope_marker, siblings, try_find_head, make_dst)) {
				free(*new_all); if (new_all->reference_count == 0) free(new_all);
				return false;
			}
			if (new_left != nullptr) {
				if (!apply_head_to_array(src->any_array.right, new_right, max_variable, remove_wide_scope_marker, siblings, try_find_head, make_dst)) {
					free(*new_all); if (new_all->reference_count == 0) free(new_all);
					for (unsigned int i = 0; i < src->any_array.left.length; i++) {
						free(*new_left[i]); if (new_left[i]->reference_count == 0) free(new_left[i]);
					}
					free(new_left);
					return false;
				}

				if (new_right != nullptr) {
					if (!apply_head_to_array(src->any_array.any, new_any, max_variable, remove_wide_scope_marker, siblings, try_find_head, make_dst)) {
						free(*new_all); if (new_all->reference_count == 0) free(new_all);
						for (unsigned int i = 0; i < src->any_array.left.length; i++) {
							free(*new_left[i]); if (new_left[i]->reference_count == 0) free(new_left[i]);
						} for (unsigned int i = 0; i < src->any_array.right.length; i++) {
							free(*new_right[i]); if (new_right[i]->reference_count == 0) free(new_right[i]);
						}
						free(new_left); free(new_right);
						return false;
					}

					if (new_any != nullptr) {
						get_free_variables(*new_all, dst_variables);
						for (unsigned int i = 0; i < src->any_array.left.length; i++)
							get_free_variables(*new_left[i], dst_variables);
						for (unsigned int i = 0; i < src->any_array.right.length; i++)
							get_free_variables(*new_right[i], dst_variables);
						for (unsigned int i = 0; i < src->any_array.any.length; i++)
							get_free_variables(*new_any[i], dst_variables);
						if (dst_variables.length > 1) insertion_sort(dst_variables);
						if (!prune_independent_siblings(dst_variables, siblings)) {
							free(*new_all); if (new_all->reference_count == 0) free(new_all);
							for (unsigned int i = 0; i < src->any_array.left.length; i++) {
								free(*new_left[i]); if (new_left[i]->reference_count == 0) free(new_left[i]);
							} for (unsigned int i = 0; i < src->any_array.right.length; i++) {
								free(*new_right[i]); if (new_right[i]->reference_count == 0) free(new_right[i]);
							} for (unsigned int i = 0; i < src->any_array.any.length; i++) {
								free(*new_any[i]); if (new_any[i]->reference_count == 0) free(new_any[i]);
							}
							free(new_left); free(new_right); free(new_any);
							return false;
						}

						/* check if there are any redundant elements of left, right, or any */
						unsigned int right_start = 0; unsigned int any_start = 0;
						unsigned int current_left_length = src->any_array.left.length;
						unsigned int current_right_length = src->any_array.right.length;
						unsigned int current_any_length = src->any_array.any.length;
						while (current_left_length > 0) {
							if (*new_left[current_left_length - 1] != *new_all) break;
							current_left_length--;
						} while (current_right_length > 0) {
							if (*new_right[right_start] != *new_all) break;
							right_start++;
							current_right_length--;
						} while (current_any_length > 0) {
							if (*new_any[any_start] != *new_all) break;
							any_start++;
							current_any_length--;
						} while (current_any_length > 0) {
							if (*new_any[any_start + current_any_length - 1] != *new_all) break;
							current_any_length--;
						}

						/* but we have to be careful since the length of these arrays put a non-trivial constraint on the length of the ANY_ARRAY */
						unsigned int min_length = max(src->any_array.left.length, max(src->any_array.right.length, src->any_array.any.length));

						removed_quantifier = false;
						if (min_length > 1 && min_length > current_left_length) {
							dst = hol_term::new_any_array(src->any_array.oper, new_all,
									make_array_view(new_any + any_start, current_any_length),
									make_concat_array_view(make_array_view(new_left, current_left_length), make_repeated_array_view(new_all, min_length - current_left_length)),
									make_array_view(new_right + right_start, current_right_length));
						} else {
							dst = hol_term::new_any_array(src->any_array.oper, new_all,
									make_array_view(new_any + any_start, current_any_length),
									make_array_view(new_left, current_left_length),
									make_array_view(new_right + right_start, current_right_length));
						}
						if (dst == nullptr) {
							free(*new_all); if (new_all->reference_count == 0) free(new_all);
							for (unsigned int i = 0; i < src->any_array.left.length; i++) {
								free(*new_left[i]); if (new_left[i]->reference_count == 0) free(new_left[i]);
							} for (unsigned int i = 0; i < src->any_array.right.length; i++) {
								free(*new_right[i]); if (new_right[i]->reference_count == 0) free(new_right[i]);
							} for (unsigned int i = 0; i < src->any_array.any.length; i++) {
								free(*new_any[i]); if (new_any[i]->reference_count == 0) free(new_any[i]);
							}
							free(new_left); free(new_right); free(new_any);
							return false;
						}
						for (unsigned int i = 0; i < dst->any_array.left.length; i++) {
							dst->any_array.left.operands[i]->reference_count++;
						} for (unsigned int i = 0; i < dst->any_array.right.length; i++) {
							dst->any_array.right.operands[i]->reference_count++;
						} for (unsigned int i = 0; i < dst->any_array.any.length; i++) {
							dst->any_array.any.operands[i]->reference_count++;
						} for (unsigned int i = 0; i < src->any_array.left.length; i++) {
							free(*new_left[i]); if (new_left[i]->reference_count == 0) free(new_left[i]);
						} for (unsigned int i = 0; i < src->any_array.right.length; i++) {
							free(*new_right[i]); if (new_right[i]->reference_count == 0) free(new_right[i]);
						} for (unsigned int i = 0; i < src->any_array.any.length; i++) {
							free(*new_any[i]); if (new_any[i]->reference_count == 0) free(new_any[i]);
						}
						free(new_left); free(new_right); free(new_any);
						return true;
					}

					for (unsigned int i = 0; i < src->any_array.right.length; i++) {
						free(*new_right[i]); if (new_right[i]->reference_count == 0) free(new_right[i]);
					}
					free(new_right);
				}

				for (unsigned int i = 0; i < src->any_array.left.length; i++) {
					free(*new_left[i]); if (new_left[i]->reference_count == 0) free(new_left[i]);
				}
				free(new_left);
			}

			free(*new_all); if (new_all->reference_count == 0) free(new_all);
		}
	}

	/* we didn't find the head, so keep looking */
	/* NOTE: this function should mirror the semantics of
	   `apply_head`, `apply<head_substituter>`, `apply_arg`, and
	   `find_head` in `hdp_parser.h` */
	hol_term* new_formula;
	switch (src->type) {
	case hol_term_type::VARIABLE:
	case hol_term_type::VARIABLE_PREIMAGE:
	case hol_term_type::CONSTANT:
	case hol_term_type::PARAMETER:
	case hol_term_type::NUMBER:
	case hol_term_type::STRING:
	case hol_term_type::UINT_LIST:
	case hol_term_type::TRUE:
	case hol_term_type::FALSE:
	case hol_term_type::EQUALS:
	case hol_term_type::BINARY_APPLICATION:
	case hol_term_type::IFF:
	case hol_term_type::ANY_CONSTANT:
	case hol_term_type::ANY_CONSTANT_EXCEPT:
	case hol_term_type::ANY_RIGHT_ONLY:
		dst = nullptr;
		removed_quantifier = false;
		remove_negations = false;
		return true;

	case hol_term_type::NOT:
		if (!apply_head<false, false>(src->unary.operand, new_formula, dst_variables, siblings, max_variable, removed_quantifier, remove_negations, remove_wide_scope_marker, try_find_head, make_dst, apply))
			return false;
		if (new_formula != nullptr) {
			if (remove_negations) {
				dst = new_formula;
			} else if (new_formula == src->unary.operand) {
				free(*new_formula);
				dst = src;
				dst->reference_count++;
			} else {
				dst = hol_term::new_not(new_formula);
				if (dst == nullptr) {
					free(*new_formula);
					if (new_formula->reference_count == 0)
						free(new_formula);
					return false;
				}
			}
		} else {
			dst = nullptr;
		}
		return true;

	case hol_term_type::AND:
	case hol_term_type::OR:
		if (!siblings.ensure_capacity(siblings.length + src->array.length - 1))
			return false;
		for (unsigned int i = 0; i + 1 < src->array.length; i++)
			siblings[siblings.length++] = src->array.operands[i];
		if (!apply_head<false, false>(src->array.operands[src->array.length - 1], new_formula, dst_variables, siblings, max_variable, removed_quantifier, remove_negations, remove_wide_scope_marker, try_find_head, make_dst, apply))
			return false;
		remove_negations = false;
		if (new_formula != nullptr) {
			hol_term** new_dst = (hol_term**) malloc(sizeof(hol_term*) * src->array.length);
			if (new_dst == nullptr) {
				free(*new_formula);
				if (new_formula->reference_count == 0)
					free(new_formula);
				return false;
			}
			new_dst[src->array.length - 1] = new_formula;

			unsigned int new_start = src->array.length - 1;
			unsigned int new_length = 1;
			for (unsigned int i = src->array.length - 1; i > 0; i--) {
				if ((IsRoot && KeepIndependentSiblings) || siblings.contains(src->array.operands[i - 1])) {
					new_dst[--new_start] = src->array.operands[i - 1];
					src->array.operands[i - 1]->reference_count++;
					new_length++;
				} else {
					if (new_length == 1) {
						dst = new_dst[new_start];
					} else if (src->type == hol_term_type::AND) {
						dst = hol_term::new_and(make_array_view(new_dst + new_start, new_length));
					} else {
						dst = hol_term::new_or(make_array_view(new_dst + new_start, new_length));
					}
					if (dst == nullptr) {
						for (unsigned int j = 0; j < new_length; j++) {
							free(*new_dst[new_start + j]);
							if (new_dst[new_start + j]->reference_count == 0)
								free(new_dst[new_start + j]);
						}
						free(new_dst); return false;
					}
					new_length = 1;
					new_dst[new_start] = dst;
				}
			}

			if (new_length == 1) {
				dst = new_dst[new_start];
			} else if (new_length == src->array.length && new_formula == src->array.operands[src->array.length - 1]) {
				for (unsigned int i = 0; i < new_length; i++) {
					free(*new_dst[i]);
					if (new_dst[i]->reference_count == 0)
						free(new_dst[i]);
				}
				dst = src;
				dst->reference_count++;
			} else if (src->type == hol_term_type::AND) {
				dst = hol_term::new_and(make_array_view(new_dst + new_start, new_length));
			} else {
				dst = hol_term::new_or(make_array_view(new_dst + new_start, new_length));
			}
			if (dst == nullptr) {
				for (unsigned int i = 0; i < new_length; i++) {
					free(*new_dst[i]);
					if (new_dst[i]->reference_count == 0)
						free(new_dst[i]);
				}
				free(new_dst);
				return false;
			}
			free(new_dst);
		} else {
			dst = nullptr;
		}
		return true;

	case hol_term_type::FOR_ALL:
	case hol_term_type::EXISTS:
	case hol_term_type::LAMBDA:
		if (!apply_head<false, false>(src->quantifier.operand, new_formula, dst_variables, siblings, max(max_variable, src->quantifier.variable), removed_quantifier, remove_negations, remove_wide_scope_marker, try_find_head, make_dst, apply))
			return false;
		if (new_formula != nullptr) {
			if (!dst_variables.contains(src->quantifier.variable)) {
				removed_quantifier = true;
				remove_negations = true;
				dst = new_formula;
			} else {
				remove_negations = false;
				if (new_formula == src->quantifier.operand) {
					free(*new_formula);
					dst = src;
					dst->reference_count++;
				} else {
					if (src->type == hol_term_type::FOR_ALL)
						dst = hol_term::new_for_all(src->quantifier.variable_type, src->quantifier.variable, new_formula);
					else if (src->type == hol_term_type::EXISTS)
						dst = hol_term::new_exists(src->quantifier.variable_type, src->quantifier.variable, new_formula);
					else dst = hol_term::new_lambda(src->quantifier.variable_type, src->quantifier.variable, new_formula);
					if (dst == nullptr) {
						free(*new_formula);
						if (new_formula->reference_count == 0)
							free(new_formula);
						return false;
					}
				}
			}
		} else {
			dst = nullptr;
		}
		return true;

	case hol_term_type::IF_THEN:
	case hol_term_type::UNARY_APPLICATION:
		if (src->type == hol_term_type::IF_THEN) {
			if (!siblings.ensure_capacity(siblings.length + 1))
				return false;
			siblings[siblings.length++] = src->binary.left;
		}
		if (!apply_head<false, false>(src->binary.right, new_formula, dst_variables, siblings, max_variable, removed_quantifier, remove_negations, remove_wide_scope_marker, try_find_head, make_dst, apply))
			return false;
		remove_negations = false;
		if (new_formula != nullptr) {
			if (remove_wide_scope_marker && src->type == hol_term_type::UNARY_APPLICATION && src->binary.left->type == hol_term_type::CONSTANT && src->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
				dst = new_formula;
			} else if (!(IsRoot && KeepIndependentSiblings) && src->type == hol_term_type::IF_THEN && !siblings.contains(src->binary.left)) {
				dst = new_formula;
			} else if (new_formula == src->binary.right) {
				free(*new_formula);
				dst = src;
				dst->reference_count++;
			} else {
				if (src->type == hol_term_type::IF_THEN)
					dst = hol_term::new_if_then(src->binary.left, new_formula);
				else dst = hol_term::new_apply(src->binary.left, new_formula);
				if (dst == nullptr) {
					free(*new_formula);
					if (new_formula->reference_count == 0)
						free(new_formula);
					return false;
				}
				src->binary.left->reference_count++;
			}
		} else {
			dst = nullptr;
		}
		return true;

	case hol_term_type::ANY:
	case hol_term_type::ANY_RIGHT:
		if (src->any.included != nullptr) {
			if (!apply_head<false, false>(src->any.included, new_formula, dst_variables, siblings, max_variable, removed_quantifier, remove_negations, remove_wide_scope_marker, try_find_head, make_dst, apply))
				return false;
			remove_negations = false;
			if (new_formula != nullptr) {
				if (new_formula == src->any.included) {
					free(*new_formula);
					dst = src;
					dst->reference_count++;
				} else if (new_formula->type == hol_term_type::ANY && new_formula->any.excluded_tree_count == 0) {
					dst = new_formula;
				} else if (new_formula->type == hol_term_type::ANY_RIGHT && new_formula->any.excluded_tree_count == 0) {
					if (src->type == hol_term_type::ANY_RIGHT) {
						dst = new_formula;
					} else {
						dst = hol_term::new_any(new_formula->any.included);
						if (dst == nullptr) {
							free(*new_formula); if (new_formula->reference_count == 0) free(new_formula);
							return false;
						}
					}
				} else if (new_formula->type == hol_term_type::ANY || new_formula->type == hol_term_type::ANY_RIGHT) {
					array<hol_term*> excluded(max(1u, new_formula->any.excluded_tree_count + src->any.excluded_tree_count));
					for (unsigned int i = 0; i < new_formula->any.excluded_tree_count; i++) {
						hol_term* tree = new_formula->any.excluded_trees[i];
						if (tree->type != hol_term_type::ANY || tree->any.included == nullptr
						 || !(tree->any.included->type == hol_term_type::EXISTS || tree->any.included->type == hol_term_type::FOR_ALL || tree->any.included->type == hol_term_type::LAMBDA)
						 || dst_variables.contains(tree->any.included->quantifier.variable))
						{
							/* make sure this tree is not a subset of any tree in `src->any.excluded_trees` */
							bool irreducible = true;
							for (unsigned int j = 0; j < src->any.excluded_tree_count; j++) {
								hol_term* other = src->any.excluded_trees[j];
								if (is_subset<built_in_predicates>(tree, other)) {
									irreducible = false;
									break;
								}
							}
							if (irreducible)
								excluded[excluded.length++] = tree;
						}
					}
					unsigned int old_excluded_tree_count = excluded.length;
					for (unsigned int i = 0; i < src->any.excluded_tree_count; i++) {
						hol_term* tree = src->any.excluded_trees[i];
						if (tree->type != hol_term_type::ANY || tree->any.included == nullptr
						 || !(tree->any.included->type == hol_term_type::EXISTS || tree->any.included->type == hol_term_type::FOR_ALL || tree->any.included->type == hol_term_type::LAMBDA)
						 || dst_variables.contains(tree->any.included->quantifier.variable))
						{
							/* make sure this tree is not a subset of any tree in `excluded` so far */
							bool irreducible = true;
							for (unsigned int j = 0; j < old_excluded_tree_count; j++) {
								hol_term* other = excluded[j];
								if (is_subset<built_in_predicates>(tree, other)) {
									irreducible = false;
									break;
								}
							}
							if (irreducible)
								excluded[excluded.length++] = tree;
						}
					}
					if (src->type == hol_term_type::ANY || new_formula->type == hol_term_type::ANY)
						dst = hol_term::new_any(new_formula->any.included, excluded.data, excluded.length);
					else dst = hol_term::new_any_right(new_formula->any.included, excluded.data, excluded.length);
					if (dst == nullptr) {
						free(*new_formula); if (new_formula->reference_count == 0) free(new_formula);
						return false;
					}
					if (new_formula->any.included != nullptr)
						new_formula->any.included->reference_count++;
					for (hol_term* tree : excluded)
						tree->reference_count++;
					free(*new_formula); if (new_formula->reference_count == 0) free(new_formula);
				} else {
					/* make sure we remove any subtrees that exclude removed quantifiers */
					array<hol_term*> excluded_trees(max(1u, src->any.excluded_tree_count));
					for (unsigned int i = 0; i < src->any.excluded_tree_count; i++) {
						hol_term* excluded_tree = src->any.excluded_trees[i];
						if (excluded_tree->type != hol_term_type::ANY || excluded_tree->any.included == nullptr
						 || !(excluded_tree->any.included->type == hol_term_type::EXISTS || excluded_tree->any.included->type == hol_term_type::FOR_ALL || excluded_tree->any.included->type == hol_term_type::LAMBDA)
						 || dst_variables.contains(excluded_tree->any.included->quantifier.variable))
						{
							excluded_trees[excluded_trees.length++] = excluded_tree;
						}
					}

					if (src->type == hol_term_type::ANY)
						dst = hol_term::new_any(new_formula, excluded_trees.data, excluded_trees.length);
					else dst = hol_term::new_any_right(new_formula, excluded_trees.data, excluded_trees.length);
					if (dst == nullptr) {
						free(*new_formula); if (new_formula->reference_count == 0) free(new_formula);
						return false;
					}
					for (unsigned int i = 0; i < excluded_trees.length; i++)
						excluded_trees[i]->reference_count++;
				}
			} else {
				dst = nullptr;
			}
		} else {
			dst = nullptr;
		}
		return true;

	case hol_term_type::ANY_ARRAY:
		if (src->any_array.right.length == 0) {
			dst = nullptr;
			return true;
		} if (!apply_head<false, false>(src->any_array.right.operands[src->any_array.right.length - 1], new_formula, dst_variables, siblings, max_variable, removed_quantifier, remove_negations, remove_wide_scope_marker, try_find_head, make_dst, apply))
			return false;
		remove_negations = false;
		if (new_formula != nullptr) {
			if (new_formula == src->any_array.right.operands[src->any_array.right.length - 1]) {
				free(*new_formula);
				dst = src;
				dst->reference_count++;
			} else {
				dst = hol_term::new_any_array(src->any_array.oper, src->any_array.all,
						make_array_view(src->any_array.any.operands, src->any_array.any.length),
						make_array_view(src->any_array.left.operands, src->any_array.left.length),
						make_appended_array_view(make_array_view(src->any_array.right.operands, src->any_array.right.length - 1), new_formula));
				if (dst == nullptr) {
					free(*new_formula);
					if (new_formula->reference_count == 0)
						free(new_formula);
					return false;
				}
				dst->any_array.all->reference_count++;
				for (unsigned int i = 0; i < dst->any_array.any.length; i++)
					dst->any_array.any.operands[i]->reference_count++;
				for (unsigned int i = 0; i < dst->any_array.left.length; i++)
					dst->any_array.left.operands[i]->reference_count++;
				for (unsigned int i = 0; i + 1 < dst->any_array.right.length; i++)
					dst->any_array.right.operands[i]->reference_count++;
			}
		} else {
			dst = nullptr;
		}
		return true;

	case hol_term_type::ANY_QUANTIFIER:
		if (!apply_head<false, false>(src->any_quantifier.operand, new_formula, dst_variables, siblings, max_variable, removed_quantifier, remove_negations, remove_wide_scope_marker, try_find_head, make_dst, apply))
			return false;
		remove_negations = false;
		if (new_formula != nullptr) {
			if (new_formula == src->any_quantifier.operand) {
				free(*new_formula);
				dst = src;
				dst->reference_count++;
			} else {
				dst = hol_term::new_any_quantifier(src->any_quantifier.quantifier, new_formula);
				if (dst == nullptr) {
					free(*new_formula);
					if (new_formula->reference_count == 0)
						free(new_formula);
					return false;
				}
			}
		} else {
			dst = nullptr;
		}
		return true;
	}
	fprintf(stderr, "apply_head ERROR: Unrecognized hol_term_type.\n");
	return false;
}

enum class any_node_position {
	LEFT,
	RIGHT,
	NONE
};

template<any_node_position AnyNodePosition, bool AnyRightOnly>
struct head_substituter {
	bool found_wide_scope;
	bool could_have_wide_scope;
	bool first_any;
	bool has_any;
	bool parent_is_negation;
	const hol_term* src;
	hol_term* dst;
	unsigned int last_declared_variable;

	head_substituter(bool found_wide_scope, bool could_have_wide_scope, bool first_any, const hol_term* src, hol_term* dst) :
			found_wide_scope(found_wide_scope), could_have_wide_scope(could_have_wide_scope), first_any(first_any), has_any(false), parent_is_negation(false), src(src), dst(dst), last_declared_variable(0) { }
};

template<bool AnyRightOnly>
inline hol_term* wrap_any_right(hol_term* operand, unsigned int prev_declared_variable, bool exclude_wide_scope)
{
	if (prev_declared_variable != 0) {
		unsigned int excluded_tree_count = 3 + (exclude_wide_scope ? 1 : 0);
		hol_term* excluded_trees[4];
		excluded_trees[0] = hol_term::new_any(hol_term::new_for_all(prev_declared_variable, &HOL_ANY));
		excluded_trees[1] = hol_term::new_any(hol_term::new_exists(prev_declared_variable, &HOL_ANY));
		excluded_trees[2] = hol_term::new_any(hol_term::new_lambda(prev_declared_variable, &HOL_ANY));
		if (exclude_wide_scope)
			excluded_trees[3] = hol_term::new_any_right(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ANY));
		if (excluded_trees[0] != nullptr) HOL_ANY.reference_count++;
		if (excluded_trees[1] != nullptr) HOL_ANY.reference_count++;
		if (excluded_trees[2] != nullptr) HOL_ANY.reference_count++;
		if (exclude_wide_scope && excluded_trees[3] != nullptr) HOL_ANY.reference_count++;
		if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr || excluded_trees[2] == nullptr || (exclude_wide_scope && excluded_trees[3] == nullptr)) {
			if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
			if (excluded_trees[1] != nullptr) { free(*excluded_trees[1]); free(excluded_trees[1]); }
			if (excluded_trees[2] != nullptr) { free(*excluded_trees[2]); free(excluded_trees[2]); }
			return nullptr;
		}
		hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;

		hol_term* term;
		if (AnyRightOnly)
			term = hol_term::new_any_right_only(operand, excluded_trees, excluded_tree_count);
		else term = hol_term::new_any_right(operand, excluded_trees, excluded_tree_count);
		if (term == nullptr) {
			free(*excluded_trees[0]); free(excluded_trees[0]);
			free(*excluded_trees[1]); free(excluded_trees[1]);
			free(*excluded_trees[2]); free(excluded_trees[2]);
			free(*excluded_trees[3]); free(excluded_trees[3]);
			return nullptr;
		}
		return term;
	} else if (exclude_wide_scope) {
		hol_term* excluded = hol_term::new_any_right(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ANY));
		if (excluded == nullptr) return nullptr;
		hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
		HOL_ANY.reference_count++;
		hol_term* term;
		if (AnyRightOnly)
			term = hol_term::new_any_right_only(operand, &excluded, 1);
		else term = hol_term::new_any_right(operand, &excluded, 1);
		if (term == nullptr) {
			free(*excluded); free(excluded);
			return nullptr;
		}
		return term;
	} else {
		if (AnyRightOnly)
			return hol_term::new_any_right_only(operand);
		else return hol_term::new_any_right(operand);
	}
}

template<hol_term_type Type, any_node_position AnyNodePosition, bool AnyRightOnly>
inline hol_term* apply(hol_term* src, head_substituter<AnyNodePosition, AnyRightOnly>& substituter)
{
	if (src == substituter.src) {
		if (AnyNodePosition == any_node_position::LEFT) {
			if (substituter.dst->type == hol_term_type::ANY || substituter.dst->type == hol_term_type::ANY_RIGHT
			 || (substituter.dst->type == hol_term_type::UNARY_APPLICATION && substituter.dst->binary.left->type == hol_term_type::CONSTANT && substituter.dst->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE))
				substituter.could_have_wide_scope = true;
			if (substituter.has_any || substituter.dst->type == hol_term_type::ANY || substituter.dst->type == hol_term_type::ANY_RIGHT) {
				if (substituter.src != substituter.dst)
					substituter.dst->reference_count++;
				return substituter.dst;
			} else {
				hol_term* new_term = wrap_any_right<AnyRightOnly>(substituter.dst, substituter.last_declared_variable, substituter.found_wide_scope || (!substituter.could_have_wide_scope && substituter.first_any));
				substituter.first_any = false;
				if (new_term == nullptr)
					return nullptr;
				substituter.dst->reference_count++;
				return new_term;
			}
		} else if (AnyNodePosition == any_node_position::RIGHT && (src->type == hol_term_type::ANY || src->type == hol_term_type::ANY_RIGHT)) {
			hol_term* new_term = wrap_any_right<false>(substituter.dst, substituter.last_declared_variable, substituter.found_wide_scope || (!substituter.could_have_wide_scope && substituter.first_any));
			substituter.first_any = false;
			if (new_term == nullptr)
				return nullptr;
			substituter.dst->reference_count++;
			return new_term;
		}
		if (substituter.src != substituter.dst)
			substituter.dst->reference_count++;
		return substituter.dst;
	}

	/* NOTE: this function should mirror the semantics of
	   `apply_head_conjunct`, `apply<head_substituter>`, `apply_arg`, and
	   `find_head` in `hdp_parser.h` */
	bool changed; hol_term* new_term = nullptr;
	hol_term* first; hol_term* second; hol_term* third;
	unsigned int prev_declared_variable = 0;
	bool found_wide_scope = false, first_any = false, has_any = false, parent_is_negation = false;
	switch (Type) {
	case hol_term_type::IF_THEN:
	case hol_term_type::EQUALS:
	case hol_term_type::UNARY_APPLICATION:
		if ((AnyNodePosition == any_node_position::RIGHT && src->type == hol_term_type::IF_THEN && src->binary.right->type != hol_term_type::ANY && src->binary.right->type != hol_term_type::ANY_RIGHT)
		 || (AnyNodePosition == any_node_position::LEFT && src->type == hol_term_type::UNARY_APPLICATION))
		{
			prev_declared_variable = substituter.last_declared_variable;
			found_wide_scope = substituter.found_wide_scope;
			first_any = substituter.first_any;
			has_any = substituter.has_any;
			parent_is_negation = substituter.parent_is_negation;
			substituter.last_declared_variable = 0;
			substituter.first_any = false;
			substituter.has_any = false;
		}
		substituter.found_wide_scope = (src->type == hol_term_type::UNARY_APPLICATION && src->binary.left->type == hol_term_type::CONSTANT && src->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE);
		substituter.parent_is_negation = false;
		first = src->binary.left;
		second = apply(src->binary.right, substituter);
		if (second == nullptr)
			return nullptr;

		if (src->type == hol_term_type::UNARY_APPLICATION && src->binary.left->type == hol_term_type::CONSTANT && src->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE)
			substituter.could_have_wide_scope = true;

		if (AnyNodePosition == any_node_position::RIGHT && src->type == hol_term_type::IF_THEN && second->type != hol_term_type::ANY && second->type != hol_term_type::ANY_RIGHT && second->type != hol_term_type::ANY_RIGHT_ONLY && !has_any) {
			hol_term* term = wrap_any_right<AnyRightOnly>(second, prev_declared_variable, found_wide_scope || (first_any && !substituter.could_have_wide_scope));
			if (term == nullptr) {
				if (second != src->binary.right) { free(*second); if (second->reference_count == 0) free(second); }
				return nullptr;
			}
			if (second == src->binary.right) second->reference_count++;
			second = term;
		}

		if (second == src->binary.right) {
			new_term = src;
		} else {
			if (!new_hol_term(new_term)) {
				if (second != src->binary.right) {
					free(*second); if (second->reference_count == 0) free(second);
				}
				return nullptr;
			}
			new_term->binary.left = first;
			new_term->binary.right = second;
			first->reference_count++;
			if (second == src->binary.right) second->reference_count++;
			new_term->type = Type;
			new_term->reference_count = 1;
		}

		if (AnyNodePosition == any_node_position::LEFT && src->type == hol_term_type::UNARY_APPLICATION && !has_any) {
			hol_term* term = wrap_any_right<AnyRightOnly>(new_term, prev_declared_variable, found_wide_scope || (first_any && !substituter.could_have_wide_scope));
			if (term == nullptr) {
				if (new_term != src) { free(*new_term); if (new_term->reference_count == 0) free(new_term); }
				return nullptr;
			}
			if (new_term == src) new_term->reference_count++;
			new_term = term;
		}
		return new_term;

	case hol_term_type::BINARY_APPLICATION:
		if (AnyNodePosition == any_node_position::RIGHT || AnyNodePosition == any_node_position::LEFT) {
			prev_declared_variable = substituter.last_declared_variable;
			found_wide_scope = substituter.found_wide_scope;
			first_any = substituter.first_any;
			has_any = substituter.has_any;
			parent_is_negation = substituter.parent_is_negation;
			substituter.last_declared_variable = 0;
			substituter.found_wide_scope = false;
			substituter.first_any = false;
			substituter.has_any = false;
			substituter.parent_is_negation = false;
		}
		first = src->ternary.first;
		second = src->ternary.second;
		third = apply(src->ternary.third, substituter);
		if (third == nullptr)
			return nullptr;

		if (AnyNodePosition == any_node_position::RIGHT && third->type != hol_term_type::ANY && third->type != hol_term_type::ANY_RIGHT && third->type != hol_term_type::ANY_RIGHT_ONLY) {
			hol_term* term = wrap_any_right<AnyRightOnly>(third, prev_declared_variable, found_wide_scope || (first_any && !substituter.could_have_wide_scope));
			if (term == nullptr) {
				if (third != src->unary.operand) { free(*third); if (third->reference_count == 0) free(third); }
				return nullptr;
			}
			if (third == src->unary.operand) third->reference_count++;
			third = term;
		}

		if (third == src->ternary.third) {
			new_term = src;
		} else {
			if (!new_hol_term(new_term)) {
				if (third != src->ternary.third) {
					free(*third); if (third->reference_count == 0) free(third);
				}
				return nullptr;
			}
			new_term->ternary.first = first;
			new_term->ternary.second = second;
			new_term->ternary.third = third;
			first->reference_count++;
			second->reference_count++;
			if (third == src->ternary.third) third->reference_count++;
			new_term->type = Type;
			new_term->reference_count = 1;
		}

		if (AnyNodePosition == any_node_position::LEFT && !has_any) {
			hol_term* term = wrap_any_right<AnyRightOnly>(new_term, prev_declared_variable, found_wide_scope || (first_any && !substituter.could_have_wide_scope));
			if (term == nullptr) {
				if (new_term != src) { free(*new_term); if (new_term->reference_count == 0) free(new_term); }
				return nullptr;
			}
			if (new_term == src) new_term->reference_count++;
			new_term = term;
		}
		return new_term;

	case hol_term_type::AND:
	case hol_term_type::OR:
	case hol_term_type::IFF:
		changed = false;
		substituter.has_any = false;
		substituter.parent_is_negation = false;
		first = apply(src->array.operands[src->array.length - 1], substituter);
		if (first == nullptr) {
			return nullptr;
		} else if (first != src->array.operands[src->array.length - 1])
			changed = true;

		if (!changed) {
			return src;
		} else {
			if (!new_hol_term(new_term)) {
				if (first != src->array.operands[src->array.length - 1]) {
					free(*first);
					if (first->reference_count == 0)
						free(first);
				}
				return nullptr;
			}
			new_term->type = Type;
			new_term->reference_count = 1;
			if (first->type == Type && first->reference_count == 1) {
				/* the new child is the same type as the parent, so merge them */
				new_term->array.operands = (hol_term**) realloc(first->array.operands, sizeof(hol_term*) * (src->array.length + first->array.length - 1));
				if (new_term->array.operands == nullptr) {
					if (first != src->array.operands[src->array.length - 1]) {
						free(*first); if (first->reference_count == 0) free(first);
					}
					return nullptr;
				}
				for (unsigned int i = first->array.length; i > 0; i--)
					new_term->array.operands[i + src->array.length - 2] = new_term->array.operands[i - 1];
				for (unsigned int i = 0; i + 1 < src->array.length; i++) {
					new_term->array.operands[i] = src->array.operands[i];
					new_term->array.operands[i]->reference_count++;
				}
				new_term->array.length = src->array.length + first->array.length - 1;
				free(first);
			} else {
				new_term->array.length = src->array.length;
				new_term->array.operands = (hol_term**) malloc(sizeof(hol_term*) * new_term->array.length);
				if (new_term->array.operands == nullptr) {
					if (first != src->array.operands[src->array.length - 1]) {
						free(*first);
						if (first->reference_count == 0)
							free(first);
					}
					free(new_term);
					return nullptr;
				}
				for (unsigned int i = 0; i + 1 < src->array.length; i++) {
					new_term->array.operands[i] = src->array.operands[i];
					new_term->array.operands[i]->reference_count++;
				}
				new_term->array.operands[src->array.length - 1] = first;
				if (first == src->array.operands[src->array.length - 1])
					first->reference_count++;
			}
			return new_term;
		}

	case hol_term_type::ANY_ARRAY:
		changed = false;
		substituter.has_any = false;
		substituter.parent_is_negation = false;
		if (src->any_array.right.length == 0)
			first = apply(src->any_array.all, substituter);
		else first = apply(src->any_array.right.operands[src->any_array.right.length - 1], substituter);
		if (first == nullptr) {
			return nullptr;
		} else if (first != (src->any_array.right.length == 0 ? src->any_array.all : src->any_array.right.operands[src->any_array.right.length - 1])) {
			changed = true;
		}

		if (!changed) {
			new_term = src;
		} else {
			if (src->any_array.right.length == 0) {
				new_term = hol_term::new_any_array(src->any_array.oper, first,
						make_array_view(src->any_array.any.operands, src->any_array.any.length),
						make_array_view(src->any_array.left.operands, src->any_array.left.length),
						make_array_view(src->any_array.right.operands, src->any_array.right.length));
			} else {
				new_term = hol_term::new_any_array(src->any_array.oper, src->any_array.all,
						make_array_view(src->any_array.any.operands, src->any_array.any.length),
						make_array_view(src->any_array.left.operands, src->any_array.left.length),
						make_appended_array_view(make_array_view(src->any_array.right.operands, src->any_array.right.length - 1), first));
			}
			if (new_term == nullptr) {
				free(*first); if (first->reference_count == 0) free(first);
				return nullptr;
			}
			new_term->any_array.all->reference_count++;
			for (unsigned int i = 0; i < new_term->any_array.any.length; i++)
				new_term->any_array.any.operands[i]->reference_count++;
			for (unsigned int i = 0; i < new_term->any_array.left.length; i++)
				new_term->any_array.left.operands[i]->reference_count++;
			for (unsigned int i = 0; i < new_term->any_array.right.length; i++)
				new_term->any_array.right.operands[i]->reference_count++;
			first->reference_count--;
		}
		return new_term;

	case hol_term_type::FOR_ALL:
	case hol_term_type::EXISTS:
	case hol_term_type::LAMBDA:
		if ((AnyNodePosition == any_node_position::RIGHT && src->type == hol_term_type::LAMBDA)
		 || (AnyNodePosition == any_node_position::LEFT && src->type != hol_term_type::LAMBDA))
		{
			prev_declared_variable = substituter.last_declared_variable;
			found_wide_scope = substituter.found_wide_scope;
			first_any = substituter.first_any;
			has_any = substituter.has_any;
			parent_is_negation = substituter.parent_is_negation;
			substituter.last_declared_variable = 0;
			substituter.found_wide_scope = false;
			substituter.first_any = false;
			substituter.has_any = false;
		}
		substituter.last_declared_variable = src->quantifier.variable;
		substituter.parent_is_negation = false;
		first = apply(src->quantifier.operand, substituter);
		if (first == nullptr)
			return nullptr;

		if (AnyNodePosition == any_node_position::RIGHT && src->type == hol_term_type::LAMBDA && first->type != hol_term_type::ANY && first->type != hol_term_type::ANY_RIGHT && first->type != hol_term_type::ANY_RIGHT_ONLY) {
			hol_term* term = wrap_any_right<AnyRightOnly>(first, src->quantifier.variable, found_wide_scope || (first_any && !substituter.could_have_wide_scope));
			if (term == nullptr) {
				if (first != src->quantifier.operand) { free(*first); if (first->reference_count == 0) free(first); }
				return nullptr;
			}
			if (first == src->quantifier.operand) first->reference_count++;
			first = term;
		}

		if (first == src->quantifier.operand) {
			new_term = src;
		} else {
			if (src->type == hol_term_type::FOR_ALL)
				new_term = hol_term::new_for_all(src->quantifier.variable_type, src->quantifier.variable, first);
			else if (src->type == hol_term_type::EXISTS)
				new_term = hol_term::new_exists(src->quantifier.variable_type, src->quantifier.variable, first);
			else if (src->type == hol_term_type::LAMBDA)
				new_term = hol_term::new_lambda(src->quantifier.variable_type, src->quantifier.variable, first);
			if (new_term == nullptr) {
				free(*first); if (first->reference_count == 0) free(first);
				return nullptr;
			}
		}

		if (AnyNodePosition == any_node_position::LEFT && src->type != hol_term_type::LAMBDA && !parent_is_negation && !has_any) {
			hol_term* term = wrap_any_right<AnyRightOnly>(new_term, prev_declared_variable, found_wide_scope || (first_any && !substituter.could_have_wide_scope));
			if (term == nullptr) {
				if (new_term != src) { free(*new_term); if (new_term->reference_count == 0) free(new_term); }
				return nullptr;
			}
			if (new_term == src) new_term->reference_count++;
			new_term = term;
		}
		return new_term;

	case hol_term_type::ANY_QUANTIFIER:
		if (AnyNodePosition == any_node_position::LEFT && src->any_quantifier.quantifier != hol_quantifier_type::EXISTS) {
			prev_declared_variable = substituter.last_declared_variable;
			found_wide_scope = substituter.found_wide_scope;
			first_any = substituter.first_any;
			has_any = substituter.has_any;
			parent_is_negation = substituter.parent_is_negation;
			substituter.last_declared_variable = 0;
			substituter.found_wide_scope = false;
			substituter.first_any = false;
			substituter.has_any = false;
		}
		substituter.parent_is_negation = false;
		first = apply(src->any_quantifier.operand, substituter);
		if (first == nullptr)
			return nullptr;

		if (first == src->any_quantifier.operand) {
			new_term = src;
		} else {
			new_term = hol_term::new_any_quantifier(src->any_quantifier.quantifier, first);
			if (new_term == nullptr) {
				free(*first); if (first->reference_count == 0) free(first);
				return nullptr;
			}
		}

		if (AnyNodePosition == any_node_position::LEFT && src->any_quantifier.quantifier != hol_quantifier_type::EXISTS && !parent_is_negation && !has_any) {
			hol_term* term = wrap_any_right<AnyRightOnly>(new_term, prev_declared_variable, found_wide_scope || (first_any && !substituter.could_have_wide_scope));
			if (term == nullptr) {
				if (new_term != src) { free(*new_term); if (new_term->reference_count == 0) free(new_term); }
				return nullptr;
			}
			if (new_term == src) new_term->reference_count++;
			new_term = term;
		}
		return new_term;

	case hol_term_type::NOT:
		if (AnyNodePosition == any_node_position::RIGHT || AnyNodePosition == any_node_position::LEFT) {
			prev_declared_variable = substituter.last_declared_variable;
			found_wide_scope = substituter.found_wide_scope;
			first_any = substituter.first_any;
			has_any = substituter.has_any;
			parent_is_negation = substituter.parent_is_negation;
			substituter.last_declared_variable = 0;
			substituter.found_wide_scope = false;
			substituter.first_any = false;
			substituter.has_any = false;
		}
		substituter.parent_is_negation = true;
		first = apply(src->unary.operand, substituter);
		if (first == nullptr)
			return nullptr;

		if (AnyNodePosition == any_node_position::RIGHT && first->type != hol_term_type::ANY && first->type != hol_term_type::ANY_RIGHT && first->type != hol_term_type::ANY_RIGHT_ONLY) {
			hol_term* term = wrap_any_right<AnyRightOnly>(first, prev_declared_variable, found_wide_scope || (first_any && !substituter.could_have_wide_scope));
			if (term == nullptr) {
				if (first != src->unary.operand) { free(*first); if (first->reference_count == 0) free(first); }
				return nullptr;
			}
			if (first == src->unary.operand) first->reference_count++;
			first = term;
		}

		if (first == src->unary.operand) {
			new_term = src;
		} else {
			new_term = hol_term::new_not(first);
			if (new_term == nullptr) {
				free(*first); if (first->reference_count == 0) free(first);
				return nullptr;
			}
		}

		if (AnyNodePosition == any_node_position::LEFT && !has_any) {
			hol_term* term = wrap_any_right<AnyRightOnly>(new_term, prev_declared_variable, found_wide_scope || (first_any && !substituter.could_have_wide_scope));
			if (term == nullptr) {
				if (new_term != src) { free(*new_term); if (new_term->reference_count == 0) free(new_term); }
				return nullptr;
			}
			if (new_term == src) new_term->reference_count++;
			new_term = term;
		}
		return new_term;

	case hol_term_type::ANY:
	case hol_term_type::ANY_RIGHT:
	case hol_term_type::ANY_RIGHT_ONLY:
		if (src->any.included == nullptr)
			return nullptr;
		substituter.has_any = true;
		substituter.parent_is_negation = false;
		first = apply(src->any.included, substituter);
		if (first == nullptr)
			return nullptr;
		substituter.could_have_wide_scope = true;

		if (first == src->any.included) {
			new_term = src;
		} else {
			if (first->type == src->type) {
				array<hol_term*> excluded(max(1u, first->any.excluded_tree_count + src->any.excluded_tree_count));
				for (unsigned int i = 0; i < first->any.excluded_tree_count; i++) {
					/* make sure this tree isn't a subset of any tree in `src->any.excluded_trees` */
					bool irreducible = true;
					for (unsigned int j = 0; j < src->any.excluded_tree_count; j++) {
						if (is_subset<built_in_predicates>(first->any.excluded_trees[i], src->any.excluded_trees[j])) {
							irreducible = false;
							break;
						}
					}
					if (irreducible)
						excluded[excluded.length++] = first->any.excluded_trees[i];
				}
				unsigned int old_excluded_tree_count = excluded.length;
				for (unsigned int i = 0; i < src->any.excluded_tree_count; i++) {
					/* make sure this tree isn't a subset of any tree in `excluded` so far */
					bool irreducible = true;
					for (unsigned int j = 0; j < old_excluded_tree_count; j++) {
						if (is_subset<built_in_predicates>(src->any.excluded_trees[i], excluded[j])) {
							irreducible = false;
							break;
						}
					}
					if (irreducible)
						excluded[excluded.length++] = src->any.excluded_trees[i];
				}
				if (src->type == hol_term_type::ANY)
					new_term = hol_term::new_any(first->any.included, excluded.data, excluded.length);
				else new_term = hol_term::new_any_right(first->any.included, excluded.data, excluded.length);
				if (new_term == nullptr) {
					free(*first); if (first->reference_count == 0) free(first);
					return nullptr;
				}
				if (first->any.included != nullptr)
					first->any.included->reference_count++;
				for (hol_term* tree : excluded)
					tree->reference_count++;
				free(*first); if (first->reference_count == 0) free(first);
			} else if (src->type == hol_term_type::ANY || src->type == hol_term_type::ANY_RIGHT) {
				if (src->type == hol_term_type::ANY)
					new_term = hol_term::new_any(first, src->any.excluded_trees, src->any.excluded_tree_count);
				else new_term = hol_term::new_any_right(first, src->any.excluded_trees, src->any.excluded_tree_count);
				if (new_term == nullptr) {
					free(*first); if (first->reference_count == 0) free(first);
					return nullptr;
				}
				for (unsigned int i = 0; i < src->any.excluded_tree_count; i++)
					src->any.excluded_trees[i]->reference_count++;
			} else {
				new_term = hol_term::new_any_right_only(first, src->any.excluded_trees, src->any.excluded_tree_count);
				if (new_term == nullptr) {
					free(*first); if (first->reference_count == 0) free(first);
					return nullptr;
				}
				for (unsigned int i = 0; i < src->any.excluded_tree_count; i++)
					src->any.excluded_trees[i]->reference_count++;
			}
		}
		return new_term;

	case hol_term_type::CONSTANT:
	case hol_term_type::VARIABLE:
	case hol_term_type::VARIABLE_PREIMAGE:
	case hol_term_type::PARAMETER:
	case hol_term_type::NUMBER:
	case hol_term_type::STRING:
	case hol_term_type::UINT_LIST:
	case hol_term_type::TRUE:
	case hol_term_type::FALSE:
	case hol_term_type::ANY_CONSTANT:
	case hol_term_type::ANY_CONSTANT_EXCEPT:
		return default_apply<Type>(src, substituter);
	}
	fprintf(stderr, "apply ERROR: Unrecognized hol_term_type when substituting head.\n");
	return NULL;
}

template<any_node_position AnyNodePosition, bool AnyRightOnly = true>
inline hol_term* substitute_head(hol_term* src,
		const hol_term* src_term, hol_term* dst_term,
		bool could_have_wide_scope = false)
{
	head_substituter<AnyNodePosition, AnyRightOnly> substituter(false, could_have_wide_scope, true, src_term, dst_term);
	hol_term* dst = apply(src, substituter);
	if (dst == nullptr)
		return nullptr;

	if (AnyNodePosition == any_node_position::RIGHT && dst->type == hol_term_type::ANY_RIGHT_ONLY) {
		hol_term* term = hol_term::new_any_right(dst->any.included, dst->any.excluded_trees, dst->any.excluded_tree_count);
		if (term->any.included != nullptr)
			term->any.included->reference_count++;
		for (unsigned int i = 0; i < term->any.excluded_tree_count; i++)
			term->any.excluded_trees[i]->reference_count++;
		if (dst != src) { free(*dst); if (dst->reference_count == 0) free(dst); }
		if (term == nullptr)
			return nullptr;
		dst = term;
	} else if (AnyNodePosition == any_node_position::RIGHT && dst->type != hol_term_type::LAMBDA && dst->type != hol_term_type::ANY && dst->type != hol_term_type::ANY_RIGHT) {
		hol_term* term = hol_term::new_any_right(dst);
		if (term == nullptr) {
			if (dst != src) { free(*dst); if (dst->reference_count == 0) free(dst); }
			return nullptr;
		}
		if (dst == src) dst->reference_count++;
		dst = term;
	}

	if (dst == src)
		dst->reference_count++;
	return dst;
}

template<typename TryFindHeadFunction>
struct any_node_remover {
	TryFindHeadFunction try_find_head;
	array<hol_term*> excluded_trees;

	any_node_remover(TryFindHeadFunction try_find_head) : try_find_head(try_find_head), excluded_trees(8) { }
};

template<hol_term_type Type, typename TryFindHeadFunction>
inline hol_term* apply(hol_term* src, any_node_remover<TryFindHeadFunction>& remover)
{
	if (src->type != hol_term_type::ANY_RIGHT_ONLY) {
		hol_term* head; head_index predicate_index;
		remover.try_find_head(src, head, predicate_index);
		if (head != nullptr)
			return src;
	}

	/* NOTE: this function should mirror the semantics of
	   `apply_head_conjunct`, `apply<head_substituter>`, `apply_arg`, and
	   `find_head` in `hdp_parser.h` */
	bool changed; hol_term* new_term = nullptr;
	hol_term* first; hol_term* second; hol_term* third;
	array<hol_term*> temp_excluded_trees(8);
	switch (Type) {
	case hol_term_type::IF_THEN:
	case hol_term_type::EQUALS:
	case hol_term_type::UNARY_APPLICATION:
		first = src->binary.left;
		second = apply(src->binary.right, remover);
		if (second == nullptr)
			return nullptr;

		if (second == src->binary.right) {
			return src;
		} else {
			if (!new_hol_term(new_term)) {
				if (second != src->binary.right) {
					free(*second); if (second->reference_count == 0) free(second);
				}
				return nullptr;
			}
			new_term->binary.left = first;
			new_term->binary.right = second;
			first->reference_count++;
			if (second == src->binary.right) second->reference_count++;
			new_term->type = Type;
			new_term->reference_count = 1;
			return new_term;
		}

	case hol_term_type::BINARY_APPLICATION:
		first = src->ternary.first;
		second = src->ternary.second;
		third = apply(src->ternary.third, remover);
		if (third == nullptr)
			return nullptr;

		if (third == src->ternary.third) {
			new_term = src;
		} else {
			if (!new_hol_term(new_term)) {
				if (third != src->ternary.third) {
					free(*third); if (third->reference_count == 0) free(third);
				}
				return nullptr;
			}
			new_term->ternary.first = first;
			new_term->ternary.second = second;
			new_term->ternary.third = third;
			first->reference_count++;
			second->reference_count++;
			if (third == src->ternary.third) third->reference_count++;
			new_term->type = Type;
			new_term->reference_count = 1;
		}
		return new_term;

	case hol_term_type::AND:
	case hol_term_type::OR:
	case hol_term_type::IFF:
		changed = false;
		first = apply(src->array.operands[src->array.length - 1], remover);
		if (first == nullptr) {
			return nullptr;
		} else if (first != src->array.operands[src->array.length - 1])
			changed = true;

		if (!changed) {
			return src;
		} else {
			if (!new_hol_term(new_term)) {
				if (first != src->array.operands[src->array.length - 1]) {
					free(*first);
					if (first->reference_count == 0)
						free(first);
				}
				return nullptr;
			}
			new_term->type = Type;
			new_term->reference_count = 1;
			if (first->type == Type && first->reference_count == 1) {
				/* the new child is the same type as the parent, so merge them */
				new_term->array.operands = (hol_term**) realloc(first->array.operands, sizeof(hol_term*) * (src->array.length + first->array.length - 1));
				if (new_term->array.operands == nullptr) {
					if (first != src->array.operands[src->array.length - 1]) {
						free(*first);
						if (first->reference_count == 0)
							free(first);
					}
					return nullptr;
				}
				for (unsigned int i = first->array.length; i > 0; i--)
					new_term->array.operands[i + src->array.length - 2] = new_term->array.operands[i - 1];
				for (unsigned int i = 0; i + 1 < src->array.length; i++) {
					new_term->array.operands[i] = src->array.operands[i];
					new_term->array.operands[i]->reference_count++;
				}
				new_term->array.length = src->array.length + first->array.length - 1;
				free(first);
			} else {
				new_term->array.length = src->array.length;
				new_term->array.operands = (hol_term**) malloc(sizeof(hol_term*) * new_term->array.length);
				if (new_term->array.operands == nullptr) {
					if (first != src->array.operands[src->array.length - 1]) {
						free(*first);
						if (first->reference_count == 0)
							free(first);
					}
					free(new_term);
					return nullptr;
				}
				for (unsigned int i = 0; i + 1 < src->array.length; i++) {
					new_term->array.operands[i] = src->array.operands[i];
					new_term->array.operands[i]->reference_count++;
				}
				new_term->array.operands[src->array.length - 1] = first;
				if (first == src->array.operands[src->array.length - 1])
					first->reference_count++;
			}
			return new_term;
		}

	case hol_term_type::ANY_ARRAY:
		changed = false;
		if (src->any_array.right.length == 0)
			first = apply(src->any_array.all, remover);
		else first = apply(src->any_array.right.operands[src->any_array.right.length - 1], remover);
		if (first == nullptr) {
			return nullptr;
		} else if (first != (src->any_array.right.length == 0 ? src->any_array.all : src->any_array.right.operands[src->any_array.right.length - 1])) {
			changed = true;
		}

		if (!changed) {
			new_term = src;
		} else {
			if (src->any_array.right.length == 0) {
				new_term = hol_term::new_any_array(src->any_array.oper, first,
						make_array_view(src->any_array.any.operands, src->any_array.any.length),
						make_array_view(src->any_array.left.operands, src->any_array.left.length),
						make_array_view(src->any_array.right.operands, src->any_array.right.length));
			} else {
				new_term = hol_term::new_any_array(src->any_array.oper, src->any_array.all,
						make_array_view(src->any_array.any.operands, src->any_array.any.length),
						make_array_view(src->any_array.left.operands, src->any_array.left.length),
						make_appended_array_view(make_array_view(src->any_array.right.operands, src->any_array.right.length - 1), first));
			}
			if (new_term == nullptr) {
				free(*first); if (first->reference_count == 0) free(first);
				return nullptr;
			}
			new_term->any_array.all->reference_count++;
			for (unsigned int i = 0; i < new_term->any_array.any.length; i++)
				new_term->any_array.any.operands[i]->reference_count++;
			for (unsigned int i = 0; i < new_term->any_array.left.length; i++)
				new_term->any_array.left.operands[i]->reference_count++;
			for (unsigned int i = 0; i + 1 < new_term->any_array.right.length; i++)
				new_term->any_array.right.operands[i]->reference_count++;
		}
		return new_term;

	case hol_term_type::FOR_ALL:
	case hol_term_type::EXISTS:
	case hol_term_type::LAMBDA:
		first = apply(src->quantifier.operand, remover);
		if (first == nullptr)
			return nullptr;

		if (first == src->quantifier.operand) {
			new_term = src;
		} else {
			if (src->type == hol_term_type::FOR_ALL)
				new_term = hol_term::new_for_all(src->quantifier.variable_type, src->quantifier.variable, first);
			else if (src->type == hol_term_type::EXISTS)
				new_term = hol_term::new_exists(src->quantifier.variable_type, src->quantifier.variable, first);
			else if (src->type == hol_term_type::LAMBDA)
				new_term = hol_term::new_lambda(src->quantifier.variable_type, src->quantifier.variable, first);
			if (new_term == nullptr) {
				free(*first); if (first->reference_count == 0) free(first);
				return nullptr;
			}
		}
		return new_term;

	case hol_term_type::ANY_QUANTIFIER:
		first = apply(src->any_quantifier.operand, remover);
		if (first == nullptr)
			return nullptr;

		if (first == src->any_quantifier.operand) {
			new_term = src;
		} else {
			new_term = hol_term::new_any_quantifier(src->any_quantifier.quantifier, first);
			if (new_term == nullptr) {
				free(*first); if (first->reference_count == 0) free(first);
				return nullptr;
			}
		}
		return new_term;

	case hol_term_type::NOT:
		first = apply(src->unary.operand, remover);
		if (first == nullptr)
			return nullptr;

		if (first == src->unary.operand) {
			new_term = src;
		} else {
			new_term = hol_term::new_not(first);
			if (new_term == nullptr) {
				free(*first); if (first->reference_count == 0) free(first);
				return nullptr;
			}
		}
		return new_term;

	case hol_term_type::ANY:
	case hol_term_type::ANY_RIGHT:
		if (src->any.included == nullptr)
			return nullptr;

		swap(temp_excluded_trees, remover.excluded_trees);
		first = apply(src->any.included, remover);
		if (first == nullptr)
			return nullptr;

		if (first == src->any.included && temp_excluded_trees.length == 0) {
			new_term = src;
		} else {
			array<hol_term*> new_excluded(max(1, temp_excluded_trees.length + src->any.excluded_tree_count));
			for (unsigned int i = 0; i < temp_excluded_trees.length; i++) {
				bool contains = false;
				for (unsigned int j = 0; !contains && j < src->any.excluded_tree_count; j++)
					if (is_subset<built_in_predicates>(temp_excluded_trees[i], src->any.excluded_trees[j])) contains = true;
				if (!contains)
					new_excluded[new_excluded.length++] = temp_excluded_trees[i];
			} for (unsigned int i = 0; i < src->any.excluded_tree_count; i++) {
				bool contains = false;
				for (unsigned int j = 0; !contains && j < temp_excluded_trees.length; j++)
					if (is_subset<built_in_predicates>(src->any.excluded_trees[i], temp_excluded_trees[j])) contains = true;
				if (!contains)
					new_excluded[new_excluded.length++] = src->any.excluded_trees[i];
			}

			if (src->type == hol_term_type::ANY)
				new_term = hol_term::new_any(first, new_excluded.data, new_excluded.length);
			else new_term = hol_term::new_any_right(first, new_excluded.data, new_excluded.length);
			if (new_term == nullptr) {
				free(*first); if (first->reference_count == 0) free(first);
				return nullptr;
			}
			if (first == src->any.included)
				first->reference_count++;
			for (hol_term* excluded_tree : new_excluded)
				excluded_tree->reference_count++;
		}
		swap(temp_excluded_trees, remover.excluded_trees);
		return new_term;

	case hol_term_type::ANY_RIGHT_ONLY:
		if (!remover.excluded_trees.append(src->any.excluded_trees, src->any.excluded_tree_count))
			return nullptr;
		first = apply(src->any.included, remover);
		if (first == src->any.included)
			first->reference_count++;
		return first;

	case hol_term_type::CONSTANT:
	case hol_term_type::VARIABLE:
	case hol_term_type::VARIABLE_PREIMAGE:
	case hol_term_type::PARAMETER:
	case hol_term_type::NUMBER:
	case hol_term_type::STRING:
	case hol_term_type::UINT_LIST:
	case hol_term_type::TRUE:
	case hol_term_type::FALSE:
	case hol_term_type::ANY_CONSTANT:
	case hol_term_type::ANY_CONSTANT_EXCEPT:
		return default_apply<Type>(src, remover);
	}
	fprintf(stderr, "apply ERROR: Unrecognized hol_term_type when substituting head.\n");
	return NULL;
}

template<typename TryFindHeadFunction>
inline hol_term* remove_any_nodes(hol_term* src, TryFindHeadFunction try_find_head)
{
	any_node_remover<TryFindHeadFunction> remover(try_find_head);
	if (src->type == hol_term_type::ANY_RIGHT_ONLY) {
		if (!remover.excluded_trees.append(src->any.excluded_trees, src->any.excluded_tree_count))
			return nullptr;
		src = src->any.included;
	}

	hol_term* dst = apply(src, remover);

	if (dst == src)
		dst->reference_count++;
	return dst;
}

struct apply_head_inverter {
	array<hol_term*> outer;
	bool has_bound_variables;
	unsigned int max_variable;

	apply_head_inverter() : outer(8), has_bound_variables(false), max_variable(0) { }

	inline void operator() (hol_term* node) {
		/* NOTE: this function should mirror the semantics of
		  `apply_head_conjunct`, `apply<head_substituter>`, `apply_arg`, and
		  `find_head` in `hdp_parser.h` */
		if (node->type == hol_term_type::IF_THEN || node->type == hol_term_type::EQUALS || node->type == hol_term_type::UNARY_APPLICATION) {
			has_bound_variables |= max_bound_variable(*node->binary.left, max_variable);
		} else if (node->type == hol_term_type::AND || node->type == hol_term_type::OR) {
			for (unsigned int i = 0; i + 1 < node->array.length; i++)
				has_bound_variables |= max_bound_variable(*node->array.operands[i], max_variable);
		} else if (node->type == hol_term_type::FOR_ALL || node->type == hol_term_type::EXISTS || node->type == hol_term_type::LAMBDA) {
			max_variable = max(max_variable, node->quantifier.variable);
		}
		outer.add(node);
	}
};

template<typename TryFindHeadFunction, typename Function>
hol_term* find_head(hol_term* term, head_index& predicate_index, TryFindHeadFunction& try_find_head, Function& apply)
{
	apply(term);

	hol_term* head;
	try_find_head(term, head, predicate_index);
	if (head != nullptr) return head;

	/* NOTE: this function should mirror the semantics of
	   `apply_head_conjunct`, `apply<head_substituter>`,
	   `apply_arg`, and `find_head` in `hdp_parser.h` */
	switch (term->type) {
	case hol_term_type::VARIABLE:
	case hol_term_type::VARIABLE_PREIMAGE:
	case hol_term_type::CONSTANT:
	case hol_term_type::PARAMETER:
	case hol_term_type::NUMBER:
	case hol_term_type::STRING:
	case hol_term_type::UINT_LIST:
	case hol_term_type::TRUE:
	case hol_term_type::FALSE:
	case hol_term_type::BINARY_APPLICATION:
	case hol_term_type::IFF:
	case hol_term_type::ANY_CONSTANT:
	case hol_term_type::ANY_CONSTANT_EXCEPT:
		return nullptr;

	case hol_term_type::NOT:
		return find_head(term->unary.operand, predicate_index, try_find_head, apply);

	case hol_term_type::FOR_ALL:
	case hol_term_type::EXISTS:
	case hol_term_type::LAMBDA:
		return find_head(term->quantifier.operand, predicate_index, try_find_head, apply);

	case hol_term_type::IF_THEN:
	case hol_term_type::EQUALS:
	case hol_term_type::UNARY_APPLICATION:
		return find_head(term->binary.right, predicate_index, try_find_head, apply);

	case hol_term_type::AND:
	case hol_term_type::OR:
		return find_head(term->array.operands[term->array.length - 1], predicate_index, try_find_head, apply);

	case hol_term_type::ANY:
	case hol_term_type::ANY_RIGHT:
	case hol_term_type::ANY_RIGHT_ONLY:
		if (term->any.included == nullptr) return nullptr;
		return find_head(term->any.included, predicate_index, try_find_head, apply);

	case hol_term_type::ANY_ARRAY:
		if (term->any_array.right.length == 0)
			return find_head(term->any_array.all, predicate_index, try_find_head, apply);
		return find_head(term->any_array.right.operands[term->any_array.right.length - 1], predicate_index, try_find_head, apply);

	case hol_term_type::ANY_QUANTIFIER:
		return find_head(term->any_quantifier.operand, predicate_index, try_find_head, apply);
	}
	fprintf(stderr, "find_head ERROR: Unrecognied hol_term_type.\n");
	return nullptr;
}

template<int_fast8_t ConjunctIndex, bool SelectNegation = false>
inline bool select_conjunct(
		hol_term* src, hol_term*& dst)
{
	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<false>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker, find_head<built_in_predicates>,
			[](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				hol_term* old_head = head;
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && predicate_index.position != head_position::NONE)
					head = head->any.included;

				bool negated = false;
				if (head->type == hol_term_type::NOT) {
					head = head->unary.operand;
					negated = true;
				}

				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT
				 || (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY)
				 || (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY_RIGHT))
				{
					hol_term* head_var = hol_term::new_variable(head_variable);
					if (head_var == nullptr) return (hol_term*) nullptr;
					constexpr unsigned int additional_excluded_tree_count = 2;
					unsigned int excluded_tree_count = hol_non_head_constants<built_in_predicates>::count() + additional_excluded_tree_count;
					hol_term** excluded_trees = (hol_term**) alloca(sizeof(hol_term*) * excluded_tree_count);
					excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
								(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
								(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
							&HOL_ANY), head_var));
					excluded_trees[1] = hol_term::new_any(hol_term::new_exists(head_variable, &HOL_ANY));
					if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
					if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
					if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr) {
						if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
						free(*head_var); free(head_var);
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < hol_non_head_constants<built_in_predicates>::count(); i++)
						excluded_trees[i + additional_excluded_tree_count] = hol_non_head_constants<built_in_predicates>::get_terms()[i];

					hol_term* predicate_term = hol_term::new_apply(
							hol_term::new_any(nullptr, excluded_trees, hol_non_head_constants<built_in_predicates>::count() + additional_excluded_tree_count), head_var);
					if (predicate_term == nullptr) {
						free(*excluded_trees[0]); free(excluded_trees[0]);
						free(*excluded_trees[1]); free(excluded_trees[1]);
						free(*head_var); free(head_var);
						return (hol_term*) nullptr;
					}
					hol_non_head_constants<built_in_predicates>::increment_terms();

					excluded_trees[additional_excluded_tree_count] = predicate_term;
					hol_term* dst = hol_term::new_exists(head_variable, hol_term::new_and(
						predicate_term,
						hol_term::new_any(nullptr, excluded_trees, additional_excluded_tree_count + 1)
					));
					if (dst == nullptr) {
						free(*predicate_term); free(predicate_term);
						return (hol_term*) nullptr;
					}
					predicate_term->reference_count += 2 - 1;
					for (unsigned int i = 0; i < additional_excluded_tree_count; i++)
						excluded_trees[i]->reference_count++;

					if (negated && SelectNegation) {
						hol_term* new_dst = hol_term::new_not(dst);
						if (new_dst->reference_count == 0) {
							free(*dst); if (dst->reference_count == 0) free(dst);
							return (hol_term*) nullptr;
						}
						dst = new_dst;
					}

					array<hol_term*> intersection(2);
					intersect<built_in_predicates>(intersection, dst, head);
					if (intersection.length > 1) {
						fprintf(stderr, "select_conjunct WARNING: Expected intersection size to be 1.\n");
						for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					free(*dst); if (dst->reference_count == 0) free(dst);
					if (intersection.length == 0)
						return (hol_term*) nullptr;
					if (is_array) {
						dst = hol_term::new_any_right(intersection[0]);
					} else if (SelectNegation && (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT)) {
						/* in case the head is negated */
						dst = hol_term::new_any_right(hol_term::new_any_array(hol_term_type::ANY_ARRAY, hol_term::new_any_right(intersection[0]),
								make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0)));
					} else {
						dst = hol_term::new_any_right(hol_term::new_any_array(hol_term_type::ANY_ARRAY, intersection[0],
								make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0)));
					}
					if (dst == nullptr) {
						free(*intersection[0]); if (intersection[0]->reference_count == 0) free(intersection[0]);
						return (hol_term*) nullptr;
					}
					return dst;
				} else if (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY_ARRAY) {
					if (predicate_index.compare(ConjunctIndex))
						return (hol_term*) nullptr;
					hol_term* operand = head->quantifier.operand;
					hol_term* conjunct;
					if (ConjunctIndex >= 0) {
						if (ConjunctIndex < operand->any_array.left.length) {
							conjunct = operand->any_array.left.operands[ConjunctIndex];
							conjunct->reference_count++;
						} else {
							hol_term* expected_predicate = hol_term::new_apply(
									hol_term::new_any(nullptr, hol_non_head_constants<built_in_predicates>::get_terms(), hol_non_head_constants<built_in_predicates>::count()),
									hol_term::new_variable(head_variable));
							if (expected_predicate == nullptr)
								return (hol_term*) nullptr;
							hol_non_head_constants<built_in_predicates>::increment_terms();

							array<hol_term*> difference(2);
							subtract<built_in_predicates>(difference, operand->any_array.all, expected_predicate);
							free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
							if (difference.length == 0) {
								return (hol_term*) nullptr;
							} else if (difference.length != 1) {
								fprintf(stderr, "select_conjunct ERROR: Set difference is not unique.\n");
								free_all(difference); return (hol_term*) nullptr;
							}
							conjunct = difference[0];
						}
					} else if (ConjunctIndex < 0) {
						unsigned int index = (unsigned int) (-ConjunctIndex) - 1;
						if (index < operand->any_array.right.length){
							conjunct = operand->any_array.right.operands[operand->any_array.right.length - index - 1];
							conjunct->reference_count++;
						} else {
							hol_term* expected_predicate = hol_term::new_apply(
									hol_term::new_any(nullptr, hol_non_head_constants<built_in_predicates>::get_terms(), hol_non_head_constants<built_in_predicates>::count()),
									hol_term::new_variable(head_variable));
							if (expected_predicate == nullptr)
								return (hol_term*) nullptr;
							hol_non_head_constants<built_in_predicates>::increment_terms();

							array<hol_term*> difference(2);
							subtract<built_in_predicates>(difference, operand->any_array.all, expected_predicate);
							free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
							if (difference.length == 0) {
								return (hol_term*) nullptr;
							} else if (difference.length != 1) {
								fprintf(stderr, "select_conjunct ERROR: Set difference is not unique.\n");
								free_all(difference); return (hol_term*) nullptr;
							}
							conjunct = difference[0];
						}
					}

					hol_term* predicate;
					if (predicate_index.position == head_position::LEFT) {
						predicate = operand->any_array.left.operands[predicate_index.index];
					} else if (predicate_index.position == head_position::RIGHT) {
						predicate = operand->any_array.right.operands[operand->any_array.right.length - predicate_index.index - 1];
					} else {
						predicate = operand->any_array.any.operands[predicate_index.index];
					}
					hol_term* dst = hol_term::new_exists(head_variable, hol_term::new_and(predicate, conjunct));
					if (dst == nullptr) {
						free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
						return (hol_term*) nullptr;
					}
					predicate->reference_count++;
					if (old_head->type == hol_term_type::ANY || old_head->type == hol_term_type::ANY_RIGHT) {
						hol_term* new_dst = hol_term::new_any_right(dst);
						if (new_dst == nullptr) {
							free(*dst); free(dst);
							return (hol_term*) nullptr;
						}
						dst = new_dst;
					}

					if (negated && SelectNegation) {
						hol_term* new_dst = hol_term::new_not(dst);
						if (new_dst->reference_count == 0) {
							free(*dst); if (dst->reference_count == 0) free(dst);
							return (hol_term*) nullptr;
						}
						dst = new_dst;
					}
					return dst;
				} else if (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::AND) {
					hol_term* operand = head->quantifier.operand;
					unsigned int conjunct_index = (ConjunctIndex < 0) ? (operand->array.length + ConjunctIndex) : ConjunctIndex;
					if (conjunct_index == predicate_index.index)
						return (hol_term*) nullptr;
					hol_term* conjunct = operand->array.operands[conjunct_index];
					hol_term* dst = hol_term::new_exists(head_variable, hol_term::new_and(operand->array.operands[predicate_index.index], conjunct));
					if (dst == nullptr)
						return (hol_term*) nullptr;
					operand->array.operands[predicate_index.index]->reference_count++;
					conjunct->reference_count++;
					if (old_head->type == hol_term_type::ANY || old_head->type == hol_term_type::ANY_RIGHT) {
						hol_term* new_dst = hol_term::new_any_right(dst, old_head->any.excluded_trees, old_head->any.excluded_tree_count);
						if (new_dst == nullptr) {
							free(*dst); free(dst);
							return (hol_term*) nullptr;
						}
						dst = new_dst;
						for (unsigned int i = 0; i < old_head->any.excluded_tree_count; i++)
							old_head->any.excluded_trees[i]->reference_count++;
					}

					if (negated && SelectNegation) {
						hol_term* new_dst = hol_term::new_not(dst);
						if (new_dst->reference_count == 0) {
							free(*dst); if (dst->reference_count == 0) free(dst);
							return (hol_term*) nullptr;
						}
						dst = new_dst;
					}
					return dst;
				} else {
					return (hol_term*) nullptr;
				}
			}, no_op()) && dst != nullptr;
}

template<int_fast8_t ConjunctIndex, bool RemoveNegation = false>
inline bool remove_conjunct(
		hol_term* src, hol_term*& dst)
{
	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<true>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker, find_head<built_in_predicates>,
			[](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				hol_term* old_head = head;
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && predicate_index.position != head_position::NONE)
					head = head->any.included;

				bool negated = false;
				if (head->type == hol_term_type::NOT) {
					head = head->unary.operand;
					negated = true;
				}

				hol_term* dst;
				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT
				 || (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY)
				 || (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY_RIGHT))
				{
					hol_term* head_var = hol_term::new_variable(head_variable);
					if (head_var == nullptr) return (hol_term*) nullptr;
					constexpr unsigned int excluded_tree_count = 2;
					hol_term** excluded_trees = (hol_term**) alloca(sizeof(hol_term) * (excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()));
					excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
								(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
								(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
							&HOL_ANY), head_var));
					excluded_trees[1] = hol_term::new_any(hol_term::new_exists(head_variable, &HOL_ANY));
					if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
					if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
					if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr) {
						if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
						free(*head_var); free(head_var);
						return (hol_term*) nullptr;
					}
					free(*head_var);

					for (unsigned int i = 0; i < hol_non_head_constants<built_in_predicates>::count(); i++) {
						excluded_trees[excluded_tree_count + i] = hol_non_head_constants<built_in_predicates>::get_terms()[i];
						excluded_trees[excluded_tree_count + i]->reference_count++;
					}

					hol_term* expected_predicate = hol_term::new_apply(
								hol_term::new_any(nullptr, excluded_trees, excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()), head_var);
					if (expected_predicate == nullptr) {
						for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
							free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
						}
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++)
						excluded_trees[i]->reference_count++;
					head_var->reference_count++;

					dst = hol_term::new_exists(head_variable, hol_term::new_any_array(hol_term_type::AND,
							hol_term::new_any(nullptr, excluded_trees, excluded_tree_count), make_array_view(&expected_predicate, 1),
							make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0)));
					if (dst == nullptr) {
						free(*expected_predicate); free(expected_predicate);
						for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
							free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
						}
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < excluded_tree_count; i++)
						excluded_trees[i]->reference_count++;
					for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
						free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
					}

					array<hol_term*> intersection(2);
					intersect<built_in_predicates>(intersection, dst, head);
					if (intersection.length > 1) {
						fprintf(stderr, "remove_conjunct WARNING: Expected intersection size to be 1.\n");
						for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					free(*dst); if (dst->reference_count == 0) free(dst);
					if (intersection.length == 0)
						return (hol_term*) nullptr;
					dst = intersection[0];
				} else if (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY_ARRAY) {
					hol_term* operand = head->quantifier.operand;

					hol_term* conjunction = nullptr;
					if (ConjunctIndex >= 0) {
						if (ConjunctIndex < operand->any_array.left.length) {
							if (predicate_index.position == head_position::LEFT && predicate_index.index == ConjunctIndex)
								/* this operation would remove the predicate */
								return (hol_term*) nullptr;
							conjunction = hol_term::new_any_array(hol_term_type::AND, operand->any_array.all,
									make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
									make_excluded_array_view(operand->any_array.left.operands, operand->any_array.left.length, ConjunctIndex),
									make_array_view(operand->any_array.right.operands, operand->any_array.right.length));
						} else {
							conjunction = operand;
						}
					} else if (ConjunctIndex < 0) {
						if (-ConjunctIndex - 1 < operand->any_array.right.length) {
							unsigned int index = (unsigned int) (-ConjunctIndex) - 1;
							if (predicate_index.position == head_position::RIGHT && predicate_index.index == index)
								/* this operation would remove the predicate */
								return (hol_term*) nullptr;
							index = operand->any_array.right.length - index - 1;
							conjunction = hol_term::new_any_array(hol_term_type::AND, operand->any_array.all,
									make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
									make_array_view(operand->any_array.left.operands, operand->any_array.left.length),
									make_excluded_array_view(operand->any_array.right.operands, operand->any_array.right.length, index));
						} else {
							conjunction = operand;
						}
					}
					if (conjunction == nullptr)
						return (hol_term*) nullptr;
					if (conjunction == operand) {
						operand->reference_count++;
					} else {
						conjunction->any_array.all->reference_count++;
						for (unsigned int i = 0; i < conjunction->any_array.any.length; i++)
							conjunction->any_array.any.operands[i]->reference_count++;
						for (unsigned int i = 0; i < conjunction->any_array.left.length; i++)
							conjunction->any_array.left.operands[i]->reference_count++;
						for (unsigned int i = 0; i < conjunction->any_array.right.length; i++)
							conjunction->any_array.right.operands[i]->reference_count++;
					}

					dst = hol_term::new_exists(head_variable, conjunction);
					if (dst == nullptr) {
						free(*conjunction); if (conjunction->reference_count == 0) free(conjunction);
						return (hol_term*) nullptr;
					}
				} else if (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::AND) {
					hol_term* operand = head->quantifier.operand;
					unsigned int conjunct_index = (ConjunctIndex < 0) ? (operand->array.length + ConjunctIndex) : ConjunctIndex;
					if (predicate_index.index == conjunct_index)
						/* this operation would remove the predicate */
						return (hol_term*) nullptr;
					if (operand->array.length == 2) {
						dst = hol_term::new_exists(head_variable, (conjunct_index == 0 ? operand->array.operands[1] : operand->array.operands[0]));
					} else {
						dst = hol_term::new_exists(head_variable, hol_term::new_and(make_excluded_array_view(operand->array.operands, operand->array.length, conjunct_index)));
					}
					if (dst != nullptr) {
						for (unsigned int i = 0; i < operand->array.length; i++)
							if (i != conjunct_index) operand->array.operands[i]->reference_count++;
					}
				} else {
					return (hol_term*) nullptr;
				}

				if (negated && !RemoveNegation) {
					hol_term* new_dst = hol_term::new_not(dst);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					dst = new_dst;
				}

				if (old_head->type == hol_term_type::ANY || old_head->type == hol_term_type::ANY_RIGHT)
				{
					array<unsigned int> dst_variables(8);
					get_free_variables(*dst, dst_variables);
					if (dst_variables.length > 1) insertion_sort(dst_variables);
					if (!prune_independent_siblings(dst_variables, siblings)) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}

					array<hol_term*> excluded_trees(max(1u, old_head->any.excluded_tree_count));
					for (unsigned int i = 0; i < old_head->any.excluded_tree_count; i++) {
						hol_term* excluded_tree = old_head->any.excluded_trees[i];
						if (excluded_tree->type != hol_term_type::ANY || excluded_tree->any.included == nullptr
						 || !(excluded_tree->any.included->type == hol_term_type::EXISTS || excluded_tree->any.included->type == hol_term_type::FOR_ALL || excluded_tree->any.included->type == hol_term_type::LAMBDA)
						 || dst_variables.contains(excluded_tree->any.included->quantifier.variable))
						{
							excluded_trees[excluded_trees.length++] = excluded_tree;
						}
					}

					hol_term* new_dst = hol_term::new_any_right(dst, excluded_trees.data, excluded_trees.length);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < excluded_trees.length; i++)
						excluded_trees[i]->reference_count++;
					dst = new_dst;
				}
				return dst;
			}, no_op()) && dst != nullptr;
}

template<int_fast8_t ConjunctIndex, bool IsDstRoot = false>
inline bool select_set_conjunct(
		hol_term* src, hol_term*& dst)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
		src = src->quantifier.operand;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<false>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker,
			predicative_head_finder<built_in_predicates>(lambda_variable),
			[](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
					head = head->any.included;

				if (head->type == hol_term_type::NOT)
					head = head->unary.operand;

				hol_term* excluded_quantifiers[3];
				excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(head_variable, &HOL_ANY));
				excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(head_variable, &HOL_ANY));
				excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(head_variable, &HOL_ANY));
				if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
				if (excluded_quantifiers[1] != nullptr) HOL_ANY.reference_count++;
				if (excluded_quantifiers[2] != nullptr) HOL_ANY.reference_count++;
				if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr) {
					if (excluded_quantifiers[0] != nullptr) { free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]); }
					if (excluded_quantifiers[1] != nullptr) { free(*excluded_quantifiers[1]); free(excluded_quantifiers[1]); }
					return (hol_term*) nullptr;
				}

				hol_term* expected_conjunct = hol_term::new_any(nullptr, excluded_quantifiers, array_length(excluded_quantifiers));
				if (expected_conjunct == nullptr) {
					for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
					return (hol_term*) nullptr;
				}

				hol_term* expected_head;
				if (ConjunctIndex >= 0) {
					expected_head = hol_term::new_exists(head_variable, hol_term::new_any_array(hol_term_type::AND, expected_conjunct,
							make_array_view((hol_term**) nullptr, 0), make_repeated_array_view(expected_conjunct, ConjunctIndex + 1), make_array_view((hol_term**) nullptr, 0)));
					if (expected_head == nullptr) {
						free(*expected_conjunct); free(expected_conjunct);
						return (hol_term*) nullptr;
					}
					expected_conjunct->reference_count += ConjunctIndex + 1;
				} else {
					expected_head = hol_term::new_exists(head_variable, hol_term::new_any_array(hol_term_type::AND, expected_conjunct,
							make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0), make_repeated_array_view(expected_conjunct, (unsigned int) (-ConjunctIndex))));
					if (expected_head == nullptr) {
						free(*expected_conjunct); free(expected_conjunct);
						return (hol_term*) nullptr;
					}
					expected_conjunct->reference_count += (unsigned int) (-ConjunctIndex);
				}

				array<hol_term*> intersection(2);
				intersect<built_in_predicates>(intersection, expected_head, head);
				free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
				if (intersection.length == 0) {
					return (hol_term*) nullptr;
				} else if (intersection.length != 1) {
					fprintf(stderr, "select_set_conjunct ERROR: Expected intersection to be unique.\n");
					free_all(intersection);
					return (hol_term*) nullptr;
				}

				hol_term* conjunct;
				hol_term* operand = intersection[0]->quantifier.operand;
				if (operand->type == hol_term_type::ANY_ARRAY) {
					if (ConjunctIndex >= 0) {
						if (ConjunctIndex < operand->any_array.left.length)
							conjunct = operand->any_array.left.operands[ConjunctIndex];
						else conjunct = operand->any_array.all;
					} else {
						if (operand->any_array.right.length >= -ConjunctIndex) {
							unsigned int index = (unsigned int) (operand->any_array.right.length + ConjunctIndex);
							conjunct = operand->any_array.right.operands[index];
						} else {
							conjunct = operand->any_array.all;
						}
					}
				} else {
					if (ConjunctIndex >= 0) {
						conjunct = operand->array.operands[ConjunctIndex];
					} else {
						unsigned int index = (unsigned int) (operand->array.length + ConjunctIndex);
						conjunct = operand->array.operands[index];
					}
				}

				hol_term* dst = hol_term::new_exists(head_variable, conjunct);
				if (dst == nullptr) {
					free_all(intersection);
					return (hol_term*) nullptr;
				}
				conjunct->reference_count++;
				free_all(intersection);

				if (IsDstRoot) {
					/* check that there are no undeclared variables */
					array<unsigned int> free_variables(4);
					if (!get_free_variables(*dst, free_variables) || free_variables.length != 0) {
						free(*dst); free(dst);
						return (hol_term*) nullptr;
					}
				}

				return dst;
			}, no_op()) && dst != nullptr;
}

template<int_fast8_t ConjunctIndex>
inline bool remove_set_conjunct(
		hol_term* src, hol_term*& dst)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<true>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker,
			predicative_head_finder<built_in_predicates>(lambda_variable),
			[](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				hol_term* old_head = head;
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
					head = head->any.included;

				if (head->type == hol_term_type::NOT)
					head = head->unary.operand;

				hol_term* excluded_quantifiers[3];
				excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(head_variable, &HOL_ANY));
				excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(head_variable, &HOL_ANY));
				excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(head_variable, &HOL_ANY));
				if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
				if (excluded_quantifiers[1] != nullptr) HOL_ANY.reference_count++;
				if (excluded_quantifiers[2] != nullptr) HOL_ANY.reference_count++;
				if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr) {
					if (excluded_quantifiers[0] != nullptr) { free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]); }
					if (excluded_quantifiers[1] != nullptr) { free(*excluded_quantifiers[1]); free(excluded_quantifiers[1]); }
					return (hol_term*) nullptr;
				}

				hol_term* expected_conjunct = hol_term::new_any(nullptr, excluded_quantifiers, array_length(excluded_quantifiers));
				if (expected_conjunct == nullptr) {
					for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
					return (hol_term*) nullptr;
				}

				hol_term* expected_head;
				if (ConjunctIndex >= 0) {
					expected_head = hol_term::new_exists(head_variable, hol_term::new_any_array(hol_term_type::AND, expected_conjunct,
							make_array_view((hol_term**) nullptr, 0), make_repeated_array_view(expected_conjunct, ConjunctIndex + 1), make_array_view((hol_term**) nullptr, 0)));
					if (expected_head == nullptr) {
						free(*expected_conjunct); free(expected_conjunct);
						return (hol_term*) nullptr;
					}
					expected_conjunct->reference_count += ConjunctIndex + 1;
				} else {
					expected_head = hol_term::new_exists(head_variable, hol_term::new_any_array(hol_term_type::AND, expected_conjunct,
							make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0), make_repeated_array_view(expected_conjunct, (unsigned int) (-ConjunctIndex))));
					if (expected_head == nullptr) {
						free(*expected_conjunct); free(expected_conjunct);
						return (hol_term*) nullptr;
					}
					expected_conjunct->reference_count += (unsigned int) (-ConjunctIndex);
				}

				array<hol_term*> intersection(2);
				intersect<built_in_predicates>(intersection, expected_head, head);
				free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
				if (intersection.length == 0) {
					return (hol_term*) nullptr;
				} else if (intersection.length != 1) {
					fprintf(stderr, "remove_set_conjunct ERROR: Expected intersection to be unique.\n");
					free_all(intersection);
					return (hol_term*) nullptr;
				}

				hol_term* new_conjunction;
				hol_term* operand = intersection[0]->quantifier.operand;
				if (operand->type == hol_term_type::ANY_ARRAY) {
					if (ConjunctIndex >= 0) {
						if (ConjunctIndex < operand->any_array.left.length) {
							new_conjunction = hol_term::new_any_array(hol_term_type::AND,
									operand->any_array.all, make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
									make_excluded_array_view(operand->any_array.left.operands, operand->any_array.left.length, ConjunctIndex),
									make_array_view(operand->any_array.right.operands, operand->any_array.right.length));
						} else {
							new_conjunction = operand;
							operand->reference_count++;
						}
					} else {
						if (operand->any_array.right.length >= ConjunctIndex) {
							unsigned int index = (unsigned int) (operand->any_array.right.length + ConjunctIndex);
							new_conjunction = hol_term::new_any_array(hol_term_type::AND,
									operand->any_array.all, make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
									make_array_view(operand->any_array.left.operands, operand->any_array.left.length),
									make_excluded_array_view(operand->any_array.right.operands, operand->any_array.right.length, index));
						} else {
							new_conjunction = operand;
							operand->reference_count++;
						}
					}
					if (new_conjunction == nullptr) {
						free_all(intersection);
						return (hol_term*) nullptr;
					}
					if (new_conjunction != operand) {
						new_conjunction->any_array.all->reference_count++;
						for (unsigned int i = 0; i < new_conjunction->any_array.any.length; i++)
							new_conjunction->any_array.any.operands[i]->reference_count++;
						for (unsigned int i = 0; i < new_conjunction->any_array.left.length; i++)
							new_conjunction->any_array.left.operands[i]->reference_count++;
						for (unsigned int i = 0; i < new_conjunction->any_array.right.length; i++)
							new_conjunction->any_array.right.operands[i]->reference_count++;
					}
				} else {
					if (ConjunctIndex >= 0) {
						new_conjunction = hol_term::new_and(make_excluded_array_view(operand->array.operands, operand->array.length, ConjunctIndex));
					} else {
						unsigned int index = (unsigned int) (operand->array.length + ConjunctIndex);
						new_conjunction = hol_term::new_and(make_excluded_array_view(operand->array.operands, operand->array.length, index));
					}
					if (new_conjunction == nullptr) {
						free_all(intersection);
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < new_conjunction->array.length; i++)
						new_conjunction->array.operands[i]->reference_count++;
				}
				free_all(intersection);

				hol_term* dst = hol_term::new_exists(head_variable, new_conjunction);
				if (dst == nullptr) {
					free(*new_conjunction); free(new_conjunction);
					return (hol_term*) nullptr;
				}

				if (old_head->type == hol_term_type::ANY || old_head->type == hol_term_type::ANY_RIGHT) {
					hol_term* new_dst = hol_term::new_any_right(dst, old_head->any.excluded_trees, old_head->any.excluded_tree_count);
					if (new_dst == nullptr) {
						free(*dst); free(dst);
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < old_head->any.excluded_tree_count; i++)
						old_head->any.excluded_trees[i]->reference_count++;
					dst = new_dst;
				}
				return dst;
			}, no_op()) && dst != nullptr;
}

template<int_fast8_t ConjunctIndex>
inline bool select_conjunct_in_set(
		hol_term* src, hol_term*& dst)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
		src = src->quantifier.operand;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<false>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker,
			predicative_head_finder<built_in_predicates>(lambda_variable),
			[&max_variable](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				hol_term* old_head = head;
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr
				 && (head->any.included->type == hol_term_type::NOT || head->any.included->type == hol_term_type::EXISTS))
					head = head->any.included;

				bool negated = false;
				if (head->type == hol_term_type::NOT) {
					head = head->unary.operand;
					negated = true;
				}

				unsigned int set_variable, element_variable = 0;
				hol_term* left = nullptr;
				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT)
				{
					set_variable = ++max_variable;
					element_variable = ++max_variable;
				} else {
#if !defined(NDEBUG)
					if (head->type != hol_term_type::EXISTS)
						fprintf(stderr, "select_conjunct_in_set WARNING: Expected an existential quantification.\n");
#endif
					set_variable = head->quantifier.variable;
					hol_term* operand = head->quantifier.operand;

					hol_term* right = nullptr;
					if (operand->type == hol_term_type::ANY || operand->type == hol_term_type::ANY_RIGHT) {
						element_variable = ++max_variable;
					} else if (operand->type == hol_term_type::AND && operand->array.length != 0) {
						left = operand->array.operands[0];
						right = operand->array.operands[operand->array.length - 1];
					} else if (operand->type == hol_term_type::ANY_ARRAY) {
						if (operand->any_array.left.length != 0)
							left = operand->any_array.left.operands[0];
						else left = operand->any_array.all;
						if (operand->any_array.right.length != 0)
							right = operand->any_array.right.operands[operand->any_array.right.length - 1];
						else right = operand->any_array.all;
					} else {
						return (hol_term*) nullptr;
					}

					hol_term* set_definition = nullptr;
					if (left != nullptr) {
						if (left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT) {
							if (left->any.included != nullptr)
								set_definition = left->any.included;
						} else if (left->type == hol_term_type::EQUALS) {
							set_definition = left->binary.right;
						} else if (left->type == hol_term_type::BINARY_APPLICATION) {
							set_definition = left->ternary.third;
						} else {
							return (hol_term*) nullptr;
						}
					}

					if (set_definition != nullptr) {
						if (set_definition->type == hol_term_type::ANY || set_definition->type == hol_term_type::ANY_RIGHT) {
							/* no-op */
						} else if (set_definition->type == hol_term_type::LAMBDA) {
							element_variable = set_definition->quantifier.variable;
						} else {
							return (hol_term*) nullptr;
						}
					}

					if (element_variable == 0 && right != nullptr) {
						/* try to get the element variable from the right conjunct, since we couldn't get it from the left conjunct */
						if ((right->type == hol_term_type::ANY || right->type == hol_term_type::ANY_RIGHT) && right->any.included != nullptr)
							right = right->any.included;
						if (right->type == hol_term_type::UNARY_APPLICATION && right->binary.left->type == hol_term_type::CONSTANT && right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE)
							right = right->binary.right;
						if (right->type == hol_term_type::ANY || right->type == hol_term_type::ANY_RIGHT) {
							element_variable = ++max_variable;
						} else if (right->type == hol_term_type::EXISTS || right->type == hol_term_type::FOR_ALL) {
							element_variable = right->quantifier.variable;
						} else if (right->type == hol_term_type::AND && right->array.length == 2 && right->array.operands[1]->type == hol_term_type::UNARY_APPLICATION
								&& right->array.operands[1]->binary.left->type == hol_term_type::VARIABLE && right->array.operands[1]->binary.left->variable == set_variable
								&& right->array.operands[1]->binary.right->type == hol_term_type::VARIABLE)
						{
							element_variable = right->array.operands[1]->binary.right->variable;
						} else {
							return (hol_term*) nullptr;
						}
					}
				}

				hol_term* head_var = hol_term::new_variable(element_variable);
				if (head_var == nullptr) return (hol_term*) nullptr;
				unsigned int excluded_tree_count = 2;
				hol_term** excluded_trees = (hol_term**) alloca(sizeof(hol_term) * (excluded_tree_count + hol_non_head_constants<built_in_predicates>::count() + 1));
				excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
							(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
							(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
						&HOL_ANY), head_var));
				excluded_trees[1] = hol_term::new_any(hol_term::new_lambda(element_variable, &HOL_ANY));
				if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
				if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
				if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr) {
					if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
					free(*head_var); free(head_var);
					return (hol_term*) nullptr;
				}

				for (unsigned int i = 0; i < hol_non_head_constants<built_in_predicates>::count(); i++) {
					excluded_trees[excluded_tree_count + i] = hol_non_head_constants<built_in_predicates>::get_terms()[i];
					excluded_trees[excluded_tree_count + i]->reference_count++;
				}

				hol_term* conjunct = hol_term::new_any(nullptr, excluded_trees, excluded_tree_count);
				if (conjunct == nullptr) {
					for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
						free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
					}
					free(*head_var); free(head_var);
					return (hol_term*) nullptr;
				}
				for (unsigned int i = 0; i < excluded_tree_count; i++)
					excluded_trees[i]->reference_count++;

				hol_term* conjunction = hol_term::new_any_array(
						hol_term_type::AND, conjunct,
						make_array_view((hol_term**) nullptr, 0),
						make_array_view((hol_term**) nullptr, 0),
						make_array_view((hol_term**) nullptr, 0));
				if (conjunction == nullptr) {
					for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
						free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
					}
					free(*conjunct); free(conjunct);
					free(*head_var); free(head_var);
					return (hol_term*) nullptr;
				}
				conjunction->any_array.all->reference_count++;
				for (unsigned int i = 0; i < conjunction->any_array.left.length; i++)
					conjunction->any_array.left.operands[i]->reference_count++;
				for (unsigned int i = 0; i < conjunction->any_array.right.length; i++)
					conjunction->any_array.right.operands[i]->reference_count++;
				for (unsigned int i = 0; i < conjunction->any_array.any.length; i++)
					conjunction->any_array.any.operands[i]->reference_count++;
				free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);

				hol_term* set_definition;
				if (left == nullptr || left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT) {
					set_definition = hol_term::new_any_right(hol_term::new_lambda(element_variable, conjunction));
					if (set_definition == nullptr) {
						free(*conjunction); free(conjunction);
						for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
							free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
						}
						free(*head_var); free(head_var);
						return (hol_term*) nullptr;
					}
				} else if (left->type == hol_term_type::EQUALS) {
					set_definition = hol_term::new_equals(hol_term::new_variable(set_variable), hol_term::new_lambda(element_variable, conjunction));
					if (set_definition == nullptr) {
						free(*conjunction); free(conjunction);
						for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
							free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
						}
						free(*head_var); free(head_var);
						return (hol_term*) nullptr;
					}
				} else if (left->type == hol_term_type::BINARY_APPLICATION) {
					set_definition = hol_term::new_apply(&HOL_ANY, hol_term::new_variable(set_variable), hol_term::new_lambda(element_variable, conjunction));
					if (set_definition == nullptr) {
						free(*conjunction); free(conjunction);
						for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
							free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
						}
						free(*head_var); free(head_var);
						return (hol_term*) nullptr;
					}
					HOL_ANY.reference_count++;
				}

				hol_term* dst = hol_term::new_exists(set_variable, hol_term::new_any_array(hol_term_type::AND, &HOL_ANY,
						make_array_view((hol_term**) nullptr, 0), make_array_view(&set_definition, 1), make_array_view((hol_term**) nullptr, 0)));
				if (dst == nullptr) {
					for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
						free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
					}
					free(*set_definition); free(set_definition);
					free(*head_var); free(head_var);
					return (hol_term*) nullptr;
				}
				HOL_ANY.reference_count++;

				array<hol_term*> intersection(2);
				intersect<built_in_predicates>(intersection, dst, head);
				free(*dst); if (dst->reference_count == 0) free(dst);
				if (intersection.length == 0) {
					for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
						free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
					}
					free(*head_var); free(head_var);
					return (hol_term*) nullptr;
				} else if (intersection.length != 1) {
					fprintf(stderr, "select_conjunct_in_set ERROR: Intersection is not unique.\n");
					free_all(intersection);
					for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
						free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
					}
					free(*head_var); free(head_var);
					return (hol_term*) nullptr;
				}

				hol_term* operand = intersection[0]->quantifier.operand;
				hol_term* new_left;
				if (operand->type == hol_term_type::AND) {
					new_left = operand->array.operands[0];
				} else {
					new_left = operand->any_array.left.operands[0];
				}

				hol_term* inner_operand;
				if (new_left->type == hol_term_type::ANY || new_left->type == hol_term_type::ANY_RIGHT) {
					inner_operand = new_left->any.included->quantifier.operand;
				} else if (new_left->type == hol_term_type::EQUALS) {
					inner_operand = new_left->binary.right->quantifier.operand;
				} else {
					inner_operand = new_left->ternary.third->quantifier.operand;
				}

				/* find the predicate in `inner_operand` */
				head_index inner_predicate_index;
				bool predicate_is_scope = false;
				hol_term* predicate = find_predicate<built_in_predicates>(element_variable, inner_operand, inner_predicate_index);
				if (predicate == nullptr) {
					head_index temp;
					predicate = find_variable_definition<built_in_predicates>(element_variable, inner_operand, temp);
					if (inner_predicate_index.position == head_position::NONE)
						inner_predicate_index = temp;
					if (predicate == nullptr) {
						head_index temp;
						predicate = find_scope<built_in_predicates, (unsigned int) built_in_predicates::NAME>(element_variable, inner_operand, temp);
						if (predicate != nullptr)
							predicate_is_scope = true;
						if (inner_predicate_index.position == head_position::NONE)
							inner_predicate_index = temp;
						if (inner_predicate_index.position == head_position::NONE) {
							/* if `inner_operand` is ANY_ARRAY, the predicate could be `all` */
							if (inner_operand->type == hol_term_type::ANY_ARRAY && is_scope<built_in_predicates, (unsigned int) built_in_predicates::NAME>(inner_operand->any_array.all, element_variable)) {
								inner_predicate_index.position = head_position::NONE;
								inner_predicate_index.index = 0;
							} else {
								free_all(intersection);
								for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
									free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
								}
								free(*head_var); free(head_var);
								return (hol_term*) nullptr;
							}
						}
					}
				}

				hol_term* new_conjunct;
				if (inner_operand->type == hol_term_type::AND) {
					unsigned int index = (unsigned int) ((ConjunctIndex >= 0) ? ConjunctIndex : (inner_operand->array.length + ConjunctIndex));
					new_conjunct = inner_operand->array.operands[index];
					if (predicate == nullptr)
						predicate = inner_operand->array.operands[inner_predicate_index.index];
				} else if (inner_operand->type == hol_term_type::ANY_ARRAY) {
					if (ConjunctIndex >= 0) {
						if (ConjunctIndex < inner_operand->any_array.left.length)
							new_conjunct = inner_operand->any_array.left.operands[ConjunctIndex];
						else new_conjunct = inner_operand->any_array.all;
					} else {
						if (inner_operand->any_array.right.length >= -ConjunctIndex) {
							unsigned int index = (unsigned int) (inner_operand->any_array.right.length + ConjunctIndex);
							new_conjunct = inner_operand->any_array.right.operands[index];
						} else {
							new_conjunct = inner_operand->any_array.all;
						}
					}
					if (predicate == nullptr) {
						if (inner_predicate_index.position == head_position::LEFT)
							predicate = inner_operand->any_array.left.operands[inner_predicate_index.index];
						else if (inner_predicate_index.position == head_position::RIGHT)
							predicate = inner_operand->any_array.right.operands[inner_operand->any_array.right.length - inner_predicate_index.index - 1];
						else if (inner_predicate_index.position == head_position::ANY)
							predicate = inner_operand->any_array.any.operands[inner_predicate_index.index];
						else if (inner_predicate_index.position == head_position::NONE)
							predicate = inner_operand->any_array.all;
					}
				} else if (ConjunctIndex == 0 || ConjunctIndex == -1) {
					new_conjunct = inner_operand;
					if (predicate == nullptr && inner_predicate_index.position == head_position::LEFT && inner_predicate_index.index == 0)
						predicate = inner_operand;
				} else {
					free_all(intersection);
					for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
						free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
					}
					free(*head_var); free(head_var);
					return (hol_term*) nullptr;
				}

				/* make sure the left conjunct is a predicate */
				hol_term* new_predicate;
				hol_term* expected_predicate;
				if (predicate_is_scope) {
					expected_predicate = hol_term::new_apply(
								hol_term::new_any(nullptr, excluded_trees, excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()), head_var);
					if (expected_predicate == nullptr) {
						free_all(intersection);
						for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
							free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
						}
						free(*head_var); free(head_var);
						return (hol_term*) nullptr;
					}

					new_predicate = hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::NAMED_ENTITY>::value, head_var);
					if (new_predicate == nullptr) {
						free_all(intersection); free(*head_var); free(head_var);
						free(*expected_predicate); free(expected_predicate);
						return (hol_term*) nullptr;
					}
					hol_term::constants<(unsigned int) built_in_predicates::NAMED_ENTITY>::value.reference_count++;
					head_var->reference_count++;
				} else {
					if (predicate != nullptr) {
						/* the predicate cannot be a scope (e.g. a named entity) */
						bool found_any_constant = false;
						for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
							hol_term* current_excluded = excluded_trees[i];
							if (current_excluded->type == hol_term_type::ANY_CONSTANT) {
								unsigned int index = index_of((unsigned int) built_in_predicates::NAMED_ENTITY, current_excluded->any_constant.constants, current_excluded->any_constant.length);
								if (index == current_excluded->any_constant.length) {
									array<unsigned int> constants(current_excluded->any_constant.length + 1);
									for (unsigned int j = 0; j < current_excluded->any_constant.length; j++)
										constants[constants.length++] = current_excluded->any_constant.constants[j];
									constants[constants.length++] = (unsigned int) built_in_predicates::NAMED_ENTITY;
									sort(constants);
									hol_term* new_excluded = hol_term::new_any_constant(make_array_view(constants.data, constants.length));
									if (new_excluded == nullptr) {
										free_all(intersection);
										for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
											free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
										}
										free(*head_var); free(head_var);
										return (hol_term*) nullptr;
									}
									free(*current_excluded); if (current_excluded->reference_count == 0) free(current_excluded);
									excluded_trees[i] = new_excluded;
								}
								found_any_constant = true;
							}
						}
						if (!found_any_constant) {
							excluded_trees[excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()] = &hol_term::constants<(unsigned int) built_in_predicates::NAMED_ENTITY>::value;
							hol_term::constants<(unsigned int) built_in_predicates::NAMED_ENTITY>::value.reference_count++;
							excluded_tree_count++;
						}
					}

					expected_predicate = hol_term::new_apply(
								hol_term::new_any(nullptr, excluded_trees, excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()), head_var);
					if (expected_predicate == nullptr) {
						free_all(intersection);
						for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
							free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
						}
						free(*head_var); free(head_var);
						return (hol_term*) nullptr;
					}

					array<hol_term*> new_predicates(2);
					intersect<built_in_predicates>(new_predicates, predicate, expected_predicate);
					if (new_predicates.length == 0) {
						free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
						free_all(intersection); return (hol_term*) nullptr;
					} else if (new_predicates.length != 1) {
						fprintf(stderr, "select_conjunct_in_set ERROR: Intersection is not unique.\n");
						free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
						free_all(new_predicates); free_all(intersection); return (hol_term*) nullptr;
					}
					new_predicate = new_predicates[0];
				}

				/* since we are removing the quantifier over `set_variable`,
				   remove any excluded quantifiers for `set_variable` from
				   `new_conjunct`, if they exist */
				hol_term* other_conjunct;
				if (new_conjunct->type == hol_term_type::ANY || new_conjunct->type == hol_term_type::ANY_RIGHT) {
					array<hol_term*> excluded_trees(max(1, new_conjunct->any.excluded_tree_count));
					for (unsigned int i = 0; i < new_conjunct->any.excluded_tree_count; i++) {
						hol_term* new_excluded_tree = new_conjunct->any.excluded_trees[i];
						if (new_excluded_tree->type == hol_term_type::ANY && new_excluded_tree->any.included != nullptr
						 && (new_excluded_tree->any.included->type == hol_term_type::EXISTS || new_excluded_tree->any.included->type == hol_term_type::FOR_ALL || new_excluded_tree->any.included->type == hol_term_type::LAMBDA)
						 && new_excluded_tree->any.included->quantifier.variable == set_variable)
						{
							continue;
						} else if (new_excluded_tree->type == hol_term_type::ANY && new_excluded_tree->any.included != nullptr
						 && new_excluded_tree->any.included->type == hol_term_type::LAMBDA
						 && new_excluded_tree->any.included->quantifier.variable == element_variable)
						{
							new_excluded_tree = hol_term::new_any(hol_term::new_exists(element_variable, new_excluded_tree->any.included->quantifier.operand));
							if (new_excluded_tree == nullptr) {
								free_all(excluded_trees);
								free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
								free(*new_predicate); if (new_predicate->reference_count == 0) free(new_predicate);
								free_all(intersection); return (hol_term*) nullptr;
							}
							new_excluded_tree->any.included->quantifier.operand->reference_count++;
						} else {
							new_excluded_tree->reference_count++;
						}

						bool contains = false;
						for (hol_term* existing_excluded_tree : excluded_trees) {
							if (*existing_excluded_tree == *new_excluded_tree) {
								contains = true;
								break;
							}
						}
						if (!contains) {
							excluded_trees[excluded_trees.length++] = new_excluded_tree;
						} else {
							free(*new_excluded_tree); if (new_excluded_tree->reference_count == 0) free(new_excluded_tree);
						}
					}

					if (excluded_trees.length == new_conjunct->any.excluded_tree_count) {
						free_all(excluded_trees);
						other_conjunct = new_conjunct;
						new_conjunct->reference_count++;
					} else {
						if (new_conjunct->type == hol_term_type::ANY)
							other_conjunct = hol_term::new_any(new_conjunct->any.included, excluded_trees.data, excluded_trees.length);
						else other_conjunct = hol_term::new_any_right(new_conjunct->any.included, excluded_trees.data, excluded_trees.length);
						if (other_conjunct == nullptr) {
							free_all(excluded_trees);
							free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
							free(*new_predicate); if (new_predicate->reference_count == 0) free(new_predicate);
							free_all(intersection); return (hol_term*) nullptr;
						}
						if (other_conjunct->any.included != nullptr)
							other_conjunct->any.included->reference_count++;
					}
				} else {
					other_conjunct = new_conjunct;
					new_conjunct->reference_count++;
				}

				array<hol_term*> new_conjuncts(2);
				subtract<built_in_predicates>(new_conjuncts, other_conjunct, expected_predicate);
				free(*other_conjunct); if (other_conjunct->reference_count == 0) free(other_conjunct);
				free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
				if (new_conjuncts.length == 0) {
					free(*new_predicate); if (new_predicate->reference_count == 0) free(new_predicate);
					free_all(intersection); return (hol_term*) nullptr;
				} else if (new_conjuncts.length != 1) {
					fprintf(stderr, "select_conjunct_in_set ERROR: Intersection is not unique.\n");
					free_all(new_conjuncts); free_all(intersection);
					free(*new_predicate); if (new_predicate->reference_count == 0) free(new_predicate);
					return (hol_term*) nullptr;
				}

				dst = hol_term::new_exists(element_variable, hol_term::new_and(new_predicate, new_conjuncts[0]));
				if (dst == nullptr) {
					free_all(new_conjuncts); free_all(intersection);
					free(*new_predicate); if (new_predicate->reference_count == 0) free(new_predicate);
					return (hol_term*) nullptr;
				}
				free_all(intersection);

				if (negated) {
					hol_term* new_dst = hol_term::new_not(dst);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					dst = new_dst;
				}
				if (old_head->type == hol_term_type::ANY || old_head->type == hol_term_type::ANY_RIGHT) {
					hol_term* new_dst = hol_term::new_any_right(dst);
					if (new_dst == nullptr) {
						free(*dst); free(dst);
						return (hol_term*) nullptr;
					}
					dst = new_dst;
				}
				return dst;
			}, no_op()) && dst != nullptr;
}

template<int_fast8_t ConjunctIndex, bool Predicative>
inline bool remove_conjunct_in_set(
		hol_term* src, hol_term*& dst)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<true>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker,
			predicative_head_finder<built_in_predicates>(lambda_variable),
			[lambda_variable,&max_variable](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				hol_term* old_head = head;
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr
				 && (head->any.included->type == hol_term_type::NOT || head->any.included->type == hol_term_type::EXISTS))
					head = head->any.included;

				bool negated = false;
				if (head->type == hol_term_type::NOT) {
					head = head->unary.operand;
					negated = true;
				}

				hol_term* operand;
				hol_term* left = nullptr;
				unsigned int set_variable, element_variable = 0;
				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT)
				{
					if (head->any.included != nullptr && head->any.included->type == hol_term_type::UNARY_APPLICATION
					 && head->any.included->binary.left->type == hol_term_type::VARIABLE
					 && head->any.included->binary.left->variable == lambda_variable
					 && head->any.included->binary.right->type == hol_term_type::VARIABLE)
					{
						element_variable = head->any.included->binary.right->variable;
						if (element_variable > max_variable)
							max_variable = element_variable;
					} else {
						element_variable = ++max_variable;
					}
					set_variable = ++max_variable;
				} else {
#if !defined(NDEBUG)
					if (head->type != hol_term_type::EXISTS)
						fprintf(stderr, "remove_conjunct_in_set WARNING: Expected an existential quantification.\n");
#endif
					set_variable = head->quantifier.variable;
					operand = head->quantifier.operand;

					if (operand->type == hol_term_type::ANY || operand->type == hol_term_type::ANY_RIGHT) {
						element_variable = ++max_variable;
					} else if (operand->type == hol_term_type::AND && operand->array.length != 0) {
						left = operand->array.operands[0];
					} else if (operand->type == hol_term_type::ANY_ARRAY) {
						if (operand->any_array.left.length != 0) {
							left = operand->any_array.left.operands[0];
						} if (operand->any_array.right.length != 0) {
							hol_term* right = operand->any_array.right.operands[operand->any_array.right.length - 1];

							bool has_any_right = false;
							if (right->type == hol_term_type::ANY_RIGHT && right->any.included != nullptr) {
								has_any_right = true;
								right = right->any.included;
							}

							if (right->type == hol_term_type::UNARY_APPLICATION && right->binary.left->type == hol_term_type::CONSTANT
							 && right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE)
								right = right->binary.right;
							while (right->type == hol_term_type::NOT)
								right = right->unary.operand;
							if (right->type == hol_term_type::FOR_ALL || right->type == hol_term_type::EXISTS) {
								element_variable = right->quantifier.variable;
							} else if (right->type == hol_term_type::AND && right->array.length == 2
									&& right->array.operands[0]->type == hol_term_type::UNARY_APPLICATION
									&& right->array.operands[0]->binary.left->type == hol_term_type::VARIABLE
									&& right->array.operands[0]->binary.left->variable == set_variable
									&& right->array.operands[0]->binary.right->type == hol_term_type::VARIABLE)
							{
								element_variable = right->array.operands[0]->binary.right->variable;
							} else if (has_any_right && right->type == hol_term_type::UNARY_APPLICATION
									&& right->binary.left->type == hol_term_type::VARIABLE
									&& right->binary.left->variable == lambda_variable
									&& right->binary.right->type == hol_term_type::VARIABLE)
							{
								element_variable = right->binary.right->variable;
							} else {
								return (hol_term*) nullptr;
							}
						}
					} else {
						return (hol_term*) nullptr;
					}

					hol_term* set_definition = nullptr;
					if (left != nullptr) {
						if (left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT) {
							if (left->any.included != nullptr && left->any.included->type == hol_term_type::LAMBDA) {
								set_definition = left->any.included;
							} else if (element_variable == 0) {
								element_variable = ++max_variable;
							}
						} else if (left->type == hol_term_type::EQUALS) {
							set_definition = left->binary.right;
						} else if (left->type == hol_term_type::BINARY_APPLICATION) {
							if (!Predicative) return (hol_term*) nullptr;
							set_definition = left->ternary.third;
						} else {
							return (hol_term*) nullptr;
						}
					}

					if (set_definition != nullptr) {
						if (set_definition->type == hol_term_type::ANY || set_definition->type == hol_term_type::ANY_RIGHT) {
							element_variable = ++max_variable;
						} else if (set_definition->type == hol_term_type::LAMBDA) {
							element_variable = set_definition->quantifier.variable;
						} else {
							return (hol_term*) nullptr;
						}
					}
				}

				hol_term* head_var = hol_term::new_variable(element_variable);
				if (head_var == nullptr) return (hol_term*) nullptr;
				constexpr unsigned int excluded_tree_count = 2;
				hol_term** excluded_trees = (hol_term**) alloca(sizeof(hol_term) * (excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()));
				excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
							(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
							(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
						&HOL_ANY), head_var));
				excluded_trees[1] = hol_term::new_any(hol_term::new_lambda(element_variable, &HOL_ANY));
				if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
				if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
				if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr) {
					if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
					free(*head_var); free(head_var);
					return (hol_term*) nullptr;
				}
				free(*head_var);

				if (!Predicative) {
					for (unsigned int i = 0; i < hol_non_head_constants<built_in_predicates>::count(); i++) {
						excluded_trees[excluded_tree_count + i] = hol_non_head_constants<built_in_predicates>::get_terms()[i];
						excluded_trees[excluded_tree_count + i]->reference_count++;
					}
				}

				hol_term* conjunct = hol_term::new_any(nullptr, excluded_trees, excluded_tree_count);
				if (conjunct == nullptr) {
					for (unsigned int i = 0; i < excluded_tree_count + (Predicative ? 0 : hol_non_head_constants<built_in_predicates>::count()); i++) {
						free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
					}
					return (hol_term*) nullptr;
				}
				if (!Predicative) {
					for (unsigned int i = 0; i < excluded_tree_count; i++)
						excluded_trees[i]->reference_count++;
				}

				hol_term* expected_predicate;
				if (!Predicative) {
					expected_predicate = hol_term::new_apply(
								hol_term::new_any(nullptr, excluded_trees, excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()), head_var);
					if (expected_predicate == nullptr) {
						free(*conjunct); free(conjunct);
						for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
							free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
						}
						return (hol_term*) nullptr;
					}
					head_var->reference_count++;
				}

				hol_term* conjunction = nullptr;
				if (ConjunctIndex >= 0) {
					if (ConjunctIndex == 0) {
						conjunction = hol_term::new_any_array(hol_term_type::AND, conjunct,
								(Predicative ? make_array_view((hol_term**) nullptr, 0) : make_array_view(&expected_predicate, 1)),
								make_array_view((hol_term**) nullptr, 0),
								make_array_view((hol_term**) nullptr, 0));
					} else {
						conjunction = hol_term::new_any_array(hol_term_type::AND, conjunct,
								(Predicative ? make_array_view((hol_term**) nullptr, 0) : make_array_view(&expected_predicate, 1)),
								make_repeated_array_view(conjunct, ConjunctIndex + 1),
								make_array_view((hol_term**) nullptr, 0));
					}
					if (conjunction == nullptr) {
						if (!Predicative) { free(*expected_predicate); free(expected_predicate); }
						free(*conjunct); free(conjunct);
						return (hol_term*) nullptr;
					}
					if (ConjunctIndex != 0)
						conjunct->reference_count += ConjunctIndex + 1;
				} else if (ConjunctIndex < 0) {
					unsigned int index = (unsigned int) (-ConjunctIndex) - 1;
					if (index == 0) {
						conjunction = hol_term::new_any_array(hol_term_type::AND, conjunct,
								(Predicative ? make_array_view((hol_term**) nullptr, 0) : make_array_view(&expected_predicate, 1)),
								make_array_view((hol_term**) nullptr, 0),
								make_array_view((hol_term**) nullptr, 0));
					} else {
						conjunction = hol_term::new_any_array(hol_term_type::AND, conjunct,
								(Predicative ? make_array_view((hol_term**) nullptr, 0) : make_array_view(&expected_predicate, 1)),
								make_array_view((hol_term**) nullptr, 0),
								make_repeated_array_view(conjunct, index + 1));
					}
					if (conjunction == nullptr) {
						if (!Predicative) { free(*expected_predicate); free(expected_predicate); }
						free(*conjunct); free(conjunct);
						return (hol_term*) nullptr;
					}
					if (index != 0)
						conjunct->reference_count += index + 1;
				}

				hol_term* set_definition;
				if (left == nullptr || left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT) {
					set_definition = hol_term::new_any_right(hol_term::new_lambda(element_variable, conjunction));
					if (set_definition == nullptr) {
						free(*conjunction); free(conjunction);
						return (hol_term*) nullptr;
					}
				} else if (left->type == hol_term_type::EQUALS) {
					set_definition = hol_term::new_equals(hol_term::new_variable(set_variable), hol_term::new_lambda(element_variable, conjunction));
					if (set_definition == nullptr) {
						free(*conjunction); free(conjunction);
						return (hol_term*) nullptr;
					}
				} else if (left->type == hol_term_type::BINARY_APPLICATION) {
					set_definition = hol_term::new_apply(&HOL_ANY, hol_term::new_variable(set_variable), hol_term::new_lambda(element_variable, conjunction));
					if (set_definition == nullptr) {
						free(*conjunction); free(conjunction);
						return (hol_term*) nullptr;
					}
					HOL_ANY.reference_count++;
				}

				hol_term* dst = hol_term::new_exists(set_variable, hol_term::new_any_array(hol_term_type::AND, &HOL_ANY,
						make_array_view((hol_term**) nullptr, 0), make_array_view(&set_definition, 1), make_array_view((hol_term**) nullptr, 0)));
				if (dst == nullptr) {
					free(*set_definition); free(set_definition);
					return (hol_term*) nullptr;
				}
				HOL_ANY.reference_count++;

				array<hol_term*> intersection(2);
				intersect<built_in_predicates>(intersection, dst, head);
				free(*dst); if (dst->reference_count == 0) free(dst);
				if (intersection.length == 0) {
					return (hol_term*) nullptr;
				} else if (intersection.length != 1) {
					fprintf(stderr, "remove_conjunct_in_set ERROR: Expected intersection to be unique.\n");
					free_all(intersection);
					return (hol_term*) nullptr;
				}

				operand = intersection[0]->quantifier.operand;
				if (operand->type == hol_term_type::AND) {
					left = operand->array.operands[0];
				} else {
					left = operand->any_array.left.operands[0];
				}

				hol_term* inner_operand;
				if (left->type == hol_term_type::ANY_RIGHT) {
					inner_operand = left->any.included->quantifier.operand;
				} else if (left->type == hol_term_type::EQUALS) {
					inner_operand = left->binary.right->quantifier.operand;
				} else {
					inner_operand = left->ternary.third->quantifier.operand;
				}

				hol_term* new_conjunction;
				if (inner_operand->type == hol_term_type::AND) {
					unsigned int index = (unsigned int) ((ConjunctIndex >= 0) ? ConjunctIndex : (inner_operand->array.length + ConjunctIndex));
					if (inner_operand->array.length == 2) {
						new_conjunction = (index == 0 ? inner_operand->array.operands[1] : inner_operand->array.operands[0]);
					} else {
						new_conjunction = hol_term::new_and(
								make_excluded_array_view(inner_operand->array.operands, inner_operand->array.length, index));
					}
					if (new_conjunction == nullptr) {
						free_all(intersection);
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < inner_operand->array.length; i++)
						if (i != index) inner_operand->array.operands[i]->reference_count++;
				} else if (inner_operand->type == hol_term_type::ANY_ARRAY) {
					unsigned int right_start = 0; unsigned int any_start = 0;
					unsigned int left_length = inner_operand->any_array.left.length;
					unsigned int right_length = inner_operand->any_array.right.length;
					unsigned int any_length = inner_operand->any_array.any.length;
					if (left_length > 1 && *inner_operand->any_array.left.operands[left_length - 1] == *inner_operand->any_array.all) {
						left_length--;
					} if (right_length > 1 && *inner_operand->any_array.right.operands[0] == *inner_operand->any_array.all) {
						right_start++;
						right_length--;
					} if (any_length > 1 && *inner_operand->any_array.any.operands[any_length - 1] == *inner_operand->any_array.all) {
						any_length--;
					} if (any_length > 1 && *inner_operand->any_array.any.operands[0] == *inner_operand->any_array.all) {
						any_start++;
						any_length--;
					}
					if (ConjunctIndex >= 0) {
						if (ConjunctIndex < inner_operand->any_array.left.length) {
							new_conjunction = hol_term::new_any_array(hol_term_type::AND, inner_operand->any_array.all,
									make_array_view(inner_operand->any_array.any.operands + any_start, any_length),
									make_excluded_array_view(inner_operand->any_array.left.operands, left_length, ConjunctIndex),
									make_array_view(inner_operand->any_array.right.operands + right_start, right_length));
						} else {
							new_conjunction = inner_operand;
							inner_operand->reference_count++;
						}
					} else {
						if (right_length >= -ConjunctIndex) {
							new_conjunction = hol_term::new_any_array(hol_term_type::AND, inner_operand->any_array.all,
									make_array_view(inner_operand->any_array.any.operands + any_start, any_length),
									make_array_view(inner_operand->any_array.left.operands, left_length),
									make_excluded_array_view(inner_operand->any_array.right.operands + right_start, right_length, (unsigned int) (right_length + ConjunctIndex)));
						} else {
							new_conjunction = inner_operand;
							inner_operand->reference_count++;
						}
					}
					if (new_conjunction == nullptr) {
						free_all(intersection);
						return (hol_term*) nullptr;
					}
					if (new_conjunction != inner_operand) {
						new_conjunction->any_array.all->reference_count++;
						for (unsigned int i = 0; i < new_conjunction->any_array.any.length; i++)
							new_conjunction->any_array.any.operands[i]->reference_count++;
						for (unsigned int i = 0; i < new_conjunction->any_array.left.length; i++)
							new_conjunction->any_array.left.operands[i]->reference_count++;
						for (unsigned int i = 0; i < new_conjunction->any_array.right.length; i++)
							new_conjunction->any_array.right.operands[i]->reference_count++;
					}
				} else {
					new_conjunction = &HOL_TRUE;
					HOL_TRUE.reference_count++;
				}

				if (!Predicative) {
					free_all(intersection);
					dst = hol_term::new_exists(element_variable, new_conjunction);
					if (dst == nullptr) {
						free(*new_conjunction); if (new_conjunction->reference_count == 0) free(new_conjunction);
						return (hol_term*) nullptr;
					}
					if (negated) {
						hol_term* new_dst = hol_term::new_not(dst);
						if (new_dst == nullptr) {
							free(*dst); if (dst->reference_count == 0) free(dst);
							return (hol_term*) nullptr;
						}
						dst = new_dst;
					}
					if (old_head->type == hol_term_type::ANY || old_head->type == hol_term_type::ANY_RIGHT) {
						hol_term* new_dst = hol_term::new_any_right(dst);
						if (new_dst == nullptr) {
							free(*dst); if (dst->reference_count == 0) free(dst);
							return (hol_term*) nullptr;
						}
						dst = new_dst;
					}
					return dst;

				} else {
					hol_term* new_set_definition = hol_term::new_lambda(element_variable, new_conjunction);
					if (new_set_definition == nullptr) {
						free(*new_conjunction); if (new_conjunction->reference_count == 0) free(new_conjunction);
						return (hol_term*) nullptr;
					}

					hol_term* new_left;
					if (left->type == hol_term_type::ANY_RIGHT) {
						new_left = hol_term::new_any_right(new_set_definition, left->any.excluded_trees, left->any.excluded_tree_count);
						if (new_left == nullptr) {
							free(*new_set_definition); free(new_set_definition);
							return (hol_term*) nullptr;
						}
						for (unsigned int i = 0; i < left->any.excluded_tree_count; i++)
							left->any.excluded_trees[i]->reference_count++;
					} else if (left->type == hol_term_type::EQUALS) {
						new_left = hol_term::new_equals(left->binary.left, new_set_definition);
						if (new_left == nullptr) {
							free(*new_set_definition); free(new_set_definition);
							return (hol_term*) nullptr;
						}
						left->binary.left->reference_count++;
					} else {
						new_left = hol_term::new_apply(left->ternary.first, left->ternary.second, new_set_definition);
						if (new_left == nullptr) {
							free(*new_set_definition); free(new_set_definition);
							return (hol_term*) nullptr;
						}
						left->ternary.first->reference_count++;
						left->ternary.second->reference_count++;
					}

					if (operand->type == hol_term_type::AND) {
						dst = hol_term::new_exists(set_variable, hol_term::new_and(
								make_prepended_array_view(new_left, make_array_view(operand->array.operands + 1, operand->array.length - 1))));
						if (dst == nullptr) {
							free_all(intersection);
							free(*new_left); free(new_left);
							return (hol_term*) nullptr;
						}
						for (unsigned int i = 1; i < operand->array.length; i++)
							operand->array.operands[i]->reference_count++;
					} else {
						dst = hol_term::new_exists(set_variable, hol_term::new_any_array(hol_term_type::AND,
								operand->any_array.all, make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
								make_prepended_array_view(new_left, make_array_view(operand->any_array.left.operands + 1, operand->any_array.left.length - 1)),
								make_array_view(operand->any_array.right.operands, operand->any_array.right.length)));
						if (dst == nullptr) {
							free_all(intersection);
							free(*new_left); free(new_left);
							return (hol_term*) nullptr;
						}
						operand->any_array.all->reference_count++;
						for (unsigned int i = 0; i < operand->any_array.any.length; i++)
							operand->any_array.any.operands[i]->reference_count++;
						for (unsigned int i = 1; i < operand->any_array.left.length; i++)
							operand->any_array.left.operands[i]->reference_count++;
						for (unsigned int i = 0; i < operand->any_array.right.length; i++)
							operand->any_array.right.operands[i]->reference_count++;
					}
				}
				free_all(intersection);

				if (negated) {
					hol_term* new_dst = hol_term::new_not(dst);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					dst = new_dst;
				}
				if (old_head->type == hol_term_type::ANY || old_head->type == hol_term_type::ANY_RIGHT) {
					hol_term* new_dst = hol_term::new_any_right(dst);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					dst = new_dst;
				}
				return dst;
			}, no_op()) && dst != nullptr;
}

template<int_fast8_t ConjunctIndex>
inline bool select_subset_in_set(
		hol_term* src, hol_term*& dst)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	array_map<unsigned int, hol_term*> scopes(8);
	auto gather_scope = [&scopes](hol_term* term) {
		if (term->type == hol_term_type::ANY || term->type == hol_term_type::ANY_RIGHT) {
			if (!scopes.ensure_capacity(scopes.size + 1))
				return false;
			scopes.keys[scopes.size] = 0;
			scopes.values[scopes.size++] = term;
		} else if (term->type == hol_term_type::FOR_ALL || term->type == hol_term_type::EXISTS || term->type == hol_term_type::LAMBDA) {
			if (!scopes.ensure_capacity(scopes.size + 1))
				return false;
			scopes.keys[scopes.size] = term->quantifier.variable;
			scopes.values[scopes.size++] = term;
		}
		return true;
	};

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<false>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker,
			predicative_head_finder<built_in_predicates>(lambda_variable),
			[lambda_variable,&max_variable,&scopes](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				hol_term* old_head = head;
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
					head = head->any.included;

				if (head->type == hol_term_type::NOT)
					head = head->unary.operand;

				bool has_new_set = false;
				unsigned int element_variable = 0, new_set_variable;
				hol_term* left = nullptr;
				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT)
				{
					element_variable = ++max_variable;
					new_set_variable = ++max_variable;
				} else {
#if !defined(NDEBUG)
					if (head->type != hol_term_type::EXISTS)
						fprintf(stderr, "select_subset_in_set WARNING: Expected an existential quantification.\n");
#endif
					hol_term* operand = head->quantifier.operand;

					if (operand->type == hol_term_type::ANY || operand->type == hol_term_type::ANY_RIGHT) {
						element_variable = ++max_variable;
						new_set_variable = ++max_variable;
					} else if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
						if (operand->any_array.left.length == 0) {
							left = operand->any_array.all;
						} else {
							left = operand->any_array.left.operands[0];
						}
					} else if (operand->type == hol_term_type::AND) {
						left = operand->array.operands[0];
					} else {
						return (hol_term*) nullptr;
					}

					hol_term* set_definition = nullptr;
					if (left != nullptr) {
						/* make sure `left` can be of the form `subset(*,*)` */
						hol_term* subset_term = hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::SUBSET>::value, &HOL_ANY, &HOL_ANY);
						if (subset_term == nullptr)
							return (hol_term*) nullptr;
						hol_term::constants<(unsigned int) built_in_predicates::SUBSET>::value.reference_count++;
						HOL_ANY.reference_count += 2;
						if (!has_intersection<built_in_predicates>(left, subset_term)) {
							free(*subset_term); free(subset_term);
							return (hol_term*) nullptr;
						}
						free(*subset_term); free(subset_term);

						if (left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT) {
							if (left->any.included != nullptr) {
								set_definition = left->any.included;
							} else {
								new_set_variable = ++max_variable;
							}
						} else if (left->type == hol_term_type::BINARY_APPLICATION) {
							set_definition = left->ternary.third;
						} else {
							return (hol_term*) nullptr;
						}
					}

					hol_term* inner_operand = nullptr;
					if (set_definition != nullptr) {
						if (set_definition->type == hol_term_type::ANY || set_definition->type == hol_term_type::ANY_RIGHT) {
							new_set_variable = ++max_variable;
						} else if (set_definition->type == hol_term_type::ANY_QUANTIFIER && has_intersection(set_definition->any_quantifier.quantifier, hol_quantifier_type::LAMBDA)) {
							new_set_variable = ++max_variable;
							inner_operand = set_definition->any_quantifier.operand;
						} else if (set_definition->type == hol_term_type::LAMBDA) {
							element_variable = set_definition->quantifier.variable;
							inner_operand = set_definition->quantifier.operand;
						} else {
							return (hol_term*) nullptr;
						}
					}

					hol_term* subset_term = nullptr;
					if (inner_operand != nullptr) {
						if (inner_operand->type == hol_term_type::ANY || inner_operand->type == hol_term_type::ANY_RIGHT) {
							new_set_variable = ++max_variable;
						} else if (inner_operand->type == hol_term_type::ANY_ARRAY) {
							if (ConjunctIndex >= 0) {
								if (ConjunctIndex < inner_operand->any_array.left.length)
									subset_term = inner_operand->any_array.left.operands[ConjunctIndex];
								else subset_term = inner_operand->any_array.all;
							} else {
								if (-ConjunctIndex - 1 < inner_operand->any_array.right.length)
									subset_term = inner_operand->any_array.right.operands[inner_operand->any_array.right.length + ConjunctIndex];
								else subset_term = inner_operand->any_array.all;
							}
						} else if (inner_operand->type == hol_term_type::AND) {
							if (ConjunctIndex >= 0 && (unsigned int) ConjunctIndex >= inner_operand->array.length)
								return (hol_term*) nullptr;
							else if (ConjunctIndex < 0 && (unsigned int) (-ConjunctIndex) > inner_operand->array.length)
								return (hol_term*) nullptr;
							unsigned int index = (ConjunctIndex >= 0) ? ConjunctIndex : (unsigned int) (inner_operand->array.length + ConjunctIndex);
							subset_term = inner_operand->array.operands[index];
						} else if (ConjunctIndex == 0 || ConjunctIndex == -1) {
							subset_term = inner_operand;
						} else {
							return (hol_term*) nullptr;
						}
					}

					if (subset_term == nullptr || subset_term->type == hol_term_type::ANY || subset_term->type == hol_term_type::ANY_RIGHT) {
						new_set_variable = ++max_variable;
					} else if (subset_term->type == hol_term_type::UNARY_APPLICATION) {
						if (subset_term->binary.left->type == hol_term_type::VARIABLE) {
							has_new_set = true;
							new_set_variable = subset_term->binary.left->variable;
						} else {
							new_set_variable = ++max_variable;
						}
					} else {
						return (hol_term*) nullptr;
					}

					if (element_variable == 0) {
						/* try to get the variable from the right conjunct in the set scope */
						hol_term* right = nullptr;
						if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
							if (operand->any_array.right.length == 0) {
								right = operand->any_array.all;
							} else {
								right = operand->any_array.right.operands[operand->any_array.right.length - 1];
							}
						} else if (operand->type == hol_term_type::AND) {
							right = operand->array.operands[operand->array.length - 1];
						}

						if ((right->type == hol_term_type::ANY || right->type == hol_term_type::ANY_RIGHT) && right->any.included != nullptr)
							right = right->any.included;

						hol_term* lambda_application = nullptr;
						if (right->type == hol_term_type::FOR_ALL && right->quantifier.operand->type == hol_term_type::IF_THEN) {
							lambda_application = right->quantifier.operand->binary.right;
						} else if (right->type == hol_term_type::EXISTS && right->quantifier.operand->type == hol_term_type::AND && right->quantifier.operand->array.length == 2) {
							lambda_application = right->quantifier.operand->array.operands[1];
						} else if (right->type == hol_term_type::AND && right->array.length == 2) {
							lambda_application = right->array.operands[1];
						} else {
							lambda_application = right;
						}

						if ((lambda_application->type == hol_term_type::ANY || lambda_application->type == hol_term_type::ANY_RIGHT) && lambda_application->any.included != nullptr)
							lambda_application = lambda_application->any.included;

						if (lambda_application->type == hol_term_type::UNARY_APPLICATION
						 && lambda_application->binary.left->type == hol_term_type::VARIABLE
						 && lambda_application->binary.left->variable == lambda_variable
						 && lambda_application->binary.right->type == hol_term_type::VARIABLE)
						{
							element_variable = lambda_application->binary.right->variable;
						} else {
							return (hol_term*) nullptr;
						}
					}
				}

				hol_term* dst;
				if (has_new_set) {
					/* the new set is already defined, so we don't need to define it here */
					hol_term* new_set_scope = scopes.get(new_set_variable)->quantifier.operand;

					/* get the element variable of this set */
					hol_term* left = nullptr;
					unsigned int new_element_variable = 0;
					if (new_set_scope->type == hol_term_type::ANY || new_set_scope->type == hol_term_type::ANY_RIGHT) {
						new_element_variable = element_variable;
					} else if (new_set_scope->type == hol_term_type::ANY_ARRAY && new_set_scope->any_array.oper == hol_term_type::AND) {
						if (new_set_scope->any_array.left.length == 0)
							left = new_set_scope->any_array.all;
						else left = new_set_scope->any_array.left.operands[0];
					} else if (new_set_scope->type == hol_term_type::AND) {
						left = new_set_scope->array.operands[0];
					} else {
						return (hol_term*) nullptr;
					}

					hol_term* new_set_definition = nullptr;
					if (left != nullptr) {
						if (left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT) {
							new_element_variable = element_variable;
						} else if (left->type == hol_term_type::EQUALS) {
							new_set_definition = left->binary.right;
						} else if (left->type == hol_term_type::BINARY_APPLICATION) {
							new_set_definition = left->ternary.third;
						} else {
							return (hol_term*) nullptr;
						}
					}

					if (new_set_definition != nullptr) {
						if (new_set_definition->type == hol_term_type::ANY || new_set_definition->type == hol_term_type::ANY_RIGHT
						 || (new_set_definition->type == hol_term_type::ANY_QUANTIFIER && has_intersection(new_set_definition->any_quantifier.quantifier, hol_quantifier_type::LAMBDA)))
						{
							new_element_variable = element_variable;
						} else if (new_set_definition->type == hol_term_type::LAMBDA) {
							new_element_variable = new_set_definition->quantifier.variable;
						} else {
							return (hol_term*) nullptr;
						}
					}

					hol_term* new_element_var = hol_term::new_variable(new_element_variable);
					if (new_element_var == nullptr)
						return (hol_term*) nullptr;
					dst = hol_term::new_for_all(new_element_variable, hol_term::new_if_then(
							hol_term::new_apply(hol_term::new_variable(new_set_variable), new_element_var),
							hol_term::new_apply(hol_term::new_variable(lambda_variable), new_element_var)));
					if (dst == nullptr) {
						free(*new_element_var); free(new_element_var);
						return (hol_term*) nullptr;
					}
					new_element_var->reference_count += 2 - 1;
				} else {
					unsigned int new_element_variable = element_variable;
					hol_term* new_element_var = hol_term::new_variable(new_element_variable);
					if (new_element_var == nullptr)
						return (hol_term*) nullptr;
					hol_term* expected_right = hol_term::new_for_all(new_element_variable, hol_term::new_if_then(
							hol_term::new_apply(hol_term::new_variable(new_set_variable), new_element_var),
							hol_term::new_apply(hol_term::new_variable(lambda_variable), new_element_var)));
					if (expected_right == nullptr) {
						free(*new_element_var); free(new_element_var);
						return (hol_term*) nullptr;
					}
					new_element_var->reference_count += 2 - 1;

					hol_term* excluded_quantifiers[3];
					excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(head_variable, &HOL_ANY));
					excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(head_variable, &HOL_ANY));
					excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(head_variable, &HOL_ANY));
					if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
					if (excluded_quantifiers[1] != nullptr) HOL_ANY.reference_count++;
					if (excluded_quantifiers[2] != nullptr) HOL_ANY.reference_count++;
					if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr) {
						if (excluded_quantifiers[0] != nullptr) { free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]); }
						if (excluded_quantifiers[1] != nullptr) { free(*excluded_quantifiers[1]); free(excluded_quantifiers[1]); }
						free(*expected_right); free(expected_right);
						return (hol_term*) nullptr;
					}

					hol_term* expected_conjunct = hol_term::new_any(nullptr, excluded_quantifiers, array_length(excluded_quantifiers));
					if (expected_conjunct == nullptr) {
						for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
						free(*expected_right); free(expected_right);
						return (hol_term*) nullptr;
					}

					dst = hol_term::new_exists(new_set_variable, hol_term::new_any_array(hol_term_type::AND, expected_conjunct,
							make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0), make_array_view(&expected_right, 1)));
					if (dst == nullptr) {
						free(*expected_right); free(expected_right);
						free(*expected_conjunct); free(expected_conjunct);
						return (hol_term*) nullptr;
					}
				}

				if (old_head->type == hol_term_type::ANY || old_head->type == hol_term_type::ANY_RIGHT) {
					hol_term* new_dst = hol_term::new_any_right(dst);
					if (new_dst == nullptr) {
						free(*dst); free(dst);
						return (hol_term*) nullptr;
					}
					dst = new_dst;
				}
				return dst;
			}, gather_scope);
}

template<int_fast8_t ConjunctIndex>
inline bool select_only_conjunct_in_set_predicative(
		hol_term* src, hol_term*& dst)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<false>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker,
			predicative_head_finder<built_in_predicates>(lambda_variable),
			[lambda_variable,&max_variable](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
					head = head->any.included;

				bool negated = false;
				if (head->type == hol_term_type::NOT) {
					head = head->unary.operand;
					negated = true;
				}

				hol_term* left = nullptr;
				unsigned int set_variable, element_variable = 0;
				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT)
				{
					set_variable = ++max_variable;
					element_variable = ++max_variable;
				} else {
#if !defined(NDEBUG)
					if (head->type != hol_term_type::EXISTS)
						fprintf(stderr, "select_only_conjunct_in_set_predicative WARNING: Expected an existential quantification.\n");
#endif
					set_variable = head->quantifier.variable;
					hol_term* operand = head->quantifier.operand;

					if (operand->type == hol_term_type::ANY || operand->type == hol_term_type::ANY_RIGHT) {
						element_variable = ++max_variable;
					} else if (operand->type == hol_term_type::AND && operand->array.length != 0) {
						left = operand->array.operands[0];
					} else if (operand->type == hol_term_type::ANY_ARRAY) {
						if (operand->any_array.left.length != 0) {
							left = operand->any_array.left.operands[0];
						} if (operand->any_array.right.length != 0) {
							hol_term* right = operand->any_array.right.operands[operand->any_array.right.length - 1];

							bool has_any_right = false;
							if (right->type == hol_term_type::ANY_RIGHT && right->any.included != nullptr) {
								has_any_right = true;
								right = right->any.included;
							}

							if (right->type == hol_term_type::UNARY_APPLICATION && right->binary.left->type == hol_term_type::CONSTANT
							 && right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE)
								right = right->binary.right;
							while (right->type == hol_term_type::NOT)
								right = right->unary.operand;
							if (right->type == hol_term_type::FOR_ALL || right->type == hol_term_type::EXISTS) {
								element_variable = right->quantifier.variable;
							} else if (right->type == hol_term_type::AND && right->array.length == 2
									&& right->array.operands[0]->type == hol_term_type::UNARY_APPLICATION
									&& right->array.operands[0]->binary.left->type == hol_term_type::VARIABLE
									&& right->array.operands[0]->binary.left->variable == set_variable
									&& right->array.operands[0]->binary.right->type == hol_term_type::VARIABLE)
							{
								element_variable = right->array.operands[0]->binary.right->variable;
							} else if (has_any_right && right->type == hol_term_type::UNARY_APPLICATION
									&& right->binary.left->type == hol_term_type::VARIABLE
									&& right->binary.left->variable == lambda_variable
									&& right->binary.right->type == hol_term_type::VARIABLE)
							{
								element_variable = right->binary.right->variable;
							} else {
								return (hol_term*) nullptr;
							}
						}
					} else {
						return (hol_term*) nullptr;
					}

					hol_term* set_definition = nullptr;
					if (left != nullptr) {
						if (left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT) {
							if (left->any.included != nullptr && left->any.included->type == hol_term_type::LAMBDA) {
								set_definition = left->any.included;
							} else if (element_variable == 0) {
								element_variable = ++max_variable;
							}
						} else if (left->type == hol_term_type::EQUALS) {
							set_definition = left->binary.right;
						} else if (left->type == hol_term_type::BINARY_APPLICATION) {
							set_definition = left->ternary.third;
						} else {
							return (hol_term*) nullptr;
						}
					}

					if (set_definition != nullptr) {
						if (set_definition->type == hol_term_type::ANY || set_definition->type == hol_term_type::ANY_RIGHT) {
							element_variable = ++max_variable;
						} else if (set_definition->type == hol_term_type::LAMBDA) {
							element_variable = set_definition->quantifier.variable;
						} else {
							return (hol_term*) nullptr;
						}
					}
				}

				hol_term* head_var = hol_term::new_variable(element_variable);
				if (head_var == nullptr) return (hol_term*) nullptr;
				constexpr unsigned int excluded_tree_count = 2;
				hol_term* excluded_trees[excluded_tree_count];
				excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
							(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
							(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
						&HOL_ANY), head_var));
				excluded_trees[1] = hol_term::new_any(hol_term::new_lambda(element_variable, &HOL_ANY));
				if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
				if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
				if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr) {
					if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
					free(*head_var); free(head_var);
					return (hol_term*) nullptr;
				}
				free(*head_var);

				hol_term* conjunct = hol_term::new_any(nullptr, excluded_trees, excluded_tree_count);
				if (conjunct == nullptr) {
					free(*excluded_trees[0]); free(excluded_trees[0]);
					free(*excluded_trees[1]); free(excluded_trees[1]);
					return (hol_term*) nullptr;
				}

				hol_term* conjunction = nullptr;
				if (ConjunctIndex >= 0) {
					conjunction = hol_term::new_any_array(hol_term_type::AND, conjunct, make_array_view((hol_term**) nullptr, 0),
							make_repeated_array_view(conjunct, ConjunctIndex + 1),
							make_array_view((hol_term**) nullptr, 0));
				} else if (ConjunctIndex < 0) {
					unsigned int index = (unsigned int) (-ConjunctIndex) - 1;
					conjunction = hol_term::new_any_array(hol_term_type::AND, conjunct, make_array_view((hol_term**) nullptr, 0),
							make_array_view((hol_term**) nullptr, 0),
							make_repeated_array_view(conjunct, index + 1));
				}
				if (conjunction == nullptr) {
					free(*conjunct); free(conjunct);
					return (hol_term*) nullptr;
				}
				conjunction->any_array.all->reference_count++;
				for (unsigned int i = 0; i < conjunction->any_array.left.length; i++)
					conjunction->any_array.left.operands[i]->reference_count++;
				for (unsigned int i = 0; i < conjunction->any_array.right.length; i++)
					conjunction->any_array.right.operands[i]->reference_count++;
				for (unsigned int i = 0; i < conjunction->any_array.any.length; i++)
					conjunction->any_array.any.operands[i]->reference_count++;
				free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);

				hol_term* set_definition;
				if (left == nullptr || left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT) {
					set_definition = hol_term::new_any_right(hol_term::new_lambda(element_variable, conjunction));
					if (set_definition == nullptr) {
						free(*conjunction); free(conjunction);
						return (hol_term*) nullptr;
					}
				} else if (left->type == hol_term_type::EQUALS) {
					set_definition = hol_term::new_equals(hol_term::new_variable(set_variable), hol_term::new_lambda(element_variable, conjunction));
					if (set_definition == nullptr) {
						free(*conjunction); free(conjunction);
						return (hol_term*) nullptr;
					}
				} else if (left->type == hol_term_type::BINARY_APPLICATION) {
					set_definition = hol_term::new_apply(&HOL_ANY, hol_term::new_variable(set_variable), hol_term::new_lambda(element_variable, conjunction));
					if (set_definition == nullptr) {
						free(*conjunction); free(conjunction);
						return (hol_term*) nullptr;
					}
					HOL_ANY.reference_count++;
				}

				hol_term* dst = hol_term::new_exists(set_variable, hol_term::new_any_array(hol_term_type::AND, &HOL_ANY,
						make_array_view((hol_term**) nullptr, 0), make_array_view(&set_definition, 1), make_array_view((hol_term**) nullptr, 0)));
				if (dst == nullptr) {
					free(*set_definition); free(set_definition);
					return (hol_term*) nullptr;
				}
				HOL_ANY.reference_count++;

				array<hol_term*> intersection(2);
				intersect<built_in_predicates>(intersection, dst, head);
				free(*dst); if (dst->reference_count == 0) free(dst);
				if (intersection.length == 0) {
					return (hol_term*) nullptr;
				} else if (intersection.length != 1) {
					fprintf(stderr, "select_only_conjunct_in_set_predicative ERROR: Expected intersection to be unique.\n");
					free_all(intersection);
					return (hol_term*) nullptr;
				}

				hol_term* operand = intersection[0]->quantifier.operand;
				if (operand->type == hol_term_type::AND) {
					left = operand->array.operands[0];
				} else {
					left = operand->any_array.left.operands[0];
				}

				hol_term* inner_operand;
				if (left->type == hol_term_type::ANY_RIGHT) {
					inner_operand = left->any.included->quantifier.operand;
				} else if (left->type == hol_term_type::EQUALS) {
					inner_operand = left->binary.right->quantifier.operand;
				} else {
					inner_operand = left->ternary.third->quantifier.operand;
				}

				hol_term* new_set_definition;
				if (inner_operand->type == hol_term_type::AND) {
					unsigned int index = (unsigned int) ((ConjunctIndex >= 0) ? ConjunctIndex : (inner_operand->array.length + ConjunctIndex));
					new_set_definition = hol_term::new_lambda(element_variable, inner_operand->array.operands[index]);
					if (new_set_definition == nullptr) {
						free_all(intersection);
						return (hol_term*) nullptr;
					}
					inner_operand->array.operands[index]->reference_count++;
				} else if (inner_operand->type == hol_term_type::ANY_ARRAY) {
					if (ConjunctIndex >= 0) {
						new_set_definition = hol_term::new_lambda(element_variable, inner_operand->any_array.left.operands[ConjunctIndex]);
					} else {
						new_set_definition = hol_term::new_lambda(element_variable, inner_operand->any_array.right.operands[inner_operand->any_array.right.length + ConjunctIndex]);
					}
					if (new_set_definition == nullptr) {
						free_all(intersection);
						return (hol_term*) nullptr;
					}
					hol_term* new_conjunction = new_set_definition->quantifier.operand;
					new_conjunction->reference_count++;
				} else {
					if (ConjunctIndex == 0 || ConjunctIndex == -1) {
						new_set_definition = hol_term::new_lambda(element_variable, inner_operand);
						if (new_set_definition == nullptr) {
							free_all(intersection);
							return (hol_term*) nullptr;
						}
						inner_operand->reference_count++;
					} else {
						free_all(intersection);
						return (hol_term*) nullptr;
					}
				}

				hol_term* new_left;
				if (left->type == hol_term_type::ANY_RIGHT) {
					new_left = hol_term::new_any_right(new_set_definition, left->any.excluded_trees, left->any.excluded_tree_count);
					if (new_left == nullptr) {
						free(*new_set_definition); free(new_set_definition);
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < left->any.excluded_tree_count; i++)
						left->any.excluded_trees[i]->reference_count++;
				} else if (left->type == hol_term_type::EQUALS) {
					new_left = hol_term::new_equals(left->binary.left, new_set_definition);
					if (new_left == nullptr) {
						free(*new_set_definition); free(new_set_definition);
						return (hol_term*) nullptr;
					}
					left->binary.left->reference_count++;
				} else {
					new_left = hol_term::new_apply(left->ternary.first, left->ternary.second, new_set_definition);
					if (new_left == nullptr) {
						free(*new_set_definition); free(new_set_definition);
						return (hol_term*) nullptr;
					}
					left->ternary.first->reference_count++;
					left->ternary.second->reference_count++;
				}

				if (operand->type == hol_term_type::AND) {
					dst = hol_term::new_exists(set_variable, hol_term::new_and(
							make_prepended_array_view(new_left, make_array_view(operand->array.operands + 1, operand->array.length - 1))));
					if (dst == nullptr) {
						free_all(intersection);
						free(*new_left); free(new_left);
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 1; i < operand->array.length; i++)
						operand->array.operands[i]->reference_count++;
				} else {
					dst = hol_term::new_exists(set_variable, hol_term::new_any_array(hol_term_type::AND,
							operand->any_array.all, make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
							make_prepended_array_view(new_left, make_array_view(operand->any_array.left.operands + 1, operand->any_array.left.length - 1)),
							make_array_view(operand->any_array.right.operands, operand->any_array.right.length)));
					if (dst == nullptr) {
						free_all(intersection);
						free(*new_left); free(new_left);
						return (hol_term*) nullptr;
					}
					operand->any_array.all->reference_count++;
					for (unsigned int i = 0; i < operand->any_array.any.length; i++)
						operand->any_array.any.operands[i]->reference_count++;
					for (unsigned int i = 1; i < operand->any_array.left.length; i++)
						operand->any_array.left.operands[i]->reference_count++;
					for (unsigned int i = 0; i < operand->any_array.right.length; i++)
						operand->any_array.right.operands[i]->reference_count++;
				}
				free_all(intersection);

				if (negated) {
					hol_term* new_dst = hol_term::new_not(dst);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					dst = new_dst;
				}
				return dst;
			}, no_op()) && dst != nullptr;
}

template<int_fast8_t PredicateIndex>
inline bool require_predicate(
		hol_term* src, hol_term*& dst,
		hol_term* predicate)
{
	array_map<unsigned int, hol_term*> predicates(4);

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	bool result = apply_head<true>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker, find_head<built_in_predicates>,
			[predicate, &predicates](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				if (!predicates.ensure_capacity(predicates.size + 1))
					return (hol_term*) nullptr;
				hol_term* current_predicate;
				unsigned int index = predicates.index_of(head_variable);
				if (index == predicates.size) {
					array_map<unsigned int, unsigned int> variable_map(1);
					variable_map.put(0, head_variable);
					predicates.keys[index] = head_variable;
					predicates.values[index] = map_variables(predicate, variable_map);
					if (predicates.values[index] == nullptr)
						return (hol_term*) nullptr;
					predicates.size++;
				}
				current_predicate = predicates.values[index];

				hol_term* old_head = head;
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && predicate_index.position != head_position::NONE)
					head = head->any.included;

				bool negated = false;
				if (head->type == hol_term_type::NOT) {
					head = head->unary.operand;
					negated = true;
				}

				hol_term* dst;
				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT
				 || (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY)
				 || (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY_RIGHT))
				{
					hol_term* head_var = hol_term::new_variable(head_variable);
					if (head_var == nullptr) return (hol_term*) nullptr;
					constexpr unsigned int excluded_tree_count = 2;
					hol_term** excluded_trees = (hol_term**) alloca(sizeof(hol_term) * (excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()));
					excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
								(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
								(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
							&HOL_ANY), head_var));
					excluded_trees[1] = hol_term::new_any(hol_term::new_exists(head_variable, &HOL_ANY));
					if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
					if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
					if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr) {
						if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
						free(*head_var); free(head_var);
						return (hol_term*) nullptr;
					}
					free(*head_var);

					for (unsigned int i = 0; i < hol_non_head_constants<built_in_predicates>::count(); i++) {
						excluded_trees[excluded_tree_count + i] = hol_non_head_constants<built_in_predicates>::get_terms()[i];
						excluded_trees[excluded_tree_count + i]->reference_count++;
					}

					hol_term* conjunct = hol_term::new_any(nullptr, excluded_trees, excluded_tree_count);
					if (conjunct == nullptr) {
						for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
							free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
						}
						return (hol_term*) nullptr;
					}

					hol_term* conjunction;
					if (!new_hol_term(conjunction)) return (hol_term*) nullptr;
					conjunction->type = hol_term_type::ANY_ARRAY;
					conjunction->reference_count = 1;
					conjunction->any_array.oper = hol_term_type::AND;
					conjunction->any_array.all = conjunct;
					if (PredicateIndex >= 0 && PredicateIndex != INT_FAST8_MAX) {
						conjunction->any_array.left.length = PredicateIndex + 1;
						conjunction->any_array.left.operands = (hol_term**) malloc(sizeof(hol_term*) * (PredicateIndex + 1));
						if (conjunction->any_array.left.operands == nullptr) {
							free(conjunction); free(*conjunct); free(conjunct);
							return (hol_term*) nullptr;
						}
						for (unsigned int i = 0; i < PredicateIndex; i++)
							conjunction->any_array.left.operands[i] = conjunct;
						conjunction->any_array.left.operands[PredicateIndex] = current_predicate;
						conjunction->any_array.right.length = 0;
						conjunction->any_array.right.operands = nullptr;
						conjunction->any_array.any.length = 0;
						conjunction->any_array.any.operands = nullptr;
						conjunct->reference_count += 1 + PredicateIndex;
					} else if (PredicateIndex < 0) {
						unsigned int index = (unsigned int) (-PredicateIndex) - 1;
						conjunction->any_array.right.length = index + 1;
						conjunction->any_array.right.operands = (hol_term**) malloc(sizeof(hol_term*) * (index + 1));
						if (conjunction->any_array.right.operands == nullptr) {
							free(conjunction); free(*conjunct); free(conjunct);
							return (hol_term*) nullptr;
						}
						for (unsigned int i = 1; i < index + 1; i++)
							conjunction->any_array.right.operands[i] = conjunct;
						conjunction->any_array.right.operands[0] = current_predicate;
						conjunction->any_array.left.length = 0;
						conjunction->any_array.left.operands = nullptr;
						conjunction->any_array.any.length = 0;
						conjunction->any_array.any.operands = nullptr;
						conjunct->reference_count += 1 + index;
					} else if (PredicateIndex == INT_FAST8_MAX) {
						conjunction->any_array.left.length = 0;
						conjunction->any_array.left.operands = nullptr;
						conjunction->any_array.right.length = 0;
						conjunction->any_array.right.operands = nullptr;
						conjunction->any_array.any.length = 1;
						conjunction->any_array.any.operands = (hol_term**) malloc(sizeof(hol_term*) * 1);
						if (conjunction->any_array.any.operands == nullptr) {
							free(conjunction); free(*conjunct); free(conjunct);
							return (hol_term*) nullptr;
						}
						conjunction->any_array.any.operands[0] = current_predicate;
						conjunct->reference_count += 1;
					} else {
						fprintf(stderr, "require_predicate ERROR: Unsupported value of `PredicateIndex`.\n");
						free(conjunction); free(*conjunct); free(conjunct);
						return (hol_term*) nullptr;
					}
					free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
					current_predicate->reference_count++;

					dst = hol_term::new_exists(head_variable, conjunction);
					if (dst == nullptr) {
						free(*conjunction); free(conjunction);
						return (hol_term*) nullptr;
					}

					array<hol_term*> intersection(2);
					intersect<built_in_predicates>(intersection, dst, head);
					if (intersection.length > 1) {
						fprintf(stderr, "require_predicate ERROR: Expected intersection size to be 1.\n");
						for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					free(*dst); if (dst->reference_count == 0) free(dst);
					if (intersection.length == 0)
						return (hol_term*) nullptr;
					dst = intersection[0];
				} else if (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY_ARRAY) {
					hol_term* operand = head->quantifier.operand;
					if (PredicateIndex != INT_FAST8_MAX) {
						if (predicate_index.position == head_position::ANY) {
							if (PredicateIndex >= 0 && PredicateIndex < predicate_index.index)
								return (hol_term*) nullptr;
							else if (PredicateIndex < 0 && head->quantifier.operand->any_array.any.length - predicate_index.index > -PredicateIndex)
								return (hol_term*) nullptr;
						} else if (!predicate_index.compare(PredicateIndex)) {
							return (hol_term*) nullptr;
						}
					}

					hol_term* predicate = nullptr;
					if (predicate_index.position == head_position::LEFT) {
						predicate = operand->any_array.left.operands[predicate_index.index];
					} else if (predicate_index.position == head_position::RIGHT) {
						predicate = operand->any_array.right.operands[operand->any_array.right.length - predicate_index.index - 1];
					} else {
						predicate = operand->any_array.any.operands[predicate_index.index];
					}
					array<hol_term*> intersection(2);
					intersect<built_in_predicates>(intersection, predicate, current_predicate);
					if (intersection.length > 1) {
						fprintf(stderr, "require_predicate ERROR: Expected intersection size to be 1.\n");
						for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
						return (hol_term*) nullptr;
					}
					if (intersection.length == 0)
						return (hol_term*) nullptr;

					if (intersection[0] == predicate) {
						for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
						dst = head;
						head->reference_count++;
					} else {
						hol_term* conjunction;
						if (!new_hol_term(conjunction)) {
							for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
							return (hol_term*) nullptr;
						}
						conjunction->type = hol_term_type::ANY_ARRAY;
						conjunction->reference_count = 1;
						conjunction->any_array.oper = hol_term_type::AND;
						conjunction->any_array.all = operand->any_array.all;
						conjunction->any_array.all->reference_count++;
						conjunction->any_array.left.length = 0;
						conjunction->any_array.left.operands = nullptr;
						conjunction->any_array.right.length = 0;
						conjunction->any_array.right.operands = nullptr;
						conjunction->any_array.any.length = 0;
						conjunction->any_array.any.operands = nullptr;

						conjunction->any_array.left.length = operand->any_array.left.length;
						if (conjunction->any_array.left.length == 0) {
							conjunction->any_array.left.operands = nullptr;
						} else {
							conjunction->any_array.left.operands = (hol_term**) malloc(sizeof(hol_term*) * conjunction->any_array.left.length);
							if (conjunction->any_array.left.operands == nullptr) {
								for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
								free(*conjunction); free(conjunction);
								return (hol_term*) nullptr;
							}
							for (unsigned int i = 0; i < conjunction->any_array.left.length; i++) {
								if (predicate_index.position == head_position::LEFT && predicate_index.index == i) {
									conjunction->any_array.left.operands[i] = intersection[0];
								} else {
									conjunction->any_array.left.operands[i] = operand->any_array.left.operands[i];
								}
								conjunction->any_array.left.operands[i]->reference_count++;
							}
						}
						conjunction->any_array.right.length = operand->any_array.right.length;
						if (conjunction->any_array.right.length == 0) {
							conjunction->any_array.right.operands = nullptr;
						} else {
							conjunction->any_array.right.operands = (hol_term**) malloc(sizeof(hol_term*) * conjunction->any_array.right.length);
							if (conjunction->any_array.right.operands == nullptr) {
								for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
								free(*conjunction); free(conjunction);
								return (hol_term*) nullptr;
							}
							for (unsigned int i = 0; i < conjunction->any_array.right.length; i++) {
								if (predicate_index.position == head_position::RIGHT && predicate_index.index == conjunction->any_array.right.length - i - 1) {
									conjunction->any_array.right.operands[i] = intersection[0];
								} else {
									conjunction->any_array.right.operands[i] = operand->any_array.right.operands[i];
								}
								conjunction->any_array.right.operands[i]->reference_count++;
							}
						}
						conjunction->any_array.any.length = operand->any_array.any.length;
						if (conjunction->any_array.any.length == 0) {
							conjunction->any_array.any.operands = nullptr;
						} else {
							conjunction->any_array.any.operands = (hol_term**) malloc(sizeof(hol_term*) * conjunction->any_array.any.length);
							if (conjunction->any_array.any.operands == nullptr) {
								for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
								free(*conjunction); free(conjunction);
								return (hol_term*) nullptr;
							}
							for (unsigned int i = 0; i < conjunction->any_array.any.length; i++) {
								if (predicate_index.position == head_position::ANY && predicate_index.index == i) {
									conjunction->any_array.any.operands[i] = intersection[0];
								} else {
									conjunction->any_array.any.operands[i] = operand->any_array.any.operands[i];
								}
								conjunction->any_array.any.operands[i]->reference_count++;
							}
						}
						for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }

						dst = hol_term::new_exists(head->quantifier.variable, conjunction);
						if (dst == nullptr) {
							free(*conjunction); free(conjunction);
							return (hol_term*) nullptr;
						}
					}
				} else {
#if !defined(NDEBUG)
					if (head->type != hol_term_type::EXISTS)
						fprintf(stderr, "require_predicate WARNING: Expected `head` to be an existentially quantified conjunction.\n");
#endif
					hol_term* operand = head->quantifier.operand;
					if (PredicateIndex != INT_FAST8_MAX) {
						int expected_predicate_index = PredicateIndex;
						if (expected_predicate_index < 0)
							expected_predicate_index += operand->array.length;
						if (!predicate_index.compare(expected_predicate_index))
							return (hol_term*) nullptr;
					}

					if (operand->type != hol_term_type::AND && predicate_index.index != 0)
						return (hol_term*) nullptr;

					hol_term* predicate = (operand->type == hol_term_type::AND ? operand->array.operands[predicate_index.index] : operand);
					array<hol_term*> intersection(2);
					intersect<built_in_predicates>(intersection, predicate, current_predicate);
					if (intersection.length > 1) {
						fprintf(stderr, "require_predicate ERROR: Expected intersection size to be 1.\n");
						for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
						return (hol_term*) nullptr;
					}
					if (intersection.length == 0)
						return (hol_term*) nullptr;

					if (intersection[0] == predicate) {
						free_all(intersection);
						dst = head;
						head->reference_count++;
					} else if (operand->type == hol_term_type::AND) {
						hol_term* conjunction;
						if (!new_hol_term(conjunction)) {
							free_all(intersection);
							return (hol_term*) nullptr;
						}
						conjunction->type = hol_term_type::AND;
						conjunction->reference_count = 1;
						conjunction->array.length = operand->array.length;
						conjunction->array.operands = (hol_term**) malloc(sizeof(hol_term*) * operand->array.length);
						if (conjunction->array.operands == nullptr) {
							fprintf(stderr, "require_predicate ERROR: Out of memory.\n");
							free_all(intersection); return (hol_term*) nullptr;
						}
						for (unsigned int i = 0; i < operand->array.length; i++) {
							if (i == predicate_index.index)
								conjunction->array.operands[i] = intersection[0];
							else
								conjunction->array.operands[i] = operand->array.operands[i];
							conjunction->array.operands[i]->reference_count++;
						}
						free_all(intersection);

						dst = hol_term::new_exists(head->quantifier.variable, conjunction);
						if (dst == nullptr) {
							free(*conjunction); free(conjunction);
							return (hol_term*) nullptr;
						}
					} else {
						dst = hol_term::new_exists(head->quantifier.variable, intersection[0]);
						if (dst == nullptr) {
							free_all(intersection);
							return (hol_term*) nullptr;
						}
					}
				}

				if (negated) {
					hol_term* new_dst = hol_term::new_not(dst);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					dst = new_dst;
				}

				if (old_head->type == hol_term_type::ANY || old_head->type == hol_term_type::ANY_RIGHT) {
					hol_term* new_dst = hol_term::new_any_right(dst, old_head->any.excluded_trees, old_head->any.excluded_tree_count);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < old_head->any.excluded_tree_count; i++)
						old_head->any.excluded_trees[i]->reference_count++;
					dst = new_dst;
				}
				return dst;
			}, no_op()) && dst != nullptr;
	for (auto entry : predicates) {
		free(*entry.value); if (entry.value->reference_count == 0) free(entry.value);
	}
	if (src->type == hol_term_type::LAMBDA && !(dst->type == hol_term_type::LAMBDA && dst->quantifier.variable == src->quantifier.variable)) {
		hol_term* temp = hol_term::new_lambda(src->quantifier.variable, dst);
		if (temp == nullptr) {
			free(*dst); if (dst->reference_count == 0) free(dst);
			return false;
		}
		dst = temp;
	}
	return result;
}

inline bool require_no_inverse(hol_term* src, hol_term*& dst)
{
	hol_term** excluded_constants = (hol_term**) malloc(sizeof(hol_term*) * (hol_non_head_constants<built_in_predicates>::count() + 1));
	if (excluded_constants == nullptr) {
		fprintf(stderr, "require_no_inverse ERROR: Out of memory.\n");
		return false;
	}
	for (unsigned int i = 0; i < hol_non_head_constants<built_in_predicates>::count(); i++)
		excluded_constants[i] = hol_non_head_constants<built_in_predicates>::get_terms()[i];
	excluded_constants[hol_non_head_constants<built_in_predicates>::count()] = &hol_term::constants<(unsigned int) built_in_predicates::INVERSE>::value;

	hol_term* predicate = hol_term::new_apply(
			hol_term::new_any(nullptr, excluded_constants, hol_non_head_constants<built_in_predicates>::count() + 1),
			&hol_term::variables<0>::value);
	if (predicate == nullptr) {
		free(excluded_constants);
		return false;
	}
	hol_non_head_constants<built_in_predicates>::increment_terms();
	hol_term::constants<(unsigned int) built_in_predicates::INVERSE>::value.reference_count++;
	hol_term::variables<0>::value.reference_count++;
	free(excluded_constants);

	bool result = require_predicate<INT_FAST8_MAX>(src, dst, predicate);
	free(*predicate); if (predicate->reference_count == 0) free(predicate);
	return result;
}

inline bool require_left_predicate_same(hol_term* src, hol_term*& dst)
{
	hol_term* predicate = hol_term::new_apply(
			&hol_term::constants<(unsigned int) built_in_predicates::SAME>::value,
			&hol_term::variables<0>::value);
	if (predicate == nullptr) return false;
	hol_term::constants<(unsigned int) built_in_predicates::SAME>::value.reference_count++;
	hol_term::variables<0>::value.reference_count++;

	bool result = require_predicate<0>(src, dst, predicate);
	free(*predicate); if (predicate->reference_count == 0) free(predicate);
	return result;
}

inline bool require_no_predicate_same(hol_term* src, hol_term*& dst)
{
	hol_term** excluded_constants = (hol_term**) malloc(sizeof(hol_term*) * (hol_non_head_constants<built_in_predicates>::count() + 1));
	if (excluded_constants == nullptr) {
		fprintf(stderr, "require_no_predicate_same ERROR: Out of memory.\n");
		return false;
	}
	for (unsigned int i = 0; i < hol_non_head_constants<built_in_predicates>::count(); i++)
		excluded_constants[i] = hol_non_head_constants<built_in_predicates>::get_terms()[i];
	excluded_constants[hol_non_head_constants<built_in_predicates>::count()] = &hol_term::constants<(unsigned int) built_in_predicates::SAME>::value;

	hol_term* predicate = hol_term::new_apply(
			hol_term::new_any(nullptr, excluded_constants, hol_non_head_constants<built_in_predicates>::count() + 1),
			&hol_term::variables<0>::value);
	if (predicate == nullptr) {
		free(excluded_constants);
		return false;
	}
	hol_non_head_constants<built_in_predicates>::increment_terms();
	hol_term::constants<(unsigned int) built_in_predicates::SAME>::value.reference_count++;
	hol_term::variables<0>::value.reference_count++;
	free(excluded_constants);

	bool result = require_predicate<INT_FAST8_MAX>(src, dst, predicate);
	free(*predicate); if (predicate->reference_count == 0) free(predicate);
	return result;
}

inline bool require_left_predicate_inverse(hol_term* src, hol_term*& dst)
{
	hol_term* predicate = hol_term::new_apply(
			hol_term::new_apply(
				&hol_term::constants<(unsigned int) built_in_predicates::INVERSE>::value,
				hol_term::new_any(nullptr, hol_non_head_constants<built_in_predicates>::get_terms(), hol_non_head_constants<built_in_predicates>::count())),
			&hol_term::variables<0>::value);
	if (predicate == nullptr) return false;
	hol_non_head_constants<built_in_predicates>::increment_terms();
	hol_term::constants<(unsigned int) built_in_predicates::INVERSE>::value.reference_count++;
	hol_term::variables<0>::value.reference_count++;

	bool result = require_predicate<0>(src, dst, predicate);
	free(*predicate); if (predicate->reference_count == 0) free(predicate);
	return result;
}

inline bool require_left_predicate_inverse_has(hol_term* src, hol_term*& dst)
{
	hol_term* predicate = hol_term::new_apply(
			hol_term::new_apply(
				&hol_term::constants<(unsigned int) built_in_predicates::INVERSE>::value,
				&hol_term::constants<(unsigned int) built_in_predicates::HAS>::value),
			&hol_term::variables<0>::value);
	if (predicate == nullptr) return false;
	hol_term::constants<(unsigned int) built_in_predicates::INVERSE>::value.reference_count++;
	hol_term::constants<(unsigned int) built_in_predicates::HAS>::value.reference_count++;
	hol_term::variables<0>::value.reference_count++;

	bool result = require_predicate<0>(src, dst, predicate);
	free(*predicate); if (predicate->reference_count == 0) free(predicate);
	return result;
}

inline bool require_left_predicate_exist(hol_term* src, hol_term*& dst)
{
	hol_term* predicate = hol_term::new_apply(
			&hol_term::constants<(unsigned int) built_in_predicates::EXIST>::value,
			&hol_term::variables<0>::value);
	if (predicate == nullptr) return false;
	hol_term::constants<(unsigned int) built_in_predicates::EXIST>::value.reference_count++;
	hol_term::variables<0>::value.reference_count++;

	bool result = require_predicate<0>(src, dst, predicate);
	free(*predicate); if (predicate->reference_count == 0) free(predicate);
	return result;
}

inline bool require_left_greatest(hol_term* src, hol_term*& dst)
{
	hol_term* predicate = hol_term::new_apply(
			hol_term::new_apply(
				&hol_term::constants<(unsigned int) built_in_predicates::GREATEST>::value,
				hol_term::new_any(nullptr, hol_non_head_constants<built_in_predicates>::get_terms(), hol_non_head_constants<built_in_predicates>::count())),
			&hol_term::variables<0>::value);
	if (predicate == nullptr) return false;
	hol_term::constants<(unsigned int) built_in_predicates::GREATEST>::value.reference_count++;
	hol_non_head_constants<built_in_predicates>::increment_terms();
	hol_term::variables<0>::value.reference_count++;

	bool result = require_predicate<0>(src, dst, predicate);
	free(*predicate); if (predicate->reference_count == 0) free(predicate);
	return result;
}

inline bool require_no_left_predicate_exist(hol_term* src, hol_term*& dst)
{
	hol_term* hol_exist = &HOL_EXIST;
	hol_term* predicate = hol_term::new_apply(
			hol_term::new_any(nullptr, &hol_exist, 1),
			&hol_term::variables<0>::value);
	if (predicate == nullptr) return false;
	hol_term::variables<0>::value.reference_count++;
	HOL_EXIST.reference_count++;

	bool result = require_predicate<0>(src, dst, predicate);
	free(*predicate); if (predicate->reference_count == 0) free(predicate);
	return result;
}

inline bool require_no_predicate_empty(hol_term* src, hol_term*& dst)
{
	hol_term* hol_empty = &HOL_EMPTY;
	hol_term* predicate = hol_term::new_apply(
			hol_term::new_any(nullptr, &hol_empty, 1),
			&hol_term::variables<0>::value);
	if (predicate == nullptr) return false;
	hol_term::variables<0>::value.reference_count++;
	HOL_EMPTY.reference_count++;

	bool result = require_predicate<INT_FAST8_MAX>(src, dst, predicate);
	free(*predicate); if (predicate->reference_count == 0) free(predicate);
	return result;
}

template<int_fast8_t PredicateIndex>
inline bool require_predicate_in_set(
		hol_term* src, hol_term*& dst,
		hol_term* predicate)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	array_map<unsigned int, hol_term*> predicates(4);

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	bool result = apply_head<true>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker, predicative_head_finder<built_in_predicates>(lambda_variable),
			[predicate, &predicates, &max_variable](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				hol_term* old_head = head;
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr
				 && (head->any.included->type == hol_term_type::NOT || head->any.included->type == hol_term_type::EXISTS))
					head = head->any.included;

				bool negated = false;
				if (head->type == hol_term_type::NOT) {
					head = head->unary.operand;
					negated = true;
				}

				unsigned int set_variable, element_variable = 0;
				hol_term* left = nullptr;
				hol_term* set_definition = nullptr;
				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT)
				{
					set_variable = ++max_variable;
					element_variable = ++max_variable;
				} else {
#if !defined(NDEBUG)
					if (head->type != hol_term_type::EXISTS)
						fprintf(stderr, "require_predicate_in_set WARNING: Expected an existential quantification.\n");
#endif
					set_variable = head->quantifier.variable;
					hol_term* operand = head->quantifier.operand;

					hol_term* right = nullptr;
					if (operand->type == hol_term_type::ANY || operand->type == hol_term_type::ANY_RIGHT) {
						element_variable = ++max_variable;
					} else if (operand->type == hol_term_type::AND && operand->array.length != 0) {
						left = operand->array.operands[0];
						right = operand->array.operands[operand->array.length - 1];
					} else if (operand->type == hol_term_type::ANY_ARRAY) {
						if (operand->any_array.left.length != 0)
							left = operand->any_array.left.operands[0];
						else left = operand->any_array.all;
						if (operand->any_array.right.length != 0)
							right = operand->any_array.right.operands[operand->any_array.right.length - 1];
						else right = operand->any_array.all;
					} else {
						return (hol_term*) nullptr;
					}

					if (left != nullptr) {
						if (left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT) {
							if (left->any.included != nullptr)
								set_definition = left->any.included;
						} else if (left->type == hol_term_type::EQUALS) {
							set_definition = left->binary.right;
						} else if (left->type == hol_term_type::BINARY_APPLICATION) {
							set_definition = left->ternary.third;
						} else {
							return (hol_term*) nullptr;
						}
					}

					if (set_definition != nullptr) {
						if (set_definition->type == hol_term_type::ANY || set_definition->type == hol_term_type::ANY_RIGHT) {
							/* no-op */
						} else if (set_definition->type == hol_term_type::LAMBDA) {
							element_variable = set_definition->quantifier.variable;
						} else {
							return (hol_term*) nullptr;
						}
					}

					if (element_variable == 0 && right != nullptr) {
						/* try to get the element variable from the right conjunct, since we couldn't get it from the left conjunct */
						if ((right->type == hol_term_type::ANY || right->type == hol_term_type::ANY_RIGHT) && right->any.included != nullptr)
							right = right->any.included;
						if (right->type == hol_term_type::UNARY_APPLICATION && right->binary.left->type == hol_term_type::CONSTANT && right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE)
							right = right->binary.right;
						if (right->type == hol_term_type::ANY || right->type == hol_term_type::ANY_RIGHT) {
							element_variable = ++max_variable;
						} else if (right->type == hol_term_type::EXISTS || right->type == hol_term_type::FOR_ALL) {
							element_variable = right->quantifier.variable;
						} else if (right->type == hol_term_type::AND && right->array.length == 2 && right->array.operands[1]->type == hol_term_type::UNARY_APPLICATION
								&& right->array.operands[1]->binary.left->type == hol_term_type::VARIABLE && right->array.operands[1]->binary.left->variable == set_variable
								&& right->array.operands[1]->binary.right->type == hol_term_type::VARIABLE)
						{
							element_variable = right->array.operands[1]->binary.right->variable;
						} else {
							return (hol_term*) nullptr;
						}
					}
				}

				if (!predicates.ensure_capacity(predicates.size + 1))
					return (hol_term*) nullptr;
				hol_term* current_predicate;
				unsigned int index = predicates.index_of(element_variable);
				if (index == predicates.size) {
					array_map<unsigned int, unsigned int> variable_map(1);
					variable_map.put(0, element_variable);
					predicates.keys[index] = element_variable;
					predicates.values[index] = map_variables(predicate, variable_map);
					if (predicates.values[index] == nullptr)
						return (hol_term*) nullptr;
					predicates.size++;
				}
				current_predicate = predicates.values[index];

				hol_term* inner_set_definition = nullptr;
				if (set_definition != nullptr && set_definition->type == hol_term_type::LAMBDA)
					inner_set_definition = set_definition->quantifier.operand;

				/* get index of the predicate in `inner_set_definition` */
				head_index expected_predicate_index;
				if (PredicateIndex == INT_FAST8_MAX)
					expected_predicate_index = {head_position::ANY, 0};
				else if (PredicateIndex >= 0)
					expected_predicate_index = {head_position::LEFT, (unsigned int) PredicateIndex};
				else expected_predicate_index = {head_position::RIGHT, (unsigned int) -(PredicateIndex + 1)};
				if (inner_set_definition != nullptr && inner_set_definition->type != hol_term_type::ANY && inner_set_definition->type != hol_term_type::ANY_RIGHT) {
					head_index predicate_index;
					find_predicate<built_in_predicates>(element_variable, inner_set_definition, predicate_index);
					if (inner_set_definition != nullptr && inner_set_definition->type == hol_term_type::AND) {
						if (predicate_index.position == head_position::NONE)
							return (hol_term*) nullptr;
						if (PredicateIndex < 0 && predicate_index.index != inner_set_definition->array.length + PredicateIndex)
							return (hol_term*) nullptr;
						if (PredicateIndex >= 0 && PredicateIndex != INT_FAST8_MAX && predicate_index.index != (unsigned int) PredicateIndex)
							return (hol_term*) nullptr;
					} else if (inner_set_definition != nullptr && inner_set_definition->type == hol_term_type::ANY_ARRAY) {
						if (predicate_index.position != head_position::NONE && PredicateIndex != INT_FAST8_MAX
						 && (predicate_index.position != expected_predicate_index.position || predicate_index.index != expected_predicate_index.index))
							return (hol_term*) nullptr;
					} else if (inner_set_definition != nullptr && inner_set_definition->type != hol_term_type::ANY_ARRAY) {
						if (predicate_index.position == head_position::NONE || (PredicateIndex != -1 && PredicateIndex != 0 && PredicateIndex != INT_FAST8_MAX))
							return (hol_term*) nullptr;
					}
				}

				hol_term* head_var = hol_term::new_variable(head_variable);
				if (head_var == nullptr) return (hol_term*) nullptr;
				constexpr unsigned int excluded_tree_count = 3;
				hol_term** excluded_trees = (hol_term**) alloca(sizeof(hol_term) * (excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()));
				excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
							(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
							(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
						&HOL_ANY), head_var));
				excluded_trees[1] = hol_term::new_any(hol_term::new_exists(head_variable, &HOL_ANY));
				excluded_trees[2] = hol_term::new_any(hol_term::new_lambda(element_variable, &HOL_ANY));
				if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
				if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
				if (excluded_trees[2] != nullptr) { HOL_ANY.reference_count++; }
				if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr || excluded_trees[2] == nullptr) {
					if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
					if (excluded_trees[1] != nullptr) { free(*excluded_trees[1]); free(excluded_trees[1]); }
					free(*head_var); free(head_var);
					return (hol_term*) nullptr;
				}
				free(*head_var);

				for (unsigned int i = 0; i < hol_non_head_constants<built_in_predicates>::count(); i++) {
					excluded_trees[excluded_tree_count + i] = hol_non_head_constants<built_in_predicates>::get_terms()[i];
					excluded_trees[excluded_tree_count + i]->reference_count++;
				}

				hol_term* conjunct = hol_term::new_any(nullptr, excluded_trees, excluded_tree_count);
				if (conjunct == nullptr) {
					for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
						free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
					}
					return (hol_term*) nullptr;
				}

				hol_term* conjunction;
				if (!new_hol_term(conjunction)) return (hol_term*) nullptr;
				conjunction->type = hol_term_type::ANY_ARRAY;
				conjunction->reference_count = 1;
				conjunction->any_array.oper = hol_term_type::AND;
				conjunction->any_array.all = conjunct;
				if (expected_predicate_index.position == head_position::LEFT) {
					conjunction->any_array.left.length = expected_predicate_index.index + 1;
					conjunction->any_array.left.operands = (hol_term**) malloc(sizeof(hol_term*) * (expected_predicate_index.index + 1));
					if (conjunction->any_array.left.operands == nullptr) {
						free(conjunction); free(*conjunct); free(conjunct);
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < expected_predicate_index.index; i++)
						conjunction->any_array.left.operands[i] = conjunct;
					conjunction->any_array.left.operands[expected_predicate_index.index] = current_predicate;
					conjunction->any_array.right.length = 0;
					conjunction->any_array.right.operands = nullptr;
					conjunction->any_array.any.length = 0;
					conjunction->any_array.any.operands = nullptr;
					conjunct->reference_count += 1 + expected_predicate_index.index;
				} else if (expected_predicate_index.position == head_position::RIGHT) {
					conjunction->any_array.right.length = expected_predicate_index.index + 1;
					conjunction->any_array.right.operands = (hol_term**) malloc(sizeof(hol_term*) * (expected_predicate_index.index + 1));
					if (conjunction->any_array.right.operands == nullptr) {
						free(conjunction); free(*conjunct); free(conjunct);
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 1; i < expected_predicate_index.index + 1; i++)
						conjunction->any_array.right.operands[i] = conjunct;
					conjunction->any_array.right.operands[0] = current_predicate;
					conjunction->any_array.left.length = 0;
					conjunction->any_array.left.operands = nullptr;
					conjunction->any_array.any.length = 0;
					conjunction->any_array.any.operands = nullptr;
					conjunct->reference_count += 1 + expected_predicate_index.index;
				} else {
					conjunction->any_array.left.length = 0;
					conjunction->any_array.left.operands = nullptr;
					conjunction->any_array.right.length = 0;
					conjunction->any_array.right.operands = nullptr;
					conjunction->any_array.any.length = expected_predicate_index.index + 1;
					conjunction->any_array.any.operands = (hol_term**) malloc(sizeof(hol_term*) * (expected_predicate_index.index + 1));
					if (conjunction->any_array.any.operands == nullptr) {
						free(conjunction); free(*conjunct); free(conjunct);
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < expected_predicate_index.index; i++)
						conjunction->any_array.any.operands[i] = conjunct;
					conjunction->any_array.any.operands[expected_predicate_index.index] = current_predicate;
					conjunct->reference_count += 1 + expected_predicate_index.index;
				}
				free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
				current_predicate->reference_count++;

				hol_term* new_set_definition;
				if (inner_set_definition == nullptr) {
					new_set_definition = conjunction;
				} else {
					array<hol_term*> intersection(2);
					intersect<built_in_predicates>(intersection, conjunction, inner_set_definition);
					free(*conjunction); free(conjunction);
					if (intersection.length > 1) {
						fprintf(stderr, "require_predicate_in_set ERROR: Expected intersection size to be 1.\n");
						for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
						return (hol_term*) nullptr;
					} else if (intersection.length == 0) {
						return (hol_term*) nullptr;
					}
					new_set_definition = intersection[0];
					if (new_set_definition == inner_set_definition) {
						free_all(intersection);
						old_head->reference_count++;
						return old_head;
					}
				}

				hol_term* new_left;
				if (left == nullptr || left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT) {
					new_left = hol_term::new_any_right(hol_term::new_lambda(element_variable, new_set_definition));
					if (new_left == nullptr) {
						free(*new_set_definition); if (new_set_definition->reference_count == 0) free(new_set_definition);
						return (hol_term*) nullptr;
					}
				} else if (left->type == hol_term_type::EQUALS) {
					new_left = hol_term::new_equals(left->binary.left, hol_term::new_lambda(element_variable, new_set_definition));
					if (new_left == nullptr) {
						free(*new_set_definition); if (new_set_definition->reference_count == 0) free(new_set_definition);
						return (hol_term*) nullptr;
					}
					left->binary.left->reference_count++;
				} else {
					new_left = hol_term::new_apply(left->ternary.first, left->ternary.second, hol_term::new_lambda(element_variable, new_set_definition));
					if (new_left == nullptr) {
						free(*new_set_definition); if (new_set_definition->reference_count == 0) free(new_set_definition);
						return (hol_term*) nullptr;
					}
					left->ternary.first->reference_count++;
					left->ternary.second->reference_count++;
				}

				hol_term* excluded_quantifiers[3];
				excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(set_variable, &HOL_ANY));
				excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(set_variable, &HOL_ANY));
				excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(set_variable, &HOL_ANY));
				if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
				if (excluded_quantifiers[1] != nullptr) HOL_ANY.reference_count++;
				if (excluded_quantifiers[2] != nullptr) HOL_ANY.reference_count++;
				if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr) {
					if (excluded_quantifiers[0] != nullptr) { free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]); }
					if (excluded_quantifiers[1] != nullptr) { free(*excluded_quantifiers[1]); free(excluded_quantifiers[1]); }
					free(*new_left); free(new_left); return (hol_term*) nullptr;
				}

				conjunct = hol_term::new_any(nullptr, excluded_quantifiers, array_length(excluded_quantifiers));
				if (conjunct == nullptr) {
					for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
					free(*new_left); free(new_left); return (hol_term*) nullptr;
				}

				hol_term* new_head = hol_term::new_exists(head->quantifier.variable, hol_term::new_any_array(hol_term_type::AND, conjunct,
						make_array_view((hol_term**) nullptr, 0), make_array_view(&new_left, 1), make_array_view((hol_term**) nullptr, 0)));
				if (new_head == nullptr) {
					free(*conjunct); free(conjunct);
					free(*new_left); free(new_left);
					return (hol_term*) nullptr;
				}

				array<hol_term*> intersection(2);
				intersect<built_in_predicates>(intersection, new_head, head);
				free(*new_head); if (new_head->reference_count == 0) free(new_head);
				if (intersection.length > 1) {
					fprintf(stderr, "require_predicate_in_set ERROR: Expected intersection size to be 1.\n");
					for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
					return (hol_term*) nullptr;
				} else if (intersection.length == 0) {
					return (hol_term*) nullptr;
				}
				hol_term* dst = intersection[0];

				if (negated) {
					hol_term* new_dst = hol_term::new_not(dst);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					dst = new_dst;
				}

				if (old_head->type == hol_term_type::ANY || old_head->type == hol_term_type::ANY_RIGHT) {
					hol_term* new_dst = hol_term::new_any_right(dst, old_head->any.excluded_trees, old_head->any.excluded_tree_count);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < old_head->any.excluded_tree_count; i++)
						old_head->any.excluded_trees[i]->reference_count++;
					dst = new_dst;
				}
				return dst;
			}, no_op()) && dst != nullptr;
	for (auto entry : predicates) {
		free(*entry.value); if (entry.value->reference_count == 0) free(entry.value);
	}
	return result;
}

template<int_fast8_t ConjunctIndex>
inline bool require_predicate_in_set(hol_term* src, hol_term*& dst)
{
	constexpr unsigned int excluded_tree_count = 2;
	hol_term** excluded_trees = (hol_term**) alloca(sizeof(hol_term) * (excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()));
	excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
				(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
				(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
			&HOL_ANY), &hol_term::variables<0>::value));
	excluded_trees[1] = hol_term::new_any(hol_term::new_lambda(0, &HOL_ANY));
	if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; hol_term::variables<0>::value.reference_count++; }
	if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
	if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr) {
		if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
		return false;
	}

	for (unsigned int i = 0; i < hol_non_head_constants<built_in_predicates>::count(); i++) {
		excluded_trees[excluded_tree_count + i] = hol_non_head_constants<built_in_predicates>::get_terms()[i];
		excluded_trees[excluded_tree_count + i]->reference_count++;
	}

	hol_term* expected_predicate = hol_term::new_apply(
				hol_term::new_any(nullptr, excluded_trees, excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()),
				&hol_term::variables<0>::value);
	if (expected_predicate == nullptr) {
		for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
			free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
		}
		return false;
	}
	hol_term::variables<0>::value.reference_count++;

	bool result = require_predicate_in_set<ConjunctIndex>(src, dst, expected_predicate);
	free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
	return result;
}

template<unsigned int Predicate>
inline bool remove_higher_order_predicate(
		hol_term* src, hol_term*& dst)
{
	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<true>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker, find_head<built_in_predicates>,
			[](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				hol_term* old_head = head;
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr
				 && (head->any.included->type == hol_term_type::NOT || head->any.included->type == hol_term_type::EXISTS))
					head = head->any.included;

				bool negated = false;
				if (head->type == hol_term_type::NOT) {
					head = head->unary.operand;
					negated = true;
				}

				hol_term* dst;
				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT
				 || (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY)
				 || (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY_RIGHT))
				{
					dst = head;
					dst->reference_count++;
				} else if (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY_ARRAY) {
					hol_term* operand = head->quantifier.operand;

					hol_term* predicate;
					if (predicate_index.position == head_position::LEFT) {
						predicate = operand->any_array.left.operands[predicate_index.index];
					} else if (predicate_index.position == head_position::RIGHT) {
						predicate = operand->any_array.right.operands[operand->any_array.right.length - predicate_index.index - 1];
					} else {
						predicate = operand->any_array.any.operands[predicate_index.index];
					}

					hol_term* expected_predicate = hol_term::new_apply(
							hol_term::new_apply(
								hol_term::new_constant(Predicate),
								&HOL_ANY),
							hol_term::new_variable(head_variable));
					if (expected_predicate == nullptr) return (hol_term*) nullptr;
					HOL_ANY.reference_count++;

					if (!has_intersection<built_in_predicates>(expected_predicate, predicate)) {
						free(*expected_predicate); free(expected_predicate);
						return (hol_term*) nullptr;
					}
					free(*expected_predicate); free(expected_predicate);

					hol_term* new_predicate = nullptr;
					if (predicate->type == hol_term_type::UNARY_APPLICATION) {
						if (predicate->binary.left->type == hol_term_type::UNARY_APPLICATION) {
							new_predicate = hol_term::new_apply(predicate->binary.left->binary.right, predicate->binary.right);
							if (new_predicate == nullptr) return (hol_term*) nullptr;
							new_predicate->binary.left->reference_count++;
							new_predicate->binary.right->reference_count++;
						} else if (predicate->binary.left->type == hol_term_type::ANY) {
							/* remove excluded trees that are constants */
							array<hol_term*> new_excluded(max(1, predicate->binary.left->any.excluded_tree_count));
							for (unsigned int i = 0; i < predicate->binary.left->any.excluded_tree_count; i++) {
								if (predicate->binary.left->any.excluded_trees[i]->type == hol_term_type::CONSTANT
								 || predicate->binary.left->any.excluded_trees[i]->type == hol_term_type::ANY_CONSTANT
								 || predicate->binary.left->any.excluded_trees[i]->type == hol_term_type::ANY_CONSTANT_EXCEPT)
									continue;
								new_excluded[new_excluded.length++] = predicate->binary.left->any.excluded_trees[i];
							}
							if (new_excluded.length == predicate->binary.left->any.excluded_tree_count) {
								new_predicate = predicate;
								new_predicate->reference_count++;
							} else {
								new_predicate = hol_term::new_apply(hol_term::new_any(predicate->binary.left->any.included, new_excluded.data, new_excluded.length), predicate->binary.right);
								if (new_predicate == nullptr) return (hol_term*) nullptr;
								if (predicate->binary.left->any.included != nullptr)
									predicate->binary.left->any.included->reference_count++;
								for (hol_term* tree : new_excluded)
									tree->reference_count++;
								predicate->binary.right->reference_count++;
							}
						}
					} else if (predicate->type == hol_term_type::ANY) {
						new_predicate = predicate;
						new_predicate->reference_count++;
					}

					hol_term* conjunction;
					if (!new_hol_term(conjunction)) {
						free(*new_predicate); if (new_predicate->reference_count == 0) free(new_predicate);
						return (hol_term*) nullptr;
					}
					conjunction->type = hol_term_type::ANY_ARRAY;
					conjunction->reference_count = 1;
					conjunction->any_array.oper = hol_term_type::AND;
					conjunction->any_array.all = operand->any_array.all;
					conjunction->any_array.all->reference_count++;
					conjunction->any_array.left.length = 0;
					conjunction->any_array.left.operands = nullptr;
					conjunction->any_array.right.length = 0;
					conjunction->any_array.right.operands = nullptr;
					conjunction->any_array.any.length = 0;
					conjunction->any_array.any.operands = nullptr;

					conjunction->any_array.left.length = operand->any_array.left.length;
					if (conjunction->any_array.left.length == 0) {
						conjunction->any_array.left.operands = nullptr;
					} else {
						conjunction->any_array.left.operands = (hol_term**) malloc(sizeof(hol_term*) * conjunction->any_array.left.length);
						if (conjunction->any_array.left.operands == nullptr) {
							free(*conjunction); free(conjunction);
							free(*new_predicate); if (new_predicate->reference_count == 0) free(new_predicate);
							return (hol_term*) nullptr;
						}
						for (unsigned int i = 0; i < conjunction->any_array.left.length; i++) {
							if (predicate_index.position == head_position::LEFT && predicate_index.index == i) {
								conjunction->any_array.left.operands[i] = new_predicate;
							} else {
								conjunction->any_array.left.operands[i] = operand->any_array.left.operands[i];
							}
							conjunction->any_array.left.operands[i]->reference_count++;
						}
					}
					conjunction->any_array.right.length = operand->any_array.right.length;
					if (conjunction->any_array.right.length == 0) {
						conjunction->any_array.right.operands = nullptr;
					} else {
						conjunction->any_array.right.operands = (hol_term**) malloc(sizeof(hol_term*) * conjunction->any_array.right.length);
						if (conjunction->any_array.right.operands == nullptr) {
							free(*conjunction); free(conjunction);
							free(*new_predicate); if (new_predicate->reference_count == 0) free(new_predicate);
							return (hol_term*) nullptr;
						}
						for (unsigned int i = 0; i < conjunction->any_array.right.length; i++) {
							if (predicate_index.position == head_position::RIGHT && predicate_index.index == conjunction->any_array.right.length - i - 1) {
								conjunction->any_array.right.operands[i] = new_predicate;
							} else {
								conjunction->any_array.right.operands[i] = operand->any_array.right.operands[i];
							}
							conjunction->any_array.right.operands[i]->reference_count++;
						}
					}
					conjunction->any_array.any.length = operand->any_array.any.length;
					if (conjunction->any_array.any.length == 0) {
						conjunction->any_array.any.operands = nullptr;
					} else {
						conjunction->any_array.any.operands = (hol_term**) malloc(sizeof(hol_term*) * conjunction->any_array.any.length);
						if (conjunction->any_array.any.operands == nullptr) {
							free(*conjunction); free(conjunction);
							free(*new_predicate); if (new_predicate->reference_count == 0) free(new_predicate);
							return (hol_term*) nullptr;
						}
						for (unsigned int i = 0; i < conjunction->any_array.any.length; i++) {
							if (predicate_index.position == head_position::ANY && predicate_index.index == i) {
								conjunction->any_array.any.operands[i] = new_predicate;
							} else {
								conjunction->any_array.any.operands[i] = operand->any_array.any.operands[i];
							}
							conjunction->any_array.any.operands[i]->reference_count++;
						}
					}
					free(*new_predicate); if (new_predicate->reference_count == 0) free(new_predicate);

					dst = hol_term::new_exists(head_variable, conjunction);
					if (dst == nullptr) {
						free(*conjunction); free(conjunction);
						return (hol_term*) nullptr;
					}

				} else if (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::AND) {
					hol_term* expected_predicate = hol_term::new_apply(
							hol_term::new_apply(
								hol_term::new_constant(Predicate),
								&HOL_ANY),
							hol_term::new_variable(head_variable));
					if (expected_predicate == nullptr) return (hol_term*) nullptr;
					HOL_ANY.reference_count++;

					hol_term* operand = head->quantifier.operand;
					hol_term* predicate = operand->array.operands[predicate_index.index];
					if (!has_intersection<built_in_predicates>(expected_predicate, predicate)) {
						free(*expected_predicate); free(expected_predicate);
						return (hol_term*) nullptr;
					}
					free(*expected_predicate); free(expected_predicate);

					hol_term* new_predicate = nullptr;
					if (predicate->type == hol_term_type::UNARY_APPLICATION) {
						if (predicate->binary.left->type == hol_term_type::UNARY_APPLICATION) {
							new_predicate = hol_term::new_apply(predicate->binary.left->binary.right, predicate->binary.right);
							if (new_predicate == nullptr) return (hol_term*) nullptr;
							new_predicate->binary.left->reference_count++;
							new_predicate->binary.right->reference_count++;
						} else if (predicate->binary.left->type == hol_term_type::ANY) {
							/* remove excluded trees that are constants */
							array<hol_term*> new_excluded(max(1, predicate->binary.left->any.excluded_tree_count));
							for (unsigned int i = 0; i < predicate->binary.left->any.excluded_tree_count; i++) {
								if (predicate->binary.left->any.excluded_trees[i]->type == hol_term_type::CONSTANT
								 || predicate->binary.left->any.excluded_trees[i]->type == hol_term_type::ANY_CONSTANT
								 || predicate->binary.left->any.excluded_trees[i]->type == hol_term_type::ANY_CONSTANT_EXCEPT)
									continue;
								new_excluded[new_excluded.length++] = predicate->binary.left->any.excluded_trees[i];
							}
							if (new_excluded.length == predicate->binary.left->any.excluded_tree_count) {
								new_predicate = predicate;
								new_predicate->reference_count++;
							} else {
								new_predicate = hol_term::new_apply(hol_term::new_any(predicate->binary.left->any.included, new_excluded.data, new_excluded.length), predicate->binary.right);
								if (new_predicate == nullptr) return (hol_term*) nullptr;
								if (predicate->binary.left->any.included != nullptr)
									predicate->binary.left->any.included->reference_count++;
								for (hol_term* tree : new_excluded)
									tree->reference_count++;
								predicate->binary.right->reference_count++;
							}
						}
					} else if (predicate->type == hol_term_type::ANY) {
						new_predicate = predicate;
						new_predicate->reference_count++;
					}

					hol_term* conjunction;
					if (!new_hol_term(conjunction)) {
						free(*new_predicate); if (new_predicate->reference_count == 0) free(new_predicate);
						return (hol_term*) nullptr;
					}
					conjunction->type = hol_term_type::AND;
					conjunction->reference_count = 1;
					conjunction->array.length = operand->array.length;
					conjunction->array.operands = (hol_term**) malloc(sizeof(hol_term*) * operand->array.length);
					if (conjunction->array.operands == nullptr) {
						fprintf(stderr, "remove_higher_order_predicate ERROR: Out of memory.\n");
						free(*new_predicate); if (new_predicate->reference_count == 0) free(new_predicate);
						free(conjunction); return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < operand->array.length; i++) {
						if (i == predicate_index.index) {
							conjunction->array.operands[i] = new_predicate;
						} else {
							conjunction->array.operands[i] = operand->array.operands[i];
							conjunction->array.operands[i]->reference_count++;
						}
					}

					dst = hol_term::new_exists(head_variable, conjunction);
					if (dst == nullptr) {
						free(*conjunction); free(conjunction);
						return (hol_term*) nullptr;
					}

				} else if (head->type == hol_term_type::EXISTS) {
					if (predicate_index.position != head_position::LEFT || predicate_index.index != 0)
						return (hol_term*) nullptr;
					hol_term* expected_predicate = hol_term::new_apply(
							hol_term::new_apply(
								hol_term::new_constant(Predicate),
								&HOL_ANY),
							hol_term::new_variable(head_variable));
					if (expected_predicate == nullptr) return (hol_term*) nullptr;
					HOL_ANY.reference_count++;

					hol_term* predicate = head->quantifier.operand;
					if (!has_intersection<built_in_predicates>(expected_predicate, predicate)) {
						free(*expected_predicate); free(expected_predicate);
						return (hol_term*) nullptr;
					}
					free(*expected_predicate); free(expected_predicate);

					hol_term* new_predicate = nullptr;
					if (predicate->type == hol_term_type::UNARY_APPLICATION) {
						if (predicate->binary.left->type == hol_term_type::UNARY_APPLICATION) {
							new_predicate = hol_term::new_apply(predicate->binary.left->binary.right, predicate->binary.right);
							if (new_predicate == nullptr) return (hol_term*) nullptr;
							new_predicate->binary.left->reference_count++;
							new_predicate->binary.right->reference_count++;
						} else if (predicate->binary.left->type == hol_term_type::ANY) {
							new_predicate = predicate;
							new_predicate->reference_count++;
						}
					} else if (predicate->type == hol_term_type::ANY) {
						new_predicate = predicate;
						new_predicate->reference_count++;
					}

					dst = hol_term::new_exists(head_variable, new_predicate);
					if (dst == nullptr) {
						free(*new_predicate); free(new_predicate);
						return (hol_term*) nullptr;
					}

				} else {
					return (hol_term*) nullptr;
				}

				if (negated) {
					hol_term* new_dst = hol_term::new_not(dst);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					dst = new_dst;
				}

				if (old_head->type == hol_term_type::ANY || old_head->type == hol_term_type::ANY_RIGHT) {
					hol_term* new_dst = hol_term::new_any_right(dst);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					dst = new_dst;
				}
				return dst;
			}, no_op()) && dst != nullptr;
}

inline bool remove_inverse(
		hol_term* src, hol_term*& dst)
{
	return remove_higher_order_predicate<(unsigned int) built_in_predicates::INVERSE>(src, dst);
}

inline bool remove_greatest(
		hol_term* src, hol_term*& dst)
{
	return remove_higher_order_predicate<(unsigned int) built_in_predicates::GREATEST>(src, dst);
}

template<int_fast8_t ConjunctIndex>
inline bool remove_constant(
		hol_term* src, hol_term*& dst, hol_term* constant)
{
	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<true>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker, find_head<built_in_predicates>,
			[constant](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				hol_term* old_head = head;
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && predicate_index.position != head_position::NONE)
					head = head->any.included;

				bool negated = false;
				if (head->type == hol_term_type::NOT) {
					head = head->unary.operand;
					negated = true;
				}

				hol_term* dst;
				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT
				 || (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY)
				 || (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY_RIGHT))
				{
					hol_term* head_var = hol_term::new_variable(head_variable);
					if (head_var == nullptr) return (hol_term*) nullptr;
					constexpr unsigned int excluded_tree_count = 2;
					hol_term** excluded_trees = (hol_term**) alloca(sizeof(hol_term) * (excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()));
					excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
								(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
								(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
							&HOL_ANY), head_var));
					excluded_trees[1] = hol_term::new_any(hol_term::new_exists(head_variable, &HOL_ANY));
					if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
					if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
					if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr) {
						if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
						free(*head_var); free(head_var);
						return (hol_term*) nullptr;
					}
					free(*head_var);

					for (unsigned int i = 0; i < hol_non_head_constants<built_in_predicates>::count(); i++) {
						excluded_trees[excluded_tree_count + i] = hol_non_head_constants<built_in_predicates>::get_terms()[i];
						excluded_trees[excluded_tree_count + i]->reference_count++;
					}

					hol_term* expected_predicate = hol_term::new_apply(
								hol_term::new_any(nullptr, excluded_trees, excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()), head_var);
					if (expected_predicate == nullptr) {
						for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
							free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
						}
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++)
						excluded_trees[i]->reference_count++;
					head_var->reference_count++;

					dst = hol_term::new_exists(head_variable, hol_term::new_any_array(hol_term_type::AND,
							hol_term::new_any(nullptr, excluded_trees, excluded_tree_count), make_array_view(&expected_predicate, 1),
							make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0)));
					if (dst == nullptr) {
						free(*expected_predicate); free(expected_predicate);
						for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
							free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
						}
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < excluded_tree_count; i++)
						excluded_trees[i]->reference_count++;
					for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
						free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
					}

					array<hol_term*> intersection(2);
					intersect<built_in_predicates>(intersection, dst, head);
					if (intersection.length > 1) {
						fprintf(stderr, "remove_constant WARNING: Expected intersection size to be 1.\n");
						for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					free(*dst); if (dst->reference_count == 0) free(dst);
					if (intersection.length == 0)
						return (hol_term*) nullptr;
					dst = intersection[0];
				} else if (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY_ARRAY) {
					hol_term* operand = head->quantifier.operand;

					hol_term* conjunction = nullptr;
					if (ConjunctIndex >= 0) {
						if (ConjunctIndex < operand->any_array.left.length) {
							if (!has_intersection<built_in_predicates>(operand->any_array.left.operands[ConjunctIndex], constant))
								return (hol_term*) nullptr;
							conjunction = hol_term::new_any_array(hol_term_type::AND, operand->any_array.all,
									make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
									make_excluded_array_view(operand->any_array.left.operands, operand->any_array.left.length, ConjunctIndex),
									make_array_view(operand->any_array.right.operands, operand->any_array.right.length));
							if (conjunction == nullptr)
								return (hol_term*) nullptr;
							conjunction->any_array.all->reference_count++;
							for (unsigned int i = 0; i < conjunction->any_array.any.length; i++)
								conjunction->any_array.any.operands[i]->reference_count++;
							for (unsigned int i = 0; i < conjunction->any_array.left.length; i++)
								conjunction->any_array.left.operands[i]->reference_count++;
							for (unsigned int i = 0; i < conjunction->any_array.right.length; i++)
								conjunction->any_array.right.operands[i]->reference_count++;
						} else {
							if (!has_intersection<built_in_predicates>(operand->any_array.all, constant))
								return (hol_term*) nullptr;
							conjunction = operand;
							operand->reference_count++;
						}
					} else if (ConjunctIndex < 0) {
						if (-ConjunctIndex - 1 < operand->any_array.right.length) {
							unsigned int index = operand->any_array.right.length + ConjunctIndex;
							if (!has_intersection<built_in_predicates>(operand->any_array.right.operands[index], constant))
								return (hol_term*) nullptr;
							conjunction = hol_term::new_any_array(hol_term_type::AND, operand->any_array.all,
									make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
									make_array_view(operand->any_array.left.operands, operand->any_array.left.length),
									make_excluded_array_view(operand->any_array.right.operands, operand->any_array.right.length, index));
							if (conjunction == nullptr)
								return (hol_term*) nullptr;
							conjunction->any_array.all->reference_count++;
							for (unsigned int i = 0; i < conjunction->any_array.any.length; i++)
								conjunction->any_array.any.operands[i]->reference_count++;
							for (unsigned int i = 0; i < conjunction->any_array.left.length; i++)
								conjunction->any_array.left.operands[i]->reference_count++;
							for (unsigned int i = 0; i < conjunction->any_array.right.length; i++)
								conjunction->any_array.right.operands[i]->reference_count++;
						} else {
							if (!has_intersection<built_in_predicates>(operand->any_array.all, constant))
								return (hol_term*) nullptr;
							conjunction = operand;
							operand->reference_count++;
						}
					}

					dst = hol_term::new_exists(head_variable, conjunction);
					if (dst == nullptr) {
						free(*conjunction); if (conjunction->reference_count == 0) free(conjunction);
						return (hol_term*) nullptr;
					}
				} else if (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::AND) {
					hol_term* operand = head->quantifier.operand;
					unsigned int conjunct_index = (ConjunctIndex < 0) ? (operand->array.length + ConjunctIndex) : ConjunctIndex;
					if (!has_intersection<built_in_predicates>(operand->array.operands[conjunct_index], constant))
						return (hol_term*) nullptr;
					if (operand->array.length == 2) {
						dst = hol_term::new_exists(head_variable, (conjunct_index == 0 ? operand->array.operands[1] : operand->array.operands[0]));
					} else {
						dst = hol_term::new_exists(head_variable, hol_term::new_and(make_excluded_array_view(operand->array.operands, operand->array.length, conjunct_index)));
					}
					if (dst != nullptr) {
						for (unsigned int i = 0; i < operand->array.length; i++)
							if (i != conjunct_index) operand->array.operands[i]->reference_count++;
					}
				} else {
					return (hol_term*) nullptr;
				}

				if (negated) {
					hol_term* new_dst = hol_term::new_not(dst);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					dst = new_dst;
				}

				if (old_head->type == hol_term_type::ANY || old_head->type == hol_term_type::ANY_RIGHT)
				{
					array<unsigned int> dst_variables(8);
					get_free_variables(*dst, dst_variables);
					if (dst_variables.length > 1) insertion_sort(dst_variables);
					if (!prune_independent_siblings(dst_variables, siblings)) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}

					array<hol_term*> excluded_trees(max(1u, old_head->any.excluded_tree_count));
					for (unsigned int i = 0; i < old_head->any.excluded_tree_count; i++) {
						hol_term* excluded_tree = old_head->any.excluded_trees[i];
						if (excluded_tree->type != hol_term_type::ANY || excluded_tree->any.included == nullptr
						 || !(excluded_tree->any.included->type == hol_term_type::EXISTS || excluded_tree->any.included->type == hol_term_type::FOR_ALL || excluded_tree->any.included->type == hol_term_type::LAMBDA)
						 || dst_variables.contains(excluded_tree->any.included->quantifier.variable))
						{
							excluded_trees[excluded_trees.length++] = excluded_tree;
						}
					}

					hol_term* new_dst = hol_term::new_any_right(dst, excluded_trees.data, excluded_trees.length);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < excluded_trees.length; i++)
						excluded_trees[i]->reference_count++;
					dst = new_dst;
				}
				return dst;
			}, no_op()) && dst != nullptr;
}

inline hol_term* make_selected_arg_without_head(
		unsigned int negation_count, unsigned int element_variable, unsigned int lambda_variable)
{
	hol_term* element_var = hol_term::new_variable(element_variable);
	if (element_var == nullptr)
		return nullptr;
	hol_term* lambda_var = hol_term::new_variable(lambda_variable);
	if (lambda_var == nullptr) {
		free(*element_var); free(element_var);
		return nullptr;
	}

	/* TODO: this set isn't really the same as the result of applying the function to `ANY` */
	hol_term* quantified_term = hol_term::new_any_right(hol_term::new_apply(lambda_var, element_var));
	if (quantified_term == nullptr) {
		free(*element_var); free(element_var);
		free(*lambda_var); free(lambda_var);
		return nullptr;
	}

	for (unsigned int i = 0; i < negation_count; i++) {
		hol_term* temp = hol_term::new_not(quantified_term);
		if (temp == nullptr) {
			free(*quantified_term); free(quantified_term);
			return nullptr;
		}
		quantified_term = temp;
	}

	return quantified_term;
}

struct scope_info {
	hol_term* scope;
	bool narrow_scope;
	unsigned int negations;
};

template<int_fast8_t ConjunctIndex, unsigned int ArgConstant, bool MustBeSetValued = false>
inline bool select_arg_without_head_predicative(
		hol_term* src, hol_term*& dst)
{
	unsigned int lambda_variable = 0;
	max_bound_variable(*src, lambda_variable);
	lambda_variable++;

	bool narrow_scope = false;
	unsigned int parent_negations = 0;
	hol_term* next_universal_scope = nullptr;
	hol_term* parent = nullptr;
	array_map<unsigned int, scope_info> scopes(8);
	auto gather_scope = [&parent_negations,&scopes,&narrow_scope,&next_universal_scope,&parent](hol_term* term) {
		if (term->type == hol_term_type::ANY || term->type == hol_term_type::ANY_RIGHT) {
			if (!scopes.ensure_capacity(scopes.size + 1))
				return false;
			scopes.keys[scopes.size] = 0;
			scopes.values[scopes.size++] = {term, narrow_scope, parent_negations};
		} else if (term->type == hol_term_type::FOR_ALL || term->type == hol_term_type::EXISTS || term->type == hol_term_type::LAMBDA) {
			if (!scopes.ensure_capacity(scopes.size + 1))
				return false;
			scopes.keys[scopes.size] = term->quantifier.variable;
			scopes.values[scopes.size++] = {term, narrow_scope, parent_negations};
		} else if (term->type == hol_term_type::UNARY_APPLICATION && term->binary.left->type == hol_term_type::CONSTANT && term->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
			narrow_scope = true;
			if (term->binary.right->type == hol_term_type::FOR_ALL)
				next_universal_scope = term->binary.right;
		}
		if (term->type == hol_term_type::NOT)
			parent_negations++;
		else parent_negations = 0;
		parent = term;
		return true;
	};

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	bool result = apply_head<false>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker, find_head<built_in_predicates>,
			[&scopes,lambda_variable,&narrow_scope,&next_universal_scope,&parent](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
					head = head->any.included;

				unsigned int negation_count = 0;
				while (head->type == hol_term_type::NOT) {
					head = head->unary.operand;
					negation_count++;
				}

				hol_term* dst = nullptr;
				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT
				 || (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY)
				 || (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY_RIGHT))
				{
					unsigned int element_variable = lambda_variable + 1;
					dst = make_selected_arg_without_head(negation_count, element_variable, lambda_variable);
					if (dst == nullptr) return (hol_term*) nullptr;
					remove_wide_scope_marker = true;
				} else if (head->type == hol_term_type::EXISTS) {
					hol_term* operand = head->quantifier.operand;

					hol_term* conjunct;
					hol_term* predicate = nullptr;
					if (operand->type == hol_term_type::ANY_ARRAY) {
						if (predicate_index.position == head_position::LEFT)
							predicate = operand->any_array.left.operands[predicate_index.index];
						else if (predicate_index.position == head_position::RIGHT)
							predicate = operand->any_array.right.operands[operand->any_array.right.length - predicate_index.index - 1];
						else if (predicate_index.position == head_position::ANY)
							predicate = operand->any_array.any.operands[predicate_index.index];
						if (ConjunctIndex >= 0) {
							if (ConjunctIndex < operand->any_array.left.length)
								conjunct = operand->any_array.left.operands[ConjunctIndex];
							else conjunct = operand->any_array.all;
						} else if (ConjunctIndex < 0) {
							unsigned int index = (unsigned int) (-ConjunctIndex) - 1;
							if (index < operand->any_array.right.length)
								conjunct = operand->any_array.right.operands[operand->any_array.right.length - index - 1];
							else conjunct = operand->any_array.all;
						}
					} else if (operand->type == hol_term_type::AND) {
						int conjunct_index = ConjunctIndex;
						if (ConjunctIndex < 0)
							conjunct_index += operand->array.length;
						conjunct = operand->array.operands[conjunct_index];
						if (predicate_index.position == head_position::LEFT)
							predicate = operand->array.operands[predicate_index.index];
					} else {
						return (hol_term*) nullptr;
					}

					if (predicate != nullptr && predicate->type == hol_term_type::UNARY_APPLICATION) {
						predicate = predicate->binary.left;
						if (predicate->type == hol_term_type::UNARY_APPLICATION && predicate->binary.left->type == hol_term_type::CONSTANT && predicate->binary.left->constant == (unsigned int) built_in_predicates::INVERSE)
							predicate = predicate->binary.right;
						if (predicate->type == hol_term_type::CONSTANT) {
							if ((ArgConstant == (unsigned int) built_in_predicates::ARG3 || ArgConstant == (unsigned int) built_in_predicates::ARG3_OF)
							 && (predicate->constant == (unsigned int) built_in_predicates::EXIST || predicate->constant == (unsigned int) built_in_predicates::SAME || predicate->constant == (unsigned int) built_in_predicates::NAME))
								return (hol_term*) nullptr;
							if ((ArgConstant == (unsigned int) built_in_predicates::ARG2 || ArgConstant == (unsigned int) built_in_predicates::ARG2_OF)
							 && (predicate->constant == (unsigned int) built_in_predicates::EXIST))
								return (hol_term*) nullptr;
						}
					}

					hol_term* expected_left_side = hol_term::new_apply(hol_term::new_constant(ArgConstant), hol_term::new_variable(head->quantifier.variable));
					if (expected_left_side == nullptr)
						return (hol_term*) nullptr;
					hol_term* expected_conjunct = hol_term::new_any_right(hol_term::new_equals(expected_left_side, &HOL_ANY));
					if (expected_left_side == nullptr) {
						free(*expected_left_side); free(expected_left_side);
						return (hol_term*) nullptr;
					}
					expected_left_side->reference_count++;
					HOL_ANY.reference_count++;
					if (!has_intersection<built_in_predicates>(expected_conjunct, conjunct)) {
						free(*expected_conjunct); free(expected_conjunct);
						free(*expected_left_side); free(expected_left_side);
						return (hol_term*) nullptr;
					}
					free(*expected_conjunct); free(expected_conjunct);

					if (conjunct->type == hol_term_type::ANY || conjunct->type == hol_term_type::ANY_RIGHT) {
						free(*expected_left_side); free(expected_left_side);
						unsigned int element_variable = lambda_variable + 1;
						dst = make_selected_arg_without_head(negation_count, element_variable, lambda_variable);
						if (dst == nullptr) return (hol_term*) nullptr;
						remove_wide_scope_marker = true;
					} else if (conjunct->type == hol_term_type::EQUALS) {
						if (!has_intersection<built_in_predicates>(expected_left_side, conjunct->binary.left)) {
							free(*expected_left_side); free(expected_left_side);
							return (hol_term*) nullptr;
						}
						free(*expected_left_side); free(expected_left_side);

						hol_term* arg = conjunct->binary.right;
						if (arg->type == hol_term_type::ANY) {
							unsigned int element_variable = lambda_variable + 1;
							dst = make_selected_arg_without_head(negation_count, element_variable, lambda_variable);
							if (dst == nullptr) return (hol_term*) nullptr;
							remove_wide_scope_marker = true;
						} else if (arg->type == hol_term_type::CONSTANT || arg->type == hol_term_type::ANY_CONSTANT || arg->type == hol_term_type::ANY_CONSTANT_EXCEPT
								|| arg->type == hol_term_type::STRING || arg->type == hol_term_type::NUMBER)
						{
							unsigned int set_variable = lambda_variable + 1;
							unsigned int element_variable = lambda_variable + 2;
							hol_term* element_var = hol_term::new_variable(element_variable);
							if (element_var == nullptr)
								return (hol_term*) nullptr;
							hol_term* set_var = hol_term::new_variable(set_variable);
							if (set_var == nullptr) {
								free(*element_var); free(element_var);
								return (hol_term*) nullptr;
							}
							hol_term* quantified_term = hol_term::new_exists(element_variable, hol_term::new_and(
									hol_term::new_apply(set_var, element_var),
									hol_term::new_apply(hol_term::new_variable(lambda_variable), element_var)
								));
							if (quantified_term == nullptr) {
								free(*element_var); free(element_var);
								free(*set_var); free(set_var);
								return (hol_term*) nullptr;
							}
							element_var->reference_count += 2 - 1;

							for (unsigned int i = 0; i < negation_count; i++) {
								hol_term* temp = hol_term::new_not(quantified_term);
								if (temp == nullptr) {
									free(*quantified_term); free(quantified_term);
									return (hol_term*) nullptr;
								}
								quantified_term = temp;
							}

							hol_term* set_definition = hol_term::new_equals(set_var, hol_term::new_lambda(element_variable, hol_term::new_equals(element_var, arg)));
							if (set_definition == nullptr) {
								free(*quantified_term); free(quantified_term);
								return (hol_term*) nullptr;
							}
							element_var->reference_count++;
							set_var->reference_count++;
							arg->reference_count++;
							dst = hol_term::new_exists(set_variable, hol_term::new_and(set_definition, quantified_term));
							if (dst == nullptr) {
								free(*set_definition); free(set_definition);
								free(*quantified_term); free(quantified_term);
								return (hol_term*) nullptr;
							}
						} else if (arg->type == hol_term_type::VARIABLE) {
							unsigned int element_variable = arg->variable;
							unsigned int index = scopes.index_of(element_variable);
							scope_info& scope = scopes.values[index];
							hol_term* operand = scope.scope->quantifier.operand;

							bool wide_scope_must_be_before_quantifier = false;
							bool wide_scope_must_be_after_quantifier = false;
							bool wide_scope_can_be_before_quantifier = false;
							if (narrow_scope && !scope.narrow_scope) {
								wide_scope_must_be_after_quantifier = true;
								wide_scope_can_be_before_quantifier = false;
							} else if (narrow_scope && scope.narrow_scope) {
								wide_scope_must_be_before_quantifier = true;
								wide_scope_can_be_before_quantifier = true;
							} else {
								wide_scope_can_be_before_quantifier = false;
								for (unsigned int i = 0; i < index; i++) {
									if (scopes.keys[i] == 0) {
										wide_scope_can_be_before_quantifier = true;
										break;
									}
								}
							}

							if (scope.scope->type == hol_term_type::FOR_ALL && operand->type == hol_term_type::IF_THEN) {
								if (MustBeSetValued) return (hol_term*) nullptr;

								/* check if the scope is a relativized quantification over a set */
								hol_term* antecedent = operand->binary.left;
								if (antecedent->type == hol_term_type::UNARY_APPLICATION && antecedent->binary.right->type == hol_term_type::VARIABLE
								 && antecedent->binary.right->variable == element_variable && antecedent->binary.left->type == hol_term_type::VARIABLE)
								{
									hol_term* new_head = hol_term::new_apply(hol_term::new_variable(lambda_variable), arg);
									if (new_head == nullptr)
										return (hol_term*) nullptr;
									arg->reference_count++;

									unsigned int index = scopes.index_of(antecedent->binary.left->variable);
									scope_info& set_scope = scopes.values[index];

									auto check_wide_scope = [&remove_wide_scope_marker](hol_term* term) {
										remove_wide_scope_marker |= (term->type == hol_term_type::UNARY_APPLICATION
											&& term->binary.left->type == hol_term_type::CONSTANT
											&& term->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE);
										return true;
									};
									array<hol_term*> child_siblings(8); array<unsigned int> dst_variables(8);
									bool removed_quantifier, dummy = false, remove_negations = false;
									bool result = apply_head<true>(set_scope.scope, dst, dst_variables, child_siblings, 0, removed_quantifier, remove_negations, dummy, node_finder(is_array ? parent : head),
									[new_head](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings) { return new_head; }, check_wide_scope);
									if (!result || dst == nullptr) {
										free(*new_head); free(new_head);
										return (hol_term*) nullptr;
									}
									for (hol_term* sibling : child_siblings) {
										unsigned int index = siblings.index_of(sibling);
										if (index < siblings.length) siblings.remove(index);
									}
								} else {
									unsigned int set_variable = lambda_variable + 1;
									hol_term* set_var = hol_term::new_variable(set_variable);
									if (set_var == nullptr)
										return (hol_term*) nullptr;
									hol_term* set_definition = hol_term::new_equals(set_var, hol_term::new_lambda(element_variable, antecedent));
									if (set_definition == nullptr) {
										free(*set_var); free(set_var);
										return (hol_term*) nullptr;
									}
									antecedent->reference_count++;
									hol_term* quantified_term;
									if (wide_scope_must_be_after_quantifier) {
										quantified_term = hol_term::new_for_all(element_variable, hol_term::new_if_then(
												hol_term::new_apply(set_var, arg),
												hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, hol_term::new_apply(hol_term::new_variable(lambda_variable), arg))));
										if (quantified_term == nullptr) {
											free(*set_definition); free(set_definition);
											return (hol_term*) nullptr;
										}
										set_var->reference_count++;
										hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
										arg->reference_count += 2;
										remove_wide_scope_marker = true;

										for (unsigned int i = 0; i < scope.negations; i++) {
											hol_term* temp = hol_term::new_not(quantified_term);
											if (temp == nullptr) {
												free(*set_definition); free(set_definition);
												free(*quantified_term); free(quantified_term);
												return (hol_term*) nullptr;
											}
											quantified_term = temp;
										}
									} else if (wide_scope_must_be_before_quantifier || !wide_scope_can_be_before_quantifier) {
										quantified_term = hol_term::new_for_all(element_variable, hol_term::new_if_then(
												hol_term::new_apply(set_var, arg),
												hol_term::new_apply(hol_term::new_variable(lambda_variable), arg)));
										if (quantified_term == nullptr) {
											free(*set_definition); free(set_definition);
											return (hol_term*) nullptr;
										}
										set_var->reference_count++;
										arg->reference_count += 2;

										if (scope.scope == next_universal_scope) {
											hol_term* temp = hol_term::new_apply(
													&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, quantified_term);
											remove_wide_scope_marker = true;
											if (temp == nullptr) {
												free(*set_definition); free(set_definition);
												free(*quantified_term); free(quantified_term);
												return (hol_term*) nullptr;
											}
											hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
											quantified_term = temp;
										}

										for (unsigned int i = 0; i < scope.negations; i++) {
											hol_term* temp = hol_term::new_not(quantified_term);
											if (temp == nullptr) {
												free(*set_definition); free(set_definition);
												free(*quantified_term); free(quantified_term);
												return (hol_term*) nullptr;
											}
											quantified_term = temp;
										}
									} else {
										quantified_term = hol_term::new_any_right(hol_term::new_for_all(element_variable, hol_term::new_if_then(
												hol_term::new_apply(set_var, arg),
												hol_term::new_apply(hol_term::new_variable(lambda_variable), arg))));
										if (quantified_term == nullptr) {
											free(*set_definition); free(set_definition);
											return (hol_term*) nullptr;
										}
										set_var->reference_count++;
										arg->reference_count += 2;

										for (unsigned int i = 0; i < scope.negations; i++) {
											hol_term* temp = hol_term::new_not(quantified_term);
											if (temp == nullptr) {
												free(*set_definition); free(set_definition);
												free(*quantified_term); free(quantified_term);
												return (hol_term*) nullptr;
											}
											quantified_term = temp;
										}
									}
									dst = hol_term::new_exists(set_variable, hol_term::new_and(set_definition, quantified_term));
									if (dst == nullptr) {
										free(*set_definition); free(set_definition);
										free(*quantified_term); free(quantified_term);
										return (hol_term*) nullptr;
									}
								}
							} else if (scope.scope->type == hol_term_type::EXISTS && operand->type == hol_term_type::AND) {
								hol_term* first_conjunct = operand->array.operands[0];
								if ((first_conjunct->type == hol_term_type::EQUALS && first_conjunct->binary.left->type == hol_term_type::VARIABLE
								  && first_conjunct->binary.left->variable == element_variable && first_conjunct->binary.right->type == hol_term_type::LAMBDA)
								 || (first_conjunct->type == hol_term_type::BINARY_APPLICATION && first_conjunct->ternary.second->type == hol_term_type::VARIABLE
								  && first_conjunct->ternary.second->variable == element_variable && first_conjunct->ternary.third->type == hol_term_type::LAMBDA))
								{
									/* first check if `element_variable` is a set variable (i.e. set-valued) */
									unsigned int inner_element_variable;
									if (first_conjunct->type == hol_term_type::EQUALS)
										inner_element_variable = first_conjunct->binary.right->quantifier.variable;
									else inner_element_variable = first_conjunct->ternary.third->quantifier.variable;

									hol_term* inner_element_var = hol_term::new_variable(inner_element_variable);
									if (inner_element_var == nullptr)
										return (hol_term*) nullptr;

									hol_term* new_head = hol_term::new_for_all(inner_element_variable, hol_term::new_if_then(
											hol_term::new_apply(arg, inner_element_var),
											hol_term::new_apply(hol_term::new_variable(lambda_variable), inner_element_var)));
									if (new_head == nullptr) {
										free(*inner_element_var); free(inner_element_var);
										return (hol_term*) nullptr;
									}
									arg->reference_count++;
									inner_element_var->reference_count += 2 - 1;

									auto check_wide_scope = [&remove_wide_scope_marker](hol_term* term) {
										remove_wide_scope_marker |= (term->type == hol_term_type::UNARY_APPLICATION
											&& term->binary.left->type == hol_term_type::CONSTANT
											&& term->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE);
										return true;
									};
									array<hol_term*> child_siblings(8); array<unsigned int> dst_variables(8);
									bool removed_quantifier, dummy = false, remove_negations = false;
									bool result = apply_head<true>(scope.scope, dst, dst_variables, child_siblings, 0, removed_quantifier, remove_negations, dummy, node_finder(is_array ? parent : head),
											[new_head](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings) { return new_head; }, check_wide_scope);
									if (!result || dst == nullptr) {
										free(*new_head); free(new_head);
										return (hol_term*) nullptr;
									}
									for (hol_term* sibling : child_siblings) {
										unsigned int index = siblings.index_of(sibling);
										if (index < siblings.length) siblings.remove(index);
									}

								} else if (first_conjunct->type == hol_term_type::UNARY_APPLICATION && first_conjunct->binary.right->type == hol_term_type::VARIABLE
										&& first_conjunct->binary.right->variable == element_variable && first_conjunct->binary.left->type == hol_term_type::VARIABLE)
								{
									/* check if the scope is a relativized quantification over a set */
									if (MustBeSetValued) return (hol_term*) nullptr;
									hol_term* new_head = hol_term::new_apply(hol_term::new_variable(lambda_variable), arg);
									if (new_head == nullptr)
										return (hol_term*) nullptr;
									arg->reference_count++;

									unsigned int index = scopes.index_of(first_conjunct->binary.left->variable);
									scope_info& set_scope = scopes.values[index];

									auto check_wide_scope = [&remove_wide_scope_marker](hol_term* term) {
										remove_wide_scope_marker |= (term->type == hol_term_type::UNARY_APPLICATION
											&& term->binary.left->type == hol_term_type::CONSTANT
											&& term->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE);
										return true;
									};
									array<hol_term*> child_siblings(8); array<unsigned int> dst_variables(8);
									bool removed_quantifier, dummy = false, remove_negations = false;
									bool result = apply_head<true>(set_scope.scope, dst, dst_variables, child_siblings, 0, removed_quantifier, remove_negations, dummy, node_finder(is_array ? parent : head),
											[new_head](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings) { return new_head; }, check_wide_scope);
									if (!result || dst == nullptr) {
										free(*new_head); free(new_head);
										return (hol_term*) nullptr;
									}
									for (hol_term* sibling : child_siblings) {
										unsigned int index = siblings.index_of(sibling);
										if (index < siblings.length) siblings.remove(index);
									}

								} else {
									if (MustBeSetValued) return (hol_term*) nullptr;
									unsigned int set_variable = lambda_variable + 1;
									hol_term* set_var = hol_term::new_variable(set_variable);
									if (set_var == nullptr)
										return (hol_term*) nullptr;
									hol_term* set_definition;
									if (operand->array.length == 2) {
										set_definition = hol_term::new_equals(set_var, hol_term::new_lambda(element_variable, operand->array.operands[0]));
									} else {
										set_definition = hol_term::new_equals(set_var, hol_term::new_lambda(element_variable,
												hol_term::new_and(make_array_view(operand->array.operands, operand->array.length - 1))));
									}
									if (set_definition == nullptr) {
										free(*set_var); free(set_var);
										return (hol_term*) nullptr;
									}
									for (unsigned int i = 0; i + 1 < operand->array.length; i++)
										operand->array.operands[i]->reference_count++;

									/* check if the wide scope must come before a quantifier before the new set quantifier */
									array<unsigned int> dst_variables(4);
									dst_variables[dst_variables.length++] = lambda_variable;
									if (!get_free_variables(*set_definition, dst_variables)) {
										free(*set_definition); free(set_definition);
										return (hol_term*) nullptr;
									}
									unsigned int temp_index = dst_variables.index_of(set_variable);
									if (temp_index < dst_variables.length)
										dst_variables.remove(temp_index);
									if (dst_variables.length > 1) insertion_sort(dst_variables);
									if (!prune_independent_siblings(dst_variables, siblings)) {
										free(*set_definition); free(set_definition);
										return (hol_term*) nullptr;
									}
									for (unsigned int i = index; i > 0; i--) {
										if (dst_variables.contains(scopes.keys[i - 1]) && scopes.values[i - 1].narrow_scope) {
											wide_scope_must_be_before_quantifier = false;
											wide_scope_can_be_before_quantifier = false;
											break;
										}
									}

									hol_term* quantified_term;
									if (wide_scope_must_be_after_quantifier) {
										quantified_term = hol_term::new_exists(element_variable, hol_term::new_and(
												hol_term::new_apply(set_var, arg),
												hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, hol_term::new_apply(hol_term::new_variable(lambda_variable), arg))));
										remove_wide_scope_marker = true;
										if (quantified_term == nullptr) {
											free(*set_definition); free(set_definition);
											return (hol_term*) nullptr;
										}
										set_var->reference_count++;
										arg->reference_count += 2;
										hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
									} else if (wide_scope_must_be_before_quantifier || wide_scope_can_be_before_quantifier) {
										quantified_term = hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value,
												hol_term::new_exists(element_variable, hol_term::new_and(
													hol_term::new_apply(set_var, arg),
													hol_term::new_apply(hol_term::new_variable(lambda_variable), arg))));
										remove_wide_scope_marker = true;
										if (quantified_term == nullptr) {
											free(*set_definition); free(set_definition);
											return (hol_term*) nullptr;
										}
										set_var->reference_count++;
										arg->reference_count += 2;
										hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
									} else if (!wide_scope_can_be_before_quantifier) {
										quantified_term = hol_term::new_exists(element_variable, hol_term::new_and(
													hol_term::new_apply(set_var, arg),
													hol_term::new_apply(hol_term::new_variable(lambda_variable), arg)));
										if (quantified_term == nullptr) {
											free(*set_definition); free(set_definition);
											return (hol_term*) nullptr;
										}
										set_var->reference_count++;
										arg->reference_count += 2;
									} else {
										quantified_term = hol_term::new_any_right(hol_term::new_exists(element_variable, hol_term::new_and(
												hol_term::new_apply(set_var, arg),
												hol_term::new_apply(hol_term::new_variable(lambda_variable), arg))));
										remove_wide_scope_marker = true;
										if (quantified_term == nullptr) {
											free(*set_definition); free(set_definition);
											return (hol_term*) nullptr;
										}
										set_var->reference_count++;
										arg->reference_count += 2;
									}

									for (unsigned int i = 0; i < scope.negations; i++) {
										hol_term* temp = hol_term::new_not(quantified_term);
										if (temp == nullptr) {
											free(*set_definition); free(set_definition);
											free(*quantified_term); free(quantified_term);
											return (hol_term*) nullptr;
										}
										quantified_term = temp;
									}

									for (unsigned int i = 0; i + 1 < operand->array.length; i++) {
										unsigned int index = siblings.index_of(operand->array.operands[i]);
										if (index < siblings.length) siblings.remove(index);
									}

									dst = hol_term::new_exists(set_variable, hol_term::new_and(set_definition, quantified_term));
									if (dst == nullptr) {
										free(*set_definition); free(set_definition);
										free(*quantified_term); free(quantified_term);
										return (hol_term*) nullptr;
									}
								}
							} else if (scope.scope->type == hol_term_type::EXISTS && operand->type == hol_term_type::ANY_ARRAY && (operand->any_array.oper == hol_term_type::AND || operand->any_array.oper == hol_term_type::ANY_ARRAY)) {
								hol_term* first_conjunct = (operand->any_array.left.length == 0 ? nullptr : operand->any_array.left.operands[0]);
								if ((first_conjunct->type == hol_term_type::EQUALS && first_conjunct->binary.left->type == hol_term_type::VARIABLE
								  && first_conjunct->binary.left->variable == element_variable && first_conjunct->binary.right->type == hol_term_type::LAMBDA)
								 || (first_conjunct->type == hol_term_type::BINARY_APPLICATION && first_conjunct->ternary.second->type == hol_term_type::VARIABLE
								  && first_conjunct->ternary.second->variable == element_variable && first_conjunct->ternary.third->type == hol_term_type::LAMBDA))
								{
									/* first check if `element_variable` is a set variable (i.e. set-valued) */
									unsigned int inner_element_variable;
									if (first_conjunct->type == hol_term_type::EQUALS)
										inner_element_variable = first_conjunct->binary.right->quantifier.variable;
									else inner_element_variable = first_conjunct->ternary.third->quantifier.variable;

									hol_term* inner_element_var = hol_term::new_variable(inner_element_variable);
									if (inner_element_var == nullptr)
										return (hol_term*) nullptr;

									dst = hol_term::new_for_all(inner_element_variable, hol_term::new_if_then(
											hol_term::new_apply(arg, inner_element_var),
											hol_term::new_apply(hol_term::new_variable(lambda_variable), inner_element_var)));
									if (dst == nullptr) {
										free(*inner_element_var); free(inner_element_var);
										return (hol_term*) nullptr;
									}
									arg->reference_count++;
									inner_element_var->reference_count += 2 - 1;

								} else if (first_conjunct != nullptr && first_conjunct->type == hol_term_type::UNARY_APPLICATION && first_conjunct->binary.right->type == hol_term_type::VARIABLE
										&& first_conjunct->binary.right->variable == element_variable && first_conjunct->binary.left->type == hol_term_type::VARIABLE)
								{
									/* check if the scope is a relativized quantification over a set */
									if (MustBeSetValued) return (hol_term*) nullptr;
									hol_term* new_head = hol_term::new_apply(hol_term::new_variable(lambda_variable), arg);
									if (new_head == nullptr)
										return (hol_term*) nullptr;
									arg->reference_count++;

									unsigned int index = scopes.index_of(first_conjunct->binary.left->variable);
									scope_info& set_scope = scopes.values[index];

									auto check_wide_scope = [&remove_wide_scope_marker](hol_term* term) {
										remove_wide_scope_marker |= (term->type == hol_term_type::UNARY_APPLICATION
											&& term->binary.left->type == hol_term_type::CONSTANT
											&& term->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE);
										return true;
									};
									array<hol_term*> child_siblings(8); array<unsigned int> dst_variables(8);
									bool removed_quantifier, dummy = false, remove_negations = false;
									bool result = apply_head<true>(set_scope.scope, dst, dst_variables, child_siblings, 0, removed_quantifier, remove_negations, dummy, node_finder(is_array ? parent : head),
									[new_head](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings) { return new_head; }, check_wide_scope);
									if (!result || dst == nullptr) {
										free(*new_head); free(new_head);
										return (hol_term*) nullptr;
									}
									for (hol_term* sibling : child_siblings) {
										unsigned int index = siblings.index_of(sibling);
										if (index < siblings.length) siblings.remove(index);
									}

								} else {
									if (MustBeSetValued) return (hol_term*) nullptr;
									hol_term* set_definition = hol_term::new_any_array(hol_term_type::AND, operand->any_array.all,
											make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
											make_array_view(operand->any_array.left.operands, operand->any_array.left.length),
											make_array_view(operand->any_array.right.operands, operand->any_array.right.length - 1));
									if (set_definition == nullptr)
										return (hol_term*) nullptr;
									operand->any_array.all->reference_count++;
									for (unsigned int i = 0; i < set_definition->any_array.any.length; i++)
										set_definition->any_array.any.operands[i]->reference_count++;
									for (unsigned int i = 0; i < set_definition->any_array.left.length; i++)
										set_definition->any_array.left.operands[i]->reference_count++;
									for (unsigned int i = 0; i < set_definition->any_array.right.length; i++)
										set_definition->any_array.right.operands[i]->reference_count++;

									unsigned int set_variable = lambda_variable + 1;
									hol_term* set_var = hol_term::new_variable(set_variable);
									if (set_var == nullptr) {
										free(*set_definition); free(set_definition);
										return (hol_term*) nullptr;
									}
									hol_term* set_definition_term = hol_term::new_equals(set_var, hol_term::new_lambda(element_variable, set_definition));
									if (set_definition_term == nullptr) {
										free(*set_definition); free(set_definition);
										free(*set_var); free(set_var);
										return (hol_term*) nullptr;
									}
									hol_term* quantified_term;
									if (wide_scope_must_be_after_quantifier) {
										quantified_term = hol_term::new_exists(element_variable, hol_term::new_and(
												hol_term::new_apply(set_var, arg),
												hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, hol_term::new_apply(hol_term::new_variable(lambda_variable), arg))));
										if (quantified_term == nullptr) {
											free(*set_definition_term); free(set_definition_term);
											return (hol_term*) nullptr;
										}
										set_var->reference_count++;
										hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
										arg->reference_count += 2;

										for (unsigned int i = 0; i < scope.negations; i++) {
											hol_term* temp = hol_term::new_not(quantified_term);
											if (temp == nullptr) {
												free(*set_definition_term); free(set_definition_term);
												free(*quantified_term); free(quantified_term);
												return (hol_term*) nullptr;
											}
											quantified_term = temp;
										}
									} else if (wide_scope_can_be_before_quantifier) {
										quantified_term = hol_term::new_any_right(hol_term::new_exists(element_variable, hol_term::new_and(
												hol_term::new_apply(set_var, arg),
												hol_term::new_apply(hol_term::new_variable(lambda_variable), arg))));
										if (quantified_term == nullptr) {
											free(*set_definition_term); free(set_definition_term);
											return (hol_term*) nullptr;
										}
										set_var->reference_count++;
										arg->reference_count += 2;

										for (unsigned int i = 0; i < scope.negations; i++) {
											hol_term* temp = hol_term::new_not(quantified_term);
											if (temp == nullptr) {
												free(*set_definition_term); free(set_definition_term);
												free(*quantified_term); free(quantified_term);
												return (hol_term*) nullptr;
											}
											quantified_term = temp;
										}
									} else {
										quantified_term = hol_term::new_exists(element_variable, hol_term::new_and(
												hol_term::new_apply(set_var, arg),
												hol_term::new_apply(hol_term::new_variable(lambda_variable), arg)));
										if (quantified_term == nullptr) {
											free(*set_definition_term); free(set_definition_term);
											return (hol_term*) nullptr;
										}
										set_var->reference_count++;
										arg->reference_count += 2;

										for (unsigned int i = 0; i < scope.negations; i++) {
											hol_term* temp = hol_term::new_not(quantified_term);
											if (temp == nullptr) {
												free(*set_definition_term); free(set_definition_term);
												free(*quantified_term); free(quantified_term);
												return (hol_term*) nullptr;
											}
											quantified_term = temp;
										}
									}
									dst = hol_term::new_exists(set_variable, hol_term::new_any_array(hol_term_type::AND, &HOL_ANY,
											make_array_view((hol_term**) nullptr, 0), make_array_view(&set_definition_term, 1), make_array_view(&quantified_term, 1)));
									if (dst == nullptr) {
										free(*set_definition_term); free(set_definition_term);
										free(*quantified_term); free(quantified_term);
										return (hol_term*) nullptr;
									}
									HOL_ANY.reference_count++;
									remove_wide_scope_marker = true;
								}
							} else if (scope.scope->type == hol_term_type::LAMBDA) {
								if (MustBeSetValued) return (hol_term*) nullptr;
								dst = hol_term::new_apply(hol_term::new_variable(lambda_variable), arg);
								if (dst == nullptr)
									return (hol_term*) nullptr;
								arg->reference_count++;
							}
						}
					} else if (conjunct->type == hol_term_type::EXISTS) {
						if (MustBeSetValued) return (hol_term*) nullptr;
						hol_term* inner_operand = conjunct->quantifier.operand;
						hol_term* equals_term = hol_term::new_equals(expected_left_side, hol_term::new_variable(conjunct->quantifier.variable));
						if (equals_term == nullptr) {
							free(*expected_left_side); free(expected_left_side);
							return (hol_term*) nullptr;
						}
						hol_term* expected_operand = hol_term::new_any_array(hol_term_type::AND, &HOL_ANY, make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0), make_array_view(&equals_term, 1));
						if (expected_operand == nullptr) {
							free(*equals_term); free(equals_term);
							return (hol_term*) nullptr;
						}
						equals_term->reference_count++;
						HOL_ANY.reference_count++;
						if (!has_intersection<built_in_predicates>(expected_operand, inner_operand)) {
							free(*expected_operand); free(expected_operand);
							free(*equals_term); free(equals_term);
							return (hol_term*) nullptr;
						}
						free(*expected_operand); free(expected_operand);

						unsigned int set_variable = lambda_variable + 1;
						unsigned int element_variable = conjunct->quantifier.variable;
						hol_term* element_var = hol_term::new_variable(conjunct->quantifier.variable);
						if (element_var == nullptr) {
							free(*equals_term); if (equals_term->reference_count == 0) free(equals_term);
							return (hol_term*) nullptr;
						}
						hol_term* set_var = hol_term::new_variable(set_variable);
						if (set_var == nullptr) {
							free(*equals_term); if (equals_term->reference_count == 0) free(equals_term);
							free(*element_var); free(element_var);
							return (hol_term*) nullptr;
						}
						if (inner_operand->type == hol_term_type::ANY) {
							array<hol_term*> diff(1);
							subtract_any<built_in_predicates>(diff, inner_operand, equals_term);
							free(*equals_term); if (equals_term->reference_count == 0) free(equals_term);
#if !defined(NDEBUG)
							if (diff.length > 1)
								fprintf(stderr, "select_arg_without_head_predicative WARNING: `diff` has more than one logical form.\n");
#endif

							hol_term* quantified_term = hol_term::new_exists(element_variable, hol_term::new_and(
										hol_term::new_apply(set_var, element_var),
										hol_term::new_apply(hol_term::new_variable(lambda_variable), element_var)));
							if (quantified_term == nullptr) {
								free(*element_var); free(element_var);
								free(*set_var); free(set_var);
								free_all(diff); return (hol_term*) nullptr;
							}
							element_var->reference_count += 2 - 1;

							for (unsigned int i = 0; i < negation_count; i++) {
								hol_term* temp = hol_term::new_not(quantified_term);
								if (temp == nullptr) {
									free(*quantified_term); free(quantified_term);
									free_all(diff); return (hol_term*) nullptr;
								}
								quantified_term = temp;
							}

							dst = hol_term::new_exists(set_variable, hol_term::new_and(
									hol_term::new_equals(set_var, hol_term::new_lambda(element_variable, diff[0])), quantified_term));
							for (hol_term* term : diff) { free(*term); if (term->reference_count == 0) free(term); }
							if (dst == nullptr) {
								free(*quantified_term); free(quantified_term);
								return (hol_term*) nullptr;
							}
							set_var->reference_count++;
						} else if (inner_operand->type == hol_term_type::ANY_ARRAY) {
							free(*equals_term); if (equals_term->reference_count == 0) free(equals_term);
							hol_term* new_inner_operand = hol_term::new_any_array(hol_term_type::AND, inner_operand->any_array.all,
									make_array_view(inner_operand->any_array.any.operands, inner_operand->any_array.any.length),
									make_array_view(inner_operand->any_array.left.operands, inner_operand->any_array.left.length),
									make_array_view(inner_operand->any_array.right.operands, inner_operand->any_array.right.length - 1));
							if (new_inner_operand == nullptr) {
								free(*element_var); free(element_var);
								free(*set_var); free(set_var);
								return (hol_term*) nullptr;
							}
							new_inner_operand->any_array.all->reference_count++;
							for (unsigned int i = 0; i < new_inner_operand->any_array.any.length; i++)
								new_inner_operand->any_array.any.operands[i]->reference_count++;
							for (unsigned int i = 0; i < new_inner_operand->any_array.left.length; i++)
								new_inner_operand->any_array.left.operands[i]->reference_count++;
							for (unsigned int i = 0; i < new_inner_operand->any_array.right.length; i++)
								new_inner_operand->any_array.right.operands[i]->reference_count++;

							hol_term* quantified_term = hol_term::new_exists(element_variable, hol_term::new_and(
										hol_term::new_apply(set_var, element_var),
										hol_term::new_apply(hol_term::new_variable(lambda_variable), element_var)));
							if (quantified_term == nullptr) {
								free(*element_var); free(element_var);
								free(*set_var); free(set_var);
								return (hol_term*) nullptr;
							}
							element_var->reference_count += 2 - 1;

							for (unsigned int i = 0; i < negation_count; i++) {
								hol_term* temp = hol_term::new_not(quantified_term);
								if (temp == nullptr) {
									free(*quantified_term); free(quantified_term);
									return (hol_term*) nullptr;
								}
								quantified_term = temp;
							}

							dst = hol_term::new_exists(set_variable, hol_term::new_and(
									hol_term::new_equals(set_var, hol_term::new_lambda(element_variable, new_inner_operand)), quantified_term));
							if (dst == nullptr) {
								free(*quantified_term); free(quantified_term);
								free(*new_inner_operand); free(new_inner_operand);
								return (hol_term*) nullptr;
							}
							set_var->reference_count++;
						} else if (inner_operand->type == hol_term_type::AND) {
							free(*equals_term); if (equals_term->reference_count == 0) free(equals_term);
							hol_term* set_definition;
							if (inner_operand->array.length == 2) {
								set_definition = inner_operand->array.operands[0];
							} else {
								set_definition = hol_term::new_and(make_array_view(inner_operand->array.operands, inner_operand->array.length - 1));
							}

							hol_term* quantified_term = hol_term::new_exists(element_variable, hol_term::new_and(
										hol_term::new_apply(set_var, element_var),
										hol_term::new_apply(hol_term::new_variable(lambda_variable), element_var)));
							if (quantified_term == nullptr) {
								free(*element_var); free(element_var);
								free(*set_var); free(set_var);
								return (hol_term*) nullptr;
							}
							element_var->reference_count += 2 - 1;

							for (unsigned int i = 0; i < negation_count; i++) {
								hol_term* temp = hol_term::new_not(quantified_term);
								if (temp == nullptr) {
									free(*quantified_term); free(quantified_term);
									return (hol_term*) nullptr;
								}
								quantified_term = temp;
							}

							dst = hol_term::new_exists(set_variable, hol_term::new_and(
									hol_term::new_equals(set_var, hol_term::new_lambda(element_variable, set_definition)), quantified_term));
							if (dst == nullptr) {
								free(*quantified_term); free(quantified_term);
								return (hol_term*) nullptr;
							}
							set_var->reference_count++;
							for (unsigned int i = 0; i < inner_operand->array.length - 1; i++)
								inner_operand->array.operands[i]->reference_count++;
						} else {
							free(*equals_term); if (equals_term->reference_count == 0) free(equals_term);
						}
					} else {
						free(*expected_left_side); free(expected_left_side);
						return (hol_term*) nullptr;
					}
				}
				return dst;
			}, gather_scope) && dst != nullptr;

	if (!result) return false;
	hol_term* new_dst = hol_term::new_lambda(lambda_variable, dst);
	if (new_dst == nullptr) {
		free(*dst); if (dst->reference_count == 0) free(dst);
		return false;
	}
	dst = new_dst;
	return true;
}

template<unsigned int ArgConstant, bool InvertArg, bool OuterScope>
inline bool select_singleton_arg_in_set_without_head_predicative(
		hol_term* src, hol_term*& dst)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<false>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker,
			predicative_head_finder<built_in_predicates>(lambda_variable),
			[&max_variable,lambda_variable](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				hol_term* old_head = head;
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr
				 && (head->any.included->type == hol_term_type::NOT || head->any.included->type == hol_term_type::EXISTS))
					head = head->any.included;

				bool negated = false;
				if (head->type == hol_term_type::NOT) {
					head = head->unary.operand;
					negated = true;
				}

				unsigned int set_variable, element_variable = 0;
				hol_term* left = nullptr;
				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT)
				{
					if (head->any.included != nullptr && head->any.included->type == hol_term_type::UNARY_APPLICATION
					 && head->any.included->binary.left->type == hol_term_type::VARIABLE
					 && head->any.included->binary.left->variable == lambda_variable
					 && head->any.included->binary.right->type == hol_term_type::VARIABLE)
					{
						element_variable = head->any.included->binary.right->variable;
						if (element_variable > max_variable)
							max_variable = element_variable;
					} else {
						element_variable = ++max_variable;
					}
					set_variable = ++max_variable;
				} else {
#if !defined(NDEBUG)
					if (head->type != hol_term_type::EXISTS)
						fprintf(stderr, "select_singleton_arg_in_set_without_head_predicative WARNING: Expected an existential quantification.\n");
#endif
					set_variable = head->quantifier.variable;
					hol_term* operand = head->quantifier.operand;

					hol_term* right = nullptr;
					if (operand->type == hol_term_type::ANY || operand->type == hol_term_type::ANY_RIGHT) {
						element_variable = ++max_variable;
					} else if (operand->type == hol_term_type::AND && operand->array.length != 0) {
						left = operand->array.operands[0];
						right = operand->array.operands[operand->array.length - 1];
					} else if (operand->type == hol_term_type::ANY_ARRAY) {
						if (operand->any_array.left.length != 0)
							left = operand->any_array.left.operands[0];
						else left = operand->any_array.all;
						if (operand->any_array.right.length != 0)
							right = operand->any_array.right.operands[operand->any_array.right.length - 1];
						else right = operand->any_array.all;
					} else {
						return (hol_term*) nullptr;
					}

					hol_term* set_definition = nullptr;
					if (left != nullptr) {
						if (left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT) {
							if (left->any.included != nullptr)
								set_definition = left->any.included;
						} else if (left->type == hol_term_type::EQUALS) {
							set_definition = left->binary.right;
						} else {
							return (hol_term*) nullptr;
						}
					}

					if (set_definition != nullptr) {
						if (set_definition->type == hol_term_type::ANY || set_definition->type == hol_term_type::ANY_RIGHT) {
							/* no-op */
						} else if (set_definition->type == hol_term_type::LAMBDA) {
							element_variable = set_definition->quantifier.variable;
						} else {
							return (hol_term*) nullptr;
						}
					}

					if (element_variable == 0 && right != nullptr) {
						/* try to get the element variable from the right conjunct, since we couldn't get it from the left conjunct */
						if ((right->type == hol_term_type::ANY || right->type == hol_term_type::ANY_RIGHT) && right->any.included != nullptr)
							right = right->any.included;
						if (right->type == hol_term_type::UNARY_APPLICATION && right->binary.left->type == hol_term_type::CONSTANT && right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE)
							right = right->binary.right;
						if (right->type == hol_term_type::ANY || right->type == hol_term_type::ANY_RIGHT) {
							element_variable = ++max_variable;
						} else if (right->type == hol_term_type::EXISTS || right->type == hol_term_type::FOR_ALL) {
							element_variable = right->quantifier.variable;
						} else if (right->type == hol_term_type::AND && right->array.length == 2 && right->array.operands[1]->type == hol_term_type::UNARY_APPLICATION
								&& right->array.operands[1]->binary.left->type == hol_term_type::VARIABLE && right->array.operands[1]->binary.left->variable == set_variable
								&& right->array.operands[1]->binary.right->type == hol_term_type::VARIABLE)
						{
							element_variable = right->array.operands[1]->binary.right->variable;
						} else {
							return (hol_term*) nullptr;
						}
					}
				}

				hol_term* element_var = hol_term::new_variable(element_variable);
				if (element_var == nullptr) return (hol_term*) nullptr;
				constexpr unsigned int excluded_tree_count = 2;
				hol_term* excluded_trees[excluded_tree_count];
				excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
							(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
							(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
						&HOL_ANY), element_var));
				excluded_trees[1] = hol_term::new_any(hol_term::new_lambda(element_variable, &HOL_ANY));
				if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; element_var->reference_count++; }
				if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
				if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr) {
					if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
					free(*element_var); free(element_var);
					return (hol_term*) nullptr;
				}

				hol_term* excluded_tree = hol_term::new_any(hol_term::new_any_constant(
							(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
							(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF));
				if (excluded_tree == nullptr) {
					free(*excluded_trees[0]); free(excluded_trees[0]);
					free(*excluded_trees[1]); free(excluded_trees[1]);
					free(*element_var); free(element_var);
					return (hol_term*) nullptr;
				}

				hol_term* singleton = hol_term::new_any_right(
						InvertArg
							? hol_term::new_equals(hol_term::new_apply(hol_term::new_constant(ArgConstant), element_var), hol_term::new_any(nullptr, &excluded_tree, 1))
							: hol_term::new_equals(hol_term::new_apply(hol_term::new_constant(ArgConstant), hol_term::new_any(nullptr, &excluded_tree, 1)), element_var),
						excluded_trees, excluded_tree_count);
				if (singleton == nullptr) {
					free(*excluded_trees[0]); free(excluded_trees[0]);
					free(*excluded_trees[1]); free(excluded_trees[1]);
					free(*excluded_tree); free(excluded_tree);
					free(*element_var); free(element_var);
					return (hol_term*) nullptr;
				}
				element_var->reference_count++;

				hol_term* set_var = hol_term::new_variable(set_variable);
				if (set_var == nullptr) {
					free(*singleton); free(singleton);
					free(*element_var); free(element_var);
					return (hol_term*) nullptr;
				}

				hol_term* set_definition = hol_term::new_equals(set_var, hol_term::new_lambda(element_variable, singleton));
				if (set_definition == nullptr) {
					free(*singleton); free(singleton);
					free(*set_var); free(set_var);
					free(*element_var); free(element_var);
					return (hol_term*) nullptr;
				}
				set_var->reference_count++;

				hol_term* lambda_var = hol_term::new_variable(lambda_variable);
				if (lambda_var == nullptr) {
					free(*set_definition); free(set_definition);
					free(*set_var); free(set_var);
					free(*element_var); free(element_var);
					return (hol_term*) nullptr;
				}

				hol_term* dst = hol_term::new_exists(set_variable, hol_term::new_and(set_definition, hol_term::new_exists(element_variable, hol_term::new_and(
						hol_term::new_apply(set_var, element_var), hol_term::new_apply(lambda_var, element_var)))));
				if (dst == nullptr) {
					free(*set_definition); free(set_definition);
					free(*set_var); free(set_var);
					free(*element_var); free(element_var);
					free(*lambda_var); free(lambda_var);
					return (hol_term*) nullptr;
				}
				element_var->reference_count += 2 - 1;
				set_var->reference_count++;
				lambda_var->reference_count++;

				array<hol_term*> intersection(2);
				intersect<built_in_predicates>(intersection, dst, head);
				free(*dst); if (dst->reference_count == 0) free(dst);
				if (intersection.length == 0) {
					free(*set_var); free(set_var);
					free(*lambda_var); free(lambda_var);
					return (hol_term*) nullptr;
				} else if (intersection.length != 1) {
					fprintf(stderr, "select_singleton_arg_in_set_without_head_predicative ERROR: Expected intersection to be unique.\n");
					free_all(intersection);
					free(*set_var); free(set_var);
					free(*lambda_var); free(lambda_var);
					return (hol_term*) nullptr;
				}

				hol_term* operand = intersection[0]->quantifier.operand;
				hol_term* new_left;
				if (operand->type == hol_term_type::AND) {
					new_left = operand->array.operands[0];
				} else {
					new_left = operand->any_array.left.operands[0];
				}

				hol_term* inner_operand;
				if (new_left->type == hol_term_type::ANY || new_left->type == hol_term_type::ANY_RIGHT) {
					inner_operand = new_left->any.included->quantifier.operand;
				} else if (new_left->type == hol_term_type::EQUALS) {
					inner_operand = new_left->binary.right->quantifier.operand;
				} else {
					inner_operand = new_left->ternary.third->quantifier.operand;
				}

				hol_term* second_inner_operand;
				if (inner_operand->type == hol_term_type::EXISTS) {
					second_inner_operand = inner_operand->quantifier.operand;
				} else if (inner_operand->type == hol_term_type::ANY_RIGHT) {
					free_all(intersection);

					unsigned int new_element_variable = ++max_variable;
					hol_term* new_element_var = hol_term::new_variable(new_element_variable);
					if (new_element_var == nullptr) {
						free(*set_var); free(set_var);
						free(*lambda_var); free(lambda_var);
						return (hol_term*) nullptr;
					}

					hol_term* excluded_terms[2];
					excluded_terms[0] = hol_term::new_any(hol_term::new_exists(set_variable, &HOL_ANY));
					if (excluded_terms[0] == nullptr) {
						free(*set_var); free(set_var);
						free(*new_element_var); free(new_element_var);
						free(*lambda_var); free(lambda_var);
						return (hol_term*) nullptr;
					}
					HOL_ANY.reference_count++;

					excluded_terms[1] = hol_term::new_any(hol_term::new_lambda(new_element_variable, &HOL_ANY));
					if (excluded_terms[1] == nullptr) {
						free(*set_var); free(set_var);
						free(*new_element_var); free(new_element_var);
						free(*lambda_var); free(lambda_var);
						free(*excluded_terms[0]); free(excluded_terms[0]);
						return (hol_term*) nullptr;
					}
					HOL_ANY.reference_count++;

					hol_term* excluded_quantifiers[3];
					excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(lambda_variable, &HOL_ANY));
					excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(lambda_variable, &HOL_ANY));
					excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(lambda_variable, &HOL_ANY));
					if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
					if (excluded_quantifiers[1] != nullptr) HOL_ANY.reference_count++;
					if (excluded_quantifiers[2] != nullptr) HOL_ANY.reference_count++;
					if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr) {
						if (excluded_quantifiers[0] != nullptr) { free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]); }
						if (excluded_quantifiers[1] != nullptr) { free(*excluded_quantifiers[1]); free(excluded_quantifiers[1]); }
						free(*set_var); free(set_var);
						free(*new_element_var); free(new_element_var);
						free(*lambda_var); free(lambda_var);
						free(*excluded_terms[0]); free(excluded_terms[0]);
						free(*excluded_terms[1]); free(excluded_terms[1]);
						return (hol_term*) nullptr;
					}

					hol_term* dst = hol_term::new_any_right(hol_term::new_exists(set_variable, hol_term::new_and(
							hol_term::new_equals(set_var, hol_term::new_lambda(new_element_variable, hol_term::new_any(nullptr, excluded_terms, array_length(excluded_terms)))),
							hol_term::new_exists(new_element_variable, hol_term::new_and(
									hol_term::new_apply(set_var, new_element_var),
									hol_term::new_apply(lambda_var, new_element_var)
							))
						)), excluded_quantifiers, array_length(excluded_quantifiers));
					if (dst == nullptr) {
						for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
						free(*set_var); free(set_var);
						free(*new_element_var); free(new_element_var);
						free(*lambda_var); free(lambda_var);
						free(*excluded_terms[0]); free(excluded_terms[0]);
						free(*excluded_terms[1]); free(excluded_terms[1]);
						return (hol_term*) nullptr;
					}
					new_element_var->reference_count += 2 - 1;
					set_var->reference_count += 2 - 1;
					remove_wide_scope_marker = true;
					return dst;
				} else {
					free_all(intersection);
					free(*set_var); free(set_var);
					free(*lambda_var); free(lambda_var);
					return (hol_term*) nullptr;
				}

				hol_term* inner_right;
				if (second_inner_operand->type == hol_term_type::AND) {
					inner_right = second_inner_operand->array.operands[second_inner_operand->array.length - 1];
				} else if (second_inner_operand->type == hol_term_type::ANY_ARRAY && second_inner_operand->any_array.oper == hol_term_type::AND) {
					if (second_inner_operand->any_array.right.length != 0) {
						inner_right = second_inner_operand->any_array.right.operands[second_inner_operand->any_array.right.length - 1];
					} else {
						inner_right = second_inner_operand->any_array.all;
					}
				} else if (second_inner_operand->type == hol_term_type::ANY_RIGHT && second_inner_operand->any.included != nullptr && second_inner_operand->any.included->type == hol_term_type::EXISTS) {
					inner_right = second_inner_operand->any.included;
				} else {
					free_all(intersection);
					free(*set_var); free(set_var);
					free(*lambda_var); free(lambda_var);
					return (hol_term*) nullptr;
				}

				hol_term* last_conjunct;
				hol_term* last_inner_operand;
				unsigned int new_element_variable;
				if (inner_right->type == hol_term_type::EXISTS) {
					if (!OuterScope) {
						free_all(intersection);
						free(*set_var); free(set_var);
						free(*lambda_var); free(lambda_var);
						return (hol_term*) nullptr;
					}
					last_inner_operand = inner_right->quantifier.operand;
					if (last_inner_operand->type == hol_term_type::AND) {
						last_conjunct = last_inner_operand->array.operands[last_inner_operand->array.length - 1];
					} else if (last_inner_operand->type == hol_term_type::ANY_ARRAY && last_inner_operand->any_array.oper == hol_term_type::AND) {
						if (last_inner_operand->any_array.right.length != 0) {
							last_conjunct = last_inner_operand->any_array.right.operands[last_inner_operand->any_array.right.length - 1];
						} else {
							last_conjunct = last_inner_operand->any_array.all;
						}
					} else {
						free_all(intersection);
						free(*set_var); free(set_var);
						free(*lambda_var); free(lambda_var);
						return (hol_term*) nullptr;
					}
					new_element_variable = inner_right->quantifier.variable;
				} else if (inner_right->type == hol_term_type::EQUALS) {
					last_inner_operand = second_inner_operand;
					last_conjunct = inner_right;
					new_element_variable = inner_operand->quantifier.variable;
				} else {
					free_all(intersection);
					free(*set_var); free(set_var);
					free(*lambda_var); free(lambda_var);
					return (hol_term*) nullptr;
				}

				if (!InvertArg && (last_conjunct->type != hol_term_type::EQUALS
				 || last_conjunct->binary.right->type != hol_term_type::VARIABLE
				 || last_conjunct->binary.right->variable != element_variable
				 || last_conjunct->binary.left->type != hol_term_type::UNARY_APPLICATION
				 || last_conjunct->binary.left->binary.left->type != hol_term_type::CONSTANT
				 || last_conjunct->binary.left->binary.right->type != hol_term_type::VARIABLE
				 || last_conjunct->binary.left->binary.right->variable != new_element_variable))
				{
					free_all(intersection);
					free(*set_var); free(set_var);
					free(*lambda_var); free(lambda_var);
					return (hol_term*) nullptr;
				} else if (InvertArg && (last_conjunct->type != hol_term_type::EQUALS
				 || last_conjunct->binary.right->type != hol_term_type::VARIABLE
				 || last_conjunct->binary.right->variable != new_element_variable
				 || last_conjunct->binary.left->type != hol_term_type::UNARY_APPLICATION
				 || last_conjunct->binary.left->binary.left->type != hol_term_type::CONSTANT
				 || last_conjunct->binary.left->binary.right->type != hol_term_type::VARIABLE
				 || last_conjunct->binary.left->binary.right->variable != element_variable))
				{
					free_all(intersection);
					free(*set_var); free(set_var);
					free(*lambda_var); free(lambda_var);
					return (hol_term*) nullptr;
				}

				hol_term* new_last_inner_operand;
				if (last_inner_operand->type == hol_term_type::AND) {
					if (last_inner_operand->array.length == 2) {
						new_last_inner_operand = last_inner_operand->array.operands[0];
						new_last_inner_operand->reference_count++;
					} else {
						new_last_inner_operand = hol_term::new_and(make_array_view(last_inner_operand->array.operands, last_inner_operand->array.length - 1));
						if (new_last_inner_operand == nullptr) {
							free_all(intersection);
							free(*set_var); free(set_var);
							free(*lambda_var); free(lambda_var);
							return (hol_term*) nullptr;
						}
						for (unsigned int i = 0; i < new_last_inner_operand->array.length; i++)
							new_last_inner_operand->array.operands[i]->reference_count++;
					}
				} else {
					if (last_inner_operand->any_array.right.length != 0) {
						new_last_inner_operand = hol_term::new_any_array(last_inner_operand->any_array.oper, last_inner_operand->any_array.all,
								make_array_view(last_inner_operand->any_array.any.operands, last_inner_operand->any_array.any.length),
								make_array_view(last_inner_operand->any_array.left.operands, last_inner_operand->any_array.left.length),
								make_array_view(last_inner_operand->any_array.right.operands, last_inner_operand->any_array.right.length - 1));
						if (new_last_inner_operand == nullptr) {
							free_all(intersection);
							free(*set_var); free(set_var);
							free(*lambda_var); free(lambda_var);
							return(hol_term*) nullptr;
						}
						new_last_inner_operand->any_array.all->reference_count++;
						for (unsigned int i = 0; i < new_last_inner_operand->any_array.any.length; i++)
							new_last_inner_operand->any_array.any.operands[i]->reference_count++;
						for (unsigned int i = 0; i < new_last_inner_operand->any_array.left.length; i++)
							new_last_inner_operand->any_array.left.operands[i]->reference_count++;
						for (unsigned int i = 0; i < new_last_inner_operand->any_array.right.length; i++)
							new_last_inner_operand->any_array.right.operands[i]->reference_count++;
					} else {
						new_last_inner_operand = last_inner_operand;
						new_last_inner_operand->reference_count++;
					}
				}

				hol_term* new_element_var = hol_term::new_variable(new_element_variable);
				if (new_element_var == nullptr) {
					free(*new_last_inner_operand); if (new_last_inner_operand->reference_count == 0) free(new_last_inner_operand);
					free(*set_var); if (set_var->reference_count == 0) free(set_var);
					free(*lambda_var); if (lambda_var->reference_count == 0) free(lambda_var);
					free_all(intersection); return (hol_term*) nullptr;
				}

				dst = hol_term::new_exists(set_variable, hol_term::new_and(
						hol_term::new_equals(set_var, hol_term::new_lambda(new_element_variable, new_last_inner_operand)),
						hol_term::new_exists(new_element_variable, hol_term::new_and(
								hol_term::new_apply(set_var, new_element_var),
								hol_term::new_apply(lambda_var, new_element_var)
						))
					));
				if (dst == nullptr) {
					free(*new_last_inner_operand); if (new_last_inner_operand->reference_count == 0) free(new_last_inner_operand);
					free(*set_var); if (set_var->reference_count == 0) free(set_var);
					free(*lambda_var); if (lambda_var->reference_count == 0) free(lambda_var);
					free_all(intersection); return (hol_term*) nullptr;
				}
				new_element_var->reference_count += 2 - 1;
				set_var->reference_count += 2 - 1;

				if (last_inner_operand != second_inner_operand) {
					hol_term* new_second_inner_operand;
					if (second_inner_operand->type == hol_term_type::AND) {
						new_second_inner_operand = hol_term::new_and(make_appended_array_view(make_array_view(second_inner_operand->array.operands, second_inner_operand->array.length - 1), dst));
						if (new_second_inner_operand == nullptr) {
							free(*dst); if (dst->reference_count == 0) free(dst);
							free_all(intersection); return (hol_term*) nullptr;
						}
						for (unsigned int i = 0; i + 1 < new_second_inner_operand->array.length; i++)
							new_second_inner_operand->array.operands[i]->reference_count++;
					} else if (second_inner_operand->type == hol_term_type::ANY_ARRAY) {
						new_second_inner_operand = hol_term::new_any_array(second_inner_operand->any_array.oper, second_inner_operand->any_array.all,
								make_array_view(second_inner_operand->any_array.any.operands, second_inner_operand->any_array.any.length),
								make_array_view(second_inner_operand->any_array.left.operands, second_inner_operand->any_array.left.length),
								make_appended_array_view(make_array_view(second_inner_operand->any_array.right.operands, max(1u, second_inner_operand->any_array.right.length) - 1), dst));
						if (new_second_inner_operand == nullptr) {
							free(*dst); if (dst->reference_count == 0) free(dst);
							free_all(intersection); return(hol_term*) nullptr;
						}
						new_second_inner_operand->any_array.all->reference_count++;
						for (unsigned int i = 0; i < new_second_inner_operand->any_array.any.length; i++)
							new_second_inner_operand->any_array.any.operands[i]->reference_count++;
						for (unsigned int i = 0; i < new_second_inner_operand->any_array.left.length; i++)
							new_second_inner_operand->any_array.left.operands[i]->reference_count++;
						for (unsigned int i = 0; i + 1 < new_second_inner_operand->any_array.right.length; i++)
							new_second_inner_operand->any_array.right.operands[i]->reference_count++;
					} else {
						new_second_inner_operand = hol_term::new_any_right(dst, second_inner_operand->any.excluded_trees, second_inner_operand->any.excluded_tree_count);
						for (unsigned int i = 0; i < second_inner_operand->any.excluded_tree_count; i++)
							second_inner_operand->any.excluded_trees[i]->reference_count++;
					}

					dst = hol_term::new_exists(inner_operand->quantifier.variable, new_second_inner_operand);
					if (dst == nullptr) {
						free(*new_second_inner_operand); free(new_second_inner_operand);
						free_all(intersection); return (hol_term*) nullptr;
					}
				}
				free_all(intersection);

				if (negated) {
					hol_term* new_dst = hol_term::new_not(dst);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					dst = new_dst;
				}
				if ((old_head->type == hol_term_type::ANY || old_head->type == hol_term_type::ANY_RIGHT) && can_have_free_variables(*dst)) {
					hol_term* new_dst = hol_term::new_any_right(dst, old_head->any.excluded_trees, old_head->any.excluded_tree_count);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < old_head->any.excluded_tree_count; i++)
						old_head->any.excluded_trees[i]->reference_count++;
					dst = new_dst;
				}
				return dst;
			}, no_op()) && dst != nullptr;
}

inline void find_scope_with_right_arg(
		hol_term* src, hol_term*& head,
		head_index& predicate_index)
{
	head = nullptr;
	if (src->type == hol_term_type::OR || src->type == hol_term_type::IFF
	 || src->type == hol_term_type::IF_THEN || src->type == hol_term_type::NOT
	 || src->type == hol_term_type::EXISTS || src->type == hol_term_type::FOR_ALL)
	{
		/* keep looking for the appropriate scope in the right branch of this node */
		return;
	} else if (src->type == hol_term_type::AND) {
		hol_term* right = src->array.operands[src->array.length - 1];
		/* check if the appropriate scope is further down the right branch, or if we stop the traversal here */
		if (right->type == hol_term_type::AND || right->type == hol_term_type::OR || right->type == hol_term_type::IFF
		 || right->type == hol_term_type::IF_THEN || right->type == hol_term_type::NOT
		 || right->type == hol_term_type::EXISTS || right->type == hol_term_type::FOR_ALL)
			return;
		head = src;
	} else if (src->type == hol_term_type::ANY_ARRAY) {
		hol_term* right;
		if (src->any_array.right.length == 0) {
			right = src->any_array.all;
		} else {
			right = src->any_array.right.operands[src->any_array.right.length - 1];
		}
		if (right->type == hol_term_type::AND || right->type == hol_term_type::OR || right->type == hol_term_type::IFF
		 || right->type == hol_term_type::IF_THEN || right->type == hol_term_type::NOT
		 || right->type == hol_term_type::EXISTS || right->type == hol_term_type::FOR_ALL)
			return;
		head = src;
	}
}

inline hol_term* select_arg_without_head_process_operand(hol_term* operand, hol_term* excluded)
{
	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	hol_term* dst;
	bool result = apply_head<false>(operand, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker, find_scope_with_right_arg,
			[](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				hol_term* dst;
				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) {
					HOL_ANY.reference_count++;
					return &HOL_ANY;
				} else if (head->type == hol_term_type::AND) {
					if (head->array.length == 2) {
						dst = head->array.operands[0];
					} else {
						dst = hol_term::new_and(make_array_view(head->array.operands, head->array.length - 1));
					}
					if (dst == nullptr)
						return (hol_term*) nullptr;
					for (unsigned int i = 0; i < head->array.length - 1; i++)
						head->array.operands[i]->reference_count++;
				} else if (head->type == hol_term_type::ANY_ARRAY) {
					dst = hol_term::new_any_array(hol_term_type::AND, head->any_array.all,
							make_array_view(head->any_array.any.operands, head->any_array.any.length),
							make_array_view(head->any_array.left.operands, head->any_array.left.length),
							make_array_view(head->any_array.right.operands, head->any_array.right.length - 1));
					if (dst == nullptr)
						return (hol_term*) nullptr;
					head->any_array.all->reference_count++;
					for (unsigned int i = 0; i < head->any_array.any.length; i++)
						head->any_array.any.operands[i]->reference_count++;
					for (unsigned int i = 0; i < head->any_array.left.length; i++)
						head->any_array.left.operands[i]->reference_count++;
					for (unsigned int i = 0; i < head->any_array.right.length - 1; i++)
						head->any_array.right.operands[i]->reference_count++;
				} else {
					return (hol_term*) nullptr;
				}
				return dst;
			}, no_op());

	if (!result)
		return nullptr;

	array<hol_term*> intersection(2);
	intersect<built_in_predicates>(intersection, dst, excluded);
	free(*dst); if (dst->reference_count == 0) free(dst);
	if (intersection.length == 0) {
		return nullptr;
	} else if (intersection.length != 1) {
		fprintf(stderr, "select_arg_without_head_process_operand ERROR: Intersection is not unique.\n");
		free_all(intersection); return nullptr;
	}
	return intersection[0];
}

template<int_fast8_t ConjunctIndex, unsigned int ArgConstant, bool InvertArg>
inline bool select_arg_without_head(
		hol_term* src, hol_term*& dst)
{
	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<false>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker, find_head<built_in_predicates>,
			[](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && predicate_index.position != head_position::NONE)
					head = head->any.included;

				if (head->type == hol_term_type::NOT)
					head = head->unary.operand;

				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT
				 || (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY)
				 || (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY_RIGHT))
				{
					unsigned int max_variable = 0;
					max_bound_variable(*head, max_variable);
					head_variable = ++max_variable;
				} else {
					head_variable = head->quantifier.variable;
				}

				hol_term* head_var = hol_term::new_variable(head->quantifier.variable);
				if (head_var == nullptr)
					return (hol_term*) nullptr;

				hol_term* excluded_conjuncts[2];
				excluded_conjuncts[0] = hol_term::new_any(hol_term::new_equals(
							hol_term::new_apply(hol_term::new_constant(InvertArg ? ArgConstant : (unsigned int) invert_arg<(built_in_predicates) ArgConstant>::value), head_var), &HOL_ANY));
				excluded_conjuncts[1] = hol_term::new_any(hol_term::new_equals(
							hol_term::new_apply(hol_term::new_constant(InvertArg ? (unsigned int) invert_arg<(built_in_predicates) ArgConstant>::value : ArgConstant), &HOL_ANY), head_var));
				if (excluded_conjuncts[0] != nullptr) { head_var->reference_count++; HOL_ANY.reference_count++; }
				if (excluded_conjuncts[1] != nullptr) { head_var->reference_count++; HOL_ANY.reference_count++; }
				if (excluded_conjuncts[0] == nullptr || excluded_conjuncts[1] == nullptr) {
					if (excluded_conjuncts[0] != nullptr) { free(*excluded_conjuncts[0]); free(excluded_conjuncts[0]); }
					free(*head_var); free(head_var); return (hol_term*) nullptr;
				}
				free(*head_var);

				hol_term* excluded = hol_term::new_any(nullptr, excluded_conjuncts, array_length(excluded_conjuncts));
				if (excluded == nullptr) {
					for (unsigned int i = 0; i < array_length(excluded_conjuncts); i++) { free(*excluded_conjuncts[i]); free(excluded_conjuncts[i]); }
					return (hol_term*) nullptr;
				}

				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT
				 || (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY)
				 || (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY_RIGHT))
				{
					/* TODO: this isn't really the result of applying this function to `src` */
					free(*excluded); free(excluded);
					hol_term* dst = hol_term::new_exists(head_variable, &HOL_ANY);
					if (dst == nullptr)
						return (hol_term*) nullptr;
					HOL_ANY.reference_count++;
					return dst;
				} else {
					hol_term* operand = head->quantifier.operand;

					hol_term* conjunct = nullptr;
					if (operand->type == hol_term_type::ANY_ARRAY) {
						if (ConjunctIndex >= 0) {
							if (ConjunctIndex < operand->any_array.left.length)
								conjunct = operand->any_array.left.operands[ConjunctIndex];
							else conjunct = operand->any_array.all;
						} else if (ConjunctIndex < 0) {
							unsigned int index = (unsigned int) (-ConjunctIndex) - 1;
							if (index < operand->any_array.right.length)
								conjunct = operand->any_array.right.operands[operand->any_array.right.length - index - 1];
							else conjunct = operand->any_array.all;
						}
					} else if (operand->type == hol_term_type::AND) {
						int conjunct_index = ConjunctIndex;
						if (ConjunctIndex < 0)
							conjunct_index += operand->array.length;
						conjunct = operand->array.operands[conjunct_index];
					} else {
						free(*excluded); free(excluded);
						return (hol_term*) nullptr;
					}

					hol_term* any_quantifier = hol_term::new_any_quantifier(hol_quantifier_type::ANY, &HOL_ANY);
					if (any_quantifier == nullptr) {
						free(*excluded); free(excluded);
						return (hol_term*) nullptr;
					}
					HOL_ANY.reference_count++;

					hol_term* expected_conjunct;
					if (InvertArg) {
						expected_conjunct = hol_term::new_any_right(hol_term::new_equals(
								hol_term::new_apply(hol_term::new_constant(ArgConstant), head_var),
								hol_term::new_any(nullptr, &any_quantifier, 1)));
					} else {
						expected_conjunct = hol_term::new_any_right(hol_term::new_equals(
								hol_term::new_apply(hol_term::new_constant(ArgConstant), hol_term::new_any(nullptr, &any_quantifier, 1)),
								head_var));
					}
					if (expected_conjunct == nullptr) {
						free(*excluded); free(excluded);
						free(*any_quantifier); free(any_quantifier);
						return (hol_term*) nullptr;
					}
					head_var->reference_count++;

					array<hol_term*> intersection(2);
					intersect<built_in_predicates>(intersection, expected_conjunct, conjunct);
					free(*expected_conjunct); if (expected_conjunct->reference_count == 0) free(expected_conjunct);
					if (intersection.length == 0) {
						free(*excluded); free(excluded);
						return (hol_term*) nullptr;
					} else if (intersection.length != 1) {
						fprintf(stderr, "select_arg_without_head ERROR: Intersection is not unique.\n");
						free_all(intersection);
						free(*excluded); free(excluded);
						return (hol_term*) nullptr;
					}

					if (intersection[0]->type == hol_term_type::ANY || intersection[0]->type == hol_term_type::ANY_RIGHT) {
						free_all(intersection);
						free(*excluded); free(excluded);
						HOL_ANY.reference_count++;
						return &HOL_ANY;

					} else if (intersection[0]->type == hol_term_type::ANY_ARRAY) {
						hol_term* all = select_arg_without_head_process_operand(intersection[0]->any_array.all, &HOL_ANY);

						array<hol_term*> any(max(1u, intersection[0]->any_array.any.length));
						for (unsigned int i = 0; i < intersection[0]->any_array.any.length; i++) {
							any[i] = select_arg_without_head_process_operand(intersection[0]->any_array.any.operands[i], excluded);
							if (any[i] == nullptr) {
								free(*excluded); if (excluded->reference_count == 0) free(excluded);
								free(*all); if (all->reference_count == 0) free(all);
								free_all(intersection); free_all(any);
								return (hol_term*) nullptr;
							}
							any.length++;
						}

						array<hol_term*> left(max(1u, intersection[0]->any_array.left.length));
						for (unsigned int i = 0; i < intersection[0]->any_array.left.length; i++) {
							left[i] = select_arg_without_head_process_operand(intersection[0]->any_array.left.operands[i], excluded);
							if (left[i] == nullptr) {
								free(*excluded); if (excluded->reference_count == 0) free(excluded);
								free(*all); if (all->reference_count == 0) free(all);
								free_all(intersection); free_all(any); free_all(left);
								return (hol_term*) nullptr;
							}
							left.length++;
						}

						array<hol_term*> right(max(1u, intersection[0]->any_array.right.length));
						for (unsigned int i = 0; i < intersection[0]->any_array.right.length; i++) {
							right[i] = select_arg_without_head_process_operand(intersection[0]->any_array.right.operands[i], excluded);
							if (right[i] == nullptr) {
								free(*excluded); if (excluded->reference_count == 0) free(excluded);
								free(*all); if (all->reference_count == 0) free(all);
								free_all(intersection); free_all(any); free_all(left); free_all(right);
								return (hol_term*) nullptr;
							}
							right.length++;
						}
						free_all(intersection);
						free(*excluded); if (excluded->reference_count == 0) free(excluded);

						hol_term* dst = hol_term::new_any_array(intersection[0]->any_array.oper, all,
								make_array_view(any.data, any.length), make_array_view(left.data, left.length), make_array_view(right.data, right.length));
						if (dst == nullptr) {
							free(*all); if (all->reference_count == 0) free(all);
							free_all(any); free_all(left); free_all(right);
							return (hol_term*) nullptr;
						}
						return dst;

					} else if (intersection[0]->type == hol_term_type::AND || intersection[0]->type == hol_term_type::OR) {
						array<hol_term*> new_operands(intersection[0]->array.length);
						for (unsigned int i = 0; i < intersection[0]->array.length; i++) {
							new_operands[i] = select_arg_without_head_process_operand(intersection[0]->array.operands[i], excluded);
							if (new_operands[i] == nullptr) {
								free(*excluded); if (excluded->reference_count == 0) free(excluded);
								free_all(intersection); free_all(new_operands);
								return (hol_term*) nullptr;
							}
							new_operands.length++;
						}
						hol_term_type type = intersection[0]->type;
						free_all(intersection);
						free(*excluded); if (excluded->reference_count == 0) free(excluded);

						hol_term* dst;
						if (type == hol_term_type::AND)
							dst = hol_term::new_and(make_array_view(new_operands.data, new_operands.length));
						else dst = hol_term::new_or(make_array_view(new_operands.data, new_operands.length));
						if (dst == nullptr) {
							free_all(new_operands);
							return (hol_term*) nullptr;
						}
						return dst;

					} else {
						hol_term* dst = select_arg_without_head_process_operand(intersection[0], excluded);
						free(*excluded); if (excluded->reference_count == 0) free(excluded);
						free_all(intersection);
						return dst;
					}
				}
			}, no_op()) && dst != nullptr;
}

inline bool add_constants(array<unsigned int>& constants, unsigned int constant) {
	return constants.add(constant);
}

template<size_t N>
inline bool add_constants(array<unsigned int>& constants, const unsigned int (&constant_array)[N]) {
	return constants.append(constant_array, N);
}

template<size_t N, typename OutputConstantType>
inline bool map_tense_constant(
		array<unsigned int>& constants,
		unsigned int constant,
		const unsigned int (&input_constants)[N],
		const OutputConstantType (&output_constants)[N])
{
	for (unsigned int i = 0; i < N; i++)
		if (input_constants[i] == constant)
			return add_constants(constants, output_constants[i]);
	return false;
}

template<size_t N, size_t M>
inline bool map_tense_constant(
		array<unsigned int>& constants,
		unsigned int constant,
		const unsigned int (&input_constants)[N][M],
		const unsigned int (&output_constants)[N])
{
	for (unsigned int i = 0; i < N; i++) {
		for (unsigned int j = 0; j < M; j++)
			if (input_constants[i][j] == constant)
				return add_constants(constants, output_constants[i]);
	}
	return false;
}

template<bool UniqueOutput, typename InputConstantType, typename OutputConstantType, size_t N>
inline bool map_tense_conjunct(
		array<hol_term*>& out,
		hol_term* src_conjunct, hol_term* input_conjunct,
		const InputConstantType (&input_constants)[N],
		const OutputConstantType (&output_constants)[N])
{
	array<hol_term*> intersections(4);
	intersect<built_in_predicates>(intersections, src_conjunct, input_conjunct);
	if (UniqueOutput && intersections.length > 1) {
		fprintf(stderr, "map_tense_conjunct WARNING: Expected intersection size to be 1.\n");
		for (hol_term* term : intersections) { free(*term); if (term->reference_count == 0) free(term); }
		return false;
	} else if (intersections.length == 0) {
		return true;
	}

	if (!out.ensure_capacity(out.length + intersections.length)) {
		for (hol_term* term : intersections) { free(*term); if (term->reference_count == 0) free(term); }
		return false;
	}

	for (hol_term* intersection : intersections) {
		array<unsigned int> new_constants(4);
		if (intersection->binary.left->type == hol_term_type::CONSTANT) {
			map_tense_constant(new_constants, intersection->binary.left->constant, input_constants, output_constants);
		} else {
#if !defined(NDEBUG)
			if (intersection->binary.left->type != hol_term_type::ANY_CONSTANT)
				fprintf(stderr, "map_tense_conjunct WARNING: Unexpected hol_term_type.\n");
#endif

			for (unsigned int i = 0; i < intersection->binary.left->any_constant.length; i++)
				map_tense_constant(new_constants, intersection->binary.left->any_constant.constants[i], input_constants, output_constants);
		}

		if (new_constants.length == 0) {
			continue;
		} else {
			insertion_sort(new_constants);
			unique(new_constants);
		}

		if (new_constants.length == 1) {
			out[out.length] = hol_term::new_apply(hol_term::new_constant(new_constants[0]), intersection->binary.right);
		} else {
			out[out.length] = hol_term::new_apply(hol_term::new_any_constant(make_array_view(new_constants.data, new_constants.length)), intersection->binary.right);
		}

		if (out[out.length] == nullptr) {
			for (hol_term* term : intersections) { free(*term); if (term->reference_count == 0) free(term); }
			return false;
		}
		intersection->binary.right->reference_count++;
		out.length++;
	}
	for (hol_term* term : intersections) { free(*term); if (term->reference_count == 0) free(term); }
	return true;
}

template<size_t N>
inline hol_term* make_tense_predicate(
		const unsigned int (&tense_constants)[N],
		unsigned int head_variable)
{
	return hol_term::new_apply((N == 1 ? hol_term::new_constant(tense_constants[0]) : hol_term::new_any_constant(make_array_view(tense_constants, N))), hol_term::new_variable(head_variable));
}

template<size_t N, size_t M>
inline hol_term* make_tense_predicate(
		const unsigned int (&tense_constants)[N][M],
		unsigned int head_variable)
{
	if (N == 1 && M == 1) {
		return hol_term::new_apply(hol_term::new_constant(tense_constants[0][0]), hol_term::new_variable(head_variable));
	} else {
		unsigned int values[N * M];
		for (unsigned int i = 0; i < N; i++)
			for (unsigned int j = 0; j < M; j++)
				values[i * M + j] = tense_constants[i][j];
		insertion_sort(values, N * M);
		return hol_term::new_apply(hol_term::new_any_constant(make_array_view(values, N * M)), hol_term::new_variable(head_variable));
	}
}

template<bool UniqueOutput, typename InputConstantType, typename OutputConstantType, size_t N>
inline bool map_tense_predicate(array<hol_term*>& out, hol_term* head,
		unsigned int head_variable, head_index predicate_index,
		const InputConstantType (&input_constants)[N],
		const OutputConstantType (&output_constants)[N])
{
	if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
		head = head->any.included;

	if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT
	 || (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY)
	 || (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY_RIGHT))
	{
		if (!out.ensure_capacity(out.length + 1))
			return false;

		hol_term* head_var = hol_term::new_variable(head_variable);
		if (head_var == nullptr) return (hol_term*) nullptr;
		constexpr unsigned int excluded_tree_count = 2;
		hol_term** excluded_trees = (hol_term**) alloca(sizeof(hol_term) * (excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()));
		excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
					(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
					(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
				&HOL_ANY), head_var));
		excluded_trees[1] = hol_term::new_any(hol_term::new_exists(head_variable, &HOL_ANY));
		if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
		if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
		if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr) {
			if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
			free(*head_var); free(head_var);
			return false;
		}
		free(*head_var);

		for (unsigned int i = 0; i < hol_non_head_constants<built_in_predicates>::count(); i++) {
			excluded_trees[excluded_tree_count + i] = hol_non_head_constants<built_in_predicates>::get_terms()[i];
			excluded_trees[excluded_tree_count + i]->reference_count++;
		}

		hol_term* expected_predicates[2];
		expected_predicates[0] = hol_term::new_apply(
					hol_term::new_any(nullptr, excluded_trees, excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()), head_var);
		if (expected_predicates[0] == nullptr) {
			for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
				free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
			}
			return false;
		}
		for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++)
			excluded_trees[i]->reference_count++;
		head_var->reference_count++;

		expected_predicates[1] = make_tense_predicate(output_constants, head_variable);
		if (expected_predicates[1] == nullptr) {
			free(*expected_predicates[0]); free(expected_predicates[0]);
			for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
				free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
			}
			return (hol_term*) false;
		}

		out[out.length] = hol_term::new_exists(head_variable, hol_term::new_any_array(hol_term_type::AND,
				hol_term::new_any(nullptr, excluded_trees, excluded_tree_count),
				make_array_view(expected_predicates, array_length(expected_predicates)),
				make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0)));
		if (out[out.length] == nullptr) {
			free(*expected_predicates[0]); free(expected_predicates[0]);
			free(*expected_predicates[1]); free(expected_predicates[1]);
			for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
				free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
			}
			return (hol_term*) nullptr;
		}
		for (unsigned int i = 0; i < excluded_tree_count; i++)
			excluded_trees[i]->reference_count++;
		for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
			free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
		}
		out.length++;
	} else if (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY_ARRAY) {
		hol_term* operand = head->quantifier.operand;
		if ((operand->any_array.oper != hol_term_type::AND && operand->any_array.oper != hol_term_type::ANY_ARRAY)
		 || (predicate_index.position == head_position::RIGHT && predicate_index.index == 0))
		{
			return false;
		}

		hol_term* input_conjunct = make_tense_predicate(input_constants, head_variable);
		if (input_conjunct == nullptr) return false;

		unsigned int new_left_length = operand->any_array.left.length;
		if (predicate_index.position == head_position::LEFT && predicate_index.index == new_left_length - 1)
			new_left_length++;
		unsigned int new_any_length = operand->any_array.any.length;
		if (predicate_index.position == head_position::ANY && predicate_index.index == new_any_length - 1)
			new_any_length++;

		array<hol_term*>* left_differences = (array<hol_term*>*) malloc(max((size_t) 1, sizeof(array<hol_term*>) * new_left_length));
		array<hol_term*>* right_differences = (array<hol_term*>*) malloc(max((size_t) 1, sizeof(array<hol_term*>) * operand->any_array.right.length));
		array<hol_term*>* any_differences = (array<hol_term*>*) malloc(max((size_t) 1, sizeof(array<hol_term*>) * new_any_length));
		if (left_differences == nullptr || right_differences == nullptr || any_differences == nullptr) {
			if (left_differences != nullptr) free(left_differences);
			if (right_differences != nullptr) free(right_differences);
			free(*input_conjunct); free(input_conjunct);
			return false;
		}

		for (unsigned int i = 0; i < new_left_length; i++) {
			if (!array_init(left_differences[i], 4)) {
				for (unsigned int j = 0; j < i; j++) free(left_differences[j]);
				free(left_differences); free(right_differences); free(any_differences);
				free(*input_conjunct); free(input_conjunct);
				return false;
			}
		} for (unsigned int i = 0; i < operand->any_array.right.length; i++) {
			if (!array_init(right_differences[i], 4)) {
				for (unsigned int j = 0; j < new_left_length; j++) free(left_differences[j]);
				for (unsigned int j = 0; j < i; j++) free(right_differences[j]);
				free(left_differences); free(right_differences); free(any_differences);
				free(*input_conjunct); free(input_conjunct);
				return false;
			}
		} for (unsigned int i = 0; i < new_any_length; i++) {
			if (!array_init(any_differences[i], 4)) {
				for (unsigned int j = 0; j < new_left_length; j++) free(left_differences[j]);
				for (unsigned int j = 0; j < operand->any_array.right.length; j++) free(right_differences[j]);
				for (unsigned int j = 0; j < i; j++) free(any_differences[j]);
				free(left_differences); free(right_differences); free(any_differences);
				free(*input_conjunct); free(input_conjunct);
				return false;
			}
		}

		auto cleanup = [operand,new_left_length,new_any_length,left_differences,right_differences,any_differences,input_conjunct]() {
			for (unsigned int j = 0; j < new_left_length; j++) {
				for (hol_term* term : left_differences[j]) { free(*term); if (term->reference_count == 0) free(term); }
				free(left_differences[j]);
			} for (unsigned int j = 0; j < operand->any_array.right.length; j++) {
				for (hol_term* term : right_differences[j]) { free(*term); if (term->reference_count == 0) free(term); }
				free(right_differences[j]);
			} for (unsigned int j = 0; j < new_any_length; j++) {
				for (hol_term* term : any_differences[j]) { free(*term); if (term->reference_count == 0) free(term); }
				free(any_differences[j]);
			}
			free(left_differences); free(right_differences); free(any_differences);
			free(*input_conjunct); if (input_conjunct->reference_count == 0) free(input_conjunct);
		};

		for (unsigned int i = 0; i < operand->any_array.left.length; i++) {
			if (predicate_index.position == head_position::LEFT && i == predicate_index.index + 1) {
				map_tense_conjunct<UniqueOutput>(left_differences[i], operand->any_array.left.operands[i], input_conjunct, input_constants, output_constants);
			} else {
				subtract<built_in_predicates>(left_differences[i], operand->any_array.left.operands[i], input_conjunct);
				if (UniqueOutput && left_differences[i].length > 1) {
					fprintf(stderr, "map_tense_predicate ERROR: Set difference is not unique.\n");
					cleanup(); return false;
				}
			}
			if (left_differences[i].length == 0) {
				cleanup();
				return false;
			}
		}
		if (predicate_index.position == head_position::LEFT && operand->any_array.left.length == predicate_index.index + 1) {
			map_tense_conjunct<UniqueOutput>(left_differences[operand->any_array.left.length], operand->any_array.all, input_conjunct, input_constants, output_constants);
			if (left_differences[operand->any_array.left.length].length == 0) {
				cleanup();
				return false;
			}
		}

		for (unsigned int i = 0; i < operand->any_array.right.length; i++) {
			if (predicate_index.position == head_position::RIGHT && i == predicate_index.index - 1) {
				map_tense_conjunct<UniqueOutput>(right_differences[i], operand->any_array.right.operands[i], input_conjunct, input_constants, output_constants);
			} else {
				subtract<built_in_predicates>(right_differences[i], operand->any_array.right.operands[i], input_conjunct);
				if (UniqueOutput && right_differences[i].length > 1) {
					fprintf(stderr, "map_tense_predicate ERROR: Set difference is not unique.\n");
					cleanup(); return false;
				}
			}
			if (right_differences[i].length == 0) {
				cleanup();
				return false;
			}
		}

		for (unsigned int i = 0; i < operand->any_array.any.length; i++) {
			if (predicate_index.position == head_position::ANY && i == predicate_index.index + 1) {
				map_tense_conjunct<UniqueOutput>(any_differences[i], operand->any_array.any.operands[i], input_conjunct, input_constants, output_constants);
			} else {
				subtract<built_in_predicates>(any_differences[i], operand->any_array.any.operands[i], input_conjunct);
				if (UniqueOutput && any_differences[i].length > 1) {
					fprintf(stderr, "map_tense_predicate ERROR: Set difference is not unique.\n");
					cleanup(); return false;
				}
			}
			if (any_differences[i].length == 0) {
				cleanup();
				return false;
			}
		}
		if (predicate_index.position == head_position::ANY && operand->any_array.any.length == predicate_index.index + 1) {
			map_tense_conjunct<UniqueOutput>(any_differences[operand->any_array.any.length], operand->any_array.all, input_conjunct, input_constants, output_constants);
			if (any_differences[operand->any_array.any.length].length == 0) {
				cleanup();
				return false;
			}
		}

		bool result = apply_to_cartesian_product(left_differences, new_left_length, [&out,head,left_differences,right_differences,any_differences,operand,new_left_length,new_any_length](const unsigned int* left_index_array) {
			return apply_to_cartesian_product(right_differences, operand->any_array.right.length, [&out,head,left_differences,right_differences,any_differences,operand,new_left_length,new_any_length,left_index_array](const unsigned int* right_index_array) {
				return apply_to_cartesian_product(any_differences, new_any_length, [&out,head,left_differences,right_differences,any_differences,operand,new_left_length,new_any_length,left_index_array,right_index_array](const unsigned int* any_index_array) {
					if (!out.ensure_capacity(out.length + 1)) return false;
					out[out.length] = hol_term::new_exists(head->quantifier.variable, hol_term::new_any_array(hol_term_type::AND, operand->any_array.all,
							lookup_table_array_view<array<hol_term*>, hol_term*>(any_differences, any_index_array, new_any_length),
							lookup_table_array_view<array<hol_term*>, hol_term*>(left_differences, left_index_array, new_left_length),
							lookup_table_array_view<array<hol_term*>, hol_term*>(right_differences, right_index_array, operand->any_array.right.length)));
					if (out[out.length] == nullptr)
						return false;

					out[out.length]->quantifier.operand->any_array.all->reference_count++;
					for (unsigned int i = 0; i < out[out.length]->quantifier.operand->any_array.left.length; i++)
						out[out.length]->quantifier.operand->any_array.left.operands[i]->reference_count++;
					for (unsigned int i = 0; i < out[out.length]->quantifier.operand->any_array.right.length; i++)
						out[out.length]->quantifier.operand->any_array.right.operands[i]->reference_count++;
					for (unsigned int i = 0; i < out[out.length]->quantifier.operand->any_array.any.length; i++)
						out[out.length]->quantifier.operand->any_array.any.operands[i]->reference_count++;
					out.length++;
					return true;
				});
			});
		});
		cleanup();
		return result;
	} else if (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::AND) {
		hol_term* operand = head->quantifier.operand;
		if (predicate_index.index + 1 == operand->array.length)
			return false;

		hol_term* input_conjunct = make_tense_predicate(input_constants, head_variable);
		if (input_conjunct == nullptr) return false;

		array<hol_term*>* differences = (array<hol_term*>*) malloc(sizeof(array<hol_term*>) * operand->array.length);
		if (differences == nullptr) {
			free(*input_conjunct); free(input_conjunct);
			return false;
		}

		for (unsigned int i = 0; i < operand->array.length; i++) {
			if (!array_init(differences[i], 4)) {
				for (unsigned int j = 0; j < i; j++) free(differences[j]);
				free(differences); free(*input_conjunct); free(input_conjunct);
				return false;
			}
		}

		auto cleanup = [operand,differences,input_conjunct]() {
			for (unsigned int j = 0; j < operand->array.length; j++) {
				for (hol_term* term : differences[j]) { free(*term); if (term->reference_count == 0) free(term); }
				free(differences[j]);
			}
			free(differences);
			free(*input_conjunct); if (input_conjunct->reference_count == 0) free(input_conjunct);
		};

		for (unsigned int i = 0; i < operand->array.length; i++) {
			if (i == predicate_index.index + 1) {
				map_tense_conjunct<UniqueOutput>(differences[i], operand->array.operands[i], input_conjunct, input_constants, output_constants);
			} else {
				subtract<built_in_predicates>(differences[i], operand->array.operands[i], input_conjunct);
				if (UniqueOutput && differences[i].length > 1) {
					fprintf(stderr, "map_tense_predicate ERROR: Set difference is not unique.\n");
					cleanup(); return false;
				}
			}
			if (differences[i].length == 0) {
				cleanup();
				return false;
			}
		}

		bool result = apply_to_cartesian_product(differences, operand->array.length, [&out,head,differences,operand](const unsigned int* index_array) {
			if (!out.ensure_capacity(out.length + 1)) return false;
			out[out.length] = hol_term::new_exists(head->quantifier.variable, hol_term::new_and(lookup_table_array_view<array<hol_term*>, hol_term*>(differences, index_array, operand->array.length)));
			if (out[out.length] == nullptr) return false;

			for (unsigned int i = 0; i < operand->array.length; i++)
				out[out.length]->quantifier.operand->array.operands[i]->reference_count++;
			out.length++;
			return true;
		});

		cleanup();
		if (!result) return false;
	} else {
		return false;
	}
	return true;
}

template<typename InputConstantType, typename OutputConstantType, size_t N>
inline bool apply_tense_predicate(
		hol_term* src, hol_term*& dst,
		const InputConstantType (&input_tense_predicates)[N],
		const OutputConstantType (&output_tense_predicates)[N])
{
	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<true>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker, find_head<built_in_predicates>,
			[input_tense_predicates,output_tense_predicates](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				bool negated = false;
				if (head->type == hol_term_type::NOT) {
					head = head->unary.operand;
					negated = true;
				}

				array<hol_term*> out(1);
				if (!map_tense_predicate<true>(out, head, head_variable, predicate_index, input_tense_predicates, output_tense_predicates) || out.length == 0)
					return (hol_term*) nullptr;
				hol_term* dst = out[0];

				if (negated) {
					hol_term* new_dst = hol_term::new_not(dst);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					dst = new_dst;
				}

				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) {
					hol_term* new_dst = hol_term::new_any_right(dst, head->any.excluded_trees, head->any.excluded_tree_count);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < head->any.excluded_tree_count; i++)
						head->any.excluded_trees[i]->reference_count++;
					dst = new_dst;
				}
				return dst;
			}, no_op()) && dst != nullptr;
}

template<size_t N>
inline bool require_tense_predicate(
		hol_term* src, hol_term*& dst,
		const unsigned int (&tense_predicates)[N])
{
	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<true>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker, find_head<built_in_predicates>,
			[tense_predicates](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				hol_term* old_head = head;
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && predicate_index.position != head_position::NONE)
					head = head->any.included;

				bool negated = false;
				if (head->type == hol_term_type::NOT) {
					head = head->unary.operand;
					negated = true;
				}

				hol_term* dst;
				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) {
					hol_term* head_var = hol_term::new_variable(head_variable);
					if (head_var == nullptr) return (hol_term*) nullptr;
					constexpr unsigned int excluded_tree_count = 2;
					hol_term** excluded_trees = (hol_term**) alloca(sizeof(hol_term) * (excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()));
					excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
								(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
								(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
							&HOL_ANY), head_var));
					excluded_trees[1] = hol_term::new_any(hol_term::new_exists(head_variable, &HOL_ANY));
					if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
					if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
					if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr) {
						if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
						free(*head_var); free(head_var);
						return (hol_term*) nullptr;
					}
					free(*head_var);

					for (unsigned int i = 0; i < hol_non_head_constants<built_in_predicates>::count(); i++) {
						excluded_trees[excluded_tree_count + i] = hol_non_head_constants<built_in_predicates>::get_terms()[i];
						excluded_trees[excluded_tree_count + i]->reference_count++;
					}

					hol_term* expected_predicates[2];
					expected_predicates[0] = hol_term::new_apply(
								hol_term::new_any(nullptr, excluded_trees, excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()), head_var);
					if (expected_predicates[0] == nullptr) {
						for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
							free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
						}
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++)
						excluded_trees[i]->reference_count++;
					head_var->reference_count++;

					expected_predicates[1] = hol_term::new_apply((N == 1 ? hol_term::new_constant(tense_predicates[0]) : hol_term::new_any_constant(tense_predicates)), head_var);
					if (expected_predicates[1] == nullptr) {
						free(*expected_predicates[0]); free(expected_predicates[0]);
						for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
							free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
						}
						return (hol_term*) nullptr;
					}
					head_var->reference_count++;

					hol_term* expected_head = hol_term::new_exists(head_variable, hol_term::new_any_array(hol_term_type::AND,
							hol_term::new_any(nullptr, excluded_trees, excluded_tree_count), make_array_view(expected_predicates, array_length(expected_predicates)),
							make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0)));
					if (expected_head == nullptr) {
						free(*expected_predicates[0]); free(expected_predicates[0]);
						free(*expected_predicates[1]); free(expected_predicates[1]);
						for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
							free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
						}
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < excluded_tree_count; i++)
						excluded_trees[i]->reference_count++;
					for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
						free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
					}

					array<hol_term*> intersection(2);
					intersect<built_in_predicates>(intersection, expected_head, head);
					free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
					if (intersection.length == 0) {
						return (hol_term*) nullptr;
					} else if (intersection.length > 1) {
						fprintf(stderr, "require_tense_predicate ERROR: Intersection is not unique.\n");
						for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
						return (hol_term*) nullptr;
					}
					dst = intersection[0];
				} else {
#if !defined(NDEBUG)
					if (head->type != hol_term_type::EXISTS)
						fprintf(stderr, "require_tense_predicate ERROR: Expected existentially-quantified expression.\n");
#endif
					hol_term* tense_predicate = hol_term::new_apply((N == 1 ? hol_term::new_constant(tense_predicates[0]) : hol_term::new_any_constant(tense_predicates)), hol_term::new_variable(head_variable));
					if (tense_predicate == nullptr)
						return (hol_term*) nullptr;

					hol_term* operand = head->quantifier.operand;
					if (operand->type == hol_term_type::AND) {
						if (predicate_index.index == operand->array.length - 1
						 || !has_intersection<built_in_predicates>(tense_predicate, operand->array.operands[predicate_index.index + 1]))
						{
							free(*tense_predicate); free(tense_predicate);
							return (hol_term*) nullptr;
						}

						dst = hol_term::new_exists(head_variable, hol_term::new_and(make_replaced_array_view(make_array_view(operand->array.operands, operand->array.length), tense_predicate, predicate_index.index + 1)));
						if (dst == nullptr) {
							free(*tense_predicate); free(tense_predicate);
							return (hol_term*) nullptr;
						}
						for (unsigned int i = 0; i < operand->array.length; i++) {
							if (i == predicate_index.index + 1) continue;
							operand->array.operands[i]->reference_count++;
						}
					} else if (operand->type == hol_term_type::ANY_ARRAY) {
						if (predicate_index.position == head_position::LEFT) {
							if (predicate_index.index + 1 < operand->any_array.left.length) {
								if (!has_intersection<built_in_predicates>(tense_predicate, operand->any_array.left.operands[predicate_index.index + 1])) {
									free(*tense_predicate); free(tense_predicate);
									return (hol_term*) nullptr;
								}
								dst = hol_term::new_exists(head_variable, hol_term::new_any_array(operand->any_array.oper, operand->any_array.all,
										make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
										make_replaced_array_view(make_array_view(operand->any_array.left.operands, operand->any_array.left.length), tense_predicate, predicate_index.index + 1),
										make_array_view(operand->any_array.right.operands, operand->any_array.right.length)));
							} else {
								if (!has_intersection<built_in_predicates>(tense_predicate, operand->any_array.all)) {
									free(*tense_predicate); free(tense_predicate);
									return (hol_term*) nullptr;
								}
								dst = hol_term::new_exists(head_variable, hol_term::new_any_array(operand->any_array.oper, operand->any_array.all,
										make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
										make_appended_array_view(make_array_view(operand->any_array.left.operands, operand->any_array.left.length), tense_predicate),
										make_array_view(operand->any_array.right.operands, operand->any_array.right.length)));
							}
							if (dst == nullptr) {
								free(*tense_predicate); free(tense_predicate);
								return (hol_term*) nullptr;
							}
							operand->any_array.all->reference_count++;
							for (unsigned int i = 0; i < operand->any_array.left.length; i++) {
								if (i == predicate_index.index + 1) continue;
								operand->any_array.left.operands[i]->reference_count++;
							} for (unsigned int i = 0; i < operand->any_array.any.length; i++) {
								operand->any_array.any.operands[i]->reference_count++;
							} for (unsigned int i = 0; i < operand->any_array.right.length; i++) {
								operand->any_array.right.operands[i]->reference_count++;
							}
						} else if (predicate_index.position == head_position::ANY) {
							if (predicate_index.index + 1 < operand->any_array.any.length) {
								if (!has_intersection<built_in_predicates>(tense_predicate, operand->any_array.any.operands[predicate_index.index + 1])) {
									free(*tense_predicate); free(tense_predicate);
									return (hol_term*) nullptr;
								}
								dst = hol_term::new_exists(head_variable, hol_term::new_any_array(operand->any_array.oper, operand->any_array.all,
										make_replaced_array_view(make_array_view(operand->any_array.any.operands, operand->any_array.any.length), tense_predicate, predicate_index.index + 1),
										make_array_view(operand->any_array.left.operands, operand->any_array.left.length),
										make_array_view(operand->any_array.right.operands, operand->any_array.right.length)));
							} else {
								if (!has_intersection<built_in_predicates>(tense_predicate, operand->any_array.all)) {
									free(*tense_predicate); free(tense_predicate);
									return (hol_term*) nullptr;
								}
								dst = hol_term::new_exists(head_variable, hol_term::new_any_array(operand->any_array.oper, operand->any_array.all,
										make_appended_array_view(make_array_view(operand->any_array.any.operands, operand->any_array.any.length), tense_predicate),
										make_array_view(operand->any_array.left.operands, operand->any_array.left.length),
										make_array_view(operand->any_array.right.operands, operand->any_array.right.length)));
							}
							if (dst == nullptr) {
								free(*tense_predicate); free(tense_predicate);
								return (hol_term*) nullptr;
							}
							operand->any_array.all->reference_count++;
							for (unsigned int i = 0; i < operand->any_array.left.length; i++) {
								operand->any_array.left.operands[i]->reference_count++;
							} for (unsigned int i = 0; i < operand->any_array.any.length; i++) {
								if (i == predicate_index.index + 1) continue;
								operand->any_array.any.operands[i]->reference_count++;
							} for (unsigned int i = 0; i < operand->any_array.right.length; i++) {
								operand->any_array.right.operands[i]->reference_count++;
							}
						} else if (predicate_index.position == head_position::RIGHT) {
							if (predicate_index.index == 0
							 || !has_intersection<built_in_predicates>(tense_predicate, operand->any_array.right.operands[operand->any_array.right.length - predicate_index.index]))
							{
								free(*tense_predicate); free(tense_predicate);
								return (hol_term*) nullptr;
							}
							dst = hol_term::new_exists(head_variable, hol_term::new_any_array(operand->any_array.oper, operand->any_array.all,
									make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
									make_array_view(operand->any_array.left.operands, operand->any_array.left.length),
									make_replaced_array_view(make_array_view(operand->any_array.right.operands, operand->any_array.right.length), tense_predicate, operand->any_array.right.length - predicate_index.index)));
							if (dst == nullptr) {
								free(*tense_predicate); free(tense_predicate);
								return (hol_term*) nullptr;
							}
							operand->any_array.all->reference_count++;
							for (unsigned int i = 0; i < operand->any_array.left.length; i++) {
								operand->any_array.left.operands[i]->reference_count++;
							} for (unsigned int i = 0; i < operand->any_array.any.length; i++) {
								operand->any_array.any.operands[i]->reference_count++;
							} for (unsigned int i = 0; i < operand->any_array.right.length; i++) {
								if (i == operand->any_array.right.length - predicate_index.index) continue;
								operand->any_array.right.operands[i]->reference_count++;
							}
						}
					} else {
						return (hol_term*) nullptr;
					}
				}

				if (negated) {
					hol_term* new_dst = hol_term::new_not(dst);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					dst = new_dst;
				}

				if (old_head->type == hol_term_type::ANY || old_head->type == hol_term_type::ANY_RIGHT) {
					hol_term* new_dst = hol_term::new_any_right(dst, old_head->any.excluded_trees, old_head->any.excluded_tree_count);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < old_head->any.excluded_tree_count; i++)
						old_head->any.excluded_trees[i]->reference_count++;
					dst = new_dst;
				}
				return dst;
			}, no_op()) && dst != nullptr;
}

template<size_t N>
inline bool require_no_tense_predicates(
		hol_term* src, hol_term*& dst,
		const unsigned int (&tense_predicates)[N])
{
	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<true>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker, find_head<built_in_predicates>,
			[tense_predicates](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				hol_term* old_head = head;
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && predicate_index.position != head_position::NONE)
					head = head->any.included;

				bool negated = false;
				if (head->type == hol_term_type::NOT) {
					head = head->unary.operand;
					negated = true;
				}

				hol_term* expected_head;
				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) {
					unsigned int excluded_constant_count = array_length(ARGS) + array_length(ARGS_OF) + N;
					unsigned int* excluded_constants = (unsigned int*) alloca(sizeof(unsigned int) * excluded_constant_count);
					for (unsigned int i = 0; i < array_length(ARGS); i++)
						excluded_constants[i] = ARGS[i];
					for (unsigned int i = 0; i < array_length(ARGS_OF); i++)
						excluded_constants[array_length(ARGS) + i] = ARGS_OF[i];
					for (unsigned int i = 0; i < N; i++)
						excluded_constants[array_length(ARGS) + array_length(ARGS_OF) + i] = tense_predicates[i];

					hol_term* head_var = hol_term::new_variable(head_variable);
					if (head_var == nullptr) return (hol_term*) nullptr;
					constexpr unsigned int additional_excluded_tree_count = 2;
					unsigned int excluded_tree_count = hol_non_head_constants<built_in_predicates>::count() + additional_excluded_tree_count;
					hol_term** excluded_trees = (hol_term**) alloca(sizeof(hol_term*) * excluded_tree_count);
					excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(
							hol_term::new_any_constant(make_array_view(excluded_constants, excluded_constant_count)),
							&HOL_ANY), head_var));
					excluded_trees[1] = hol_term::new_any(hol_term::new_exists(head_variable, &HOL_ANY));
					if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
					if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
					if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr) {
						if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
						free(*head_var); free(head_var);
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < hol_non_head_constants<built_in_predicates>::count(); i++)
						excluded_trees[i + additional_excluded_tree_count] = hol_non_head_constants<built_in_predicates>::get_terms()[i];

					hol_term* expected_predicate = hol_term::new_apply(
							hol_term::new_any(nullptr, excluded_trees, hol_non_head_constants<built_in_predicates>::count() + additional_excluded_tree_count), head_var);
					if (expected_predicate == nullptr) {
						free(*excluded_trees[0]); free(excluded_trees[0]);
						free(*excluded_trees[1]); free(excluded_trees[1]);
						free(*head_var); free(head_var);
						return (hol_term*) nullptr;
					}
					hol_non_head_constants<built_in_predicates>::increment_terms();

					expected_head = hol_term::new_exists(head_variable, hol_term::new_any_array(hol_term_type::AND,
							hol_term::new_any(nullptr, excluded_trees, additional_excluded_tree_count),
							make_array_view(&expected_predicate, 1), make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0)));
					if (expected_head == nullptr) {
						free(*expected_predicate); free(expected_predicate);
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < additional_excluded_tree_count; i++)
						excluded_trees[i]->reference_count++;
				} else {
					hol_term* input_conjunct = hol_term::new_apply(hol_term::new_any_constant(make_array_view(tense_predicates, N)), hol_term::new_variable(head_variable));
					if (input_conjunct == nullptr)
						return (hol_term*) nullptr;

					expected_head = hol_term::new_exists(head_variable, hol_term::new_any_array(hol_term_type::AND, hol_term::new_any(nullptr, &input_conjunct, 1),
							make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0)));
					if (expected_head == nullptr) {
						free(*input_conjunct); free(input_conjunct);
						return (hol_term*) nullptr;
					}
				}

				array<hol_term*> intersection(2);
				intersect<built_in_predicates>(intersection, expected_head, head);
				free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
				if (intersection.length == 0) {
					return (hol_term*) nullptr;
				} else if (intersection.length > 1) {
					fprintf(stderr, "require_no_tense_predicates ERROR: Intersection is not unique.\n");
					for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
					return (hol_term*) nullptr;
				}

				hol_term* dst = intersection[0];
				if (negated) {
					hol_term* new_dst = hol_term::new_not(dst);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					dst = new_dst;
				}

				if (old_head->type == hol_term_type::ANY || old_head->type == hol_term_type::ANY_RIGHT) {
					hol_term* new_dst = hol_term::new_any_right(dst, old_head->any.excluded_trees, old_head->any.excluded_tree_count);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < old_head->any.excluded_tree_count; i++)
						old_head->any.excluded_trees[i]->reference_count++;
					dst = new_dst;
				}
				return dst;
			}, no_op()) && dst != nullptr;
}

inline bool remove_perfect(
		hol_term* src, hol_term*& dst)
{
	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<true>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker, find_head<built_in_predicates>,
			[](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				bool negated = false;
				if (head->type == hol_term_type::NOT) {
					head = head->unary.operand;
					negated = true;
				}

				array<hol_term*> out(1);
				if (!map_tense_predicate<true>(out, head, head_variable, predicate_index, PERFECT_PREDICATES, NON_PERFECT_PREDICATES) || out.length == 0)
					return (hol_term*) nullptr;
				hol_term* dst = out[0];

				if (negated) {
					hol_term* new_dst = hol_term::new_not(dst);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					dst = new_dst;
				}

				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) {
					hol_term* new_dst = hol_term::new_any_right(dst);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					dst = new_dst;
				}
				return dst;
			}, no_op()) && dst != nullptr;
}

inline bool remove_not(
		hol_term* src, hol_term*& dst)
{
	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<true>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker, find_head<built_in_predicates>,
			[](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				hol_term* old_head = head;
				if (head->type == hol_term_type::ANY_RIGHT && head->any.included != nullptr && (head->any.included->type == hol_term_type::NOT || head->any.included->type == hol_term_type::EXISTS))
					head = head->any.included;
				if (head->type == hol_term_type::NOT) {
					head->unary.operand->reference_count++;
					return head->unary.operand;
				} else if (head->type == hol_term_type::EXISTS && old_head->type == hol_term_type::ANY_RIGHT) {
					/* make sure negation is not excluded */
					bool is_excluded = false;
					for (unsigned int i = 0; i < old_head->any.excluded_tree_count; i++) {
						hol_term* tree = old_head->any.excluded_trees[i];
						if ((tree->type == hol_term_type::ANY || tree->type == hol_term_type::ANY_RIGHT) && tree->any.included != nullptr)
							tree = tree->any.included;
						if (tree->type == hol_term_type::NOT && tree->unary.operand->type == hol_term_type::EXISTS
						 && tree->unary.operand->quantifier.variable == head->quantifier.variable
						 && *tree->unary.operand->quantifier.operand == HOL_ANY)
						{
							is_excluded = true;
							break;
						}
					}
					if (is_excluded)
						return (hol_term*) nullptr;
					old_head->reference_count++;
					return old_head;
				} else if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) {
					old_head->reference_count++;
					return old_head;
				} else {
					return (hol_term*) nullptr;
				}
			}, no_op()) && dst != nullptr;
}

inline bool require_no_empty_ref(hol_term* src, hol_term*& dst)
{
	hol_term* hol_empty_ptr = &HOL_EMPTY;
	hol_term* predicate = hol_term::new_apply(
			hol_term::new_any(nullptr, &hol_empty_ptr, 1),
			&hol_term::variables<0>::value);
	if (predicate == nullptr) 
		return false;
	hol_term::variables<0>::value.reference_count++;
	HOL_EMPTY.reference_count++;

	bool result = require_predicate<INT_FAST8_MAX>(src, dst, predicate);
	free(*predicate); if (predicate->reference_count == 0) free(predicate);
	return result;
}

inline bool predicate_only(hol_term* src, hol_term*& dst)
{
	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<true>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker, find_head<built_in_predicates>,
			[](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				hol_term* expected_head = hol_term::new_exists(head_variable, hol_term::new_apply(&HOL_ANY, hol_term::new_variable(head_variable)));
				if (expected_head == nullptr)
					return (hol_term*) nullptr;
				HOL_ANY.reference_count++;

				array<hol_term*> intersection(2);
				intersect<built_in_predicates>(intersection, head, expected_head);
				free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
				if (intersection.length > 1) {
					fprintf(stderr, "predicate_only ERROR: Expected intersection size to be 1.\n");
					for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
					return (hol_term*) nullptr;
				} else if (intersection.length == 0) {
					return (hol_term*) nullptr;
				}

				hol_term* dst = intersection[0]->quantifier.operand->binary.left;
				dst->reference_count++;
				for (unsigned int i = 0; i < intersection.length; i++) {
					hol_term* term = intersection[i];
					free(*term); if (term->reference_count == 0) free(term);
				}
				return dst;
			}, no_op()) && dst != nullptr;
}

inline bool predicate(hol_term* src, hol_term*& dst)
{
	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<true>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker, find_head<built_in_predicates>,
			[](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				hol_term* dst;
				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT
				 || (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY)
				 || (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY_RIGHT))
				{
					dst = &HOL_ANY;
					HOL_ANY.reference_count++;

				} else if (head->type == hol_term_type::EXISTS && (head->quantifier.operand->type == hol_term_type::AND || head->quantifier.operand->type == hol_term_type::ANY_ARRAY)) {
					hol_term* operand = head->quantifier.operand;
					hol_term* predicate = nullptr;
					if (head->quantifier.operand->type == hol_term_type::AND) {
						predicate = operand->array.operands[predicate_index.index];
					} else if (predicate_index.position == head_position::LEFT) {
						predicate = operand->any_array.left.operands[predicate_index.index];
					} else if (predicate_index.position == head_position::RIGHT) {
						predicate = operand->any_array.right.operands[operand->any_array.right.length - predicate_index.index - 1];
					} else {
						predicate = operand->any_array.any.operands[predicate_index.index];
					}

					hol_term* expected_predicate = hol_term::new_apply(&HOL_ANY, hol_term::new_variable(head->quantifier.variable));
					if (expected_predicate == nullptr)
						return (hol_term*) nullptr;
					HOL_ANY.reference_count++;

					array<hol_term*> intersection(2);
					intersect<built_in_predicates>(intersection, predicate, expected_predicate);
					free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
					if (intersection.length > 1) {
						fprintf(stderr, "predicate WARNING: Expected intersection size to be 1.\n");
						for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
						return (hol_term*) nullptr;
					}
					if (intersection.length == 0)
						return (hol_term*) nullptr;

					dst = intersection[0]->binary.left;
					dst->reference_count++;
					for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }

				} else {
					return (hol_term*) nullptr;
				}
				return dst;
			}, no_op()) && dst != nullptr;
}

inline bool predicate_and_tense(
		hol_term* head, hol_term*& dst,
		hol_term* head_variable,
		hol_term* expected_predicate)
{
	hol_term* expected_head = hol_term::new_exists(head_variable->variable, hol_term::new_and(expected_predicate,
			hol_term::new_apply(hol_term::new_any_constant(make_array_view(PAST_OR_PRESENT, array_length(PAST_OR_PRESENT))), head_variable)));
	if (expected_head == nullptr)
		return false;
	expected_predicate->reference_count++;
	head_variable->reference_count++;

	array<hol_term*> intersection(2);
	intersect<built_in_predicates>(intersection, head, expected_head);
	free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
	if (intersection.length > 1) {
		fprintf(stderr, "predicate_and_tense ERROR: Expected intersection size to be 1.\n");
		free_all(intersection); return false;
	} else if (intersection.length == 0) {
		return false;
	}
	dst = intersection[0];
	return true;
}

inline bool predicate_and_tense(
		hol_term* src, hol_term*& dst)
{
	head_index predicate_index; no_op apply;
	auto find_array_head = make_array_finder(find_head<built_in_predicates>);
	hol_term* head = find_head(src, predicate_index, find_array_head, apply);
	if (head == nullptr)
		return false;

	if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
		head = head->any.included;

	unsigned int head_variable;
	if (head->type == hol_term_type::EXISTS) {
		head_variable = head->quantifier.variable;
	} else if (head->type == hol_term_type::ANY_ARRAY) {
		if (head->any_array.all->type == hol_term_type::EXISTS) {
			head_variable = head->any_array.all->quantifier.variable;
		} else if (head->any_array.all->type == hol_term_type::ANY_RIGHT && head->any_array.all->any.included != nullptr && head->any_array.all->any.included->type == hol_term_type::EXISTS) {
			head_variable = head->any_array.all->any.included->quantifier.variable;
		} else if (head->any_array.right.length != 0 && head->any_array.right.operands[head->any_array.right.length - 1]->type == hol_term_type::EXISTS) {
			head_variable = head->any_array.right.operands[head->any_array.right.length - 1]->quantifier.variable;
		} else if (head->any_array.right.length != 0 && head->any_array.right.operands[head->any_array.right.length - 1]->type == hol_term_type::ANY_RIGHT
				&& head->any_array.right.operands[head->any_array.right.length - 1]->any.included != nullptr
				&& head->any_array.right.operands[head->any_array.right.length - 1]->any.included->type == hol_term_type::EXISTS)
		{
			head_variable = head->any_array.right.operands[head->any_array.right.length - 1]->any.included->quantifier.variable;
		} else {
			head_variable = 0;
		}
	} else if (head->type == hol_term_type::AND || head->type == hol_term_type::OR) {
		return false;
	} else {
		head_variable = 0;
	}

	if (head_variable == 0) {
		unsigned int max_variable = 0;
		max_bound_variable(*head, max_variable);
		head_variable = ++max_variable;
	}

	hol_term* src_head;
	if (head->type == hol_term_type::ANY_ARRAY) {
		/* make sure this ANY_ARRAY can be a singleton */
		if (head->any_array.left.length > 1 || head->any_array.right.length > 1 || head->any_array.any.length > 1)
			return false;

		array<hol_term*> intersection(2);
		if (head->any_array.left.length != 0) {
			intersection[0] = head->any_array.left.operands[0];
			intersection[0]->reference_count++;
			intersection.length++;
		} if (head->any_array.right.length != 0) {
			if (intersection.length == 0) {
				intersection[0] = head->any_array.right.operands[0];
				intersection[0]->reference_count++;
				intersection.length++;
			} else {
				array<hol_term*> new_intersection(2);
				for (hol_term* term : intersection)
					intersect<built_in_predicates>(new_intersection, term, head->any_array.right.operands[0]);
				free_all(intersection);
				swap(intersection, new_intersection);
				if (intersection.length == 0)
					return false;
			}
		} if (head->any_array.any.length != 0) {
			if (intersection.length == 0) {
				intersection[0] = head->any_array.any.operands[0];
				intersection[0]->reference_count++;
				intersection.length++;
			} else {
				array<hol_term*> new_intersection(2);
				for (hol_term* term : intersection)
					intersect<built_in_predicates>(new_intersection, term, head->any_array.any.operands[0]);
				free_all(intersection);
				swap(intersection, new_intersection);
				if (intersection.length == 0)
					return false;
			}
		}

		if (intersection.length == 0) {
			src_head = head->any_array.all;
			src_head->reference_count++;
		} else if (intersection.length != 1) {
			fprintf(stderr, "predicate_and_tense ERROR: Intersection is not unique.\n");
			free_all(intersection); return false;
		} else {
			src_head = intersection[0];
		}
	} else {
		src_head = head;
		src_head->reference_count++;
	}

	hol_term* var_term = hol_term::new_variable(head_variable);
	if (var_term == nullptr) {
		free(*src_head); if (src_head->reference_count == 0) free(src_head);
		return false;
	}

	hol_term* expected_predicate = hol_term::new_apply(
			hol_term::new_any(nullptr, hol_non_head_constants<built_in_predicates>::get_terms(), hol_non_head_constants<built_in_predicates>::count()), var_term);
	if (expected_predicate == nullptr) {
		free(*src_head); if (src_head->reference_count == 0) free(src_head);
		free(*var_term); free(var_term); return false;
	}
	var_term->reference_count++;
	hol_non_head_constants<built_in_predicates>::increment_terms();

	bool result = predicate_and_tense(src_head, dst, var_term, expected_predicate);
	free(*src_head); if (src_head->reference_count == 0) free(src_head);
	free(*var_term); if (var_term->reference_count == 0) free(var_term);
	free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
	return result;
}

inline bool empty_and_tense(
		hol_term* src, hol_term*& dst)
{
	head_index predicate_index; no_op apply;
	hol_term* head = find_head(src, predicate_index, find_head<built_in_predicates>, apply);
	if (head == nullptr)
		return false;

	if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
		head = head->any.included;

	unsigned int head_variable;
	if (head->type == hol_term_type::EXISTS) {
		head_variable = head->quantifier.variable;
	} else {
		unsigned int max_variable = 0;
		max_bound_variable(*head, max_variable);
		head_variable = ++max_variable;
	}

	hol_term* var_term = hol_term::new_variable(head_variable);
	if (var_term == nullptr)
		return false;

	hol_term* expected_predicate = hol_term::new_apply(&HOL_EMPTY, var_term);
	if (expected_predicate == nullptr) {
		free(*var_term); free(var_term);
		return false;
	}
	HOL_EMPTY.reference_count++;
	var_term->reference_count++;

	bool result = predicate_and_tense(head, dst, var_term, expected_predicate);
	free(*var_term); if (var_term->reference_count == 0) free(var_term);
	free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
	return result;
}

template<hol_term_type QuantifierType>
inline bool require_predicative_quantifier(hol_term* src, hol_term*& dst)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	bool success = apply_head<true>(src, dst, dst_variables, siblings, max_variable, removed_quantifier, remove_negations, remove_wide_scope_marker,
			predicative_head_finder<built_in_predicates>(lambda_variable),
			[&max_variable,lambda_variable](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				hol_term* old_head = head;
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr
				 && (head->any.included->type == hol_term_type::NOT || head->any.included->type == hol_term_type::EXISTS))
					head = head->any.included;

				bool negated = false;
				if (head->type == hol_term_type::NOT) {
					head = head->unary.operand;
					negated = true;
				}

				hol_term* dst = nullptr;
				unsigned int set_variable, element_variable;
				bool must_have_wide_scope_marker_before_quantifier = false;
				bool could_have_wide_scope_marker_before_quantifier = false;
				bool must_have_wide_scope_marker_before_lambda_term = false;
				bool could_have_wide_scope_marker_before_lambda_term = false;
				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) {
					if (head_variable > max_variable)
						max_variable = head_variable;
					if (head->any.included != nullptr && head->any.included->type == hol_term_type::UNARY_APPLICATION
					 && head->any.included->binary.left->type == hol_term_type::VARIABLE
					 && head->any.included->binary.left->variable == lambda_variable
					 && head->any.included->binary.right->type == hol_term_type::VARIABLE)
					{
						element_variable = head->any.included->binary.right->variable;
						if (element_variable > max_variable)
							max_variable = element_variable;
					} else {
						element_variable = ++max_variable;
					}
					if (head_variable != 0)
						set_variable = head_variable;
					else set_variable = ++max_variable;
					could_have_wide_scope_marker_before_lambda_term = true;
					could_have_wide_scope_marker_before_quantifier = true;
				} else if (head->type == hol_term_type::EXISTS) {
					hol_term* operand = head->quantifier.operand;
					set_variable = head->quantifier.variable;
					if (operand->type == hol_term_type::ANY) {
						element_variable = ++max_variable;
						could_have_wide_scope_marker_before_lambda_term = true;
					} else {
						hol_term* last;
						if (operand->type == hol_term_type::ANY_ARRAY) {
							if (operand->any_array.right.length == 0) {
								fprintf(stderr, "require_predicative_quantifier ERROR: Expected an existentially quantified conjunction with a right-most operand.\n");
								return (hol_term*) nullptr;
							}
							last = operand->any_array.right.operands[operand->any_array.right.length - 1];
						} else if (operand->type == hol_term_type::AND) {
							last = operand->array.operands[operand->array.length - 1];
						} else {
							last = operand;
						}

						bool last_is_any = false;
						if (last->type == hol_term_type::ANY_RIGHT && last->any.included != nullptr) {
							last = last->any.included;
							last_is_any = true;
							could_have_wide_scope_marker_before_quantifier = true;
						} if (last->type == hol_term_type::UNARY_APPLICATION && last->binary.left->type == hol_term_type::CONSTANT && last->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
							last = last->binary.right;
							must_have_wide_scope_marker_before_quantifier = true;
							could_have_wide_scope_marker_before_lambda_term = false;
						}

						while (last->type == hol_term_type::NOT)
							last = operand->unary.operand;

						if (last->type == hol_term_type::ANY_RIGHT && last->any.included != nullptr) {
							last = last->any.included;
							last_is_any = true;
							could_have_wide_scope_marker_before_quantifier = true;
						}

						if (last->type == hol_term_type::ANY_RIGHT) {
							element_variable = ++max_variable;
							could_have_wide_scope_marker_before_quantifier = true;
						} else if (last_is_any && last->type == hol_term_type::UNARY_APPLICATION && last->binary.left->type == hol_term_type::VARIABLE
								&& last->binary.left->variable == lambda_variable && last->binary.right->type == hol_term_type::VARIABLE)
						{
							element_variable = last->binary.right->variable;
							if (last_is_any)
								could_have_wide_scope_marker_before_lambda_term = true;
						} else if (last->type == hol_term_type::ANY_QUANTIFIER && has_intersection(last->any_quantifier.quantifier, (hol_quantifier_type) QuantifierType)
								&& last->any_quantifier.operand->type == hol_term_type::ANY_RIGHT && last->any_quantifier.operand->any.included != nullptr
								&& last->any_quantifier.operand->any.included->type == hol_term_type::UNARY_APPLICATION
								&& last->any_quantifier.operand->any.included->binary.left->type == hol_term_type::VARIABLE
								&& last->any_quantifier.operand->any.included->binary.left->variable == lambda_variable
								&& last->any_quantifier.operand->any.included->binary.right->type == hol_term_type::VARIABLE)
						{
							element_variable = last->any_quantifier.operand->any.included->binary.right->variable;
							if (last_is_any)
								could_have_wide_scope_marker_before_lambda_term = true;
						} else if (last->type != QuantifierType) {
							return (hol_term*) nullptr;
						} else {
							dst = head;
							head->reference_count++;

							hol_term* inner_right = nullptr;
							if (QuantifierType == hol_term_type::EXISTS && last->quantifier.operand->type == hol_term_type::AND)
								inner_right = last->quantifier.operand->array.operands[1];
							else if (QuantifierType == hol_term_type::FOR_ALL && last->quantifier.operand->type == hol_term_type::IF_THEN)
								inner_right = last->quantifier.operand->binary.right;

							if (inner_right != nullptr) {
								if (inner_right->type == hol_term_type::UNARY_APPLICATION && inner_right->binary.left->type == hol_term_type::CONSTANT && inner_right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE)
									must_have_wide_scope_marker_before_lambda_term = true;
								else if (inner_right->type == hol_term_type::ANY || inner_right->type == hol_term_type::ANY_RIGHT)
									could_have_wide_scope_marker_before_lambda_term = true;
							}
						}
					}
				} else {
					return (hol_term*) nullptr;
				}

				if (dst == nullptr) {
					hol_term* element_var = hol_term::new_variable(element_variable);
					if (element_var == nullptr)
						return (hol_term*) nullptr;

					hol_term* lambda_apply_term = hol_term::new_apply(hol_term::new_variable(lambda_variable), element_var);
					if (lambda_apply_term == nullptr) {
						free(*element_var); free(element_var);
						return (hol_term*) nullptr;
					}

					if (must_have_wide_scope_marker_before_lambda_term) {
						hol_term* temp = hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, lambda_apply_term);
						if (temp == nullptr) {
							free(*lambda_apply_term); free(lambda_apply_term);
							return (hol_term*) nullptr;
						}
						hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
						lambda_apply_term = temp;
					} else if (could_have_wide_scope_marker_before_lambda_term) {
						hol_term* excluded_quantifier = hol_term::new_any(hol_term::new_any_quantifier(hol_quantifier_type::ANY, &HOL_ANY));
						if (excluded_quantifier == nullptr) {
							free(*lambda_apply_term); free(lambda_apply_term);
							return (hol_term*) nullptr;
						}
						HOL_ANY.reference_count++;

						hol_term* temp = hol_term::new_any_right(lambda_apply_term, &excluded_quantifier, 1);
						if (temp == nullptr) {
							free(*excluded_quantifier); free(excluded_quantifier);
							free(*lambda_apply_term); free(lambda_apply_term);
							return (hol_term*) nullptr;
						}
						lambda_apply_term = temp;
					}

					hol_term* quantifier;
					if (QuantifierType == hol_term_type::FOR_ALL) {
						/* check if we need to add a WIDE_SCOPE */
						if (!must_have_wide_scope_marker_before_quantifier && can_have_free_variables(*head)) {
							hol_term* excluded_quantifiers[3];
							excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(set_variable, &HOL_ANY));
							excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(set_variable, &HOL_ANY));
							excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(set_variable, &HOL_ANY));
							if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
							if (excluded_quantifiers[1] != nullptr) HOL_ANY.reference_count++;
							if (excluded_quantifiers[2] != nullptr) HOL_ANY.reference_count++;
							if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr) {
								if (excluded_quantifiers[0] != nullptr) { free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]); }
								if (excluded_quantifiers[1] != nullptr) { free(*excluded_quantifiers[1]); free(excluded_quantifiers[1]); }
								free(*lambda_apply_term); free(lambda_apply_term);
								return (hol_term*) nullptr;
							}

							quantifier = hol_term::new_any_right(hol_term::new_for_all(element_variable, hol_term::new_if_then(
									hol_term::new_apply(hol_term::new_variable(set_variable), element_var), lambda_apply_term)),
									excluded_quantifiers, array_length(excluded_quantifiers));
							if (quantifier == nullptr) {
								for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
								free(*lambda_apply_term); free(lambda_apply_term);
								return (hol_term*) nullptr;
							}
							element_var->reference_count++;
						} else {
							quantifier = hol_term::new_apply(
									&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value,
									hol_term::new_for_all(element_variable, hol_term::new_if_then(
										hol_term::new_apply(hol_term::new_variable(set_variable), element_var), lambda_apply_term)));
							if (quantifier == nullptr) {
								free(*lambda_apply_term); free(lambda_apply_term);
								return (hol_term*) nullptr;
							}
							hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
							element_var->reference_count++;
						}
					} else if (QuantifierType == hol_term_type::EXISTS) {
						if (could_have_wide_scope_marker_before_quantifier && !must_have_wide_scope_marker_before_quantifier) {
							hol_term* excluded_quantifiers[3];
							excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(set_variable, &HOL_ANY));
							excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(set_variable, &HOL_ANY));
							excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(set_variable, &HOL_ANY));
							if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
							if (excluded_quantifiers[1] != nullptr) HOL_ANY.reference_count++;
							if (excluded_quantifiers[2] != nullptr) HOL_ANY.reference_count++;
							if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr) {
								if (excluded_quantifiers[0] != nullptr) { free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]); }
								if (excluded_quantifiers[1] != nullptr) { free(*excluded_quantifiers[1]); free(excluded_quantifiers[1]); }
								free(*lambda_apply_term); free(lambda_apply_term);
								return (hol_term*) nullptr;
							}

							quantifier = hol_term::new_any_right(hol_term::new_exists(element_variable, hol_term::new_and(
									hol_term::new_apply(hol_term::new_variable(set_variable), element_var), lambda_apply_term)),
									excluded_quantifiers, array_length(excluded_quantifiers));
							if (quantifier == nullptr) {
								for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
								free(*lambda_apply_term); free(lambda_apply_term);
								return (hol_term*) nullptr;
							}
							element_var->reference_count++;
						} else {
							quantifier = hol_term::new_exists(element_variable, hol_term::new_and(
									hol_term::new_apply(hol_term::new_variable(set_variable), element_var), lambda_apply_term));
							if (quantifier == nullptr) {
								free(*lambda_apply_term); free(lambda_apply_term);
								return (hol_term*) nullptr;
							}
							element_var->reference_count++;
						}
					} else {
						fprintf(stderr, "require_predicative_quantifier ERROR: Unsupported `QuantifierType`.\n");
						free(*lambda_apply_term); free(lambda_apply_term);
						return (hol_term*) nullptr;
					}

					if (must_have_wide_scope_marker_before_quantifier) {
						hol_term* temp = hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, quantifier);
						if (temp == nullptr) {
							free(*quantifier); free(quantifier);
							return (hol_term*) nullptr;
						}
						hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
						quantifier = temp;
					}

					hol_term* new_head;
					if (QuantifierType == hol_term_type::FOR_ALL) {
						hol_term* excluded_set_definition = hol_term::new_equals(hol_term::new_variable(set_variable), hol_term::new_lambda(element_variable, hol_term::new_any(hol_term::new_equals(element_var, &HOL_ANY))));
						if (excluded_set_definition == nullptr) {
							free(*quantifier); free(quantifier);
							return (hol_term*) nullptr;
						}
						element_var->reference_count++;
						HOL_ANY.reference_count++;
						hol_term* left = hol_term::new_any(nullptr, &excluded_set_definition, 1);
						if (left == nullptr) {
							free(*quantifier); free(quantifier);
							free(*excluded_set_definition); free(excluded_set_definition);
							return (hol_term*) nullptr;
						}
						new_head = hol_term::new_exists(set_variable, hol_term::new_any_array(hol_term_type::AND, &HOL_ANY,
								make_array_view((hol_term**) nullptr, 0), make_array_view(&left, 1), make_array_view(&quantifier, 1)));
						if (new_head == nullptr) {
							free(*quantifier); free(quantifier);
							free(*left); free(left);
							return (hol_term*) nullptr;
						}
					} else {
						new_head = hol_term::new_exists(set_variable, hol_term::new_any_array(hol_term_type::AND, &HOL_ANY,
								make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0), make_array_view(&quantifier, 1)));
						if (new_head == nullptr) {
							free(*quantifier); free(quantifier);
							return (hol_term*) nullptr;
						}
					}
					HOL_ANY.reference_count++;

					array<hol_term*> intersection(2);
					intersect<built_in_predicates>(intersection, new_head, head);
					free(*new_head); if (new_head->reference_count == 0) free(new_head);
					if (intersection.length == 0) {
						return (hol_term*) nullptr;
					} else if (intersection.length > 1) {
						fprintf(stderr, "require_predicative_quantifier ERROR: Intersection is not unique.\n");
						for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
						return (hol_term*) nullptr;
					}
					dst = intersection[0];
					for (unsigned int i = 1; i < intersection.length; i++) {
						hol_term* term = intersection[i];
						free(*term); if (term->reference_count == 0) free(term);
					}
				}

				if (negated) {
					hol_term* new_dst = hol_term::new_not(dst);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					dst = new_dst;
				}

				if (old_head->type == hol_term_type::ANY || old_head->type == hol_term_type::ANY_RIGHT) {
					hol_term* new_dst = hol_term::new_any_right(dst);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					dst = new_dst;
				}
				return dst;
			}, no_op()) && dst != nullptr;
	if (!success) return false;

	if (dst->type != hol_term_type::LAMBDA) {
		hol_term* new_dst = hol_term::new_lambda(lambda_variable, dst);
		if (new_dst == nullptr) {
			free(*dst); if (dst->reference_count == 0) free(dst);
			return false;
		}
		dst = new_dst;
	}
	return true;
}

inline bool replace_predicative_lambda_with_existential(hol_term* src, hol_term*& dst)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0, element_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
		if (src->quantifier.operand->type == hol_term_type::ANY || src->quantifier.operand->type == hol_term_type::ANY_RIGHT) {
			element_variable = ++max_variable;
		} else if (src->quantifier.operand->type == hol_term_type::LAMBDA) {
			element_variable = src->quantifier.operand->quantifier.variable;
		} else {
			return false;
		}
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
		element_variable = ++max_variable;
	} else {
		return false;
	}

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<true>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker,
			predicative_head_finder<built_in_predicates>(lambda_variable),
			[&max_variable,lambda_variable,element_variable](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				hol_term* old_head = head;
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr
				 && (head->any.included->type == hol_term_type::NOT || head->any.included->type == hol_term_type::EXISTS))
					head = head->any.included;

				bool negated = false;
				if (head->type == hol_term_type::NOT) {
					head = head->unary.operand;
					negated = true;
				}

				hol_term* dst = nullptr;
				unsigned int set_variable;
				unsigned int new_element_variable = 0;
				bool must_have_wide_scope_marker_before_lambda_term = false;
				bool could_have_wide_scope_marker_before_lambda_term = false;
				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) {
					if (head->any.included != nullptr && head->any.included->type == hol_term_type::UNARY_APPLICATION
					 && head->any.included->binary.left->type == hol_term_type::VARIABLE
					 && head->any.included->binary.left->variable == lambda_variable
					 && head->any.included->binary.right->type == hol_term_type::VARIABLE)
					{
						if (element_variable != head->any.included->binary.right->variable)
							return (hol_term*) nullptr;
					}
					if (head_variable != 0)
						set_variable = head_variable;
					else set_variable = ++max_variable;
					could_have_wide_scope_marker_before_lambda_term = true;
				} else if (head->type == hol_term_type::EXISTS) {
					hol_term* operand = head->quantifier.operand;
					set_variable = head->quantifier.variable;
					if (operand->type == hol_term_type::ANY) {
						could_have_wide_scope_marker_before_lambda_term = true;
					} else {
						hol_term* left = nullptr;
						hol_term* last = nullptr;
						if (operand->type == hol_term_type::ANY_ARRAY) {
							if (operand->any_array.right.length == 0) {
								fprintf(stderr, "replace_predicative_lambda_with_existential ERROR: Expected an existentially quantified conjunction with a right-most operand.\n");
								return (hol_term*) nullptr;
							}
							last = operand->any_array.right.operands[operand->any_array.right.length - 1];
							if (operand->any_array.left.length != 0)
								left = operand->any_array.left.operands[0];
						} else if (operand->type == hol_term_type::AND) {
							last = operand->array.operands[operand->array.length - 1];
							left = operand->array.operands[0];
						} else {
							last = operand;
						}

						hol_term* set_definition = nullptr;
						if (left != nullptr) {
							if (left->type == hol_term_type::EQUALS && left->binary.right->type == hol_term_type::LAMBDA) {
								set_definition = left->binary.right;
							} else if (left->type == hol_term_type::BINARY_APPLICATION && left->ternary.third->type == hol_term_type::LAMBDA) {
								set_definition = left->ternary.third;
							} else if ((left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT) && left->any.included != nullptr && left->any.included->type == hol_term_type::LAMBDA) {
								set_definition = left->any.included;
							}
						}

						if (set_definition != nullptr)
							new_element_variable = set_definition->quantifier.variable;

						if (last->type == hol_term_type::ANY_RIGHT && last->any.included != nullptr) {
							last = last->any.included;
							could_have_wide_scope_marker_before_lambda_term = true;
						} if (last->type == hol_term_type::UNARY_APPLICATION && last->binary.left->type == hol_term_type::CONSTANT && last->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
							last = last->binary.right;
							must_have_wide_scope_marker_before_lambda_term = true;
						}

						while (last->type == hol_term_type::NOT)
							last = operand->unary.operand;

						if (last->type == hol_term_type::UNARY_APPLICATION && last->binary.left->type == hol_term_type::VARIABLE
						 && last->binary.left->variable == lambda_variable && last->binary.right->type == hol_term_type::VARIABLE
						 && last->binary.right->variable == element_variable)
						{
							dst = head;
							head->reference_count++;
						} else if (last->type == hol_term_type::ANY_RIGHT) {
							could_have_wide_scope_marker_before_lambda_term = true;
						} else {
							return (hol_term*) nullptr;
						}
					}
				} else {
					return (hol_term*) nullptr;
				}

				if (new_element_variable == 0)
					new_element_variable = element_variable;

				if (dst == nullptr) {
					hol_term* element_var = hol_term::new_variable(element_variable);
					if (element_var == nullptr)
						return (hol_term*) nullptr;

					hol_term* lambda_apply_term = hol_term::new_apply(hol_term::new_variable(lambda_variable), element_var);
					if (lambda_apply_term == nullptr) {
						free(*element_var); free(element_var);
						return (hol_term*) nullptr;
					}

					if (must_have_wide_scope_marker_before_lambda_term) {
						hol_term* temp = hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, lambda_apply_term);
						if (temp == nullptr) {
							free(*lambda_apply_term); free(lambda_apply_term);
							return (hol_term*) nullptr;
						}
						hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
						lambda_apply_term = temp;
					} else if (could_have_wide_scope_marker_before_lambda_term) {
						hol_term* excluded_quantifiers[3];
						excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(element_variable, &HOL_ANY));
						excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(element_variable, &HOL_ANY));
						excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(element_variable, &HOL_ANY));
						if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
						if (excluded_quantifiers[1] != nullptr) HOL_ANY.reference_count++;
						if (excluded_quantifiers[2] != nullptr) HOL_ANY.reference_count++;
						if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr) {
							if (excluded_quantifiers[0] != nullptr) { free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]); }
							if (excluded_quantifiers[1] != nullptr) { free(*excluded_quantifiers[1]); free(excluded_quantifiers[1]); }
							free(*lambda_apply_term); free(lambda_apply_term);
							return (hol_term*) nullptr;
						}

						hol_term* temp = hol_term::new_any_right(lambda_apply_term, excluded_quantifiers, array_length(excluded_quantifiers));
						if (temp == nullptr) {
								for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
							free(*lambda_apply_term); free(lambda_apply_term);
							return (hol_term*) nullptr;
						}
						lambda_apply_term = temp;
					}

					hol_term* set_apply_term = hol_term::new_apply(hol_term::new_variable(set_variable), element_var);
					if (set_apply_term == nullptr) {
						free(*lambda_apply_term); free(lambda_apply_term);
						return (hol_term*) nullptr;
					}
					element_var->reference_count++;

					hol_term* right_terms[2];
					right_terms[0] = set_apply_term;
					right_terms[1] = lambda_apply_term;
					hol_term* new_head = hol_term::new_exists(set_variable, hol_term::new_any_array(hol_term_type::AND, &HOL_ANY,
							make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0), make_array_view(right_terms, 2)));
					if (new_head == nullptr) {
						free(*set_apply_term); free(set_apply_term);
						free(*lambda_apply_term); free(set_apply_term);
						return (hol_term*) nullptr;
					}
					HOL_ANY.reference_count++;

					array<hol_term*> intersection(2);
					intersect<built_in_predicates>(intersection, new_head, head);
					free(*new_head); if (new_head->reference_count == 0) free(new_head);
					if (intersection.length == 0) {
						return (hol_term*) nullptr;
					} else if (intersection.length > 1) {
						fprintf(stderr, "replace_predicative_lambda_with_existential ERROR: Intersection is not unique.\n");
						for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
						return (hol_term*) nullptr;
					}
					dst = intersection[0];
					for (unsigned int i = 1; i < intersection.length; i++) {
						hol_term* term = intersection[i];
						free(*term); if (term->reference_count == 0) free(term);
					}
				}

				hol_term* new_element_var = hol_term::new_variable(new_element_variable);
				if (new_element_var == nullptr) {
					free(*dst); if (dst->reference_count == 0) free(dst);
					return (hol_term*) nullptr;
				}

				hol_term* new_quantified_term = hol_term::new_exists(new_element_variable, hol_term::new_and(
						hol_term::new_apply(hol_term::new_variable(set_variable), new_element_var),
						hol_term::new_apply(hol_term::new_variable(lambda_variable), new_element_var)));
				if (new_quantified_term == nullptr) {
					free(*new_element_var); free(new_element_var);
					free(*dst); if (dst->reference_count == 0) free(dst);
					return (hol_term*) nullptr;
				}
				new_element_var->reference_count += 2 - 1;

				hol_term* right;
				hol_term* operand = dst->quantifier.operand;
				if (operand->type == hol_term_type::AND) {
					right = operand->array.operands[operand->array.length - 1];
				} else {
					right = operand->any_array.right.operands[operand->any_array.right.length - 1];
				}

				if (right->type == hol_term_type::UNARY_APPLICATION && right->binary.left->type == hol_term_type::CONSTANT
				 && right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE)
				{
					hol_term* temp = hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, new_quantified_term);
					if (temp == nullptr) {
						free(*new_quantified_term); free(new_quantified_term);
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
					new_quantified_term = temp;
				}

				hol_term* new_operand;
				if (operand->type == hol_term_type::AND) {
					new_operand = hol_term::new_and(make_appended_array_view(make_array_view(operand->array.operands, operand->array.length - 2), new_quantified_term));
					if (new_operand == nullptr) {
						free(*new_quantified_term); free(new_quantified_term);
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i + 1 < new_operand->array.length; i++)
						new_operand->array.operands[i]->reference_count++;
				} else {
					new_operand = hol_term::new_any_array(hol_term_type::AND, operand->any_array.all,
							make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
							make_array_view(operand->any_array.left.operands, operand->any_array.left.length),
							make_appended_array_view(make_array_view(operand->any_array.right.operands, max(2u, operand->any_array.right.length) - 2), new_quantified_term));
					if (new_operand == nullptr) {
						free(*new_quantified_term); free(new_quantified_term);
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					new_operand->any_array.all->reference_count++;
					for (unsigned int i = 0; i < new_operand->any_array.any.length; i++)
						new_operand->any_array.any.operands[i]->reference_count++;
					for (unsigned int i = 0; i < new_operand->any_array.left.length; i++)
						new_operand->any_array.left.operands[i]->reference_count++;
					for (unsigned int i = 0; i + 1 < new_operand->any_array.right.length; i++)
						new_operand->any_array.right.operands[i]->reference_count++;
				}
				free(*dst); if (dst->reference_count == 0) free(dst);

				dst = hol_term::new_exists(set_variable, new_operand);
				if (dst == nullptr) {
					free(*new_operand); free(new_operand);
					return (hol_term*) nullptr;
				}

				if (negated) {
					hol_term* new_dst = hol_term::new_not(dst);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					dst = new_dst;
				}

				if (old_head->type == hol_term_type::ANY || old_head->type == hol_term_type::ANY_RIGHT) {
					hol_term* new_dst = hol_term::new_any_right(dst);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					dst = new_dst;
				}
				return dst;
			}, no_op()) && dst != nullptr;
}

template<hol_term_type SrcQuantifierType, hol_term_type DstQuantifierType>
inline bool replace_predicative_quantifier(hol_term* src, hol_term*& dst)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	bool success = apply_head<true>(src, dst, dst_variables, siblings, max_variable, removed_quantifier, remove_negations, remove_wide_scope_marker,
			predicative_head_finder<built_in_predicates>(lambda_variable),
			[&max_variable,lambda_variable](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				hol_term* old_head = head;
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr
				 && (head->any.included->type == hol_term_type::NOT || head->any.included->type == hol_term_type::EXISTS))
					head = head->any.included;

				bool negated = false;
				if (head->type == hol_term_type::NOT) {
					head = head->unary.operand;
					negated = true;
				}

				hol_term* dst = nullptr;
				unsigned int set_variable, element_variable;
				bool must_have_wide_scope_marker_before_quantifier = false;
				bool could_have_wide_scope_marker_before_quantifier = false;
				bool must_have_wide_scope_marker_before_lambda_term = false;
				bool could_have_wide_scope_marker_before_lambda_term = false;
				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) {
					if (head_variable > max_variable)
						max_variable = head_variable;
					if (head->any.included != nullptr && head->any.included->type == hol_term_type::UNARY_APPLICATION
					 && head->any.included->binary.left->type == hol_term_type::VARIABLE
					 && head->any.included->binary.left->variable == lambda_variable
					 && head->any.included->binary.right->type == hol_term_type::VARIABLE)
					{
						element_variable = head->any.included->binary.right->variable;
						if (element_variable > max_variable)
							max_variable = element_variable;
					} else {
						element_variable = ++max_variable;
					}
					if (head_variable != 0)
						set_variable = head_variable;
					else set_variable = ++max_variable;
					could_have_wide_scope_marker_before_lambda_term = true;
					could_have_wide_scope_marker_before_quantifier = true;
				} else if (head->type == hol_term_type::EXISTS) {
					hol_term* operand = head->quantifier.operand;
					set_variable = head->quantifier.variable;
					if (operand->type == hol_term_type::ANY) {
						element_variable = ++max_variable;
						could_have_wide_scope_marker_before_lambda_term = true;
					} else {
						hol_term* last;
						if (operand->type == hol_term_type::ANY_ARRAY) {
							if (operand->any_array.right.length == 0) {
								fprintf(stderr, "replace_predicative_quantifier ERROR: Expected an existentially quantified conjunction with a right-most operand.\n");
								return (hol_term*) nullptr;
							}
							last = operand->any_array.right.operands[operand->any_array.right.length - 1];
						} else if (operand->type == hol_term_type::AND) {
							last = operand->array.operands[operand->array.length - 1];
						} else {
							last = operand;
						}

						bool last_is_any = false;
						if (last->type == hol_term_type::ANY_RIGHT && last->any.included != nullptr) {
							last = last->any.included;
							last_is_any = true;
							could_have_wide_scope_marker_before_quantifier = true;
						} if (last->type == hol_term_type::UNARY_APPLICATION && last->binary.left->type == hol_term_type::CONSTANT && last->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
							last = last->binary.right;
							must_have_wide_scope_marker_before_quantifier = true;
							could_have_wide_scope_marker_before_lambda_term = false;
						}

						while (last->type == hol_term_type::NOT)
							last = operand->unary.operand;

						if (last->type == hol_term_type::ANY_RIGHT && last->any.included != nullptr) {
							last = last->any.included;
							last_is_any = true;
							could_have_wide_scope_marker_before_quantifier = true;
						}

						if (last->type == hol_term_type::ANY_RIGHT) {
							element_variable = ++max_variable;
							could_have_wide_scope_marker_before_quantifier = true;
						} else if (last_is_any && last->type == hol_term_type::UNARY_APPLICATION && last->binary.left->type == hol_term_type::VARIABLE
								&& last->binary.left->variable == lambda_variable && last->binary.right->type == hol_term_type::VARIABLE)
						{
							element_variable = last->binary.right->variable;
							if (last_is_any)
								could_have_wide_scope_marker_before_lambda_term = true;
						} else if (last->type != SrcQuantifierType) {
							return (hol_term*) nullptr;
						} else {
							dst = head;
							head->reference_count++;

							hol_term* inner_right = nullptr;
							if (SrcQuantifierType == hol_term_type::EXISTS && last->quantifier.operand->type == hol_term_type::AND)
								inner_right = last->quantifier.operand->array.operands[1];
							else if (SrcQuantifierType == hol_term_type::FOR_ALL && last->quantifier.operand->type == hol_term_type::IF_THEN)
								inner_right = last->quantifier.operand->binary.right;

							if (inner_right != nullptr) {
								if (inner_right->type == hol_term_type::UNARY_APPLICATION && inner_right->binary.left->type == hol_term_type::CONSTANT && inner_right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE)
									must_have_wide_scope_marker_before_lambda_term = true;
								else if (inner_right->type == hol_term_type::ANY || inner_right->type == hol_term_type::ANY_RIGHT)
									could_have_wide_scope_marker_before_lambda_term = true;
							}
						}
					}
				} else {
					return (hol_term*) nullptr;
				}

				if (dst == nullptr) {
					hol_term* element_var = hol_term::new_variable(element_variable);
					if (element_var == nullptr)
						return (hol_term*) nullptr;

					hol_term* lambda_apply_term = hol_term::new_apply(hol_term::new_variable(lambda_variable), element_var);
					if (lambda_apply_term == nullptr) {
						free(*element_var); free(element_var);
						return (hol_term*) nullptr;
					}

					if (must_have_wide_scope_marker_before_lambda_term) {
						hol_term* temp = hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, lambda_apply_term);
						if (temp == nullptr) {
							free(*lambda_apply_term); free(lambda_apply_term);
							return (hol_term*) nullptr;
						}
						hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
						lambda_apply_term = temp;
					} else if (could_have_wide_scope_marker_before_lambda_term) {
						hol_term* excluded_quantifiers[3];
						excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(element_variable, &HOL_ANY));
						excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(element_variable, &HOL_ANY));
						excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(element_variable, &HOL_ANY));
						if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
						if (excluded_quantifiers[1] != nullptr) HOL_ANY.reference_count++;
						if (excluded_quantifiers[2] != nullptr) HOL_ANY.reference_count++;
						if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr) {
							if (excluded_quantifiers[0] != nullptr) { free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]); }
							if (excluded_quantifiers[1] != nullptr) { free(*excluded_quantifiers[1]); free(excluded_quantifiers[1]); }
							free(*lambda_apply_term); free(lambda_apply_term);
							return (hol_term*) nullptr;
						}

						hol_term* temp = hol_term::new_any_right(lambda_apply_term, excluded_quantifiers, array_length(excluded_quantifiers));
						if (temp == nullptr) {
								for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
							free(*lambda_apply_term); free(lambda_apply_term);
							return (hol_term*) nullptr;
						}
						lambda_apply_term = temp;
					}

					hol_term* quantifier;
					if (SrcQuantifierType == hol_term_type::FOR_ALL) {
						/* check if we need to add a WIDE_SCOPE */
						if (!must_have_wide_scope_marker_before_quantifier && can_have_free_variables(*head)) {
							hol_term* excluded_quantifiers[3];
							excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(set_variable, &HOL_ANY));
							excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(set_variable, &HOL_ANY));
							excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(set_variable, &HOL_ANY));
							if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
							if (excluded_quantifiers[1] != nullptr) HOL_ANY.reference_count++;
							if (excluded_quantifiers[2] != nullptr) HOL_ANY.reference_count++;
							if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr) {
								if (excluded_quantifiers[0] != nullptr) { free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]); }
								if (excluded_quantifiers[1] != nullptr) { free(*excluded_quantifiers[1]); free(excluded_quantifiers[1]); }
								free(*lambda_apply_term); free(lambda_apply_term);
								return (hol_term*) nullptr;
							}

							quantifier = hol_term::new_any_right(hol_term::new_for_all(element_variable, hol_term::new_if_then(
									hol_term::new_apply(hol_term::new_variable(set_variable), element_var), lambda_apply_term)),
									excluded_quantifiers, array_length(excluded_quantifiers));
							if (quantifier == nullptr) {
								for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
								free(*lambda_apply_term); free(lambda_apply_term);
								return (hol_term*) nullptr;
							}
							element_var->reference_count++;
						} else {
							quantifier = hol_term::new_apply(
									&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value,
									hol_term::new_for_all(element_variable, hol_term::new_if_then(
										hol_term::new_apply(hol_term::new_variable(set_variable), element_var), lambda_apply_term)));
							if (quantifier == nullptr) {
								free(*lambda_apply_term); free(lambda_apply_term);
								return (hol_term*) nullptr;
							}
							hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
							element_var->reference_count++;
						}
					} else if (SrcQuantifierType == hol_term_type::EXISTS) {
						if (could_have_wide_scope_marker_before_quantifier && !must_have_wide_scope_marker_before_quantifier) {
							hol_term* excluded_quantifiers[3];
							excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(set_variable, &HOL_ANY));
							excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(set_variable, &HOL_ANY));
							excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(set_variable, &HOL_ANY));
							if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
							if (excluded_quantifiers[1] != nullptr) HOL_ANY.reference_count++;
							if (excluded_quantifiers[2] != nullptr) HOL_ANY.reference_count++;
							if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr) {
								if (excluded_quantifiers[0] != nullptr) { free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]); }
								if (excluded_quantifiers[1] != nullptr) { free(*excluded_quantifiers[1]); free(excluded_quantifiers[1]); }
								free(*lambda_apply_term); free(lambda_apply_term);
								return (hol_term*) nullptr;
							}

							quantifier = hol_term::new_any_right(hol_term::new_exists(element_variable, hol_term::new_and(
									hol_term::new_apply(hol_term::new_variable(set_variable), element_var), lambda_apply_term)),
									excluded_quantifiers, array_length(excluded_quantifiers));
							if (quantifier == nullptr) {
								for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
								free(*lambda_apply_term); free(lambda_apply_term);
								return (hol_term*) nullptr;
							}
							element_var->reference_count++;
						} else {
							quantifier = hol_term::new_exists(element_variable, hol_term::new_and(
									hol_term::new_apply(hol_term::new_variable(set_variable), element_var), lambda_apply_term));
							if (quantifier == nullptr) {
								free(*lambda_apply_term); free(lambda_apply_term);
								return (hol_term*) nullptr;
							}
							element_var->reference_count++;
						}
					} else {
						fprintf(stderr, "replace_predicative_quantifier ERROR: Unsupported `SrcQuantifierType`.\n");
						free(*lambda_apply_term); free(lambda_apply_term);
						return (hol_term*) nullptr;
					}

					if (must_have_wide_scope_marker_before_quantifier) {
						hol_term* temp = hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, quantifier);
						if (temp == nullptr) {
							free(*quantifier); free(quantifier);
							return (hol_term*) nullptr;
						}
						hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
						quantifier = temp;
					}

					hol_term* new_head;
					if (SrcQuantifierType == hol_term_type::FOR_ALL) {
						hol_term* excluded_set_definition = hol_term::new_equals(hol_term::new_variable(set_variable), hol_term::new_lambda(element_variable, hol_term::new_any(hol_term::new_equals(element_var, &HOL_ANY))));
						if (excluded_set_definition == nullptr) {
							free(*quantifier); free(quantifier);
							return (hol_term*) nullptr;
						}
						element_var->reference_count++;
						HOL_ANY.reference_count++;
						hol_term* left = hol_term::new_any(nullptr, &excluded_set_definition, 1);
						if (left == nullptr) {
							free(*quantifier); free(quantifier);
							free(*excluded_set_definition); free(excluded_set_definition);
							return (hol_term*) nullptr;
						}
						new_head = hol_term::new_exists(set_variable, hol_term::new_any_array(hol_term_type::AND, &HOL_ANY,
								make_array_view((hol_term**) nullptr, 0), make_array_view(&left, 1), make_array_view(&quantifier, 1)));
						if (new_head == nullptr) {
							free(*quantifier); free(quantifier);
							free(*left); free(left);
							return (hol_term*) nullptr;
						}
					} else {
						new_head = hol_term::new_exists(set_variable, hol_term::new_any_array(hol_term_type::AND, &HOL_ANY,
								make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0), make_array_view(&quantifier, 1)));
						if (new_head == nullptr) {
							free(*quantifier); free(quantifier);
							return (hol_term*) nullptr;
						}
					}
					HOL_ANY.reference_count++;

					array<hol_term*> intersection(2);
					intersect<built_in_predicates>(intersection, new_head, head);
					free(*new_head); if (new_head->reference_count == 0) free(new_head);
					if (intersection.length == 0) {
						return (hol_term*) nullptr;
					} else if (intersection.length > 1) {
						fprintf(stderr, "replace_predicative_quantifier ERROR: Intersection is not unique.\n");
						for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
						return (hol_term*) nullptr;
					}
					dst = intersection[0];
					for (unsigned int i = 1; i < intersection.length; i++) {
						hol_term* term = intersection[i];
						free(*term); if (term->reference_count == 0) free(term);
					}
				}

				hol_term* operand = dst->quantifier.operand;
				hol_term* right;
				if (operand->type == hol_term_type::AND) {
					right = operand->array.operands[operand->array.length - 1];
				} else {
					right = operand->any_array.right.operands[operand->any_array.right.length - 1];
				}

				if (right->type == hol_term_type::UNARY_APPLICATION && right->binary.left->type == hol_term_type::CONSTANT && right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE)
					right = right->binary.right;
				if (right->type == hol_term_type::ANY_RIGHT && right->any.included != nullptr)
					right = right->any.included;

				hol_term* new_right;
				if (DstQuantifierType == hol_term_type::EXISTS) {
					new_right = hol_term::new_exists(right->quantifier.variable, hol_term::new_and(right->quantifier.operand->binary.left, right->quantifier.operand->binary.right));
					if (new_right == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					right->quantifier.operand->binary.left->reference_count++;
					right->quantifier.operand->binary.right->reference_count++;
				} else if (DstQuantifierType == hol_term_type::FOR_ALL) {
					new_right = hol_term::new_for_all(right->quantifier.variable, hol_term::new_if_then(right->quantifier.operand->array.operands[0], right->quantifier.operand->array.operands[1]));
					if (new_right == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					right->quantifier.operand->array.operands[0]->reference_count++;
					right->quantifier.operand->array.operands[1]->reference_count++;
				} else {
					fprintf(stderr, "replace_predicative_quantifier ERROR: Unsupported `DstQuantifierType`.\n");
					free(*dst); if (dst->reference_count == 0) free(dst);
					return (hol_term*) nullptr;
				}

				hol_term* new_dst = substitute_head<any_node_position::NONE>(dst, right, new_right);
				free(*dst); if (dst->reference_count == 0) free(dst);
				free(*new_right); if (new_right->reference_count == 0) free(new_right);
				dst = new_dst;

				if (negated) {
					hol_term* new_dst = hol_term::new_not(dst);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					dst = new_dst;
				}

				if (old_head->type == hol_term_type::ANY || old_head->type == hol_term_type::ANY_RIGHT) {
					hol_term* new_dst = hol_term::new_any_right(dst);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					dst = new_dst;
				}
				return dst;
			}, no_op()) && dst != nullptr;
	if (!success) return false;

	if (dst->type != hol_term_type::LAMBDA) {
		hol_term* new_dst = hol_term::new_lambda(lambda_variable, dst);
		if (new_dst == nullptr) {
			free(*dst); if (dst->reference_count == 0) free(dst);
			return false;
		}
		dst = new_dst;
	}
	return true;
}

inline bool remove_predicative_not(hol_term* src, hol_term*& dst)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<true>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker,
			predicative_head_finder<built_in_predicates>(lambda_variable),
			[](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr && head->any.included->type == hol_term_type::EXISTS)
					head = head->any.included;

				bool could_have_not = false;
				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) {
					head->reference_count++;
					return head;
				} else if (head->type != hol_term_type::EXISTS) {
					return (hol_term*) nullptr;
				}

				hol_term* operand = head->quantifier.operand;
				if (operand->type == hol_term_type::ANY) {
					head->reference_count++;
					return head;
				}

				hol_term* last;
				if (operand->type == hol_term_type::ANY_ARRAY) {
					if (operand->any_array.right.length == 0) {
						fprintf(stderr, "remove_predicative_not ERROR: Expected an existentially quantified conjunction with a right-most operand.\n");
						return (hol_term*) nullptr;
					}
					last = operand->any_array.right.operands[operand->any_array.right.length - 1];
				} else if (operand->type == hol_term_type::AND) {
					last = operand->array.operands[operand->array.length - 1];
				} else {
					last = operand;
				}

				if (last->type == hol_term_type::ANY_RIGHT && last->any.included != nullptr) {
					last = last->any.included;
					could_have_not = true;
				} if (last->type == hol_term_type::UNARY_APPLICATION && last->binary.left->type == hol_term_type::CONSTANT && last->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
					last = last->binary.right;
				}

				if (last->type == hol_term_type::NOT)
					return substitute_head<any_node_position::NONE>(head, last, last->unary.operand);

				if (!could_have_not) {
					return (hol_term*) nullptr;
				} else {
					head->reference_count++;
					return head;
				}
			}, no_op()) && dst != nullptr;
}

inline bool get_predicative_set_variables(
		hol_term* head, unsigned int lambda_variable, hol_term*& left, hol_term*& set_definition,
		unsigned int& set_variable, unsigned int& element_variable, unsigned int& max_variable)
{
	if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr && head->any.included->type == hol_term_type::EXISTS)
		head = head->any.included;

	left = nullptr; set_definition = nullptr;
	set_variable = 0; element_variable = 0;
	if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) {
		if (head->any.included != nullptr && head->any.included->type == hol_term_type::UNARY_APPLICATION
		 && head->any.included->binary.left->type == hol_term_type::VARIABLE
		 && head->any.included->binary.left->constant == lambda_variable
		 && head->any.included->binary.right->type == hol_term_type::VARIABLE)
		{
			element_variable = head->any.included->binary.right->variable;
			max_variable = max(max_variable, element_variable);
			set_variable = ++max_variable;
		} else {
			set_variable = ++max_variable;
			element_variable = ++max_variable;
		}
	} else {
#if !defined(NDEBUG)
		if (head->type != hol_term_type::EXISTS) {
			fprintf(stderr, "get_predicative_set_variables ERROR: Expected existential quantification of set.\n");
			return false;
		}
#endif

		hol_term* operand = head->quantifier.operand;
		set_variable = head->quantifier.variable;
		if (operand->type == hol_term_type::ANY) {
			if (head->any.included != nullptr && head->any.included->type == hol_term_type::UNARY_APPLICATION
				&& head->any.included->binary.left->type == hol_term_type::VARIABLE
				&& head->any.included->binary.left->variable == lambda_variable
				&& head->any.included->binary.right->type == hol_term_type::VARIABLE)
			{
				element_variable = head->any.included->binary.right->variable;
				if (element_variable > max_variable)
					max_variable = element_variable;
			} else {
				element_variable = ++max_variable;
			}
		} else {
			hol_term* last;
			if (operand->type == hol_term_type::ANY_ARRAY) {
				if (operand->any_array.right.length == 0) {
					fprintf(stderr, "get_predicative_set_variables ERROR: Expected an existentially quantified conjunction with a right-most operand.\n");
					return false;
				}
				last = operand->any_array.right.operands[operand->any_array.right.length - 1];
				if (operand->any_array.left.length != 0)
					left = operand->any_array.left.operands[0];
			} else if (operand->type == hol_term_type::AND) {
				last = operand->array.operands[operand->array.length - 1];
				left = operand->array.operands[0];
			} else {
				last = operand;
				left = operand;
			}

			if (left != nullptr) {
				if ((left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT) && left->any.included != nullptr) {
					set_definition = left->any.included;
				} else if (left->type == hol_term_type::EQUALS) {
					set_definition = left->binary.right;
				} else if (left->type == hol_term_type::BINARY_APPLICATION) {
					set_definition = left->ternary.third;
				}

				if (set_definition != nullptr && set_definition->type == hol_term_type::LAMBDA)
					element_variable = set_definition->quantifier.variable;
			}

			if (element_variable == 0) {
				bool last_is_any = false;
				if ((last->type == hol_term_type::ANY || last->type == hol_term_type::ANY_RIGHT) && last->any.included != nullptr) {
					last = last->any.included;
					last_is_any = true;
				} if (last->type == hol_term_type::UNARY_APPLICATION && last->binary.left->type == hol_term_type::CONSTANT && last->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
					last = last->binary.right;
				}

				while (last->type == hol_term_type::NOT)
					last = operand->unary.operand;

				if (last->type == hol_term_type::ANY) {
					element_variable = ++max_variable;
				} else if (last_is_any && last->type == hol_term_type::UNARY_APPLICATION && last->binary.left->type == hol_term_type::VARIABLE
						&& last->binary.left->variable == lambda_variable && last->binary.right->type == hol_term_type::VARIABLE)
				{
					element_variable = last->binary.right->variable;
				} else if (last->type == hol_term_type::FOR_ALL || last->type == hol_term_type::EXISTS) {
					element_variable = last->quantifier.variable;
				} else {
					return false;
				}
			}
		}
	}

	return true;
}

template<bool UniqueOutput, bool StorePredicates, bool AllowEquality, bool EqualityOnly, bool AllowSubset>
inline bool select_predicate_in_set(array<hol_term*>& out, hol_term* head,
		hol_term* predicate, unsigned int max_variable, unsigned int lambda_variable)
{
	static_assert(AllowEquality || !EqualityOnly, "Both `AllowEquality` cannot be false and `EqualityOnly` be true.");

	if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr && head->any.included->type == hol_term_type::EXISTS)
		head = head->any.included;

	hol_term* left; hol_term* set_definition;
	unsigned int set_variable, element_variable;
	if (!get_predicative_set_variables(head, lambda_variable, left, set_definition, set_variable, element_variable, max_variable))
		return false;

	hol_term* excluded_quantifiers[4];
	excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(set_variable, &HOL_ANY));
	excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(set_variable, &HOL_ANY));
	excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(set_variable, &HOL_ANY));
	excluded_quantifiers[3] = &hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value;
	if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
	if (excluded_quantifiers[1] != nullptr) HOL_ANY.reference_count++;
	if (excluded_quantifiers[2] != nullptr) HOL_ANY.reference_count++;
	if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr) {
		if (excluded_quantifiers[0] != nullptr) { free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]); }
		if (excluded_quantifiers[1] != nullptr) { free(*excluded_quantifiers[1]); free(excluded_quantifiers[1]); }
		if (excluded_quantifiers[2] != nullptr) { free(*excluded_quantifiers[2]); free(excluded_quantifiers[2]); }
		return (hol_term*) nullptr;
	}
	hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;

	hol_term* excluded_lambdas[3];
	excluded_lambdas[0] = hol_term::new_any(hol_term::new_exists(element_variable, &HOL_ANY));
	excluded_lambdas[1] = hol_term::new_any(hol_term::new_for_all(element_variable, &HOL_ANY));
	excluded_lambdas[2] = hol_term::new_any(hol_term::new_lambda(element_variable, &HOL_ANY));
	if (excluded_lambdas[0] != nullptr) HOL_ANY.reference_count++;
	if (excluded_lambdas[1] != nullptr) HOL_ANY.reference_count++;
	if (excluded_lambdas[2] != nullptr) HOL_ANY.reference_count++;
	if (excluded_lambdas[0] == nullptr || excluded_lambdas[1] == nullptr || excluded_lambdas[2] == nullptr) {
		if (excluded_lambdas[0] != nullptr) { free(*excluded_lambdas[0]); free(excluded_lambdas[0]); }
		if (excluded_lambdas[1] != nullptr) { free(*excluded_lambdas[1]); free(excluded_lambdas[1]); }
		for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
		return (hol_term*) nullptr;
	}

	hol_term* excluded_trees[array_length(excluded_quantifiers) + array_length(excluded_lambdas)];
	for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++)
		excluded_trees[i] = excluded_quantifiers[i];
	for (unsigned int i = 0; i < array_length(excluded_lambdas); i++)
		excluded_trees[array_length(excluded_quantifiers) + i] = excluded_lambdas[i];
	hol_term* expected_predicate = hol_term::new_any(nullptr, excluded_trees, array_length(excluded_trees));
	if (expected_predicate == nullptr) {
		for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
		for (unsigned int i = 0; i < array_length(excluded_lambdas); i++) { free(*excluded_lambdas[i]); free(excluded_lambdas[i]); }
		return false;
	}
	for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++)
		excluded_quantifiers[i]->reference_count++;

	array<hol_term*> predicates(2);
	intersect<built_in_predicates>(predicates, expected_predicate, predicate);
	free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
	if (predicates.length == 0) {
		for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
		return false;
	} else if (predicates.length != 1) {
		fprintf(stderr, "select_predicate_in_set ERROR: Not implemented.\n");
		free_all(predicates);
		for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
		return false;
	}

	if (AllowEquality && (left == nullptr || left->type == hol_term_type::EQUALS)) {
		array<hol_term*> filtered_predicates(2);
		if (UniqueOutput && StorePredicates) {
			filtered_predicates[0] = predicates[0];
			predicates[0]->reference_count++;
			filtered_predicates.length = 1;
		} else {
			hol_term* excluded_predicates = hol_term::new_any_constant(
					(unsigned int) built_in_predicates::HAS,
					(unsigned int) built_in_predicates::EXIST,
					(unsigned int) built_in_predicates::SAME,
					(unsigned int) built_in_predicates::NAME);
			if (excluded_predicates == nullptr) {
				free_all(predicates);
				for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
				return false;
			}
			subtract<built_in_predicates>(filtered_predicates, predicates[0], excluded_predicates);
			free(*excluded_predicates); if (excluded_predicates->reference_count == 0) free(excluded_predicates);
		}

		if (filtered_predicates.length > 1) {
			fprintf(stderr, "select_predicate_in_set ERROR: Not implemented.\n");
			free_all(predicates); free_all(filtered_predicates);
			for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
			return false;
		} else if (filtered_predicates.length == 1) {
			hol_term* first_expected_head = hol_term::new_exists(set_variable, hol_term::new_and(
					hol_term::new_equals(hol_term::new_variable(set_variable), hol_term::new_lambda(element_variable, hol_term::new_equals(hol_term::new_variable(element_variable), filtered_predicates[0]))),
					hol_term::new_any(nullptr, excluded_quantifiers, array_length(excluded_quantifiers))));
			if (first_expected_head == nullptr) {
				free_all(predicates); free_all(filtered_predicates);
				for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
				return false;
			}
			filtered_predicates[0]->reference_count++;
			for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++)
				excluded_quantifiers[i]->reference_count++;

			intersect<built_in_predicates>(out, first_expected_head, head);
			free(*first_expected_head); if (first_expected_head->reference_count == 0) free(first_expected_head);
			if (UniqueOutput && out.length > 1) {
				fprintf(stderr, "select_predicate_in_set ERROR: Intersection is not unique.\n");
				for (hol_term* term : out) { free(*term); if (term->reference_count == 0) free(term); }
				for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
					free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
				}
				free_all(predicates); free_all(filtered_predicates);
				return false;
			}

			for (unsigned int i = 0; StorePredicates && i < out.length; i++) {
				hol_term* term = out[i]->quantifier.operand->array.operands[0]->binary.right->quantifier.operand->binary.right;
				term->reference_count++;
				free(*out[i]); if (out[i]->reference_count == 0) free(out[i]);
				out[i] = term;
			}
		}
		free_all(filtered_predicates);

		if ((UniqueOutput && out.length == 1) || EqualityOnly) {
			for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
				free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
			}
			free_all(predicates);
			return true;
		}
	}

	if (EqualityOnly) {
		for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
			free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
		}
		free_all(predicates); return false;
	}

	array<hol_term*> second_expected_heads(2);
	if (UniqueOutput && (left == nullptr || left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT)) {
		hol_term* excluded_set_definition = hol_term::new_equals(hol_term::new_variable(set_variable),
				hol_term::new_lambda(element_variable, hol_term::new_equals(hol_term::new_variable(element_variable), predicates[0])));
		if (excluded_set_definition == nullptr) {
			for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
				free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
			}
			free_all(predicates); return false;
		}
		predicates[0]->reference_count++;

		second_expected_heads[second_expected_heads.length] = hol_term::new_exists(set_variable, hol_term::new_and(
				hol_term::new_any_right(hol_term::new_lambda(element_variable, hol_term::new_apply(predicates[0], hol_term::new_variable(element_variable))), &excluded_set_definition, 1),
				hol_term::new_any(nullptr, excluded_quantifiers, array_length(excluded_quantifiers))));
		if (second_expected_heads[second_expected_heads.length] == nullptr) {
			free(*excluded_set_definition); free(excluded_set_definition);
			for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
				free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
			}
			free_all(predicates); return false;
		}
		predicates[0]->reference_count++;
		for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++)
			excluded_quantifiers[i]->reference_count++;
		second_expected_heads.length++;
	} if (!UniqueOutput || (left != nullptr && left->type == hol_term_type::EQUALS)) {
		second_expected_heads[second_expected_heads.length] = hol_term::new_exists(set_variable, hol_term::new_and(
				hol_term::new_equals(hol_term::new_variable(set_variable), hol_term::new_lambda(element_variable, hol_term::new_apply(predicates[0], hol_term::new_variable(element_variable)))),
				hol_term::new_any(nullptr, excluded_quantifiers, array_length(excluded_quantifiers))));
		if (second_expected_heads[second_expected_heads.length] == nullptr) {
			free_all(second_expected_heads);
			for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
				free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
			}
			free_all(predicates); return false;
		}
		predicates[0]->reference_count++;
		for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++)
			excluded_quantifiers[i]->reference_count++;
		second_expected_heads.length++;
	} if (AllowSubset && (!UniqueOutput || (left != nullptr && left->type == hol_term_type::BINARY_APPLICATION))) {
		hol_term* set_var = hol_term::new_variable(set_variable);
		if (set_var == nullptr) {
			free_all(second_expected_heads);
			for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
				free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
			}
			free_all(predicates); return false;
		}

		hol_term* element_var = hol_term::new_variable(element_variable);
		if (element_var == nullptr) {
			free_all(second_expected_heads);
			free(*set_var); free(set_var);
			for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
				free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
			}
			free_all(predicates); return false;
		}

		second_expected_heads[second_expected_heads.length] = hol_term::new_exists(set_variable, hol_term::new_and(
				hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::SUBSET>::value, set_var, hol_term::new_lambda(element_variable, hol_term::new_apply(predicates[0], element_var))),
				hol_term::new_any(nullptr, excluded_quantifiers, array_length(excluded_quantifiers))));
		if (second_expected_heads[second_expected_heads.length] == nullptr) {
			free_all(second_expected_heads);
			for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
				free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
			}
			free_all(predicates); return false;
		}
		hol_term::constants<(unsigned int) built_in_predicates::SUBSET>::value.reference_count++;
		predicates[0]->reference_count++;
		for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++)
			excluded_quantifiers[i]->reference_count++;
		second_expected_heads.length++;
	}
	for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
		free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
	}
	free_all(predicates);

	unsigned int old_out_length = out.length;
	for (hol_term* second_expected_head : second_expected_heads) {
		intersect<built_in_predicates>(out, second_expected_head, head);
		if (UniqueOutput && out.length > 1) {
			fprintf(stderr, "select_predicate_in_set ERROR: Intersection is not unique.\n");
			free_all(second_expected_heads);
			for (hol_term* term : out) { free(*term); if (term->reference_count == 0) free(term); }
			return false;
		}
	}
	free_all(second_expected_heads);

	for (unsigned int i = old_out_length; StorePredicates && i < out.length; i++) {
		hol_term* term;
		hol_term* left = out[i]->quantifier.operand->array.operands[0];
		if (left->type == hol_term_type::ANY_RIGHT) {
			term = left->any.included->quantifier.operand->binary.left;
		} else if (left->type == hol_term_type::EQUALS) {
			term = left->binary.right->quantifier.operand->binary.left;
		} else {
			term = left->ternary.third->quantifier.operand->binary.left;
		}
		term->reference_count++;
		free(*out[i]); if (out[i]->reference_count == 0) free(out[i]);
		out[i] = term;
	}
	return true;
}

inline bool select_predicate_in_set(hol_term* src, hol_term*& dst)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<false>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker,
			predicative_head_finder<built_in_predicates>(lambda_variable),
			[max_variable,lambda_variable](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				array<hol_term*> out(2);
				if (!select_predicate_in_set<true, true, false, false, false>(out, head, &HOL_ANY, max_variable, lambda_variable) || out.length == 0)
					return (hol_term*) nullptr;
				remove_wide_scope_marker = true;
				return out[0];
			}, no_op()) && dst != nullptr;
}

inline bool select_constant_in_set(hol_term* src, hol_term*& dst)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<false>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker,
			predicative_head_finder<built_in_predicates>(lambda_variable),
			[max_variable,lambda_variable](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				array<hol_term*> out(2);
				if (!select_predicate_in_set<true, true, true, true, false>(out, head, &HOL_ANY, max_variable, lambda_variable) || out.length == 0)
					return (hol_term*) nullptr;
				remove_wide_scope_marker = true;
				return out[0];
			}, no_op()) && dst != nullptr;
}

inline bool select_string_in_set(hol_term* src, hol_term*& dst)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<false>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker,
			predicative_head_finder<built_in_predicates>(lambda_variable),
			[max_variable,lambda_variable](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				array<hol_term*> out(2);
				if (!select_predicate_in_set<true, true, true, true, false>(out, head, &HOL_ANY, max_variable, lambda_variable) || out.length == 0)
					return (hol_term*) nullptr;
				remove_wide_scope_marker = true;
				if (out[0]->type == hol_term_type::ANY || out[0]->type == hol_term_type::ANY_RIGHT || out[0]->type == hol_term_type::STRING)
					return out[0];
				free_all(out);
				return (hol_term*) nullptr;
			}, no_op()) && dst != nullptr;
}

template<bool UniqueOutput, bool StoreArg2Values, bool EqualityOnly, bool AllowSubset, bool AllowOtherConjuncts>
inline bool select_scope_arg_in_set(array<hol_term*>& out,
		hol_term* head, hol_term* predicate, hol_term* arg2,
		unsigned int max_variable, unsigned int lambda_variable)
{
	if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr && head->any.included->type == hol_term_type::EXISTS)
		head = head->any.included;

	hol_term* left; hol_term* set_definition;
	unsigned int set_variable, element_variable;
	if (!get_predicative_set_variables(head, lambda_variable, left, set_definition, set_variable, element_variable, max_variable))
		return false;

	hol_term* excluded_quantifiers[3];
	excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(set_variable, &HOL_ANY));
	excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(set_variable, &HOL_ANY));
	excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(set_variable, &HOL_ANY));
	if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
	if (excluded_quantifiers[1] != nullptr) HOL_ANY.reference_count++;
	if (excluded_quantifiers[2] != nullptr) HOL_ANY.reference_count++;
	if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr) {
		if (excluded_quantifiers[0] != nullptr) { free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]); }
		if (excluded_quantifiers[1] != nullptr) { free(*excluded_quantifiers[1]); free(excluded_quantifiers[1]); }
		return (hol_term*) nullptr;
	}

	hol_term* excluded_lambdas[3];
	excluded_lambdas[0] = hol_term::new_any(hol_term::new_exists(element_variable, &HOL_ANY));
	excluded_lambdas[1] = hol_term::new_any(hol_term::new_for_all(element_variable, &HOL_ANY));
	excluded_lambdas[2] = hol_term::new_any(hol_term::new_lambda(element_variable, &HOL_ANY));
	if (excluded_lambdas[0] != nullptr) HOL_ANY.reference_count++;
	if (excluded_lambdas[1] != nullptr) HOL_ANY.reference_count++;
	if (excluded_lambdas[2] != nullptr) HOL_ANY.reference_count++;
	if (excluded_lambdas[0] == nullptr || excluded_lambdas[1] == nullptr || excluded_lambdas[2] == nullptr) {
		if (excluded_lambdas[0] != nullptr) { free(*excluded_lambdas[0]); free(excluded_lambdas[0]); }
		if (excluded_lambdas[1] != nullptr) { free(*excluded_lambdas[1]); free(excluded_lambdas[1]); }
		for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
		return (hol_term*) nullptr;
	}

	hol_term* excluded_trees[array_length(excluded_quantifiers) + array_length(excluded_lambdas)];
	for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++)
		excluded_trees[i] = excluded_quantifiers[i];
	for (unsigned int i = 0; i < array_length(excluded_lambdas); i++)
		excluded_trees[array_length(excluded_quantifiers) + i] = excluded_lambdas[i];
	hol_term* expected = hol_term::new_any(nullptr, excluded_trees, array_length(excluded_trees));
	if (expected == nullptr) {
		for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
		for (unsigned int i = 0; i < array_length(excluded_lambdas); i++) { free(*excluded_lambdas[i]); free(excluded_lambdas[i]); }
		return false;
	}
	for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++)
		excluded_quantifiers[i]->reference_count++;

	array<hol_term*> predicates(2), arg2_values(2);
	intersect<built_in_predicates>(predicates, expected, predicate);
	intersect<built_in_predicates>(arg2_values, expected, arg2);
	free(*expected); if (expected->reference_count == 0) free(expected);
	if (predicates.length == 0 || arg2_values.length == 0) {
		free_all(predicates); free_all(arg2_values);
		for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
		return false;
	} else if (predicates.length != 1 || arg2_values.length != 1) {
		fprintf(stderr, "select_scope_arg_in_set ERROR: Not implemented.\n");
		free_all(predicates); free_all(arg2_values);
		for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
		return false;
	}

	array<hol_term*> new_operands(4);
	head_index scope_position;
	if (set_definition == nullptr) {
		unsigned int scope_variable = ++max_variable;
		hol_term* scope_var = hol_term::new_variable(scope_variable);
		if (scope_var == nullptr) {
			for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
				free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
			}
			free_all(predicates); free_all(arg2_values);
			return false;
		}

		hol_term* new_operand = hol_term::new_exists(scope_variable, hol_term::new_and(
			hol_term::new_apply(predicates[0], scope_var),
			hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG1_OF>::value, hol_term::new_variable(element_variable)), scope_var),
			hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value, scope_var), arg2_values[0])
		));
		if (new_operand == nullptr) {
			free(*scope_var); free(scope_var);
			for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
				free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
			}
			free_all(predicates); free_all(arg2_values);
			return false;
		}
		predicates[0]->reference_count++;
		arg2_values[0]->reference_count++;
		scope_var->reference_count += 3 - 1;
		hol_term::constants<(unsigned int) built_in_predicates::ARG1_OF>::value.reference_count++;
		hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value.reference_count++;

		if (AllowOtherConjuncts) {
			hol_term* conjunct = hol_term::new_any(nullptr, excluded_quantifiers, array_length(excluded_quantifiers));
			if (conjunct == nullptr) {
				for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
					free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
				}
				free_all(predicates); free_all(arg2_values);
				free(*new_operand); free(new_operand);
				return false;
			}
			for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++)
				excluded_quantifiers[i]->reference_count++;

			new_operands[new_operands.length] = hol_term::new_any_array(hol_term_type::AND, conjunct, make_array_view(&new_operand, 1), make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0));
			if (new_operands[new_operands.length] == nullptr) {
				for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
					free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
				}
				free_all(predicates); free_all(arg2_values);
				free(*new_operand); free(new_operand);
				free(*conjunct); free(conjunct);
				return false;
			}
			new_operands.length++;
			scope_position.position = head_position::ANY;
			scope_position.index = 0;
		} else {
			new_operands[new_operands.length++] = new_operand;
			scope_position.position = head_position::NONE;
			scope_position.index = 0;
		}
	} else if (set_definition->type != hol_term_type::LAMBDA) {
		for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
			free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
		}
		free_all(predicates); free_all(arg2_values);
		return false;
	} else {
		hol_term* operand = set_definition->quantifier.operand;
		if ((operand->type == hol_term_type::ANY || operand->type == hol_term_type::ANY_RIGHT) && operand->any.included != nullptr)
			operand = operand->any.included;

		if (operand->type == hol_term_type::AND) {
			if (!AllowOtherConjuncts) {
				for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
					free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
				}
				free_all(predicates); free_all(arg2_values);
				return false;
			}
			for (unsigned int i = 0; i < operand->array.length; i++) {
				hol_term* inner_conjunct = operand->array.operands[i];
				if (inner_conjunct->type != hol_term_type::EXISTS)
					continue;

				unsigned int scope_variable = inner_conjunct->quantifier.variable;
				hol_term* scope_var = hol_term::new_variable(scope_variable);
				if (scope_var == nullptr) {
					for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
						free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
					}
					free_all(predicates); free_all(arg2_values);
					free_all(new_operands); return false;
				}

				hol_term* new_inner_conjunct = hol_term::new_exists(scope_variable, hol_term::new_and(
					hol_term::new_apply(predicates[0], scope_var),
					hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG1_OF>::value, hol_term::new_variable(element_variable)), scope_var),
					hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value, scope_var), arg2_values[0])
				));
				if (new_inner_conjunct == nullptr) {
					free(*scope_var); free(scope_var);
					for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
						free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
					}
					free_all(predicates); free_all(arg2_values);
					free_all(new_operands); return false;
				}
				predicates[0]->reference_count++;
				arg2_values[0]->reference_count++;
				scope_var->reference_count += 3 - 1;
				hol_term::constants<(unsigned int) built_in_predicates::ARG1_OF>::value.reference_count++;
				hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value.reference_count++;

				intersect<built_in_predicates>(new_operands, new_inner_conjunct, inner_conjunct);
				free(*new_inner_conjunct); if (new_inner_conjunct->reference_count == 0) free(new_inner_conjunct);
				if (new_operands.length == 0)
					continue;

				for (unsigned int j = 0; j < new_operands.length; j++) {
					hol_term* temp = hol_term::new_and(make_replaced_array_view(make_array_view(operand->array.operands, operand->array.length), new_operands[j], i));
					if (temp == nullptr) {
						for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
							free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
						}
						free_all(predicates); free_all(arg2_values);
						free_all(new_operands); return false;
					}
					new_operands[j] = temp;
					for (unsigned int k = 0; k < operand->array.length; k++)
						if (k != i) operand->array.operands[k]->reference_count++;
				}
				scope_position.position = head_position::LEFT;
				scope_position.index = i;
				break;
			}
			if (new_operands.length == 0) {
				for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
					free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
				}
				free_all(predicates); free_all(arg2_values); return false;
			}
		} else if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
			if (!AllowOtherConjuncts && (operand->any_array.any.length > 1 || operand->any_array.left.length > 1 || operand->any_array.right.length > 1)) {
				for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
					free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
				}
				free_all(predicates); free_all(arg2_values);
				return false;
			}
			for (unsigned int i = 0; i < operand->any_array.any.length; i++) {
				hol_term* inner_conjunct = operand->any_array.any.operands[i];
				if (inner_conjunct->type != hol_term_type::EXISTS)
					continue;

				unsigned int scope_variable = inner_conjunct->quantifier.variable;
				hol_term* scope_var = hol_term::new_variable(scope_variable);
				if (scope_var == nullptr) {
					for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
						free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
					}
					free_all(predicates); free_all(arg2_values);
					free_all(new_operands); return false;
				}

				hol_term* new_inner_conjunct = hol_term::new_exists(scope_variable, hol_term::new_and(
					hol_term::new_apply(predicates[0], scope_var),
					hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG1_OF>::value, hol_term::new_variable(element_variable)), scope_var),
					hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value, scope_var), arg2_values[0])
				));
				if (new_inner_conjunct == nullptr) {
					free(*scope_var); free(scope_var);
					for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
						free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
					}
					free_all(predicates); free_all(arg2_values);
					free_all(new_operands); return false;
				}
				predicates[0]->reference_count++;
				arg2_values[0]->reference_count++;
				scope_var->reference_count += 3 - 1;
				hol_term::constants<(unsigned int) built_in_predicates::ARG1_OF>::value.reference_count++;
				hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value.reference_count++;

				intersect<built_in_predicates>(new_operands, new_inner_conjunct, inner_conjunct);
				free(*new_inner_conjunct); if (new_inner_conjunct->reference_count == 0) free(new_inner_conjunct);
				if (new_operands.length == 0)
					continue;

				for (unsigned int j = 0; AllowOtherConjuncts && j < new_operands.length; j++) {
					hol_term* temp = hol_term::new_any_array(hol_term_type::AND, operand->any_array.all,
							make_replaced_array_view(make_array_view(operand->any_array.any.operands, operand->any_array.any.length), new_operands[j], i),
							make_array_view(operand->any_array.left.operands, operand->any_array.left.length),
							make_array_view(operand->any_array.right.operands, operand->any_array.right.length));
					if (temp == nullptr) {
						for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
							free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
						}
						free_all(predicates); free_all(arg2_values);
						free_all(new_operands); return false;
					}
					new_operands[j] = temp;
					operand->any_array.all->reference_count++;
					for (unsigned int k = 0; k < operand->any_array.any.length; k++)
						if (k != i) operand->any_array.any.operands[k]->reference_count++;
					for (unsigned int k = 0; k < operand->any_array.left.length; k++)
						operand->any_array.left.operands[k]->reference_count++;
					for (unsigned int k = 0; k < operand->any_array.right.length; k++)
						operand->any_array.right.operands[k]->reference_count++;
				}
				if (AllowOtherConjuncts) {
					scope_position.position = head_position::ANY;
					scope_position.index = i;
				} else {
					scope_position.position = head_position::NONE;
					scope_position.index = 0;
				}
				break;
			} for (unsigned int i = 0; new_operands.length == 0 && i < operand->any_array.left.length; i++) {
				hol_term* inner_conjunct = operand->any_array.left.operands[i];
				if (inner_conjunct->type != hol_term_type::EXISTS)
					continue;

				unsigned int scope_variable = inner_conjunct->quantifier.variable;
				hol_term* scope_var = hol_term::new_variable(scope_variable);
				if (scope_var == nullptr) {
					for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
						free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
					}
					free_all(predicates); free_all(arg2_values);
					free_all(new_operands); return false;
				}

				hol_term* new_inner_conjunct = hol_term::new_exists(scope_variable, hol_term::new_and(
					hol_term::new_apply(predicates[0], scope_var),
					hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG1_OF>::value, hol_term::new_variable(element_variable)), scope_var),
					hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value, scope_var), arg2_values[0])
				));
				if (new_inner_conjunct == nullptr) {
					free(*scope_var); free(scope_var);
					for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
						free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
					}
					free_all(predicates); free_all(arg2_values);
					free_all(new_operands); return false;
				}
				predicates[0]->reference_count++;
				arg2_values[0]->reference_count++;
				scope_var->reference_count += 3 - 1;
				hol_term::constants<(unsigned int) built_in_predicates::ARG1_OF>::value.reference_count++;
				hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value.reference_count++;

				intersect<built_in_predicates>(new_operands, new_inner_conjunct, inner_conjunct);
				free(*new_inner_conjunct); if (new_inner_conjunct->reference_count == 0) free(new_inner_conjunct);
				if (new_operands.length == 0)
					continue;

				for (unsigned int j = 0; AllowOtherConjuncts && j < new_operands.length; j++) {
					hol_term* temp = hol_term::new_any_array(hol_term_type::AND, operand->any_array.all,
							make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
							make_replaced_array_view(make_array_view(operand->any_array.left.operands, operand->any_array.left.length), new_operands[j], i),
							make_array_view(operand->any_array.right.operands, operand->any_array.right.length));
					if (temp == nullptr) {
						for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
							free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
						}
						free_all(predicates); free_all(arg2_values);
						free_all(new_operands); return false;
					}
					new_operands[j] = temp;
					operand->any_array.all->reference_count++;
					for (unsigned int k = 0; k < operand->any_array.any.length; k++)
						operand->any_array.any.operands[k]->reference_count++;
					for (unsigned int k = 0; k < operand->any_array.left.length; k++)
						if (k != i) operand->any_array.left.operands[k]->reference_count++;
					for (unsigned int k = 0; k < operand->any_array.right.length; k++)
						operand->any_array.right.operands[k]->reference_count++;
				}
				if (AllowOtherConjuncts) {
					scope_position.position = head_position::LEFT;
					scope_position.index = i;
				} else {
					scope_position.position = head_position::NONE;
					scope_position.index = 0;
				}
				break;
			} for (unsigned int i = 0; new_operands.length == 0 && i < operand->any_array.right.length; i++) {
				hol_term* inner_conjunct = operand->any_array.right.operands[i];
				if (inner_conjunct->type != hol_term_type::EXISTS)
					continue;

				unsigned int scope_variable = inner_conjunct->quantifier.variable;
				hol_term* scope_var = hol_term::new_variable(scope_variable);
				if (scope_var == nullptr) {
					for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
						free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
					}
					free_all(predicates); free_all(arg2_values);
					free_all(new_operands); return false;
				}

				hol_term* new_inner_conjunct = hol_term::new_exists(scope_variable, hol_term::new_and(
					hol_term::new_apply(predicates[0], scope_var),
					hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG1_OF>::value, hol_term::new_variable(element_variable)), scope_var),
					hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value, scope_var), arg2_values[0])
				));
				if (new_inner_conjunct == nullptr) {
					free(*scope_var); free(scope_var);
					for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
						free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
					}
					free_all(predicates); free_all(arg2_values);
					free_all(new_operands); return false;
				}
				predicates[0]->reference_count++;
				arg2_values[0]->reference_count++;
				scope_var->reference_count += 3 - 1;
				hol_term::constants<(unsigned int) built_in_predicates::ARG1_OF>::value.reference_count++;
				hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value.reference_count++;

				intersect<built_in_predicates>(new_operands, new_inner_conjunct, inner_conjunct);
				free(*new_inner_conjunct); if (new_inner_conjunct->reference_count == 0) free(new_inner_conjunct);
				if (new_operands.length == 0)
					continue;

				for (unsigned int j = 0; AllowOtherConjuncts && j < new_operands.length; j++) {
					hol_term* temp = hol_term::new_any_array(hol_term_type::AND, operand->any_array.all,
							make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
							make_array_view(operand->any_array.left.operands, operand->any_array.left.length),
							make_replaced_array_view(make_array_view(operand->any_array.right.operands, operand->any_array.right.length), new_operands[j], i));
					if (temp == nullptr) {
						for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
							free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
						}
						free_all(predicates); free_all(arg2_values);
						free_all(new_operands); return false;
					}
					new_operands[j] = temp;
					operand->any_array.all->reference_count++;
					for (unsigned int k = 0; k < operand->any_array.any.length; k++)
						operand->any_array.any.operands[k]->reference_count++;
					for (unsigned int k = 0; k < operand->any_array.left.length; k++)
						operand->any_array.left.operands[k]->reference_count++;
					for (unsigned int k = 0; k < operand->any_array.right.length; k++)
						if (k != i) operand->any_array.right.operands[k]->reference_count++;
				}
				if (AllowOtherConjuncts) {
					scope_position.position = head_position::RIGHT;
					scope_position.index = i;
				} else {
					scope_position.position = head_position::NONE;
					scope_position.index = 0;
				}
				break;
			} if (new_operands.length == 0 && operand->any_array.any.length == 0) {
				hol_term* inner_conjunct = operand->any_array.all;
				unsigned int scope_variable;
				if (inner_conjunct->type == hol_term_type::EXISTS)
					scope_variable = inner_conjunct->quantifier.variable;
				else scope_variable = ++max_variable;
				hol_term* scope_var = hol_term::new_variable(scope_variable);
				if (scope_var == nullptr) {
					for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
						free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
					}
					free_all(predicates); free_all(arg2_values);
					free_all(new_operands); return false;
				}

				hol_term* new_inner_conjunct = hol_term::new_exists(scope_variable, hol_term::new_and(
					hol_term::new_apply(predicates[0], scope_var),
					hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG1_OF>::value, hol_term::new_variable(element_variable)), scope_var),
					hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value, scope_var), arg2_values[0])
				));
				if (new_inner_conjunct == nullptr) {
					free(*scope_var); free(scope_var);
					for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
						free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
					}
					free_all(predicates); free_all(arg2_values);
					free_all(new_operands); return false;
				}
				predicates[0]->reference_count++;
				arg2_values[0]->reference_count++;
				scope_var->reference_count += 3 - 1;
				hol_term::constants<(unsigned int) built_in_predicates::ARG1_OF>::value.reference_count++;
				hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value.reference_count++;

				intersect<built_in_predicates>(new_operands, new_inner_conjunct, inner_conjunct);
				free(*new_inner_conjunct); if (new_inner_conjunct->reference_count == 0) free(new_inner_conjunct);

				for (unsigned int j = 0; AllowOtherConjuncts && j < new_operands.length; j++) {
					hol_term* temp = hol_term::new_any_array(hol_term_type::AND, operand->any_array.all,
							make_array_view(&new_operands[j], 1),
							make_array_view(operand->any_array.left.operands, operand->any_array.left.length),
							make_array_view(operand->any_array.right.operands, operand->any_array.right.length));
					if (temp == nullptr) {
						for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
							free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
						}
						free_all(predicates); free_all(arg2_values);
						free_all(new_operands); return false;
					}
					operand->any_array.all->reference_count++;
					for (unsigned int k = 0; k < operand->any_array.left.length; k++)
						operand->any_array.left.operands[k]->reference_count++;
					for (unsigned int k = 0; k < operand->any_array.right.length; k++)
						operand->any_array.right.operands[k]->reference_count++;
				}
				if (AllowOtherConjuncts) {
					scope_position.position = head_position::ANY;
					scope_position.index = 0;
				} else {
					scope_position.position = head_position::NONE;
					scope_position.index = 0;
				}
			}
			if (new_operands.length == 0) {
				for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
					free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
				}
				free_all(predicates); free_all(arg2_values); return false;
			}
		} else {
			unsigned int scope_variable;
			if (operand->type == hol_term_type::EXISTS)
				scope_variable = operand->quantifier.variable;
			else scope_variable = ++max_variable;

			hol_term* scope_var = hol_term::new_variable(scope_variable);
			if (scope_var == nullptr) {
				for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
					free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
				}
				free_all(predicates); free_all(arg2_values);
				return false;
			}

			hol_term* new_operand = hol_term::new_exists(scope_variable, hol_term::new_and(
				hol_term::new_apply(predicates[0], scope_var),
				hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG1_OF>::value, hol_term::new_variable(element_variable)), scope_var),
				hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value, scope_var), arg2_values[0])
			));
			if (new_operand == nullptr) {
				free(*scope_var); free(scope_var);
				for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
					free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
				}
				free_all(predicates); free_all(arg2_values);
				return false;
			}
			predicates[0]->reference_count++;
			arg2_values[0]->reference_count++;
			scope_var->reference_count += 3 - 1;
			hol_term::constants<(unsigned int) built_in_predicates::ARG1_OF>::value.reference_count++;
			hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value.reference_count++;

			intersect<built_in_predicates>(new_operands, new_operand, operand);
			free(*new_operand); if (new_operand->reference_count == 0) free(new_operand);
			if (new_operands.length == 0) {
				for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
					free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
				}
				free_all(predicates); free_all(arg2_values); return false;
			}
			scope_position.position = head_position::NONE;
			scope_position.index = 0;
		}
	}
	free_all(predicates);
	free_all(arg2_values);

	array<hol_term*> second_expected_heads(2 * new_operands.length);
	if (!EqualityOnly && UniqueOutput && (left == nullptr || left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT)) {
		for (hol_term* new_operand : new_operands) {
			second_expected_heads[second_expected_heads.length] = hol_term::new_exists(set_variable, hol_term::new_and(
					hol_term::new_any_right(hol_term::new_lambda(element_variable, new_operand)),
					hol_term::new_any(nullptr, excluded_quantifiers, array_length(excluded_quantifiers))));
			if (second_expected_heads[second_expected_heads.length] == nullptr) {
				for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
					free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
				}
				free_all(new_operands); return false;
			}
			new_operand->reference_count++;
			for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++)
				excluded_quantifiers[i]->reference_count++;
			second_expected_heads.length++;
		}
	} if (EqualityOnly || !UniqueOutput || (left != nullptr && left->type == hol_term_type::EQUALS)) {
		for (hol_term* new_operand : new_operands) {
			second_expected_heads[second_expected_heads.length] = hol_term::new_exists(set_variable, hol_term::new_and(
					hol_term::new_equals(hol_term::new_variable(set_variable), hol_term::new_lambda(element_variable, new_operand)),
					hol_term::new_any(nullptr, excluded_quantifiers, array_length(excluded_quantifiers))));
			if (second_expected_heads[second_expected_heads.length] == nullptr) {
				free_all(second_expected_heads);
				for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
					free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
				}
				free_all(new_operands); return false;
			}
			new_operand->reference_count++;
			for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++)
				excluded_quantifiers[i]->reference_count++;
			second_expected_heads.length++;
		}
	} if (!EqualityOnly && AllowSubset && (!UniqueOutput || (left != nullptr && left->type == hol_term_type::BINARY_APPLICATION))) {
		hol_term* set_var = hol_term::new_variable(set_variable);
		if (set_var == nullptr) {
			free_all(second_expected_heads);
			for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
				free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
			}
			free_all(new_operands); return false;
		}

		for (hol_term* new_operand : new_operands) {
			second_expected_heads[second_expected_heads.length] = hol_term::new_exists(set_variable, hol_term::new_and(
					hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::SUBSET>::value, set_var, new_operand),
					hol_term::new_any(nullptr, excluded_quantifiers, array_length(excluded_quantifiers))));
			if (second_expected_heads[second_expected_heads.length] == nullptr) {
				free_all(second_expected_heads);
				for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
					free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
				}
				free(*set_var); if (set_var->reference_count == 0) free(set_var);
				free_all(new_operands); return false;
			}
			hol_term::constants<(unsigned int) built_in_predicates::SUBSET>::value.reference_count++;
			set_var->reference_count++;
			new_operand->reference_count++;
			for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++)
				excluded_quantifiers[i]->reference_count++;
			second_expected_heads.length++;
		}
		free(*set_var); if (set_var->reference_count == 0) free(set_var);
	}
	for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
		free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
	}
	free_all(new_operands);

	unsigned int old_out_length = out.length;
	for (hol_term* second_expected_head : second_expected_heads) {
		intersect<built_in_predicates>(out, second_expected_head, head);
		if (UniqueOutput && out.length > 1) {
			fprintf(stderr, "select_scope_arg_in_set ERROR: Intersection is not unique.\n");
			free_all(second_expected_heads);
			for (hol_term* term : out) { free(*term); if (term->reference_count == 0) free(term); }
			return false;
		}
	}
	free_all(second_expected_heads);

	for (unsigned int i = old_out_length; StoreArg2Values && i < out.length; i++) {
		hol_term* set_definition;
		hol_term* left = out[i]->quantifier.operand->array.operands[0];
		if (left->type == hol_term_type::ANY_RIGHT) {
			set_definition = left->any.included->quantifier.operand;
		} else if (left->type == hol_term_type::EQUALS) {
			set_definition = left->binary.right->quantifier.operand;
		} else {
			set_definition = left->ternary.third->quantifier.operand;
		}

		hol_term* scope;
		if (set_definition->type == hol_term_type::AND) {
			scope = set_definition->array.operands[scope_position.index];
		} else if (set_definition->type == hol_term_type::ANY_ARRAY) {
			if (scope_position.position == head_position::ANY)
				scope = set_definition->any_array.any.operands[scope_position.index];
			else if (scope_position.position == head_position::LEFT)
				scope = set_definition->any_array.left.operands[scope_position.index];
			else scope = set_definition->any_array.right.operands[scope_position.index];
		} else {
			scope = set_definition;
		}

		hol_term* term = scope->quantifier.operand->array.operands[2]->binary.right;
		term->reference_count++;
		free(*out[i]); if (out[i]->reference_count == 0) free(out[i]);
		out[i] = term;
	}
	return true;
}

inline bool select_name_in_set(hol_term* src, hol_term*& dst)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<false>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker,
			predicative_head_finder<built_in_predicates>(lambda_variable),
			[max_variable,lambda_variable](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				array<hol_term*> out(2);
				if (!select_scope_arg_in_set<true, true, false, false, false>(out, head, &HOL_NAME, &HOL_ANY, max_variable, lambda_variable) || out.length == 0)
					return (hol_term*) nullptr;
				remove_wide_scope_marker = true;
				return out[0];
			}, no_op()) && dst != nullptr;
}

inline bool select_number_in_set(hol_term* src, hol_term*& dst)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<false>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker,
			predicative_head_finder<built_in_predicates>(lambda_variable),
			[max_variable,lambda_variable](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				array<hol_term*> out(2);
				if (!select_predicate_in_set<true, true, true, true, false>(out, head, &HOL_ANY, max_variable, lambda_variable) || out.length == 0)
					return (hol_term*) nullptr;
				remove_wide_scope_marker = true;
				if (out[0]->type == hol_term_type::ANY || out[0]->type == hol_term_type::ANY_RIGHT || out[0]->type == hol_term_type::NUMBER)
					return out[0];
				free_all(out);
				return (hol_term*) nullptr;
			}, no_op()) && dst != nullptr;
}

inline bool mark_wide_scope(hol_term* src, hol_term*& dst)
{
	head_index predicate_index; no_op apply;
	hol_term* head = find_head(src, predicate_index, find_head_or_universal<built_in_predicates>, apply);
	if (head == nullptr)
		return false;

	hol_term* new_head;
	if (head->type == hol_term_type::FOR_ALL) {
		new_head = hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, head);
		if (new_head == nullptr) return false;
		hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
		head->reference_count++;
	} else {
		new_head = head;
		head->reference_count++;
	}

	hol_term* new_term = substitute_head<any_node_position::NONE>(src, head, new_head);
	free(*new_head); if (new_head->reference_count == 0) free(new_head);
	if (new_term == nullptr)
		return false;

	hol_term* any_wide_scope = hol_term::new_any_right(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ANY));
	if (any_wide_scope == nullptr) {
		free(*new_term); if (new_term->reference_count == 0) free(new_term);
		return false;
	}
	hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
	HOL_ANY.reference_count++;

	hol_term* duplicate_wide_scopes = hol_term::new_any_right(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, any_wide_scope));
	if (duplicate_wide_scopes == nullptr) {
		free(*new_term); if (new_term->reference_count == 0) free(new_term);
		free(*any_wide_scope); free(any_wide_scope);
		return false;
	}
	hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;

	hol_term* excluded_universal = hol_term::new_any_right(hol_term::new_any_quantifier(hol_quantifier_type::FOR_ALL, any_wide_scope));
	if (excluded_universal == nullptr) {
		free(*new_term); if (new_term->reference_count == 0) free(new_term);
		free(*duplicate_wide_scopes); free(duplicate_wide_scopes);
		return false;
	}
	any_wide_scope->reference_count++;

	hol_term* excluded_trees[2];
	excluded_trees[0] = excluded_universal;
	excluded_trees[1] = duplicate_wide_scopes;
	hol_term* unique_wide_scope = hol_term::new_any_right(nullptr, excluded_trees, array_length(excluded_trees));
	if (unique_wide_scope == nullptr) {
		free(*new_term); if (new_term->reference_count == 0) free(new_term);
		free(*excluded_universal); free(excluded_universal);
		free(*duplicate_wide_scopes); free(duplicate_wide_scopes);
		return false;
	}

	array<hol_term*> intersection(2);
	intersect<built_in_predicates>(intersection, new_term, unique_wide_scope);
	free(*new_term); if (new_term->reference_count == 0) free(new_term);
	free(*unique_wide_scope); if (unique_wide_scope->reference_count == 0) free(unique_wide_scope);
	if (intersection.length == 0) {
		return false;
	} else if (intersection.length > 1) {
		fprintf(stderr, "mark_wide_scope ERROR: Intersection is not unique.\n");
		free_all(intersection);
		return false;
	}
	dst = intersection[0];
	return true;
}

template<bool WideScope>
inline hol_term* do_require_narrow_or_wide_scope(hol_term* head,
		unsigned int lambda_variable, unsigned int max_variable, bool can_have_wide_scope)
{
	hol_term* old_head = head;
	if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr && head->any.included->type == hol_term_type::EXISTS)
		head = head->any.included;

	hol_term* dst = nullptr;
	unsigned int set_variable, element_variable = 0;
	if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) {
		if (head->any.included != nullptr && head->any.included->type == hol_term_type::UNARY_APPLICATION
		 && head->any.included->binary.left->type == hol_term_type::VARIABLE
		 && head->any.included->binary.left->variable == lambda_variable
		 && head->any.included->binary.right->type == hol_term_type::VARIABLE)
		{
			element_variable = head->any.included->binary.right->variable;
			max_variable = max(max_variable, element_variable);
			set_variable = ++max_variable;
		} else {
			set_variable = ++max_variable;
			element_variable = ++max_variable;
		}
	} else {
#if !defined(NDEBUG)
		if (head->type != hol_term_type::EXISTS) {
			fprintf(stderr, "do_require_narrow_or_wide_scope ERROR: Expected existential quantification of set.\n");
			return (hol_term*) nullptr;
		}
#endif

		hol_term* operand = head->quantifier.operand;
		set_variable = head->quantifier.variable;
		if (operand->type == hol_term_type::ANY) {
			element_variable = ++max_variable;
		} else {
			hol_term* last;
			if (operand->type == hol_term_type::ANY_ARRAY) {
				if (operand->any_array.right.length == 0) {
					fprintf(stderr, "do_require_narrow_or_wide_scope ERROR: Expected an existentially quantified conjunction with a right-most operand.\n");
					return (hol_term*) nullptr;
				}
				last = operand->any_array.right.operands[operand->any_array.right.length - 1];
			} else if (operand->type == hol_term_type::AND) {
				last = operand->array.operands[operand->array.length - 1];
			} else {
				last = operand;
			}

			if ((last->type == hol_term_type::ANY || last->type == hol_term_type::ANY_RIGHT) && last->any.included != nullptr) {
				last = last->any.included;
			} if (last->type == hol_term_type::UNARY_APPLICATION && last->binary.left->type == hol_term_type::CONSTANT && last->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
				last = last->binary.right;
				if (WideScope) {
					head->reference_count++;
					return head;
				} else {
					return (hol_term*) nullptr;
				}
			} else if (WideScope && !can_have_wide_scope) {
				/* it's not possible to have wide scope */
				return (hol_term*) nullptr;
			}

			while (last->type == hol_term_type::NOT)
				last = operand->unary.operand;

			if (last->type == hol_term_type::ANY || last->type == hol_term_type::ANY_RIGHT) {
				element_variable = ++max_variable;
			} else if (last->type == hol_term_type::EXISTS || last->type == hol_term_type::FOR_ALL) {
				hol_term* inner_right = nullptr;
				if (last->type == hol_term_type::EXISTS && last->quantifier.operand->type == hol_term_type::AND)
					inner_right = last->quantifier.operand->array.operands[1];
				else if (last->type == hol_term_type::FOR_ALL && last->quantifier.operand->type == hol_term_type::IF_THEN)
					inner_right = last->quantifier.operand->binary.right;

				if (inner_right != nullptr) {
					if (inner_right->type == hol_term_type::UNARY_APPLICATION && inner_right->binary.left->type == hol_term_type::CONSTANT && inner_right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
						if (WideScope) {
							return (hol_term*) nullptr;
						} else {
							head->reference_count++;
							return head;
						}
					}
				}

				dst = head;
				head->reference_count++;
			}
		}
	}

	if (dst == nullptr) {
		hol_term* element_var = hol_term::new_variable(element_variable);
		if (element_var == nullptr)
			return (hol_term*) nullptr;

		hol_term* lambda_apply_term = hol_term::new_apply(hol_term::new_variable(lambda_variable), element_var);
		if (lambda_apply_term == nullptr) {
			free(*element_var); free(element_var);
			return (hol_term*) nullptr;
		}

		if (!WideScope) {
			hol_term* temp = hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, lambda_apply_term);
			if (temp == nullptr) {
				free(*lambda_apply_term); free(lambda_apply_term);
				return (hol_term*) nullptr;
			}
			lambda_apply_term = temp;
			hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
		}

		hol_term* any_quantifier = hol_term::new_any_quantifier(hol_quantifier_type::ANY, &HOL_ANY);
		if (any_quantifier == nullptr) {
			free(*lambda_apply_term); free(lambda_apply_term);
			return (hol_term*) nullptr;
		}
		HOL_ANY.reference_count++;

		hol_term* quantifier = hol_term::new_any_quantifier(hol_quantifier_type::FOR_ALL_OR_EXISTS, hol_term::new_any_right(lambda_apply_term, &any_quantifier, 1));
		if (quantifier == nullptr) {
			free(*lambda_apply_term); free(lambda_apply_term);
			free(*any_quantifier); free(any_quantifier);
			return (hol_term*) nullptr;
		}

		if (WideScope) {
			hol_term* excluded_quantifier = hol_term::new_any(hol_term::new_exists(set_variable, &HOL_ANY));
			if (excluded_quantifier == nullptr) {
				free(*quantifier); free(quantifier);
				return (hol_term*) nullptr;
			}
			HOL_ANY.reference_count++;

			hol_term* temp = hol_term::new_any_right(quantifier, &excluded_quantifier, 1);
			if (temp == nullptr) {
				free(*quantifier); free(quantifier);
				free(*excluded_quantifier); free(excluded_quantifier);
				return (hol_term*) nullptr;
			}
			quantifier = temp;
		}

		hol_term* new_head = hol_term::new_exists(set_variable, hol_term::new_any_array(hol_term_type::AND, &HOL_ANY,
				make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0), make_array_view(&quantifier, 1)));
		if (new_head == nullptr) {
			free(*quantifier); free(quantifier);
			return (hol_term*) nullptr;
		}
		HOL_ANY.reference_count++;

		array<hol_term*> intersection(2);
		intersect<built_in_predicates>(intersection, new_head, head);
		free(*new_head); if (new_head->reference_count == 0) free(new_head);
		if (intersection.length == 0) {
			return (hol_term*) nullptr;
		} else if (intersection.length > 1) {
			fprintf(stderr, "do_require_narrow_or_wide_scope ERROR: Intersection is not unique.\n");
			for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
			return (hol_term*) nullptr;
		}
		dst = intersection[0];
		for (unsigned int i = 1; i < intersection.length; i++) {
			hol_term* term = intersection[i];
			free(*term); if (term->reference_count == 0) free(term);
		}
	}

	if (old_head->type == hol_term_type::ANY || old_head->type == hol_term_type::ANY_RIGHT) {
		hol_term* new_dst = hol_term::new_any_right(dst);
		if (new_dst == nullptr) {
			free(*dst); if (dst->reference_count == 0) free(dst);
			return (hol_term*) nullptr;
		}
		dst = new_dst;
	}
	return dst;
}

template<bool WideScope>
bool require_narrow_or_wide_scope(hol_term* src, hol_term*& dst)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	bool can_have_wide_scope = false;
	auto check_wide_scope = [&can_have_wide_scope](hol_term* term) {
		if (term->type == hol_term_type::ANY || term->type == hol_term_type::ANY_RIGHT) {
			can_have_wide_scope = true;
		} else if (term->type == hol_term_type::UNARY_APPLICATION && term->binary.left->type == hol_term_type::CONSTANT && term->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
			can_have_wide_scope = true;
		}
		return true;
	};

	head_index predicate_index;
	auto head_finder = predicative_head_finder<built_in_predicates>(lambda_variable);
	hol_term* head = find_head(src, predicate_index, head_finder, check_wide_scope);
	if (head == nullptr)
		return false;

	hol_term* new_head = do_require_narrow_or_wide_scope<WideScope>(head, lambda_variable, max_variable, can_have_wide_scope);
	if (new_head == nullptr)
		return false;

	dst = substitute_head<any_node_position::NONE>(src, head, new_head);
	free(*new_head); if (new_head->reference_count == 0) free(new_head);
	return (dst != nullptr);
}

bool remove_wide_scope(hol_term* src, hol_term*& dst)
{
	array<hol_term*> outer_scopes(8);
	auto apply = [&outer_scopes](hol_term* term) {
		outer_scopes.add(term);
	};

	head_index predicate_index;
	auto head_finder = make_head_or_unary_application_finder<(unsigned int) built_in_predicates::WIDE_SCOPE>(find_head<built_in_predicates>);
	hol_term* head = find_head(src, predicate_index, head_finder, apply);
	if (head == nullptr) return false;

	hol_term* new_head;
	if (head->type == hol_term_type::UNARY_APPLICATION && head->binary.left->type == hol_term_type::CONSTANT && head->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
		new_head = head->binary.right;

		/* removing the wide scope marker could create adjacent `ANY_RIGHT` nodes, so in that case, merge them */
		if ((new_head->type == hol_term_type::ANY || new_head->type == hol_term_type::ANY_RIGHT) && outer_scopes.length >= 2
		 && (outer_scopes[outer_scopes.length - 2]->type == hol_term_type::ANY || outer_scopes[outer_scopes.length - 2]->type == hol_term_type::ANY_RIGHT))
		{
			head = outer_scopes[outer_scopes.length - 2];

			hol_term* merged;
			array<hol_term*> excluded(max(1u, head->any.excluded_tree_count + new_head->any.excluded_tree_count));
			for (unsigned int i = 0; i < new_head->any.excluded_tree_count; i++) {
				/* make sure this tree isn't a subset of any tree in `head->any.excluded_trees` */
				bool irreducible = true;
				for (unsigned int j = 0; j < head->any.excluded_tree_count; j++) {
					if (is_subset<built_in_predicates>(new_head->any.excluded_trees[i], head->any.excluded_trees[j])) {
						irreducible = false;
						break;
					}
				}
				if (irreducible)
					excluded[excluded.length++] = new_head->any.excluded_trees[i];
			}
			unsigned int old_excluded_tree_count = excluded.length;
			for (unsigned int i = 0; i < head->any.excluded_tree_count; i++) {
				/* make sure this tree isn't a subset of any tree in `excluded` so far */
				bool irreducible = true;
				for (unsigned int j = 0; j < old_excluded_tree_count; j++) {
					if (is_subset<built_in_predicates>(head->any.excluded_trees[i], excluded[j])) {
						irreducible = false;
						break;
					}
				}
				if (irreducible)
					excluded[excluded.length++] = head->any.excluded_trees[i];
			}
			if (head->type == hol_term_type::ANY || new_head->type == hol_term_type::ANY)
				merged = hol_term::new_any(new_head->any.included, excluded.data, excluded.length);
			else merged = hol_term::new_any_right(new_head->any.included, excluded.data, excluded.length);
			if (merged == nullptr)
				return false;
			new_head = merged;
			new_head->any.included->reference_count++;
			for (unsigned int i = 0; i < excluded.length; i++)
				excluded[i]->reference_count++;
		} else {
			new_head->reference_count++;
		}
	} else {
		new_head = head;
		new_head->reference_count++;
	}

	hol_term* new_term = substitute_head<any_node_position::NONE>(src, head, new_head);
	free(*new_head); if (new_head->reference_count == 0) free(new_head);
	if (new_term == nullptr)
		return false;

	hol_term* excluded = hol_term::new_any_right(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ANY));
	if (excluded == nullptr) {
		free(*new_term); if (new_term->reference_count == 0) free(new_term);
		return false;
	}
	hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
	HOL_ANY.reference_count++;

	array<hol_term*> difference(2);
	subtract<built_in_predicates>(difference, new_term, excluded);
	free(*new_term); if (new_term->reference_count == 0) free(new_term);
	free(*excluded); if (excluded->reference_count == 0) free(excluded);
	if (difference.length == 0) {
		return false;
	} else if (difference.length != 1) {
		fprintf(stderr, "remove_wide_scope ERROR: Set difference is not unique.\n");
		free_all(difference); return false;
	}
	dst = difference[0];
	return true;
}

inline bool require_set_not_empty(hol_term* src, hol_term*& dst)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<true>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker,
			predicative_head_finder<built_in_predicates>(lambda_variable),
			[&max_variable,lambda_variable](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr && head->any.included->type == hol_term_type::EXISTS)
					head = head->any.included;

				hol_term* left; hol_term* set_definition;
				unsigned int set_variable, element_variable;
				if (!get_predicative_set_variables(head, lambda_variable, left, set_definition, set_variable, element_variable, max_variable))
					return (hol_term*) nullptr;

				hol_term* excluded_quantifiers[4];
				excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(set_variable, &HOL_ANY));
				excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(set_variable, &HOL_ANY));
				excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(set_variable, &HOL_ANY));
				excluded_quantifiers[3] = &hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value;
				if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
				if (excluded_quantifiers[1] != nullptr) HOL_ANY.reference_count++;
				if (excluded_quantifiers[2] != nullptr) HOL_ANY.reference_count++;
				if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr) {
					if (excluded_quantifiers[0] != nullptr) { free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]); }
					if (excluded_quantifiers[1] != nullptr) { free(*excluded_quantifiers[1]); free(excluded_quantifiers[1]); }
					if (excluded_quantifiers[2] != nullptr) { free(*excluded_quantifiers[2]); free(excluded_quantifiers[2]); }
					return (hol_term*) nullptr;
				}
				hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;

				hol_term* excluded_set_definitions[4];
				excluded_set_definitions[0] = hol_term::new_any(hol_term::new_exists(element_variable, &HOL_ANY));
				excluded_set_definitions[1] = hol_term::new_any(hol_term::new_for_all(element_variable, &HOL_ANY));
				excluded_set_definitions[2] = hol_term::new_any(hol_term::new_lambda(element_variable, &HOL_ANY));
				excluded_set_definitions[3] = &HOL_TRUE;
				if (excluded_set_definitions[0] != nullptr) HOL_ANY.reference_count++;
				if (excluded_set_definitions[1] != nullptr) HOL_ANY.reference_count++;
				if (excluded_set_definitions[2] != nullptr) HOL_ANY.reference_count++;
				if (excluded_set_definitions[0] == nullptr || excluded_set_definitions[1] == nullptr || excluded_set_definitions[2] == nullptr) {
					if (excluded_set_definitions[0] != nullptr) { free(*excluded_set_definitions[0]); free(excluded_set_definitions[0]); }
					if (excluded_set_definitions[1] != nullptr) { free(*excluded_set_definitions[1]); free(excluded_set_definitions[1]); }
					for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
					return (hol_term*) nullptr;
				}
				HOL_TRUE.reference_count++;

				hol_term* excluded_trees[array_length(excluded_quantifiers) + array_length(excluded_set_definitions)];
				for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++)
					excluded_trees[i] = excluded_quantifiers[i];
				for (unsigned int i = 0; i < array_length(excluded_set_definitions); i++)
					excluded_trees[array_length(excluded_quantifiers) + i] = excluded_set_definitions[i];

				hol_term* new_left;
				array<hol_term*> second_expected_heads(2);
				if (left == nullptr || left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT) {
					new_left = hol_term::new_any_right(hol_term::new_lambda(element_variable,
								hol_term::new_any(nullptr, excluded_set_definitions, array_length(excluded_set_definitions))), excluded_quantifiers, array_length(excluded_quantifiers));
					if (new_left == nullptr) {
						for (unsigned int i = 0; i < array_length(excluded_trees); i++) {
							free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
						}
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++)
						excluded_quantifiers[i]->reference_count++;
				} else if (left->type == hol_term_type::EQUALS) {
					new_left = hol_term::new_equals(hol_term::new_variable(set_variable),
								hol_term::new_lambda(element_variable, hol_term::new_any(nullptr, excluded_set_definitions, array_length(excluded_set_definitions))));
					if (new_left == nullptr) {
						for (unsigned int i = 0; i < array_length(excluded_trees); i++) {
							free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
						}
						return (hol_term*) nullptr;
					}
				} else if (left->type == hol_term_type::BINARY_APPLICATION) {
					new_left = hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::SUBSET>::value, hol_term::new_variable(set_variable),
								hol_term::new_lambda(element_variable, hol_term::new_any(nullptr, excluded_set_definitions, array_length(excluded_set_definitions))));
					if (new_left == nullptr) {
						for (unsigned int i = 0; i < array_length(excluded_trees); i++) {
							free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
						}
						return (hol_term*) nullptr;
					}
					hol_term::constants<(unsigned int) built_in_predicates::SUBSET>::value.reference_count++;
				} else {
					for (unsigned int i = 0; i < array_length(excluded_trees); i++) {
						free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
					}
					return (hol_term*) nullptr;
				}

				hol_term* new_head = hol_term::new_exists(set_variable, hol_term::new_any_array(hol_term_type::AND,
						hol_term::new_any(nullptr, excluded_quantifiers, array_length(excluded_quantifiers)),
						make_array_view((hol_term**) nullptr, 0), make_array_view(&new_left, 1), make_array_view((hol_term**) nullptr, 0)));
				if (new_head == nullptr) {
					for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) {
						free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers);
					}
					free(*new_left); free(new_left);
					return (hol_term*) nullptr;
				}

				array<hol_term*> intersection(2);
				intersect<built_in_predicates>(intersection, head, new_head);
				free(*new_head); if (new_head->reference_count == 0) free(new_head);
				if (intersection.length > 1) {
					fprintf(stderr, "require_set_not_empty ERROR: Intersection is not unique.\n");
					free_all(intersection);
					return (hol_term*) nullptr;
				} else if (intersection.length == 0) {
					return (hol_term*) nullptr;
				}
				return intersection[0];
			}, no_op()) && dst != nullptr;
}

inline bool require_constant_in_set(hol_term* src, hol_term*& dst)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<true>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker,
			predicative_head_finder<built_in_predicates>(lambda_variable),
			[&max_variable,lambda_variable](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				hol_term* any_constant = hol_term::new_any_constant_except();
				if (any_constant == nullptr)
					return (hol_term*) nullptr;
				array<hol_term*> out(2);
				if (!select_predicate_in_set<true, false, true, true, true>(out, head, any_constant, max_variable, lambda_variable) || out.length == 0) {
					free(*any_constant); free(any_constant);
					return (hol_term*) nullptr;
				}
				free(*any_constant); if (any_constant->reference_count == 0) free(any_constant);
				return out[0];
			}, no_op()) && dst != nullptr;
}

inline bool require_no_constant_in_set(hol_term* src, hol_term*& dst)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<true>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker,
			predicative_head_finder<built_in_predicates>(lambda_variable),
			[&max_variable,lambda_variable](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				hol_term* old_head = head;
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
					head = head->any.included;

				unsigned int set_variable, element_variable;
				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) {
					set_variable = ++max_variable;
					element_variable = ++max_variable;
				} else {
#if !defined(NDEBUG)
					if (head->type != hol_term_type::EXISTS) {
						fprintf(stderr, "require_no_constant_in_set ERROR: Expected existential quantification of set.\n");
						return (hol_term*) nullptr;
					}
#endif

					hol_term* operand = head->quantifier.operand;
					set_variable = head->quantifier.variable;
					if (operand->type == hol_term_type::ANY) {
						element_variable = ++max_variable;
					} else {
						hol_term* last;
						if (operand->type == hol_term_type::ANY_ARRAY) {
							if (operand->any_array.right.length == 0) {
								fprintf(stderr, "require_no_constant_in_set ERROR: Expected an existentially quantified conjunction with a right-most operand.\n");
								return (hol_term*) nullptr;
							}
							last = operand->any_array.right.operands[operand->any_array.right.length - 1];
						} else if (operand->type == hol_term_type::AND) {
							last = operand->array.operands[operand->array.length - 1];
						} else {
							last = operand;
						}

						bool last_is_any = false;
						if ((last->type == hol_term_type::ANY || last->type == hol_term_type::ANY_RIGHT) && last->any.included != nullptr) {
							last = last->any.included;
							last_is_any = true;
						} if (last->type == hol_term_type::UNARY_APPLICATION && last->binary.left->type == hol_term_type::CONSTANT && last->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
							last = last->binary.right;
						}

						while (last->type == hol_term_type::NOT)
							last = operand->unary.operand;

						if (last->type == hol_term_type::ANY) {
							element_variable = ++max_variable;
						} else if (last_is_any && last->type == hol_term_type::UNARY_APPLICATION && last->binary.left->type == hol_term_type::VARIABLE
								&& last->binary.left->variable == lambda_variable && last->binary.right->type == hol_term_type::VARIABLE)
						{
							element_variable = last->binary.right->variable;
						} else if (last->type == hol_term_type::FOR_ALL || last->type == hol_term_type::EXISTS) {
							element_variable = last->quantifier.variable;
						} else {
							return (hol_term*) nullptr;
						}
					}
				}

				hol_term* excluded_trees[3];
				excluded_trees[0] = hol_term::new_any(hol_term::new_exists(set_variable, &HOL_ANY));
				excluded_trees[1] = hol_term::new_any(hol_term::new_lambda(element_variable, &HOL_ANY));
				excluded_trees[2] = hol_term::new_any(hol_term::new_equals(hol_term::new_variable(element_variable), &HOL_ANY));
				if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; }
				if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
				if (excluded_trees[2] != nullptr) { HOL_ANY.reference_count++; }
				if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr || excluded_trees[2] == nullptr) {
					if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
					if (excluded_trees[1] != nullptr) { free(*excluded_trees[1]); free(excluded_trees[1]); }
					return (hol_term*) nullptr;
				}

				hol_term* set_definition = hol_term::new_equals(hol_term::new_variable(set_variable),
						hol_term::new_lambda(element_variable, hol_term::new_any(nullptr, excluded_trees, array_length(excluded_trees))));
				if (set_definition == nullptr) {
					free(*excluded_trees[0]); free(excluded_trees[0]);
					free(*excluded_trees[1]); free(excluded_trees[1]);
					free(*excluded_trees[2]); free(excluded_trees[2]);
					return (hol_term*) nullptr;
				}

				hol_term* expected_head = hol_term::new_exists(set_variable, hol_term::new_any_array(hol_term_type::AND,
						hol_term::new_any(nullptr, &excluded_trees[0], 1), make_array_view((hol_term**) nullptr, 0),
						make_array_view(&set_definition, 1), make_array_view((hol_term**) nullptr, 0)));
				if (expected_head == nullptr) {
					free(*set_definition); free(set_definition);
					return (hol_term*) nullptr;
				}
				excluded_trees[0]->reference_count++;

				array<hol_term*> intersection(2);
				intersect<built_in_predicates>(intersection, expected_head, head);
				free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
				if (intersection.length == 0) {
					return (hol_term*) nullptr;
				} else if (intersection.length > 1) {
					fprintf(stderr, "require_no_constant_in_set ERROR: Intersection is not unique.\n");
					free_all(intersection); return (hol_term*) nullptr;
				}

				hol_term* dst = intersection[0];
				if (old_head->type == hol_term_type::ANY || old_head->type == hol_term_type::ANY_RIGHT) {
					hol_term* new_term = hol_term::new_any_right(dst, old_head->any.excluded_trees, old_head->any.excluded_tree_count);
					if (new_term == nullptr) {
						free_all(intersection);
						return (hol_term*) nullptr;
					}
					for (unsigned int j = 0; j < old_head->any.excluded_tree_count; j++)
						old_head->any.excluded_trees[j]->reference_count++;
					dst = new_term;
				}
				return dst;
			}, no_op()) && dst != nullptr;
}

inline bool require_string_or_number_in_set(hol_term* src, hol_term*& dst)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<true>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker,
			predicative_head_finder<built_in_predicates>(lambda_variable),
			[&max_variable,lambda_variable](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				array<hol_term*> out(2);
				if (!select_predicate_in_set<true, false, true, true, true>(out, head, &HOL_ANY, max_variable, lambda_variable) || out.length == 0)
					return (hol_term*) nullptr;
				hol_term* left = out[0]->quantifier.operand->array.operands[0];
				hol_term* set_definition = left->binary.right->quantifier.operand;
				if (set_definition->binary.right->type != hol_term_type::ANY && set_definition->binary.right->type != hol_term_type::ANY_RIGHT
				 && set_definition->binary.right->type != hol_term_type::STRING && set_definition->binary.right->type != hol_term_type::NUMBER)
				{
					free_all(out);
					return (hol_term*) nullptr;
				}
				return out[0];
			}, no_op()) && dst != nullptr;
}

inline bool require_name_in_set(hol_term* src, hol_term*& dst)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<true>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker,
			predicative_head_finder<built_in_predicates>(lambda_variable),
			[&max_variable,lambda_variable](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				array<hol_term*> out(2);
				if (!select_scope_arg_in_set<true, false, true, true, true>(out, head, &HOL_NAME, &HOL_ANY, max_variable, lambda_variable) || out.length == 0)
					return (hol_term*) nullptr;
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr && head->any.included->type == hol_term_type::EXISTS) {
					hol_term* temp = hol_term::new_any_right(out[0], head->any.excluded_trees, head->any.excluded_tree_count);
					if (temp == nullptr) {
						free_all(out);
						return (hol_term*) nullptr;
					}
					out[0] = temp;
				}
				return out[0];
			}, no_op()) && dst != nullptr;
}

inline bool require_measure_in_set(hol_term* src, hol_term*& dst)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<true>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker, predicative_head_finder<built_in_predicates>(lambda_variable),
			[&max_variable,lambda_variable](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				hol_term* old_head = head;
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr
				 && (head->any.included->type == hol_term_type::NOT || head->any.included->type == hol_term_type::EXISTS))
					head = head->any.included;

				bool negated = false;
				if (head->type == hol_term_type::NOT) {
					head = head->unary.operand;
					negated = true;
				}

				unsigned int set_variable, element_variable = 0;
				hol_term* left = nullptr;
				hol_term* set_definition = nullptr;
				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT)
				{
					set_variable = ++max_variable;
					element_variable = ++max_variable;
				} else {
#if !defined(NDEBUG)
					if (head->type != hol_term_type::EXISTS)
						fprintf(stderr, "require_measure_in_set WARNING: Expected an existential quantification.\n");
#endif
					set_variable = head->quantifier.variable;
					hol_term* operand = head->quantifier.operand;

					hol_term* right = nullptr;
					if (operand->type == hol_term_type::ANY || operand->type == hol_term_type::ANY_RIGHT) {
						element_variable = ++max_variable;
					} else if (operand->type == hol_term_type::AND && operand->array.length != 0) {
						left = operand->array.operands[0];
						right = operand->array.operands[operand->array.length - 1];
					} else if (operand->type == hol_term_type::ANY_ARRAY) {
						if (operand->any_array.left.length != 0)
							left = operand->any_array.left.operands[0];
						else left = operand->any_array.all;
						if (operand->any_array.right.length != 0)
							right = operand->any_array.right.operands[operand->any_array.right.length - 1];
						else right = operand->any_array.all;
					} else {
						return (hol_term*) nullptr;
					}

					if (left != nullptr) {
						if (left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT) {
							if (left->any.included != nullptr)
								set_definition = left->any.included;
						} else if (left->type == hol_term_type::EQUALS) {
							set_definition = left->binary.right;
						} else if (left->type == hol_term_type::BINARY_APPLICATION) {
							set_definition = left->ternary.third;
						} else {
							return (hol_term*) nullptr;
						}
					}

					if (set_definition != nullptr) {
						if (set_definition->type == hol_term_type::ANY || set_definition->type == hol_term_type::ANY_RIGHT) {
							/* no-op */
						} else if (set_definition->type == hol_term_type::LAMBDA) {
							element_variable = set_definition->quantifier.variable;
						} else {
							return (hol_term*) nullptr;
						}
					}

					if (element_variable == 0 && right != nullptr) {
						/* try to get the element variable from the right conjunct, since we couldn't get it from the left conjunct */
						if ((right->type == hol_term_type::ANY || right->type == hol_term_type::ANY_RIGHT) && right->any.included != nullptr)
							right = right->any.included;
						if (right->type == hol_term_type::UNARY_APPLICATION && right->binary.left->type == hol_term_type::CONSTANT && right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE)
							right = right->binary.right;
						if (right->type == hol_term_type::ANY || right->type == hol_term_type::ANY_RIGHT) {
							element_variable = ++max_variable;
						} else if (right->type == hol_term_type::EXISTS || right->type == hol_term_type::FOR_ALL) {
							element_variable = right->quantifier.variable;
						} else if (right->type == hol_term_type::AND && right->array.length == 2 && right->array.operands[1]->type == hol_term_type::UNARY_APPLICATION
								&& right->array.operands[1]->binary.left->type == hol_term_type::VARIABLE && right->array.operands[1]->binary.left->variable == set_variable
								&& right->array.operands[1]->binary.right->type == hol_term_type::VARIABLE)
						{
							element_variable = right->array.operands[1]->binary.right->variable;
						} else {
							return (hol_term*) nullptr;
						}
					}
				}

				hol_term* inner_set_definition = nullptr;
				if (set_definition != nullptr && set_definition->type == hol_term_type::LAMBDA)
					inner_set_definition = set_definition->quantifier.operand;

				hol_term* head_var = hol_term::new_variable(head_variable);
				if (head_var == nullptr) return (hol_term*) nullptr;
				constexpr unsigned int excluded_tree_count = 3;
				hol_term* excluded_trees[excluded_tree_count];
				excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
							(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
							(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
						&HOL_ANY), head_var));
				excluded_trees[1] = hol_term::new_any(hol_term::new_exists(head_variable, &HOL_ANY));
				excluded_trees[2] = hol_term::new_any(hol_term::new_lambda(element_variable, &HOL_ANY));
				if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
				if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
				if (excluded_trees[2] != nullptr) { HOL_ANY.reference_count++; }
				if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr || excluded_trees[2] == nullptr) {
					if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
					if (excluded_trees[1] != nullptr) { free(*excluded_trees[1]); free(excluded_trees[1]); }
					free(*head_var); free(head_var);
					return (hol_term*) nullptr;
				}
				free(*head_var);

				hol_term* conjunct = hol_term::new_any(nullptr, excluded_trees, excluded_tree_count);
				if (conjunct == nullptr) {
					for (unsigned int i = 0; i < excluded_tree_count; i++) {
						free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
					}
					return (hol_term*) nullptr;
				}

				hol_term* element_var = hol_term::new_variable(element_variable);
				if (element_var == nullptr) {
					free(*conjunct); free(conjunct);
					return (hol_term*) nullptr;
				}

				hol_term* conjunction = hol_term::new_and(
							hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::MEASURE>::value, element_var),
							hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG1>::value, element_var), conjunct),
							hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value, element_var), conjunct)
						);
				if (conjunction == nullptr) {
					free(*conjunct); free(conjunct);
					free(*element_var); free(element_var);
					return (hol_term*) nullptr;
				}
				element_var->reference_count += 3;
				conjunct->reference_count += 2 - 1;
				hol_term::constants<(unsigned int) built_in_predicates::MEASURE>::value.reference_count++;
				hol_term::constants<(unsigned int) built_in_predicates::ARG1>::value.reference_count++;
				hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value.reference_count++;

				hol_term* new_set_definition;
				if (inner_set_definition == nullptr) {
					new_set_definition = conjunction;
				} else {
					array<hol_term*> intersection(2);
					intersect<built_in_predicates>(intersection, conjunction, inner_set_definition);
					free(*conjunction); free(conjunction);
					if (intersection.length > 1) {
						fprintf(stderr, "require_measure_in_set ERROR: Expected intersection size to be 1.\n");
						for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
						free(*element_var); free(element_var);
						return (hol_term*) nullptr;
					} else if (intersection.length == 0) {
						free(*element_var); free(element_var);
						return (hol_term*) nullptr;
					}
					new_set_definition = intersection[0];
					if (new_set_definition == inner_set_definition) {
						free_all(intersection);
						free(*element_var); free(element_var);
						old_head->reference_count++;
						return old_head;
					}
				}

				hol_term* set_var = hol_term::new_variable(set_variable);
				if (set_var == nullptr) {
					free(*new_set_definition); if (new_set_definition->reference_count == 0) free(new_set_definition);
					free(*element_var); free(element_var);
					return (hol_term*) nullptr;
				}

				hol_term* new_left = hol_term::new_equals(set_var, hol_term::new_lambda(element_variable, new_set_definition));
				if (new_left == nullptr) {
					free(*new_set_definition); if (new_set_definition->reference_count == 0) free(new_set_definition);
					free(*set_var); free(set_var);
					free(*element_var); free(element_var);
					return (hol_term*) nullptr;
				}
				set_var->reference_count++;

				hol_term* new_head = hol_term::new_exists(head->quantifier.variable, hol_term::new_and(new_left,
						hol_term::new_exists(element_variable, hol_term::new_and(
							hol_term::new_apply(set_var, element_var),
							hol_term::new_apply(hol_term::new_variable(lambda_variable), element_var)))));
				if (new_head == nullptr) {
					free(*set_var); free(set_var);
					free(*element_var); free(element_var);
					free(*new_left); free(new_left);
					return (hol_term*) nullptr;
				}
				element_var->reference_count += 2 - 1;

				array<hol_term*> intersection(2);
				intersect<built_in_predicates>(intersection, new_head, head);
				free(*new_head); if (new_head->reference_count == 0) free(new_head);
				if (intersection.length > 1) {
					fprintf(stderr, "require_measure_in_set ERROR: Expected intersection size to be 1.\n");
					for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
					return (hol_term*) nullptr;
				} else if (intersection.length == 0) {
					return (hol_term*) nullptr;
				}
				hol_term* dst = intersection[0];

				if (negated) {
					hol_term* new_dst = hol_term::new_not(dst);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					dst = new_dst;
				}

				if (old_head->type == hol_term_type::ANY || old_head->type == hol_term_type::ANY_RIGHT) {
					hol_term* new_dst = hol_term::new_any_right(dst, old_head->any.excluded_trees, old_head->any.excluded_tree_count);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < old_head->any.excluded_tree_count; i++)
						old_head->any.excluded_trees[i]->reference_count++;
					dst = new_dst;
				}
				return dst;
			}, no_op()) && dst != nullptr;
}

inline bool require_singleton(hol_term* src, hol_term*& dst)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<true>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker,
			predicative_head_finder<built_in_predicates>(lambda_variable),
			[&max_variable](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				hol_term* old_head = head;
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
					head = head->any.included;

				unsigned int set_variable;
				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) {
					set_variable = ++max_variable;
				} else {
#if !defined(NDEBUG)
					if (head->type != hol_term_type::EXISTS) {
						fprintf(stderr, "require_singleton ERROR: Expected existential quantification of set.\n");
						return (hol_term*) nullptr;
					}
#endif
					set_variable = head->quantifier.variable;
				}

				hol_term* excluded_quantifiers[3];
				excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(set_variable, &HOL_ANY));
				excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(set_variable, &HOL_ANY));
				excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(set_variable, &HOL_ANY));
				if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
				if (excluded_quantifiers[1] != nullptr) HOL_ANY.reference_count++;
				if (excluded_quantifiers[2] != nullptr) HOL_ANY.reference_count++;
				if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr) {
					if (excluded_quantifiers[0] != nullptr) { free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]); }
					if (excluded_quantifiers[1] != nullptr) { free(*excluded_quantifiers[1]); free(excluded_quantifiers[1]); }
					return (hol_term*) nullptr;
				}

				hol_term* conjunct = hol_term::new_any(nullptr, excluded_quantifiers, array_length(excluded_quantifiers));
				if (conjunct == nullptr) {
					for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
					return (hol_term*) nullptr;
				}

				hol_term* set_size_conjunct = hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::SIZE>::value, hol_term::new_variable(set_variable)), hol_term::new_number(1, 0));
				if (set_size_conjunct == nullptr) {
					free(*conjunct); free(conjunct);
					return (hol_term*) nullptr;
				}
				hol_term::constants<(unsigned int) built_in_predicates::SIZE>::value.reference_count++;

				hol_term* expected_head = hol_term::new_exists(set_variable, hol_term::new_any_array(hol_term_type::AND, conjunct,
						make_array_view((hol_term**) nullptr, 0),
						make_appended_array_view(make_repeated_array_view(conjunct, 1), set_size_conjunct),
						make_array_view((hol_term**) nullptr, 0)));
				if (expected_head == nullptr) {
					free(*set_size_conjunct); free(set_size_conjunct);
					free(*conjunct); free(conjunct);
					return (hol_term*) nullptr;
				}
				conjunct->reference_count += 2 - 1;

				array<hol_term*> out(2);
				intersect<built_in_predicates>(out, expected_head, head);
				free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
				if (out.length == 0) {
					return (hol_term*) nullptr;
				} else if (out.length > 1) {
					fprintf(stderr, "require_singleton ERROR: Intersection is not unique.\n");
					for (hol_term* term : out) { free(*term); if (term->reference_count == 0) free(term); }
					return (hol_term*) nullptr;
				}

				hol_term* dst = out[0];
				if (old_head->type == hol_term_type::ANY || old_head->type == hol_term_type::ANY_RIGHT) {
					hol_term* new_dst = hol_term::new_any_right(dst);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					dst = new_dst;
				}
				return dst;
			}, no_op()) && dst != nullptr;
}

inline bool require_no_string_or_number_or_name_in_set(hol_term* src, hol_term*& dst)
{
	constexpr unsigned int excluded_tree_count = 3;
	hol_term** excluded_trees = (hol_term**) alloca(sizeof(hol_term) * (excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()));
	excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
				(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
				(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
			&HOL_ANY), &hol_term::variables<0>::value));
	excluded_trees[1] = hol_term::new_any(hol_term::new_lambda(0, &HOL_ANY));
	excluded_trees[2] = hol_term::new_any(&hol_term::constants<(unsigned int) built_in_predicates::NAME>::value);
	if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; hol_term::variables<0>::value.reference_count++; }
	if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
	if (excluded_trees[2] != nullptr) { hol_term::constants<(unsigned int) built_in_predicates::NAME>::value.reference_count++; }
	if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr || excluded_trees[2] == nullptr) {
		if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
		if (excluded_trees[1] != nullptr) { free(*excluded_trees[1]); free(excluded_trees[1]); }
		return false;
	}

	for (unsigned int i = 0; i < hol_non_head_constants<built_in_predicates>::count(); i++) {
		excluded_trees[excluded_tree_count + i] = hol_non_head_constants<built_in_predicates>::get_terms()[i];
		excluded_trees[excluded_tree_count + i]->reference_count++;
	}

	hol_term* expected_predicate = hol_term::new_apply(
				hol_term::new_any(nullptr, excluded_trees, excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()),
				&hol_term::variables<0>::value);
	if (expected_predicate == nullptr) {
		for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
			free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
		}
		return false;
	}
	hol_term::variables<0>::value.reference_count++;

	bool result = require_predicate_in_set<INT_FAST8_MAX>(src, dst, expected_predicate);
	free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
	return result;
}

inline bool size(hol_term* src, hol_term*& dst, grammatical_flags& dst_flags)
{
	unsigned int head_variable;
	if (src->type == hol_term_type::EXISTS) {
		head_variable = src->quantifier.variable;
	} else if ((src->type == hol_term_type::ANY || src->type == hol_term_type::ANY_RIGHT) && src->any.included != nullptr && src->any.included->type == hol_term_type::EXISTS) {
		src = src->any.included;
		head_variable = src->quantifier.variable;
	} else {
		head_variable = 1;
	}

	hol_term* expected_head = hol_term::new_exists(head_variable, hol_term::new_equals(hol_term::new_apply(
			&hol_term::constants<(unsigned int) built_in_predicates::SIZE>::value, hol_term::new_variable(head_variable)), &HOL_ANY));
	if (expected_head == nullptr)
		return (hol_term*) nullptr;
	hol_term::constants<(unsigned int) built_in_predicates::SIZE>::value.reference_count++;
	HOL_ANY.reference_count++;

	array<hol_term*> intersection(2);
	intersect<built_in_predicates>(intersection, src, expected_head);
	free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
	if (intersection.length == 0) {
		return (hol_term*) nullptr;
	} else if (intersection.length > 1) {
		fprintf(stderr, "size ERROR: Intersection is not unique.\n");
		free_all(intersection);
		return (hol_term*) nullptr;
	}

	dst = intersection[0]->quantifier.operand->binary.right;
	if (dst->type == hol_term_type::NUMBER) {
		if (dst->number.decimal != 0) {
			free_all(intersection);
			return false;
		} else if (dst->number.integer == 1 && dst->number.decimal == 0) {
			if (!intersect(dst_flags.index_number, grammatical_num::SINGULAR, dst_flags.index_number)) {
				free_all(intersection);
				return false;
			}
		} else {
			if (!intersect(dst_flags.index_number, grammatical_num::PLURAL, dst_flags.index_number)) {
				free_all(intersection);
				return false;
			}
		}
	}

	dst->reference_count++;
	free_all(intersection);
	return true;
}

template<unsigned int Arg, int_fast8_t ArgIndex>
inline bool arg_function(hol_term* src, hol_term*& dst, grammatical_flags& dst_flags)
{
	unsigned int head_variable;
	if (src->type == hol_term_type::EXISTS) {
		head_variable = src->quantifier.variable;
	} else if ((src->type == hol_term_type::ANY || src->type == hol_term_type::ANY_RIGHT) && src->any.included != nullptr && src->any.included->type == hol_term_type::EXISTS) {
		src = src->any.included;
		head_variable = src->quantifier.variable;
	} else {
		head_variable = 1;
	}

	hol_term* head_var = hol_term::new_variable(head_variable);
	if (head_var == nullptr) return false;
	constexpr unsigned int excluded_tree_count = 2;
	hol_term* excluded_trees[excluded_tree_count];
	excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
				(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
				(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
			&HOL_ANY), head_var));
	excluded_trees[1] = hol_term::new_any(hol_term::new_exists(head_variable, &HOL_ANY));
	if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
	if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
	if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr) {
		if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
		free(*head_var); free(head_var);
		return (hol_term*) nullptr;
	}

	hol_term* conjunct = hol_term::new_any(nullptr, excluded_trees, excluded_tree_count);
	if (conjunct == nullptr) {
		for (unsigned int i = 0; i < excluded_tree_count; i++) { free(*excluded_trees[i]); free(excluded_trees[i]); }
		free(*head_var); free(head_var);
		return (hol_term*) nullptr;
	}

	hol_term* expected_arg = hol_term::new_equals(hol_term::new_apply(&hol_term::constants<Arg>::value, head_var), conjunct);
	if (expected_arg == nullptr) {
		free(*head_var); free(head_var);
		free(*conjunct); free(conjunct);
		return (hol_term*) nullptr;
	}
	hol_term::constants<Arg>::value.reference_count++;
	conjunct->reference_count++;

	hol_term* expected_head;
	if (ArgIndex >= 0) {
		expected_head = hol_term::new_exists(head_variable, hol_term::new_any_array(
				hol_term_type::AND, conjunct, make_array_view((hol_term**) nullptr, 0),
				make_appended_array_view(make_repeated_array_view(conjunct, ArgIndex), expected_arg),
				make_array_view((hol_term**) nullptr, 0)));
		if (expected_head == nullptr) {
			free(*expected_arg); free(expected_arg);
			free(*conjunct); free(conjunct);
			free(*head_var); free(head_var);
			return (hol_term*) nullptr;
		}
		conjunct->reference_count += ArgIndex + 1 - 1;
	} else {
		unsigned int index = (unsigned int) (-ArgIndex) - 1;
		expected_head = hol_term::new_exists(head_variable, hol_term::new_any_array(hol_term_type::AND, conjunct,
				make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0),
				make_prepended_array_view(expected_arg, make_repeated_array_view(conjunct, index))));
		if (expected_head == nullptr) {
			free(*expected_arg); free(expected_arg);
			free(*conjunct); free(conjunct);
			free(*head_var); free(head_var);
			return (hol_term*) nullptr;
		}
		conjunct->reference_count += index;
	}

	array<hol_term*> intersection(2);
	intersect<built_in_predicates>(intersection, src, expected_head);
	free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
	if (intersection.length == 0) {
		return (hol_term*) nullptr;
	} else if (intersection.length > 1) {
		fprintf(stderr, "arg ERROR: Intersection is not unique.\n");
		free_all(intersection);
		return (hol_term*) nullptr;
	}

	hol_term* operand = intersection[0]->quantifier.operand;
	if (operand->type == hol_term_type::AND) {
		unsigned int index = (ArgIndex >= 0) ? ArgIndex : (operand->array.length + ArgIndex);
		dst = operand->array.operands[index]->binary.right;
	} else if (intersection[0]->quantifier.operand->type == hol_term_type::ANY_ARRAY) {
		if (ArgIndex >= 0)
			dst = operand->any_array.left.operands[ArgIndex]->binary.right;
		else dst = operand->any_array.right.operands[operand->any_array.right.length + ArgIndex]->binary.right;
	} else {
		dst = operand->binary.right;
	}

	if (dst->type == hol_term_type::NUMBER) {
		if (dst->number.integer == 1 && dst->number.decimal == 0) {
			if (!intersect(dst_flags.index_number, grammatical_num::SINGULAR, dst_flags.index_number)) {
				free_all(intersection);
				return false;
			}
		} else {
			if (!intersect(dst_flags.index_number, grammatical_num::PLURAL, dst_flags.index_number)) {
				free_all(intersection);
				return false;
			}
		}
	}

	dst->reference_count++;
	free_all(intersection);
	return true;
}

inline bool set_size(hol_term* src, hol_term*& dst)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<true>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker,
			predicative_head_finder<built_in_predicates>(lambda_variable),
			[lambda_variable,&max_variable](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
					head = head->any.included;

				unsigned int set_variable;
				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) {
					set_variable = ++max_variable;
				} else {
#if !defined(NDEBUG)
					if (head->type != hol_term_type::EXISTS) {
						fprintf(stderr, "set_size ERROR: Expected existential quantification of set.\n");
						return (hol_term*) nullptr;
					}
#endif
					set_variable = head->quantifier.variable;
				}

				hol_term* excluded_quantifiers[3];
				excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(set_variable, &HOL_ANY));
				excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(set_variable, &HOL_ANY));
				excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(set_variable, &HOL_ANY));
				if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
				if (excluded_quantifiers[1] != nullptr) HOL_ANY.reference_count++;
				if (excluded_quantifiers[2] != nullptr) HOL_ANY.reference_count++;
				if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr) {
					if (excluded_quantifiers[0] != nullptr) { free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]); }
					if (excluded_quantifiers[1] != nullptr) { free(*excluded_quantifiers[1]); free(excluded_quantifiers[1]); }
					return (hol_term*) nullptr;
				}

				hol_term* expected_conjunct = hol_term::new_any(nullptr, excluded_quantifiers, array_length(excluded_quantifiers));
				if (expected_conjunct == nullptr) {
					for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
					return (hol_term*) nullptr;
				}

				hol_term* expected_head = hol_term::new_exists(set_variable, hol_term::new_and(
						expected_conjunct,
						hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::SIZE>::value, hol_term::new_variable(set_variable)), expected_conjunct),
						expected_conjunct));
				if (expected_head == nullptr) {
					free(*expected_conjunct); free(expected_conjunct);
					return (hol_term*) nullptr;
				}
				hol_term::constants<(unsigned int) built_in_predicates::SIZE>::value.reference_count++;
				expected_conjunct->reference_count += 3 - 1;

				array<hol_term*> out(2);
				intersect<built_in_predicates>(out, expected_head, head);
				free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
				if (out.length == 0) {
					return (hol_term*) nullptr;
				} else if (out.length != 1) {
					fprintf(stderr, "set_size ERROR: Intersection is not unique.\n");
					for (hol_term* term : out) { free(*term); if (term->reference_count == 0) free(term); }
					return (hol_term*) nullptr;
				}

				hol_term* right = out[0]->quantifier.operand->array.operands[out[0]->quantifier.operand->array.length - 1];
				if ((right->type == hol_term_type::ANY || right->type == hol_term_type::ANY_RIGHT) && right->any.included != nullptr)
					right = right->any.included;
				if (right->type == hol_term_type::UNARY_APPLICATION && right->binary.left->type == hol_term_type::CONSTANT && right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE)
					right = right->binary.right;
				while (right->type == hol_term_type::NOT)
					right = right->unary.operand;
				if ((right->type == hol_term_type::ANY || right->type == hol_term_type::ANY_RIGHT) && right->any.included != nullptr)
					right = right->any.included;

				bool could_be_universal, could_be_existential;
				if (right->type == hol_term_type::FOR_ALL && right->quantifier.operand->type == hol_term_type::IF_THEN) {
					could_be_existential = false;
					could_be_universal = true;
				} else if (right->type == hol_term_type::EXISTS && right->quantifier.operand->type == hol_term_type::AND && right->quantifier.operand->array.length == 2) {
					could_be_existential = true;
					could_be_universal = false;
				} else if (right->type == hol_term_type::AND && right->array.length == 2) {
					could_be_existential = false;
					could_be_universal = false;
				} else if (right->type == hol_term_type::UNARY_APPLICATION
						&& right->binary.left->type == hol_term_type::VARIABLE
						&& right->binary.left->variable == lambda_variable
						&& right->binary.right->type == hol_term_type::VARIABLE)
				{
					could_be_existential = true;
					could_be_universal = true;
				} else {
					free_all(out);
					return (hol_term*) nullptr;
				}

				hol_term* dst = out[0]->quantifier.operand->array.operands[1]->binary.right;
				if (dst->type == hol_term_type::NUMBER) {
					if (dst->number.integer == 1 && dst->number.decimal == 0) {
						/* require the quantifier to be existential */
						if (!could_be_existential) {
							free_all(out);
							return (hol_term*) nullptr;
						}
					} else {
						/* require the quantifier to be universal */
						if (!could_be_universal) {
							free_all(out);
							return (hol_term*) nullptr;
						}
					}
				} else {
					if (!could_be_universal) {
						/* since the quantifier is an existential, the set size must be 1 */
						free_all(out);
						return hol_term::new_number(1, 0);
					}
				}
				dst->reference_count++;
				free_all(out);
				return dst;
			}, no_op()) && dst != nullptr;
}

template<int_fast8_t ConjunctIndex>
inline bool remove_predicate(
		hol_term* src, hol_term*& dst)
{
	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<true>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker, find_head<built_in_predicates>,
			[](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				hol_term* old_head = head;
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && predicate_index.position != head_position::NONE)
					head = head->any.included;

				bool negated = false;
				if (head->type == hol_term_type::NOT) {
					head = head->unary.operand;
					negated = true;
				}

				hol_term* dst;
				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT
				 || (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY)
				 || (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY_RIGHT))
				{
					hol_term* head_var = hol_term::new_variable(head_variable);
					if (head_var == nullptr) return (hol_term*) nullptr;
					constexpr unsigned int excluded_tree_count = 2;
					hol_term** excluded_trees = (hol_term**) alloca(sizeof(hol_term) * (excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()));
					excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
								(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
								(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
							&HOL_ANY), head_var));
					excluded_trees[1] = hol_term::new_any(hol_term::new_exists(head_variable, &HOL_ANY));
					if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
					if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
					if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr) {
						if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
						free(*head_var); free(head_var);
						return (hol_term*) nullptr;
					}
					free(*head_var);

					for (unsigned int i = 0; i < hol_non_head_constants<built_in_predicates>::count(); i++) {
						excluded_trees[excluded_tree_count + i] = hol_non_head_constants<built_in_predicates>::get_terms()[i];
						excluded_trees[excluded_tree_count + i]->reference_count++;
					}

					dst = hol_term::new_exists(head_variable, hol_term::new_any_array(hol_term_type::AND,
							hol_term::new_any(nullptr, excluded_trees, excluded_tree_count), make_array_view((hol_term**) nullptr, 0),
							make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0)));
					if (dst == nullptr) {
						for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
							free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
						}
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < excluded_tree_count; i++)
						excluded_trees[i]->reference_count++;
					for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
						free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
					}

					array<hol_term*> intersection(2);
					intersect<built_in_predicates>(intersection, dst, head);
					if (intersection.length > 1) {
						fprintf(stderr, "remove_predicate WARNING: Expected intersection size to be 1.\n");
						for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					free(*dst); if (dst->reference_count == 0) free(dst);
					if (intersection.length == 0)
						return (hol_term*) nullptr;
					dst = intersection[0];
				} else if (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY_ARRAY) {
					hol_term* operand = head->quantifier.operand;

					if (ConjunctIndex >= 0 && (predicate_index.position != head_position::LEFT || predicate_index.index != ConjunctIndex))
						return (hol_term*) nullptr;
					if (ConjunctIndex < 0 && (predicate_index.position != head_position::RIGHT || predicate_index.index != (unsigned int) (-ConjunctIndex) - 1))
						return (hol_term*) nullptr;

					hol_term* conjunction = nullptr;
					if (ConjunctIndex >= 0) {
						if (ConjunctIndex < operand->any_array.left.length) {
							conjunction = hol_term::new_any_array(hol_term_type::AND, operand->any_array.all,
									make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
									make_excluded_array_view(operand->any_array.left.operands, operand->any_array.left.length, ConjunctIndex),
									make_array_view(operand->any_array.right.operands, operand->any_array.right.length));
						} else {
							conjunction = operand;
						}
					} else if (ConjunctIndex < 0) {
						if (-ConjunctIndex - 1 < operand->any_array.right.length) {
							unsigned int index = (unsigned int) (-ConjunctIndex) - 1;
							index = operand->any_array.right.length - index - 1;
							conjunction = hol_term::new_any_array(hol_term_type::AND, operand->any_array.all,
									make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
									make_array_view(operand->any_array.left.operands, operand->any_array.left.length),
									make_excluded_array_view(operand->any_array.right.operands, operand->any_array.right.length, index));
						} else {
							conjunction = operand;
						}
					}
					if (conjunction == nullptr)
						return (hol_term*) nullptr;
					if (conjunction == operand) {
						operand->reference_count++;
					} else {
						conjunction->any_array.all->reference_count++;
						for (unsigned int i = 0; i < conjunction->any_array.any.length; i++)
							conjunction->any_array.any.operands[i]->reference_count++;
						for (unsigned int i = 0; i < conjunction->any_array.left.length; i++)
							conjunction->any_array.left.operands[i]->reference_count++;
						for (unsigned int i = 0; i < conjunction->any_array.right.length; i++)
							conjunction->any_array.right.operands[i]->reference_count++;
					}

					dst = hol_term::new_exists(head_variable, conjunction);
					if (dst == nullptr) {
						free(*conjunction); if (conjunction->reference_count == 0) free(conjunction);
						return (hol_term*) nullptr;
					}
				} else {
#if !defined(NDEBUG)
					if (head->type != hol_term_type::EXISTS || head->quantifier.operand->type != hol_term_type::AND)
						fprintf(stderr, "remove_predicate WARNING: Expected `head` to be an existentially quantified conjunction.\n");
#endif
					hol_term* operand = head->quantifier.operand;
					unsigned int conjunct_index = (ConjunctIndex < 0) ? (operand->array.length + ConjunctIndex) : ConjunctIndex;
					if (predicate_index.index != conjunct_index)
						return (hol_term*) nullptr;
					if (operand->array.length == 2) {
						dst = hol_term::new_exists(head_variable, (conjunct_index == 0 ? operand->array.operands[1] : operand->array.operands[0]));
					} else {
						dst = hol_term::new_exists(head_variable, hol_term::new_and(make_excluded_array_view(operand->array.operands, operand->array.length, conjunct_index)));
					}
					if (dst != nullptr) {
						for (unsigned int i = 0; i < operand->array.length; i++)
							if (i != conjunct_index) operand->array.operands[i]->reference_count++;
					}
				}

				if (negated) {
					hol_term* new_dst = hol_term::new_not(dst);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					dst = new_dst;
				}

				if (old_head->type == hol_term_type::ANY || old_head->type == hol_term_type::ANY_RIGHT) {
					hol_term* new_dst = hol_term::new_any_right(dst, old_head->any.excluded_trees, old_head->any.excluded_tree_count);
					if (new_dst == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < old_head->any.excluded_tree_count; i++)
						old_head->any.excluded_trees[i]->reference_count++;
					dst = new_dst;
				}
				return dst;
			}, no_op()) && dst != nullptr;
}

template<typename FindHeadFunction>
inline bool factor(
		hol_term* src, hol_term*& dst,
		FindHeadFunction find_head_function)
{
	hol_term* parent = nullptr;
	hol_term* current = nullptr;
	auto apply = [&parent,&current](hol_term* term) {
		parent = current;
		current = term;
	};

	head_index predicate_index;
	auto find_array_head = make_array_finder(find_head_function);
	hol_term* head = find_head(src, predicate_index, find_array_head, apply);
	if (head == nullptr)
		return false;

	hol_term* new_head;
	if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) {
		hol_term* excluded_array = hol_term::new_any_array(
				hol_term_type::ANY_ARRAY, &HOL_ANY, make_array_view((hol_term**) nullptr, 0),
				make_repeated_array_view(&HOL_ANY, 2), make_array_view((hol_term**) nullptr, 0));
		if (excluded_array == nullptr)
			return false;
		HOL_ANY.reference_count += 3;

		array<hol_term*> difference(2);
		subtract<built_in_predicates>(difference, head, excluded_array);
		free(*excluded_array); if (excluded_array->reference_count == 0) free(excluded_array);
		if (difference.length == 0) {
			return false;
		} else if (difference.length != 1) {
			fprintf(stderr, "factor ERROR: Set difference is not unique.\n");
			free_all(difference);
			return false;
		}
		new_head = difference[0];

	} else if (head->type == hol_term_type::AND || head->type == hol_term_type::OR) {
		if (find_head_function == &find_head<built_in_predicates>) {
			/* make sure each operand has the same head variable */
			unsigned int head_variable = 0;
			for (unsigned int i = 0; i < head->array.length; i++) {
				unsigned int operand_variable = get_head_variable(head->array.operands[i]);
				if (head_variable == 0)
					head_variable = operand_variable;
				else if (operand_variable != 0 && operand_variable != head_variable)
					return false;
			}
		}

		array<hol_term*> intersection(2);
		intersection[intersection.length] = head->array.operands[0];
		intersection[intersection.length++]->reference_count++;
		for (unsigned int i = 1; i < head->array.length; i++) {
			array<hol_term*> new_intersection(4);
			for (hol_term* prev : intersection)
				intersect<built_in_predicates>(new_intersection, prev, head->array.operands[i]);
			free_all(intersection);
			swap(new_intersection, intersection);
		}

		if (intersection.length == 0) {
			return false;
		} else if (intersection.length != 1) {
			fprintf(stderr, "factor ERROR: Set intersection is not unique.\n");
			free_all(intersection);
			return false;
		}
		new_head = intersection[0];

	} else if (head->type == hol_term_type::ANY_ARRAY && (head->any_array.oper == hol_term_type::ANY_ARRAY || head->any_array.oper == hol_term_type::AND || head->any_array.oper == hol_term_type::OR)) {
		if (find_head_function == &find_head<built_in_predicates>) {
			/* make sure each operand has the same head variable */
			unsigned int head_variable = get_head_variable(head->any_array.all);
			for (unsigned int i = 0; i < head->any_array.left.length; i++) {
				unsigned int operand_variable = get_head_variable(head->any_array.left.operands[i]);
				if (head_variable == 0)
					head_variable = operand_variable;
				else if (operand_variable != 0 && operand_variable != head_variable)
					return false;
			} for (unsigned int i = 0; i < head->any_array.right.length; i++) {
				unsigned int operand_variable = get_head_variable(head->any_array.right.operands[i]);
				if (head_variable == 0)
					head_variable = operand_variable;
				else if (operand_variable != 0 && operand_variable != head_variable)
					return false;
			} for (unsigned int i = 0; i < head->any_array.any.length; i++) {
				unsigned int operand_variable = get_head_variable(head->any_array.any.operands[i]);
				if (head_variable == 0)
					head_variable = operand_variable;
				else if (operand_variable != 0 && operand_variable != head_variable)
					return false;
			}
		}

		array<hol_term*> intersection(2);
		intersection[intersection.length] = head->any_array.all;
		intersection[intersection.length++]->reference_count++;
		for (unsigned int i = 0; i < head->any_array.left.length; i++) {
			array<hol_term*> new_intersection(4);
			for (hol_term* prev : intersection)
				intersect<built_in_predicates>(new_intersection, prev, head->any_array.left.operands[i]);
			free_all(intersection);
			swap(new_intersection, intersection);
		} for (unsigned int i = 0; i < head->any_array.right.length; i++) {
			array<hol_term*> new_intersection(4);
			for (hol_term* prev : intersection)
				intersect<built_in_predicates>(new_intersection, prev, head->any_array.right.operands[i]);
			free_all(intersection);
			swap(new_intersection, intersection);
		} for (unsigned int i = 0; i < head->any_array.any.length; i++) {
			array<hol_term*> new_intersection(4);
			for (hol_term* prev : intersection)
				intersect<built_in_predicates>(new_intersection, prev, head->any_array.any.operands[i]);
			free_all(intersection);
			swap(new_intersection, intersection);
		}

		if (intersection.length == 0) {
			return false;
		} else if (intersection.length != 1) {
			fprintf(stderr, "factor ERROR: Set intersection is not unique.\n");
			free_all(intersection);
			return false;
		}
		new_head = intersection[0];
	} else {
		new_head = head;
		new_head->reference_count++;
	}

	if ((new_head->type == hol_term_type::ANY || new_head->type == hol_term_type::ANY_RIGHT)
	 && parent != nullptr && (parent->type == hol_term_type::ANY || parent->type == hol_term_type::ANY_RIGHT))
	{
		hol_term_type new_type = (new_head->type == hol_term_type::ANY || parent->type == hol_term_type::ANY) ? hol_term_type::ANY : hol_term_type::ANY_RIGHT;
		if (parent->any.excluded_tree_count == 0 && new_type == new_head->type) {
			/* the merger of `parent` and `new_head` is just `new_head` (ignoring `included`) */
			dst = substitute_head<any_node_position::NONE>(src, parent, new_head);
			free(*new_head); if (new_head->reference_count == 0) free(new_head);
		} else {
			array<hol_term*> excluded(max(1u, parent->any.excluded_tree_count + new_head->any.excluded_tree_count));
			for (unsigned int i = 0; i < parent->any.excluded_tree_count; i++) {
				/* make sure this tree isn't a subset of any tree in `new_head->any.excluded_trees` */
				bool irreducible = true;
				for (unsigned int j = 0; j < new_head->any.excluded_tree_count; j++) {
					if (is_subset<built_in_predicates>(parent->any.excluded_trees[i], new_head->any.excluded_trees[j])) {
						irreducible = false;
						break;
					}
				}
				if (irreducible)
					excluded[excluded.length++] = parent->any.excluded_trees[i];
			}
			unsigned int old_excluded_tree_count = excluded.length;
			for (unsigned int i = 0; i < new_head->any.excluded_tree_count; i++) {
				/* make sure this tree isn't a subset of any tree in `excluded` so far */
				bool irreducible = true;
				for (unsigned int j = 0; j < old_excluded_tree_count; j++) {
					if (is_subset<built_in_predicates>(new_head->any.excluded_trees[i], excluded[j])) {
						irreducible = false;
						break;
					}
				}
				if (irreducible)
					excluded[excluded.length++] = new_head->any.excluded_trees[i];
			}
			hol_term* temp;
			if (new_type == hol_term_type::ANY)
				temp = hol_term::new_any(new_head->any.included, excluded.data, excluded.length);
			else temp = hol_term::new_any_right(new_head->any.included, excluded.data, excluded.length);
			if (new_head->any.included != nullptr)
				new_head->any.included->reference_count++;
			for (hol_term* term : excluded)
				term->reference_count++;
			free(*new_head); if (new_head->reference_count == 0) free(new_head);
			dst = substitute_head<any_node_position::NONE>(src, parent, temp);
			free(*temp); if (temp->reference_count == 0) free(temp);
		}
	} else {
		dst = substitute_head<any_node_position::NONE>(src, head, new_head);
		free(*new_head); if (new_head->reference_count == 0) free(new_head);
	}
	return (dst != nullptr);
}

inline bool factor(
		hol_term* src, hol_term*& dst)
{
	return factor(src, dst, find_head<built_in_predicates>);
}

inline bool factor_predicative(
		hol_term* src, hol_term*& dst)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	return factor(src, dst, predicative_head_finder<built_in_predicates>(lambda_variable));
}

template<int_fast8_t ConjunctIndex>
inline bool select_predicate_and_tense(
		hol_term* src, hol_term*& dst)
{
	static_assert(ConjunctIndex != -1, "select_predicate_and_tense ERROR: `ConjunctIndex` cannot be -1.");

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<false>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker, find_head<built_in_predicates>,
			[](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && predicate_index.position != head_position::NONE)
					head = head->any.included;

				while (head->type == hol_term_type::NOT)
					head = head->unary.operand;

				hol_term* head_var = hol_term::new_variable(head_variable);
				if (head_var == nullptr) return (hol_term*) nullptr;
				constexpr unsigned int excluded_tree_count = 2;
				hol_term** excluded_trees = (hol_term**) alloca(sizeof(hol_term) * (excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()));
				excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
							(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
							(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
						&HOL_ANY), head_var));
				excluded_trees[1] = hol_term::new_any(hol_term::new_exists(head_variable, &HOL_ANY));
				if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
				if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
				if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr) {
					if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
					free(*head_var); free(head_var);
					return (hol_term*) nullptr;
				}
				free(*head_var);

				for (unsigned int i = 0; i < hol_non_head_constants<built_in_predicates>::count(); i++) {
					excluded_trees[excluded_tree_count + i] = hol_non_head_constants<built_in_predicates>::get_terms()[i];
					excluded_trees[excluded_tree_count + i]->reference_count++;
				}

				hol_term* expected_predicate = nullptr;
				if (head->type == hol_term_type::EXISTS) {
					hol_term* operand = head->quantifier.operand;
					if (operand->type == hol_term_type::AND) {
						if (predicate_index.position == head_position::LEFT)
							expected_predicate = operand->array.operands[predicate_index.index];
					} else if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
						if (predicate_index.position == head_position::LEFT)
							expected_predicate = operand->any_array.left.operands[predicate_index.index];
						else if (predicate_index.position == head_position::RIGHT)
							expected_predicate = operand->any_array.right.operands[operand->any_array.right.length - predicate_index.index - 1];
						else if (predicate_index.position == head_position::ANY)
							expected_predicate = operand->any_array.any.operands[predicate_index.index];
					} else if (predicate_index.position == head_position::LEFT && predicate_index.index == 0) {
						expected_predicate = operand;
					}
				}
				if (expected_predicate == nullptr) {
					expected_predicate = hol_term::new_apply(
								hol_term::new_any(nullptr, excluded_trees, excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()),
								hol_term::new_variable(head_variable));
					if (expected_predicate == nullptr) {
						for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
							free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
						}
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++)
						excluded_trees[i]->reference_count++;
				} else {
					expected_predicate->reference_count++;
				}

				hol_term* any_tense_predicate = hol_tense_constants<built_in_predicates>::get().constants;
				hol_term* tense_conjunct = hol_term::new_apply(any_tense_predicate, hol_term::new_variable(head_variable));
				if (tense_conjunct == nullptr) {
					for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
						free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
					}
					free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
					return (hol_term*) nullptr;
				}
				any_tense_predicate->reference_count++;

				hol_term* conjunct = hol_term::new_any(nullptr, excluded_trees, excluded_tree_count);
				if (conjunct == nullptr) {
					free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
					free(*tense_conjunct); free(tense_conjunct);
					return (hol_term*) nullptr;
				}
				for (unsigned int i = 0; i < excluded_tree_count; i++)
					excluded_trees[i]->reference_count++;
				for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
					free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
				}

				hol_term* expected_head;
				if (ConjunctIndex >= 0) {
					expected_head = hol_term::new_exists(head_variable, hol_term::new_any_array(hol_term_type::AND, conjunct, make_array_view((hol_term**) nullptr, 0),
							make_appended_array_view(make_appended_array_view(make_repeated_array_view(conjunct, ConjunctIndex), expected_predicate), tense_conjunct),
							make_array_view((hol_term**) nullptr, 0)));
					if (expected_head == nullptr) {
						free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
						free(*tense_conjunct); free(tense_conjunct);
						free(*conjunct); free(conjunct);
						return (hol_term*) nullptr;
					}
					conjunct->reference_count += ConjunctIndex;
				} else {
					unsigned int index = (unsigned int) (-ConjunctIndex) - 2;
					expected_head = hol_term::new_exists(head_variable, hol_term::new_any_array(hol_term_type::AND, conjunct,
							make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0),
							make_prepended_array_view(expected_predicate, make_prepended_array_view(tense_conjunct, make_repeated_array_view(conjunct, index)))));
					if (expected_head == nullptr) {
						free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
						free(*tense_conjunct); free(tense_conjunct);
						free(*conjunct); free(conjunct);
						return (hol_term*) nullptr;
					}
					conjunct->reference_count += index;
				}

				array<hol_term*> intersection(2);
				intersect<built_in_predicates>(intersection, expected_head, head);
				free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
				if (intersection.length == 0) {
					return (hol_term*) nullptr;
				} else if (intersection.length > 1) {
					fprintf(stderr, "select_predicate_and_tense ERROR: Intersection is not unique.\n");
					free_all(intersection);
					return (hol_term*) nullptr;
				}

				hol_term* left = nullptr; hol_term* right = nullptr;
				hol_term* operand = intersection[0]->quantifier.operand;
				if (operand->type == hol_term_type::AND) {
					unsigned index = (ConjunctIndex >= 0) ? ConjunctIndex : (operand->array.length + ConjunctIndex);
					left = operand->array.operands[index];
					right = operand->array.operands[index + 1];
				} else if (operand->type == hol_term_type::ANY_ARRAY) {
					if (ConjunctIndex >= 0) {
						left = operand->any_array.left.operands[ConjunctIndex];
						right = operand->any_array.left.operands[ConjunctIndex + 1];
					} else {
						left = operand->any_array.right.operands[operand->any_array.right.length + ConjunctIndex];
						right = operand->any_array.right.operands[operand->any_array.right.length + ConjunctIndex + 1];
					}
				}

				hol_term* dst = hol_term::new_exists(head_variable, hol_term::new_and(left, right));
				if (dst == nullptr) {
					free_all(intersection);
					return (hol_term*) nullptr;
				}
				left->reference_count++;
				right->reference_count++;
				free_all(intersection);
				return dst;
			}, no_op()) && dst != nullptr;
}

template<int_fast8_t ExpectedPredicateIndex>
inline hol_term* apply_predicate(
		hol_term* head,
		unsigned int head_variable,
		head_index predicate_index,
		hol_term* src_predicate,
		hol_term* dst_predicate)
{
	if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT
	 || (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY)
	 || (head->type == hol_term_type::EXISTS && head->quantifier.operand->type == hol_term_type::ANY_RIGHT))
	{
		hol_term* head_var = hol_term::new_variable(head_variable);
		if (head_var == nullptr) return (hol_term*) nullptr;
		constexpr unsigned int excluded_tree_count = 2;
		hol_term* excluded_trees[excluded_tree_count];
		excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
					(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
					(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
				&HOL_ANY), head_var));
		excluded_trees[1] = hol_term::new_any(hol_term::new_exists(head_variable, &HOL_ANY));
		if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
		if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
		if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr) {
			if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
			free(*head_var); free(head_var);
			return (hol_term*) nullptr;
		}
		free(*head_var);

		hol_term* conjunct = hol_term::new_any(nullptr, excluded_trees, excluded_tree_count);
		if (conjunct == nullptr) {
			for (unsigned int i = 0; i < excluded_tree_count; i++) {
				free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
			}
			return (hol_term*) nullptr;
		}

		hol_term* expected_head;
		if (ExpectedPredicateIndex == INT_FAST8_MAX) {
			expected_head = hol_term::new_exists(head_variable, hol_term::new_any_array(hol_term_type::AND, conjunct,
					make_array_view(&dst_predicate, 1), make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0)));
		} else if (ExpectedPredicateIndex >= 0) {
			expected_head = hol_term::new_exists(head_variable,
					hol_term::new_any_array(hol_term_type::AND, conjunct,
						make_array_view((hol_term**) nullptr, 0),
						make_appended_array_view(make_repeated_array_view(conjunct, ExpectedPredicateIndex), dst_predicate),
						make_array_view((hol_term**) nullptr, 0)));
		} else {
			expected_head = hol_term::new_exists(head_variable,
					hol_term::new_any_array(hol_term_type::AND, conjunct,
						make_array_view((hol_term**) nullptr, 0),
						make_array_view((hol_term**) nullptr, 0),
						make_prepended_array_view(dst_predicate, make_repeated_array_view(conjunct, -ExpectedPredicateIndex - 1))));
		}
		if (expected_head == nullptr) {
			free(*conjunct); free(conjunct);
			return (hol_term*) nullptr;
		}
		hol_term* operand = expected_head->quantifier.operand;
		operand->any_array.all->reference_count++;
		for (unsigned int i = 0; i < operand->any_array.left.length; i++)
			operand->any_array.left.operands[i]->reference_count++;
		for (unsigned int i = 0; i < operand->any_array.right.length; i++)
			operand->any_array.right.operands[i]->reference_count++;
		for (unsigned int i = 0; i < operand->any_array.any.length; i++)
			operand->any_array.any.operands[i]->reference_count++;
		free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);

		array<hol_term*> intersection(2);
		intersect<built_in_predicates>(intersection, head, expected_head);
		free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
		if (intersection.length == 0) {
			return nullptr;
		} else if (intersection.length != 1) {
			fprintf(stderr, "apply_predicate ERROR: Intersection is not unique.\n");
			free_all(intersection); return nullptr;
		}
		return intersection[0];

	} else if (head->type == hol_term_type::EXISTS) {
		hol_term* new_head;
		hol_term* operand = head->quantifier.operand;
		if (operand->type == hol_term_type::ANY_ARRAY) {
			if (predicate_index.position == head_position::ANY) {
				if (src_predicate != &HOL_ANY && !has_intersection<built_in_predicates>(src_predicate, operand->any_array.any.operands[predicate_index.index]))
					return nullptr;
				new_head = hol_term::new_exists(head_variable, hol_term::new_any_array(hol_term_type::AND, operand->any_array.all,
						make_replaced_array_view(make_array_view(operand->any_array.any.operands, operand->any_array.any.length), dst_predicate, predicate_index.index),
						make_array_view(operand->any_array.left.operands, operand->any_array.left.length),
						make_array_view(operand->any_array.right.operands, operand->any_array.right.length)));
			} else if (predicate_index.position == head_position::LEFT) {
				if (src_predicate != &HOL_ANY && !has_intersection<built_in_predicates>(src_predicate, operand->any_array.left.operands[predicate_index.index]))
					return nullptr;
				new_head = hol_term::new_exists(head_variable, hol_term::new_any_array(hol_term_type::AND, operand->any_array.all,
						make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
						make_replaced_array_view(make_array_view(operand->any_array.left.operands, operand->any_array.left.length), dst_predicate, predicate_index.index),
						make_array_view(operand->any_array.right.operands, operand->any_array.right.length)));
			} else if (predicate_index.position == head_position::RIGHT) {
				unsigned int index = operand->any_array.right.length - predicate_index.index - 1;
				if (src_predicate != &HOL_ANY && !has_intersection<built_in_predicates>(src_predicate, operand->any_array.right.operands[index]))
					return nullptr;
				new_head = hol_term::new_exists(head_variable, hol_term::new_any_array(hol_term_type::AND, operand->any_array.all,
						make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
						make_array_view(operand->any_array.left.operands, operand->any_array.left.length),
						make_replaced_array_view(make_array_view(operand->any_array.right.operands, operand->any_array.right.length), dst_predicate, index)));
			} else {
				return nullptr;
			}
			if (new_head == nullptr)
				return nullptr;
			hol_term* new_operand = new_head->quantifier.operand;
			new_operand->any_array.all->reference_count++;
			for (unsigned int i = 0; i < new_operand->any_array.left.length; i++)
				new_operand->any_array.left.operands[i]->reference_count++;
			for (unsigned int i = 0; i < new_operand->any_array.right.length; i++)
				new_operand->any_array.right.operands[i]->reference_count++;
			for (unsigned int i = 0; i < new_operand->any_array.any.length; i++)
				new_operand->any_array.any.operands[i]->reference_count++;
			if (ExpectedPredicateIndex != INT_FAST8_MAX) {
				hol_term* expected_head;
				if (ExpectedPredicateIndex >= 0) {
					expected_head = hol_term::new_exists(head_variable, hol_term::new_any_array(hol_term_type::AND, operand->any_array.all,
							make_array_view((hol_term**) nullptr, 0),
							make_appended_array_view(make_repeated_array_view(operand->any_array.all, ExpectedPredicateIndex), dst_predicate),
							make_array_view((hol_term**) nullptr, 0)));
					if (expected_head == nullptr) {
						free(*new_head); free(new_head);
						return nullptr;
					}
					operand->any_array.all->reference_count += ExpectedPredicateIndex + 1;
					dst_predicate->reference_count++;
				} else {
					expected_head = hol_term::new_exists(head_variable, hol_term::new_any_array(hol_term_type::AND, operand->any_array.all,
							make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0),
							make_prepended_array_view(dst_predicate, make_repeated_array_view(operand->any_array.all, -ExpectedPredicateIndex - 1))));
					if (expected_head == nullptr) {
						free(*new_head); free(new_head);
						return nullptr;
					}
					operand->any_array.all->reference_count += -ExpectedPredicateIndex;
					dst_predicate->reference_count++;
				}
				array<hol_term*> intersection(2);
				intersect<built_in_predicates>(intersection, new_head, expected_head);
				free(*new_head); if (new_head->reference_count == 0) free(new_head);
				free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
				if (intersection.length == 0) {
					return nullptr;
				} else if (intersection.length != 1) {
					fprintf(stderr, "apply_predicate ERROR: Intersection is not unique.\n");
					free_all(intersection); return nullptr;
				}
				new_head = intersection[0];
			}
			return new_head;
		} else if (operand->type == hol_term_type::AND) {
			if (predicate_index.position != head_position::LEFT)
				return nullptr;
			if (ExpectedPredicateIndex != INT_FAST8_MAX) {
				unsigned int index = (ExpectedPredicateIndex >= 0 ? ExpectedPredicateIndex : operand->array.length + ExpectedPredicateIndex);
				if (index != predicate_index.index) return nullptr;
			}
			if (src_predicate != &HOL_ANY && !has_intersection<built_in_predicates>(src_predicate, operand->array.operands[predicate_index.index]))
				return nullptr;
			hol_term* new_head = hol_term::new_exists(head_variable, hol_term::new_and(make_replaced_array_view(make_array_view(operand->array.operands, operand->array.length), dst_predicate, predicate_index.index)));
			if (new_head == nullptr) return nullptr;
			hol_term* new_operand = new_head->quantifier.operand;
			for (unsigned int i = 0; i < new_operand->array.length; i++)
				new_operand->array.operands[i]->reference_count++;
			return new_head;
		} else {
			if (ExpectedPredicateIndex != INT_FAST8_MAX && ExpectedPredicateIndex != 0 && ExpectedPredicateIndex != -1)
				return nullptr;
			if (predicate_index.position != head_position::LEFT || predicate_index.index != 0)
				return nullptr;
			if (src_predicate != &HOL_ANY && !has_intersection<built_in_predicates>(src_predicate, operand))
				return nullptr;
			hol_term* new_head = hol_term::new_exists(head_variable, dst_predicate);
			if (new_head == nullptr) return nullptr;
			dst_predicate->reference_count++;
			return new_head;
		}
	} else {
		return nullptr;
	}
}

template<typename ApplyHead>
inline hol_term* apply_array(hol_term*& head, hol_term* parent, ApplyHead apply_head_function)
{
	bool head_is_array = false;
	if (parent != nullptr && (parent->type == hol_term_type::AND || parent->type == hol_term_type::OR)) {
		hol_term* head; head_index predicate_index;
		find_head<built_in_predicates>(parent->array.operands[0], head, predicate_index);
		if (head != nullptr)
			head_is_array = true;
	} else if (parent != nullptr && parent->type == hol_term_type::ANY_ARRAY && (parent->any_array.oper == hol_term_type::ANY_ARRAY || parent->any_array.oper == hol_term_type::AND || parent->any_array.oper == hol_term_type::OR)) {
		if (head == parent->any_array.all) {
			head_is_array = true;
		} else {
			hol_term* head; head_index predicate_index;
			find_head<built_in_predicates>(parent->any_array.all, head, predicate_index);
			if (head != nullptr)
				head_is_array = true;
		}
	}

	hol_term* new_head;
	if (head_is_array) {
		if (parent->type == hol_term_type::AND || parent->type == hol_term_type::OR) {
			array<hol_term*> new_heads(parent->array.length);
			for (unsigned int i = 0; i < parent->array.length; i++) {
				new_heads[i] = apply_head_function(parent->array.operands[i]);
				if (new_heads[i] == nullptr) {
					free_all(new_heads);
					return nullptr;
				}
				new_heads.length++;
			}
			if (parent->type == hol_term_type::AND)
				new_head = hol_term::new_and(make_array_view(new_heads.data, new_heads.length));
			else new_head = hol_term::new_or(make_array_view(new_heads.data, new_heads.length));
			if (new_head == nullptr) {
				free_all(new_heads);
				return nullptr;
			}
		} else {
			hol_term* new_all = apply_head_function(parent->any_array.all);
			if (new_all == nullptr)
				return nullptr;
			array<hol_term*> new_left(max(1u, parent->any_array.left.length));
			array<hol_term*> new_right(max(1u, parent->any_array.right.length));
			array<hol_term*> new_any(max(1u, parent->any_array.any.length));
			for (unsigned int i = 0; i < parent->any_array.left.length; i++) {
				new_left[i] = apply_head_function(parent->any_array.left.operands[i]);
				if (new_left[i] == nullptr) {
					free_all(new_left);
					free(*new_all); if (new_all->reference_count == 0) free(new_all);
					return nullptr;
				}
				new_left.length++;
			} for (unsigned int i = 0; i < parent->any_array.right.length; i++) {
				new_right[i] = apply_head_function(parent->any_array.right.operands[i]);
				if (new_right[i] == nullptr) {
					free_all(new_left); free_all(new_right);
					free(*new_all); if (new_all->reference_count == 0) free(new_all);
					return nullptr;
				}
				new_right.length++;
			} for (unsigned int i = 0; i < parent->any_array.any.length; i++) {
				new_any[i] = apply_head_function(parent->any_array.any.operands[i]);
				if (new_any[i] == nullptr) {
					free_all(new_left); free_all(new_right); free_all(new_any);
					free(*new_all); if (new_all->reference_count == 0) free(new_all);
					return nullptr;
				}
				new_any.length++;
			}
			new_head = hol_term::new_any_array(parent->any_array.oper, new_all,
					make_array_view(new_any.data, new_any.length),
					make_array_view(new_left.data, new_left.length),
					make_array_view(new_right.data, new_right.length));
			if (new_head == nullptr) {
				free_all(new_left); free_all(new_right); free_all(new_any);
				free(*new_all); if (new_all->reference_count == 0) free(new_all);
				return nullptr;
			}
		}
		head = parent;
	} else {
		new_head = apply_head_function(head);
	}
	return new_head;
}

template<int_fast8_t PredicateIndex>
inline hol_term* do_set_predicate_empty(hol_term* head)
{
	hol_term* old_head = head;
	if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
		head = head->any.included;

	unsigned int negation_count = 0;
	while (head->type == hol_term_type::NOT) {
		head = head->unary.operand;
		negation_count++;
	}

	unsigned int head_variable;
	hol_term* operand;
	if (head->type == hol_term_type::EXISTS) {
		head_variable = head->quantifier.variable;
		operand = head->quantifier.operand;
	} else {
		unsigned int max_variable = 0;
		max_bound_variable(*head, max_variable);
		head_variable = ++max_variable;
		operand = head;
	}

	hol_term* new_predicate = hol_term::new_apply(&HOL_EMPTY, hol_term::new_variable(head_variable));
	if (new_predicate == nullptr)
		return nullptr;
	HOL_EMPTY.reference_count++;

	head_index predicate_index;
	find_predicate<built_in_predicates>(head_variable, operand, predicate_index);
	hol_term* new_head = apply_predicate<PredicateIndex>(head, head_variable, predicate_index, &HOL_ANY, new_predicate);
	free(*new_predicate); if (new_predicate->reference_count == 0) free(new_predicate);

	for (unsigned int i = 0; i < negation_count; i++) {
		hol_term* temp = hol_term::new_not(new_head);
		if (temp == nullptr) {
			free(*new_head); if (new_head->reference_count == 0) free(new_head);
			return nullptr;
		}
		new_head = temp;
	}

	if (old_head->type == hol_term_type::ANY_RIGHT) {
		hol_term* temp = hol_term::new_any_right(new_head, old_head->any.excluded_trees, old_head->any.excluded_tree_count);
		if (temp == nullptr) {
			free(*new_head); if (new_head->reference_count == 0) free(new_head);
			return nullptr;
		}
		new_head = temp;
		for (unsigned int i = 0; i < old_head->any.excluded_tree_count; i++)
			old_head->any.excluded_trees[i]->reference_count++;
	}
	return new_head;
}

template<int_fast8_t PredicateIndex>
inline bool set_predicate_empty(
		hol_term* src, hol_term*& dst)
{
	hol_term* parent = nullptr;
	hol_term* current = nullptr;
	auto apply = [&parent,&current](hol_term* term) {
		parent = current;
		current = term;
	};

	head_index predicate_index;
	hol_term* head = find_head(src, predicate_index, find_head<built_in_predicates>, apply);
	if (head == nullptr)
		return false;

	hol_term* new_head = apply_array(head, parent, do_set_predicate_empty<PredicateIndex>);
	if (new_head == nullptr)
		return false;

	dst = substitute_head<any_node_position::NONE>(src, head, new_head);
	free(*new_head); if (new_head->reference_count == 0) free(new_head);
	return (dst != nullptr);
}

template<hol_term_type Type, bool Negative, int_fast8_t Length = -1, typename FindHeadFunction>
inline bool require_array(
		hol_term* src, hol_term*& dst,
		FindHeadFunction find_head_function)
{
	static_assert(Length == -1 || Length >= 2, "require_array ERROR: `Length` must be -1 or at least 2.");
	static_assert(Type == hol_term_type::AND || Type == hol_term_type::OR, "require_array ERROR: Unsupported value for `Type`.");

	head_index predicate_index; no_op apply;
	auto find_array_head = make_array_finder(find_head_function);
	hol_term* head = find_head(src, predicate_index, find_array_head, apply);
	if (head == nullptr)
		return false;

	hol_term* old_head = head;
	if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr
	 && (head->any.included->type == hol_term_type::AND || head->any.included->type == hol_term_type::OR || head->any.included->type == hol_term_type::ANY_ARRAY))
		head = head->any.included;

	hol_term* expected_conjunct = (Negative ? hol_term::new_not(&HOL_ANY) : &HOL_ANY);
	if (expected_conjunct == nullptr)
		return false;
	HOL_ANY.reference_count++;

	hol_term* expected_head;
	if (Length == -1) {
		expected_head = hol_term::new_any_array(Type, expected_conjunct,
				make_array_view((hol_term**) nullptr, 0), make_repeated_array_view(expected_conjunct, 2), make_array_view((hol_term**) nullptr, 0));
		if (expected_head == nullptr) {
			free(*expected_conjunct); if (Negative && expected_conjunct->reference_count == 0) free(expected_conjunct);
			return false;
		}
		expected_conjunct->reference_count += 3 - 1;
	} else if (Type == hol_term_type::AND) {
		expected_head = hol_term::new_and(make_repeated_array_view(expected_conjunct, Length));
		if (expected_head == nullptr) {
			free(*expected_conjunct); if (Negative && expected_conjunct->reference_count == 0) free(expected_conjunct);
			return false;
		}
		expected_conjunct->reference_count += Length - 1;
	} else if (Type == hol_term_type::OR) {
		expected_head = hol_term::new_or(make_repeated_array_view(expected_conjunct, Length));
		if (expected_head == nullptr) {
			free(*expected_conjunct); if (Negative && expected_conjunct->reference_count == 0) free(expected_conjunct);
			return false;
		}
		expected_conjunct->reference_count += Length - 1;
	}

	array<hol_term*> intersection(2);
	intersect<built_in_predicates>(intersection, head, expected_head);
	free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
	if (intersection.length == 0) {
		return false;
	} else if (intersection.length != 1) {
		fprintf(stderr, "require_array ERROR: Set intersection is not unique.\n");
		free_all(intersection);
		return false;
	}
	hol_term* new_head = intersection[0];

	dst = substitute_head<any_node_position::NONE>(src, old_head, new_head);
	free(*new_head); if (new_head->reference_count == 0) free(new_head);
	return (dst != nullptr);
}

template<hol_term_type Type, bool Negative, typename FindHeadFunction>
inline bool require_no_array(
		hol_term* src, hol_term*& dst,
		FindHeadFunction find_head_function)
{
	static_assert(Type == hol_term_type::AND || Type == hol_term_type::OR || Type == hol_term_type::ANY_ARRAY, "require_no_array ERROR: Unsupported value for `Type`.");

	hol_term* parent = nullptr;
	hol_term* current = nullptr;
	auto apply = [&parent,&current](hol_term* term) {
		parent = current;
		current = term;
	};

	head_index predicate_index;
	auto find_array_head = make_array_finder(find_head_function);
	hol_term* head = find_head(src, predicate_index, find_array_head, apply);
	if (head == nullptr)
		return false;

	hol_term* expected_conjunct = (Negative ? hol_term::new_not(&HOL_ANY) : &HOL_ANY);
	if (expected_conjunct == nullptr)
		return false;
	HOL_ANY.reference_count++;

	hol_term* array_term = hol_term::new_any_array(Type, expected_conjunct,
			make_array_view((hol_term**) nullptr, 0), make_repeated_array_view(expected_conjunct, 2), make_array_view((hol_term**) nullptr, 0));
	if (array_term == nullptr) {
		free(*expected_conjunct); if (Negative && expected_conjunct->reference_count == 0) free(expected_conjunct);
		return false;
	}
	expected_conjunct->reference_count += 3 - 1;

	hol_term* expected_head = hol_term::new_any(nullptr, &array_term, 1);
	if (expected_head == nullptr) {
		free(*array_term); if (array_term->reference_count == 0) free(array_term);
		return false;
	}

	array<hol_term*> intersection(2);
	intersect<built_in_predicates>(intersection, head, expected_head);
	free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
	if (intersection.length == 0) {
		return false;
	} else if (intersection.length != 1) {
		fprintf(stderr, "require_no_array ERROR: Set intersection is not unique.\n");
		free_all(intersection);
		return false;
	}
	hol_term* new_head = intersection[0];

	if (parent != nullptr && parent->type == hol_term_type::ANY_RIGHT && new_head->type == hol_term_type::ANY_RIGHT)
		dst = substitute_head<any_node_position::NONE>(src, parent, new_head);
	else dst = substitute_head<any_node_position::NONE>(src, head, new_head);
	free(*new_head); if (new_head->reference_count == 0) free(new_head);
	return (dst != nullptr);
}

template<int_fast8_t ConjunctIndex, typename FindHeadFunction>
inline bool select_operand(
		hol_term* src, hol_term*& dst,
		FindHeadFunction find_head_function)
{
	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<false>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker, make_array_finder(find_head_function),
			[](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				hol_term* dst;
				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) {
					hol_term* excluded_array = hol_term::new_any_array(
							hol_term_type::ANY_ARRAY, &HOL_ANY, make_array_view((hol_term**) nullptr, 0),
							make_repeated_array_view(&HOL_ANY, 2), make_array_view((hol_term**) nullptr, 0));
					if (excluded_array == nullptr)
						return (hol_term*) nullptr;
					HOL_ANY.reference_count += 3;

					array<hol_term*> difference(2);
					subtract<built_in_predicates>(difference, head, excluded_array);
					free(*excluded_array); if (excluded_array->reference_count == 0) free(excluded_array);
					if (difference.length == 0) {
						return (hol_term*) nullptr;
					} else if (difference.length != 1) {
						fprintf(stderr, "select_operand ERROR: Set difference is not unique.\n");
						free_all(difference);
						return (hol_term*) nullptr;
					}
					dst = difference[0];

				} else if (head->type == hol_term_type::AND || head->type == hol_term_type::OR) {
					if (ConjunctIndex >= 0 && ConjunctIndex >= head->array.length)
						return (hol_term*) nullptr;
					if (ConjunctIndex < 0 && -ConjunctIndex > head->array.length)
						return (hol_term*) nullptr;

					unsigned int index = (ConjunctIndex >= 0) ? ConjunctIndex : (ConjunctIndex + head->array.length);
					dst = head->array.operands[index];
					dst->reference_count++;

				} else if (head->type == hol_term_type::ANY_ARRAY && (head->any_array.oper == hol_term_type::ANY_ARRAY || head->any_array.oper == hol_term_type::AND || head->any_array.oper == hol_term_type::OR)) {
					if (ConjunctIndex >= 0) {
						if (ConjunctIndex >= head->any_array.left.length) {
							dst = head->any_array.all;
							dst->reference_count++;
						} else {
							dst = head->any_array.left.operands[ConjunctIndex];
							dst->reference_count++;
						}
					} else {
						if (-ConjunctIndex > head->any_array.right.length) {
							dst = head->any_array.all;
							dst->reference_count++;
						} else {
							unsigned int index = ConjunctIndex + head->any_array.right.length;
							dst = head->any_array.right.operands[index];
							dst->reference_count++;
						}
					}

				} else {
					return (hol_term*) nullptr;
				}
				return dst;
			}, no_op()) && dst != nullptr;
}

template<int_fast8_t ConjunctIndex, typename FindHeadFunction>
inline bool remove_operand(
		hol_term* src, hol_term*& dst,
		FindHeadFunction find_head_function)
{
	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<true>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker, make_array_finder(find_head_function),
			[](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				hol_term* dst;
				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) {
					hol_term* expected_head = hol_term::new_any_array(
							hol_term_type::ANY_ARRAY, &HOL_ANY, make_array_view((hol_term**) nullptr, 0),
							make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0));
					if (expected_head == nullptr)
						return (hol_term*) nullptr;
					HOL_ANY.reference_count++;

					array<hol_term*> intersection(2);
					intersect<built_in_predicates>(intersection, head, expected_head);
					free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
					if (intersection.length == 0) {
						return (hol_term*) nullptr;
					} else if (intersection.length != 1) {
						fprintf(stderr, "remove_operand ERROR: Set intersection is not unique.\n");
						free_all(intersection);
						return (hol_term*) nullptr;
					}
					dst = intersection[0];

				} else if (head->type == hol_term_type::AND || head->type == hol_term_type::OR) {
					if (ConjunctIndex >= 0 && ConjunctIndex >= head->array.length)
						return (hol_term*) nullptr;
					if (ConjunctIndex < 0 && -ConjunctIndex > head->array.length)
						return (hol_term*) nullptr;

					unsigned int index = (ConjunctIndex >= 0) ? ConjunctIndex : (ConjunctIndex + head->array.length);
					if (head->array.length == 2)
						dst = (index == 0 ? head->array.operands[1] : head->array.operands[0]);
					else if (head->type == hol_term_type::AND)
						dst = hol_term::new_and(make_excluded_array_view(head->array.operands, head->array.length, index));
					else dst = hol_term::new_or(make_excluded_array_view(head->array.operands, head->array.length, index));

					if (dst == nullptr)
						return (hol_term*) nullptr;
					for (unsigned int i = 0; i < head->array.length; i++)
						if (i != index) head->array.operands[i]->reference_count++;

				} else if (head->type == hol_term_type::ANY_ARRAY && (head->any_array.oper == hol_term_type::ANY_ARRAY || head->any_array.oper == hol_term_type::AND || head->any_array.oper == hol_term_type::OR)) {
					if (ConjunctIndex >= 0) {
						if (ConjunctIndex >= head->any_array.left.length) {
							dst = head;
							dst->reference_count++;
						} else {
							dst = hol_term::new_any_array(head->any_array.oper, head->any_array.all,
									make_array_view(head->any_array.any.operands, head->any_array.any.length),
									make_excluded_array_view(head->any_array.left.operands, head->any_array.left.length, ConjunctIndex),
									make_array_view(head->any_array.right.operands, head->any_array.right.length));
							if (dst == nullptr)
								return (hol_term*) nullptr;
							dst->any_array.all->reference_count++;
							for (unsigned int i = 0; i < dst->any_array.left.length; i++)
								dst->any_array.left.operands[i]->reference_count++;
							for (unsigned int i = 0; i < dst->any_array.right.length; i++)
								dst->any_array.right.operands[i]->reference_count++;
							for (unsigned int i = 0; i < dst->any_array.any.length; i++)
								dst->any_array.any.operands[i]->reference_count++;

							if (dst->any_array.left.length <= 1 && dst->any_array.right.length <= 1 && dst->any_array.any.length <= 1) {
								if (dst->any_array.right.length == 1 && is_subset<built_in_predicates>(dst, dst->any_array.right.operands[0])) {
									hol_term* new_dst = dst->any_array.right.operands[0];
									new_dst->reference_count++;
									free(*dst); free(dst);
									dst = new_dst;
								} else if (dst->any_array.left.length == 1 && is_subset<built_in_predicates>(dst, dst->any_array.left.operands[0])) {
									hol_term* new_dst = dst->any_array.left.operands[0];
									new_dst->reference_count++;
									free(*dst); free(dst);
									dst = new_dst;
								} else if (dst->any_array.any.length == 1 && is_subset<built_in_predicates>(dst, dst->any_array.any.operands[0])) {
									hol_term* new_dst = dst->any_array.any.operands[0];
									new_dst->reference_count++;
									free(*dst); free(dst);
									dst = new_dst;
								} else if (dst->any_array.right.length == 0 && dst->any_array.left.length == 0 && dst->any_array.any.length == 0
										&& is_subset<built_in_predicates>(dst, dst->any_array.all))
								{
									hol_term* new_dst = dst->any_array.all;
									new_dst->reference_count++;
									free(*dst); free(dst);
									dst = new_dst;
								}
							}
						}
					} else {
						if (-ConjunctIndex > head->any_array.right.length) {
							dst = head;
							dst->reference_count++;
						} else {
							unsigned int index = ConjunctIndex + head->any_array.right.length;
							dst = hol_term::new_any_array(head->any_array.oper, head->any_array.all,
									make_array_view(head->any_array.any.operands, head->any_array.any.length),
									make_array_view(head->any_array.left.operands, head->any_array.left.length),
									make_excluded_array_view(head->any_array.right.operands, head->any_array.right.length, index));
							if (dst == nullptr)
								return (hol_term*) nullptr;
							dst->any_array.all->reference_count++;
							for (unsigned int i = 0; i < dst->any_array.left.length; i++)
								dst->any_array.left.operands[i]->reference_count++;
							for (unsigned int i = 0; i < dst->any_array.right.length; i++)
								dst->any_array.right.operands[i]->reference_count++;
							for (unsigned int i = 0; i < dst->any_array.any.length; i++)
								dst->any_array.any.operands[i]->reference_count++;
						}
					}

				} else {
					return (hol_term*) nullptr;
				}
				return dst;
			}, no_op()) && dst != nullptr;
}

bool apply_to_predicative_set_function(hol_term* head,
		array<hol_term*>& dst, unsigned int& max_variable,
		unsigned int src_predicate, unsigned int dst_predicate)
{
	if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
		head = head->any.included;

	unsigned int set_variable;
	if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) {
		set_variable = ++max_variable;
	} else {
#if !defined(NDEBUG)
		if (head->type != hol_term_type::EXISTS) {
			fprintf(stderr, "apply_to_predicative_set_function ERROR: Expected existential quantification of set.\n");
			return false;
		}
#endif
		set_variable = head->quantifier.variable;
	}

	hol_term* excluded_quantifiers[3];
	excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(set_variable, &HOL_ANY));
	excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(set_variable, &HOL_ANY));
	excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(set_variable, &HOL_ANY));
	if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
	if (excluded_quantifiers[1] != nullptr) HOL_ANY.reference_count++;
	if (excluded_quantifiers[2] != nullptr) HOL_ANY.reference_count++;
	if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr) {
		if (excluded_quantifiers[0] != nullptr) { free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]); }
		if (excluded_quantifiers[1] != nullptr) { free(*excluded_quantifiers[1]); free(excluded_quantifiers[1]); }
		return (hol_term*) nullptr;
	}

	hol_term* expected_head;
	if (src_predicate == (unsigned int) built_in_predicates::EQUALS) {
		expected_head = hol_term::new_exists(set_variable, hol_term::new_and(
				hol_term::new_equals(hol_term::new_variable(set_variable), hol_term::new_any(nullptr, excluded_quantifiers, array_length(excluded_quantifiers))),
				hol_term::new_any(nullptr, excluded_quantifiers, array_length(excluded_quantifiers))));
	} else {
		expected_head = hol_term::new_exists(set_variable, hol_term::new_and(
				hol_term::new_apply(hol_term::new_constant(src_predicate), hol_term::new_variable(set_variable), hol_term::new_any(nullptr, excluded_quantifiers, array_length(excluded_quantifiers))),
				hol_term::new_any(nullptr, excluded_quantifiers, array_length(excluded_quantifiers))));
	}
	if (expected_head == nullptr) {
		for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
		return false;
	}
	for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++)
		excluded_quantifiers[i]->reference_count += 2 - 1;

	array<hol_term*> intersection(2);
	intersect<built_in_predicates>(intersection, expected_head, head);
	free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
	if (intersection.length == 0)
		return false;

	if (!dst.ensure_capacity(dst.length + intersection.length)) {
		free_all(intersection);
		return false;
	}

	for (hol_term* term : intersection) {
		hol_term* set_var; hol_term* set_definition;
		if (src_predicate == (unsigned int) built_in_predicates::EQUALS) {
			set_var = term->quantifier.operand->array.operands[0]->binary.left;
			set_definition = term->quantifier.operand->array.operands[0]->binary.right;
		} else {
			set_var = term->quantifier.operand->array.operands[0]->ternary.second;
			set_definition = term->quantifier.operand->array.operands[0]->ternary.third;
		}
		hol_term* right = term->quantifier.operand->array.operands[1];
		if (dst_predicate == (unsigned int) built_in_predicates::EQUALS) {
			dst[dst.length] = hol_term::new_exists(set_variable, hol_term::new_and(
					hol_term::new_equals(set_var, set_definition), right));
		} else {
			dst[dst.length] = hol_term::new_exists(set_variable, hol_term::new_and(
					hol_term::new_apply(hol_term::new_constant(dst_predicate), set_var, set_definition), right));
		}
		if (dst[dst.length] == nullptr) {
			free_all(intersection); free_all(dst);
			return false;
		}
		set_var->reference_count++;
		set_definition->reference_count++;
		right->reference_count++;
		dst.length++;
	}
	free_all(intersection);
	return true;
}

inline bool apply_to_predicative_set_function(
		hol_term* src, hol_term*& dst,
		unsigned int src_predicate,
		unsigned int dst_predicate)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<true>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker, predicative_head_finder<built_in_predicates>(lambda_variable),
			[&max_variable,src_predicate,dst_predicate](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				array<hol_term*> dst(2);
				if (!apply_to_predicative_set_function(head, dst, max_variable, src_predicate, dst_predicate))
					return (hol_term*) nullptr;
				if (dst.length != 1) {
					fprintf(stderr, "apply_to_predicative_set_function ERROR: Intersection is not unique.\n");
					free_all(dst); return (hol_term*) nullptr;
				}
				return dst[0];
			}, no_op()) && dst != nullptr;
}

inline bool require_predicate_of_lambda(
		hol_term* src, hol_term*& dst)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_predicate_variable = 0;
	unsigned int lambda_query_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_predicate_variable = src->quantifier.variable;
		if (src->quantifier.operand->type == hol_term_type::LAMBDA) {
			lambda_query_variable = src->quantifier.operand->quantifier.variable;
		} else if (src->quantifier.operand->type == hol_term_type::ANY || src->quantifier.operand->type == hol_term_type::ANY_RIGHT) {
			lambda_query_variable = ++max_variable;
		} else {
			return false;
		}
	} else if (src->type == hol_term_type::ANY || src->type == hol_term_type::ANY_RIGHT) {
		lambda_predicate_variable = ++max_variable;
		lambda_query_variable = ++max_variable;
	} else {
		return false;
	}

	hol_term* expected_term = hol_term::new_lambda(lambda_predicate_variable, hol_term::new_lambda(lambda_query_variable,
			hol_term::new_apply(hol_term::new_variable(lambda_predicate_variable), hol_term::new_variable(lambda_query_variable))));
	if (expected_term == nullptr)
		return false;
	array<hol_term*> intersection(2);
	intersect<built_in_predicates>(intersection, src, expected_term);
	free(*expected_term); if (expected_term->reference_count == 0) free(expected_term);
	if (intersection.length == 0) {
		return false;
	} else if (intersection.length != 1) {
		fprintf(stderr, "require_predicate_of_lambda ERROR: Intersection is not unique.\n");
		free_all(intersection); return false;
	}
	dst = intersection[0];
	return true;
}

inline void find_arg(
		hol_term* conjunct, unsigned int scope_variable,
		hol_term*& arg1, unsigned int& arg1_variable, head_index& arg1_position,
		hol_term*& arg2, unsigned int& arg2_variable, head_index& arg2_position,
		head_index current_position)
{
	if (conjunct->type == hol_term_type::EQUALS && conjunct->binary.left->type == hol_term_type::UNARY_APPLICATION
	 && conjunct->binary.right->type == hol_term_type::VARIABLE
	 && conjunct->binary.left->binary.right->type == hol_term_type::VARIABLE
	 && conjunct->binary.left->binary.right->variable == scope_variable
	 && conjunct->binary.left->binary.left->type == hol_term_type::CONSTANT
	 && conjunct->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG1)
	{
		arg1 = conjunct;
		arg1_variable = conjunct->binary.right->variable;
		arg1_position = current_position;
	} else if (conjunct->type == hol_term_type::EQUALS && conjunct->binary.left->type == hol_term_type::UNARY_APPLICATION
			&& conjunct->binary.right->type == hol_term_type::VARIABLE
			&& conjunct->binary.left->binary.right->type == hol_term_type::VARIABLE
			&& conjunct->binary.left->binary.right->variable == scope_variable
			&& conjunct->binary.left->binary.left->type == hol_term_type::CONSTANT
			&& conjunct->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG2)
	{
		arg2 = conjunct;
		arg2_variable = conjunct->binary.right->variable;
		arg2_position = current_position;
	} else if (conjunct->type == hol_term_type::ANY || conjunct->type == hol_term_type::ANY_RIGHT) {
		if (arg1 == nullptr) { arg1 = conjunct; arg1_position = current_position; }
		if (arg2 == nullptr) { arg2 = conjunct; arg2_position = current_position; }
	}
}

inline bool find_lambda(hol_term* src, unsigned int lambda_variable,
		array<pair<hol_term*, head_index>>& scopes, bool& found_arg)
{
	auto apply = [&scopes](hol_term* term) {
		if (term->type == hol_term_type::AND || term->type == hol_term_type::OR || term->type == hol_term_type::IFF) {
			return scopes.add({term, {head_position::LEFT, term->array.length - 1}});
		} else if (term->type == hol_term_type::ANY_ARRAY) {
			if (term->any_array.right.length == 0)
				return scopes.add({term, {head_position::NONE, 0}});
			else return scopes.add({term, {head_position::RIGHT, term->any_array.right.length - 1}});
		} else {
			return scopes.add({term, {head_position::LEFT, 0}});
		}
	};

	head_index predicate_index;
	hol_term* head = find_head(src, predicate_index, find_head<built_in_predicates>, apply);
	if (head == nullptr)
		return false;

	if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr) {
		if (!scopes.add({head, {head_position::LEFT, 0}})) return false;
		head = head->any.included;
	}
	while (head->type == hol_term_type::NOT) {
		if (!scopes.add({head, {head_position::LEFT, 0}})) return false;
		head = head->unary.operand;
	}

	hol_term* current_scope = head;
	while (true) {
		/* walk along the "right-most path" (i.e. if a scope `x` is in the
		   right-most path, where `x` is some quantifier of `R(argn(x)=y)`,
		   then `y` is also on the right-most path) */
		if (!scopes.add({current_scope, {head_position::LEFT, 0}})) return false;
		if (current_scope->type == hol_term_type::ANY || current_scope->type == hol_term_type::ANY_RIGHT) {
			/* the right-most path ends at an `ANY` or `ANY_RIGHT` node */
			return true;
		} else if (current_scope->type == hol_term_type::EXISTS || current_scope->type == hol_term_type::FOR_ALL || current_scope->type == hol_term_type::LAMBDA) {
			hol_term* operand = current_scope->quantifier.operand;
			unsigned int scope_variable = current_scope->quantifier.variable;

			/* find the args of this scope */
			hol_term* arg1 = nullptr; unsigned int arg1_variable = 0; head_index arg1_position = {head_position::NONE, 0};
			hol_term* arg2 = nullptr; unsigned int arg2_variable = 0; head_index arg2_position = {head_position::NONE, 0};
			if (operand->type == hol_term_type::AND) {
				for (unsigned int i = 0; i < operand->array.length; i++)
					find_arg(operand->array.operands[i], scope_variable, arg1, arg1_variable, arg1_position, arg2, arg2_variable, arg2_position, {head_position::LEFT, i});
			} else if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
				for (unsigned int i = 0; i < operand->any_array.left.length; i++)
					find_arg(operand->any_array.left.operands[i], scope_variable, arg1, arg1_variable, arg1_position, arg2, arg2_variable, arg2_position, {head_position::LEFT, i});
				for (unsigned int i = 0; i < operand->any_array.right.length; i++)
					find_arg(operand->any_array.right.operands[i], scope_variable, arg1, arg1_variable, arg1_position, arg2, arg2_variable, arg2_position, {head_position::RIGHT, i});
				for (unsigned int i = 0; i < operand->any_array.any.length; i++)
					find_arg(operand->any_array.any.operands[i], scope_variable, arg1, arg1_variable, arg1_position, arg2, arg2_variable, arg2_position, {head_position::ANY, i});
			} else {
				find_arg(operand, scope_variable, arg1, arg1_variable, arg1_position, arg2, arg2_variable, arg2_position, {head_position::LEFT, 0});
			}

			if (arg1_variable == lambda_variable) {
				/* the subject can be moved, but its descendants cannot */
				if (!scopes.add({operand, arg1_position})
				 || !scopes.add({arg1, {head_position::LEFT, 0}}))
					return false;
				found_arg = true;
				return true;
			} else if (arg2_variable == lambda_variable) {
				if (!scopes.add({operand, arg2_position})
				 || !scopes.add({arg2, {head_position::LEFT, 0}}))
					return false;
				found_arg = true;
				return true;
			} else if (arg2_variable != 0) {
				/* continue searching in the scope of `arg2_variable` */
				bool found_next_scope = false;
				for (unsigned int i = scopes.length; !found_next_scope && i > 0; i--) {
					if ((scopes[i - 1].key->type == hol_term_type::EXISTS || scopes[i - 1].key->type == hol_term_type::FOR_ALL) && scopes[i - 1].key->quantifier.variable == arg2_variable) {
						/* check if this quantifier is relativized */
						hol_term* scope_operand = scopes[i - 1].key->quantifier.operand;
						if ((scopes[i - 1].key->type == hol_term_type::EXISTS
						  && scope_operand->type == hol_term_type::AND && scope_operand->array.length == 2
						  && scope_operand->array.operands[0]->type == hol_term_type::UNARY_APPLICATION
						  && scope_operand->array.operands[0]->binary.left->type == hol_term_type::VARIABLE
						  && scope_operand->array.operands[0]->binary.right->type == hol_term_type::VARIABLE
						  && scope_operand->array.operands[0]->binary.right->variable == arg2_variable)
						 || (scopes[i - 1].key->type == hol_term_type::FOR_ALL && scope_operand->type == hol_term_type::IF_THEN
						  && scope_operand->binary.left->type == hol_term_type::UNARY_APPLICATION
						  && scope_operand->binary.left->binary.left->type == hol_term_type::VARIABLE
						  && scope_operand->binary.left->binary.right->type == hol_term_type::VARIABLE
						  && scope_operand->binary.left->binary.right->variable == arg2_variable))
						{
							/* find the set definition for `set_variable` */
							unsigned int set_variable = (scopes[i - 1].key->type == hol_term_type::EXISTS) ? scope_operand->array.operands[0]->binary.left->variable : scope_operand->binary.left->binary.left->variable;
							bool found_set_definition = false;
							for (unsigned int j = i; !found_set_definition && j > 0; j--) {
								if (scopes[j - 1].key->type != hol_term_type::EXISTS || scopes[j - 1].key->quantifier.variable != set_variable)
									continue;
								hol_term* first; head_index first_position;
								hol_term* set_scope_operand = scopes[j - 1].key->quantifier.operand;
								if (set_scope_operand->type == hol_term_type::AND) {
									first = set_scope_operand->array.operands[0];
									first_position = {head_position::LEFT, 0};
								} else if (set_scope_operand->type == hol_term_type::ANY_ARRAY && set_scope_operand->any_array.oper == hol_term_type::AND) {
									if (set_scope_operand->any_array.left.length == 0) {
										first = set_scope_operand->any_array.all;
										first_position = {head_position::NONE, 0};
									} else {
										first = set_scope_operand->any_array.left.operands[0];
										first_position = {head_position::LEFT, 0};
									}
								} else {
									return false;
								}

								if (first->type == hol_term_type::EQUALS && first->binary.left->type == hol_term_type::VARIABLE
								 && first->binary.left->variable == set_variable && first->binary.right->type == hol_term_type::LAMBDA)
								{
									scopes.length = j;
									if (!scopes.add({set_scope_operand, first_position})
									 || !scopes.add({first, {head_position::LEFT, 0}}))
										return false;
									current_scope = first->binary.right;
									found_set_definition = true;
								} else if (first->type == hol_term_type::BINARY_APPLICATION && first->ternary.second->type == hol_term_type::VARIABLE
										&& first->ternary.second->variable == set_variable && first->ternary.third->type == hol_term_type::LAMBDA)
								{
									scopes.length = j;
									if (!scopes.add({set_scope_operand, first_position})
									 || !scopes.add({first, {head_position::LEFT, 0}}))
										return false;
									current_scope = first->ternary.third;
									found_set_definition = true;
								} else if (first->type == hol_term_type::ANY_RIGHT && first->any.included != nullptr && first->any.included->type == hol_term_type::LAMBDA) {
									scopes.length = j;
									if (!scopes.add({set_scope_operand, first_position})
									 || !scopes.add({first, {head_position::LEFT, 0}}))
										return false;
									current_scope = first->any.included;
									found_set_definition = true;
								}
								break;
							}
							if (!found_set_definition)
								return false;
						}
						found_next_scope = true;
					} else if (scopes[i - 1].key->type == hol_term_type::LAMBDA && scopes[i - 1].key->quantifier.variable == arg2_variable) {
						current_scope = scopes[i - 1].key;
						scopes.length = i - 1;
						found_next_scope = true;
					}
				}
				if (!found_next_scope)
					return false;
			} else if (arg1 != nullptr) {
				/* the right-most path ends at an `ANY` or `ANY_RIGHT` node */
				if (!scopes.add({operand, arg1_position})
				 || !scopes.add({arg1, {head_position::LEFT, 0}}))
					return false;
				return true;
			} else if (arg2 != nullptr) {
				/* the right-most path ends at an `ANY` or `ANY_RIGHT` node */
				if (!scopes.add({operand, arg2_position})
				 || !scopes.add({arg2, {head_position::LEFT, 0}}))
					return false;
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}
}

template<bool PruneIndependentSiblings>
hol_term* substitute_scope(
		hol_term* src_scope, hol_term* dst_scope,
		array<pair<hol_term*, head_index>>& scopes)
{
	if (scopes[scopes.length - 1].key == dst_scope) {
		free(*dst_scope); if (dst_scope->reference_count == 0) free(dst_scope);
		scopes[0].key->reference_count++;
		return scopes[0].key;
	}

	/* first compute the array of sibling nodes */
	array<unsigned int> dst_variables(8);
	array<hol_term*> siblings(16);
	if (PruneIndependentSiblings) {
		for (unsigned int i = 0; i < scopes.length; i++) {
			hol_term* scope = scopes[i].key;
			head_index position = scopes[i].value;

			switch (scope->type) {
			case hol_term_type::VARIABLE:
			case hol_term_type::VARIABLE_PREIMAGE:
			case hol_term_type::CONSTANT:
			case hol_term_type::PARAMETER:
			case hol_term_type::NUMBER:
			case hol_term_type::STRING:
			case hol_term_type::UINT_LIST:
			case hol_term_type::TRUE:
			case hol_term_type::FALSE:
			case hol_term_type::NOT:
			case hol_term_type::UNARY_APPLICATION:
			case hol_term_type::EQUALS:
			case hol_term_type::BINARY_APPLICATION:
			case hol_term_type::IFF:
			case hol_term_type::FOR_ALL:
			case hol_term_type::EXISTS:
			case hol_term_type::LAMBDA:
			case hol_term_type::ANY:
			case hol_term_type::ANY_RIGHT:
			case hol_term_type::ANY_RIGHT_ONLY:
			case hol_term_type::ANY_ARRAY:
			case hol_term_type::ANY_CONSTANT:
			case hol_term_type::ANY_CONSTANT_EXCEPT:
			case hol_term_type::ANY_QUANTIFIER:
				break;
			case hol_term_type::IF_THEN:
				if (!siblings.add(scope->binary.left)) {
					free(*dst_scope); if (dst_scope->reference_count == 0) free(dst_scope);
					return nullptr;
				}
				break;
			case hol_term_type::AND:
			case hol_term_type::OR:
				for (unsigned int i = 0; i < scope->array.length; i++) {
					if (i != position.index && !siblings.add(scope->array.operands[i])) {
						free(*dst_scope); if (dst_scope->reference_count == 0) free(dst_scope);
						return nullptr;
					}
				}
				break;
			}
		}

		get_free_variables(*dst_scope, dst_variables);
		if (dst_variables.length > 1) insertion_sort(dst_variables);
		if (!prune_independent_siblings(dst_variables, siblings)) {
			free(*dst_scope); if (dst_scope->reference_count == 0) free(dst_scope);
			return nullptr;
		}
	}

	hol_term* new_scope = dst_scope;
	for (unsigned int i = 0; i < scopes.length; i++) {
		hol_term* current_scope = scopes[i].key;
		head_index position = scopes[i].value;

		hol_term* next_scope = nullptr;
		hol_term** new_operands;
		unsigned int new_length;
		switch (current_scope->type) {
		case hol_term_type::VARIABLE:
		case hol_term_type::VARIABLE_PREIMAGE:
		case hol_term_type::CONSTANT:
		case hol_term_type::PARAMETER:
		case hol_term_type::NUMBER:
		case hol_term_type::STRING:
		case hol_term_type::UINT_LIST:
		case hol_term_type::TRUE:
		case hol_term_type::FALSE:
		case hol_term_type::BINARY_APPLICATION:
		case hol_term_type::IFF:
		case hol_term_type::ANY_CONSTANT:
		case hol_term_type::ANY_CONSTANT_EXCEPT:
		case hol_term_type::ANY_RIGHT_ONLY:
			free(*new_scope); if (new_scope->reference_count == 0) free(new_scope);
			return nullptr;

		case hol_term_type::NOT:
			next_scope = hol_term::new_not(new_scope);
			if (next_scope == nullptr) {
				free(*new_scope); if (new_scope->reference_count == 0) free(new_scope);
				return nullptr;
			}
			break;

		case hol_term_type::EQUALS:
			if (position.index == 0) {
				next_scope = hol_term::new_equals(new_scope, current_scope->binary.right);
				if (next_scope == nullptr) {
					free(*new_scope); if (new_scope->reference_count == 0) free(new_scope);
					return nullptr;
				}
				current_scope->binary.right->reference_count++;
			} else {
				next_scope = hol_term::new_equals(current_scope->binary.left, new_scope);
				if (next_scope == nullptr) {
					free(*new_scope); if (new_scope->reference_count == 0) free(new_scope);
					return nullptr;
				}
				current_scope->binary.left->reference_count++;
			}
			break;

		case hol_term_type::AND:
		case hol_term_type::OR:
			new_operands = (hol_term**) malloc(sizeof(hol_term*) * current_scope->array.length);
			if (new_operands == nullptr) {
				free(*new_scope); if (new_scope->reference_count == 0) free(new_scope);
				return nullptr;
			}

			new_length = 0;
			for (unsigned int i = 0; i < current_scope->array.length; i++) {
				if (i == position.index) {
					new_operands[new_length++] = new_scope;
					continue;
				}
				if (PruneIndependentSiblings && !siblings.contains(current_scope->array.operands[i]))
					continue;
				new_operands[new_length++] = current_scope->array.operands[i];
			}

			if (new_length == 1) {
				next_scope = new_operands[0];
			} else if (current_scope->type == hol_term_type::AND) {
				next_scope = hol_term::new_and(make_array_view(new_operands, new_length));
			} else {
				next_scope = hol_term::new_or(make_array_view(new_operands, new_length));
			}
			if (next_scope == nullptr) {
				free(*new_scope); if (new_scope->reference_count == 0) free(new_scope);
				free(new_operands); return nullptr;
			}

			for (unsigned int i = 0; i < new_length; i++)
				new_operands[i]->reference_count++;
			new_scope->reference_count--;
			free(new_operands);
			break;

		case hol_term_type::FOR_ALL:
			if (PruneIndependentSiblings && !dst_variables.contains(current_scope->quantifier.variable)) {
				next_scope = new_scope;
				break;
			}
			next_scope = hol_term::new_for_all(current_scope->quantifier.variable, new_scope);
			if (next_scope == nullptr) {
				free(*new_scope); if (new_scope->reference_count == 0) free(new_scope);
				return nullptr;
			}
			break;

		case hol_term_type::EXISTS:
			if (PruneIndependentSiblings && !dst_variables.contains(current_scope->quantifier.variable)) {
				next_scope = new_scope;
				break;
			}
			next_scope = hol_term::new_exists(current_scope->quantifier.variable, new_scope);
			if (next_scope == nullptr) {
				free(*new_scope); if (new_scope->reference_count == 0) free(new_scope);
				return nullptr;
			}
			break;

		case hol_term_type::LAMBDA:
			if (PruneIndependentSiblings && !dst_variables.contains(current_scope->quantifier.variable)) {
				next_scope = new_scope;
				break;
			}
			next_scope = hol_term::new_lambda(current_scope->quantifier.variable, new_scope);
			if (next_scope == nullptr) {
				free(*new_scope); if (new_scope->reference_count == 0) free(new_scope);
				return nullptr;
			}
			break;

		case hol_term_type::IF_THEN:
			if (PruneIndependentSiblings && !siblings.contains(current_scope->binary.left)) {
				next_scope = new_scope;
				break;
			}
			next_scope = hol_term::new_if_then(current_scope->binary.left, new_scope);
			if (next_scope == nullptr) {
				free(*new_scope); if (new_scope->reference_count == 0) free(new_scope);
				return nullptr;
			}
			current_scope->binary.left->reference_count++;
			break;

		case hol_term_type::UNARY_APPLICATION:
			next_scope = hol_term::new_if_then(current_scope->binary.left, new_scope);
			if (next_scope == nullptr) {
				free(*new_scope); if (new_scope->reference_count == 0) free(new_scope);
				return nullptr;
			}
			current_scope->binary.left->reference_count++;
			break;

		case hol_term_type::ANY:
		case hol_term_type::ANY_RIGHT:
			if (new_scope->type == hol_term_type::ANY && new_scope->any.excluded_tree_count == 0) {
				next_scope = new_scope;
			} else if (new_scope->type == hol_term_type::ANY_RIGHT && new_scope->any.excluded_tree_count == 0) {
				if (current_scope->type == hol_term_type::ANY_RIGHT) {
					next_scope = new_scope;
				} else {
					next_scope = hol_term::new_any(new_scope->any.included);
					if (next_scope == nullptr) {
						free(*new_scope); if (new_scope->reference_count == 0) free(new_scope);
						return nullptr;
					}
				}
			} else if (new_scope->type == hol_term_type::ANY || new_scope->type == hol_term_type::ANY_RIGHT) {
				array<hol_term*> excluded(max(1u, new_scope->any.excluded_tree_count + current_scope->any.excluded_tree_count));
				for (unsigned int i = 0; i < new_scope->any.excluded_tree_count; i++) {
					/* make sure this tree isn't a subset of any tree in `current_scope->any.excluded_trees` */
					bool irreducible = true;
					for (unsigned int j = 0; j < current_scope->any.excluded_tree_count; j++) {
						if (is_subset<built_in_predicates>(new_scope->any.excluded_trees[i], current_scope->any.excluded_trees[j])) {
							irreducible = false;
							break;
						}
					}
					if (irreducible)
						excluded[excluded.length++] = new_scope->any.excluded_trees[i];
				}
				unsigned int old_excluded_tree_count = excluded.length;
				for (unsigned int i = 0; i < current_scope->any.excluded_tree_count; i++) {
					/* make sure this tree isn't a subset of any tree in `new_head->any.excluded_trees` */
					bool irreducible = true;
					for (unsigned int j = 0; j < old_excluded_tree_count; j++) {
						if (is_subset<built_in_predicates>(current_scope->any.excluded_trees[i], excluded[j])) {
							irreducible = false;
							break;
						}
					}
					if (irreducible)
						excluded[excluded.length++] = current_scope->any.excluded_trees[i];
				}
				if (current_scope->type == hol_term_type::ANY || new_scope->type == hol_term_type::ANY)
					next_scope = hol_term::new_any(new_scope->any.included, excluded.data, excluded.length);
				else next_scope = hol_term::new_any_right(new_scope->any.included, excluded.data, excluded.length);
				if (next_scope == nullptr) {
					free(*new_scope); if (new_scope->reference_count == 0) free(new_scope);
					return nullptr;
				}
				if (new_scope->any.included != nullptr)
					new_scope->any.included->reference_count++;
				for (hol_term* tree : excluded)
					tree->reference_count++;
				free(*new_scope); if (new_scope->reference_count == 0) free(new_scope);
			} else {
				if (current_scope->type == hol_term_type::ANY)
					next_scope = hol_term::new_any(new_scope, current_scope->any.excluded_trees, current_scope->any.excluded_tree_count);
				else next_scope = hol_term::new_any_right(new_scope, current_scope->any.excluded_trees, current_scope->any.excluded_tree_count);
				if (next_scope == nullptr) {
					free(*new_scope); if (new_scope->reference_count == 0) free(new_scope);
					return nullptr;
				}
				for (unsigned int i = 0; i < current_scope->any.excluded_tree_count; i++)
					current_scope->any.excluded_trees[i]->reference_count++;
			}
			break;

		case hol_term_type::ANY_ARRAY:
			if (position.position == head_position::NONE) {
				next_scope = hol_term::new_any_array(current_scope->any_array.oper, new_scope,
						make_array_view(current_scope->any_array.any.operands, current_scope->any_array.any.length),
						make_array_view(current_scope->any_array.left.operands, current_scope->any_array.left.length),
						make_array_view(current_scope->any_array.right.operands, current_scope->any_array.right.length));
			} else if (position.position == head_position::LEFT) {
				next_scope = hol_term::new_any_array(current_scope->any_array.oper, current_scope->any_array.all,
						make_array_view(current_scope->any_array.any.operands, current_scope->any_array.any.length),
						make_replaced_array_view(make_array_view(current_scope->any_array.left.operands, current_scope->any_array.left.length), new_scope, position.index),
						make_array_view(current_scope->any_array.right.operands, current_scope->any_array.right.length));
			} else if (position.position == head_position::RIGHT) {
				next_scope = hol_term::new_any_array(current_scope->any_array.oper, current_scope->any_array.all,
						make_array_view(current_scope->any_array.any.operands, current_scope->any_array.any.length),
						make_array_view(current_scope->any_array.left.operands, current_scope->any_array.left.length),
						make_replaced_array_view(make_array_view(current_scope->any_array.right.operands, current_scope->any_array.right.length), new_scope, position.index));
			} else {
				next_scope = hol_term::new_any_array(current_scope->any_array.oper, current_scope->any_array.all,
						make_replaced_array_view(make_array_view(current_scope->any_array.any.operands, current_scope->any_array.any.length), new_scope, position.index),
						make_array_view(current_scope->any_array.left.operands, current_scope->any_array.left.length),
						make_array_view(current_scope->any_array.right.operands, current_scope->any_array.right.length));
			}
			if (next_scope == nullptr) {
				free(*new_scope); if (new_scope->reference_count == 0) free(new_scope);
				return nullptr;
			}
			next_scope->any_array.all->reference_count++;
			for (unsigned int i = 0; i < next_scope->any_array.left.length; i++)
				next_scope->any_array.left.operands[i]->reference_count++;
			for (unsigned int i = 0; i < next_scope->any_array.right.length; i++)
				next_scope->any_array.right.operands[i]->reference_count++;
			for (unsigned int i = 0; i < next_scope->any_array.any.length; i++)
				next_scope->any_array.any.operands[i]->reference_count++;
			new_scope->reference_count--;
			break;

		case hol_term_type::ANY_QUANTIFIER:
			next_scope = hol_term::new_any_quantifier(current_scope->any_quantifier.quantifier, new_scope);
			if (next_scope == nullptr) {
				free(*new_scope); if (new_scope->reference_count == 0) free(new_scope);
				return nullptr;
			}
			break;
		}
		new_scope = next_scope;
	}

	return new_scope;
}

inline bool select_lambda(
		hol_term* src, hol_term*& dst)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	bool found_arg = false;
	array<pair<hol_term*, head_index>> scopes(8);
	if (!find_lambda(src, lambda_variable, scopes, found_arg))
		return false;

	if (found_arg) {
		/* construct the new head */
		unsigned int head_variable = scopes[scopes.length - 3].key->quantifier.variable;
		hol_term* operand = scopes[scopes.length - 2].key;
		hol_term* arg_term = scopes[scopes.length - 1].key;

		head_index predicate_index;
		hol_term* predicate = find_predicate<built_in_predicates>(head_variable, operand, predicate_index);
		if (predicate_index.position == head_position::NONE)
			return false;

		if (predicate == nullptr) {
			hol_term* head_var = hol_term::new_variable(head_variable);
			if (head_var == nullptr) return false;
			constexpr unsigned int excluded_tree_count = 2;
			hol_term** excluded_trees = (hol_term**) alloca(sizeof(hol_term) * (excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()));
			excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
						(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
						(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
					&HOL_ANY), head_var));
			excluded_trees[1] = hol_term::new_any(hol_term::new_exists(head_variable, &HOL_ANY));
			if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
			if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
			if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr) {
				if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
				free(*head_var); free(head_var);
				return false;
			}
			free(*head_var);

			for (unsigned int i = 0; i < hol_non_head_constants<built_in_predicates>::count(); i++) {
				excluded_trees[excluded_tree_count + i] = hol_non_head_constants<built_in_predicates>::get_terms()[i];
				excluded_trees[excluded_tree_count + i]->reference_count++;
			}

			hol_term* expected_predicate = hol_term::new_apply(
						hol_term::new_any(nullptr, excluded_trees, excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()),
						hol_term::new_variable(head_variable));
			if (expected_predicate == nullptr) {
				for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
					free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
				}
				return false;
			}
			for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++)
				excluded_trees[i]->reference_count++;
			predicate = expected_predicate;
		} else {
			predicate->reference_count++;
		}

		hol_term* new_head = hol_term::new_exists(head_variable, hol_term::new_and(predicate, arg_term));
		if (new_head == nullptr) {
			free(*predicate); if (predicate->reference_count == 0) free(predicate);
			return false;
		}
		scopes.length -= 2;

		dst = substitute_scope<true>(scopes[scopes.length - 1].key, new_head, scopes);
		return (dst != nullptr);

	} else {
		unsigned int head_variable = ++max_variable;

		hol_term* head_var = hol_term::new_variable(head_variable);
		if (head_var == nullptr) return false;
		constexpr unsigned int excluded_tree_count = 2;
		hol_term** excluded_trees = (hol_term**) alloca(sizeof(hol_term) * (excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()));
		excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
					(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
					(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
				&HOL_ANY), head_var));
		excluded_trees[1] = hol_term::new_any(hol_term::new_exists(head_variable, &HOL_ANY));
		if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
		if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
		if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr) {
			if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
			free(*head_var); free(head_var);
			return false;
		}
		free(*head_var);

		for (unsigned int i = 0; i < hol_non_head_constants<built_in_predicates>::count(); i++) {
			excluded_trees[excluded_tree_count + i] = hol_non_head_constants<built_in_predicates>::get_terms()[i];
			excluded_trees[excluded_tree_count + i]->reference_count++;
		}

		hol_term* expected_predicate = hol_term::new_apply(
					hol_term::new_any(nullptr, excluded_trees, excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()),
					hol_term::new_variable(head_variable));
		if (expected_predicate == nullptr) {
			for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
				free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
			}
			return false;
		}
		for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++)
			excluded_trees[i]->reference_count++;

		dst = hol_term::new_lambda(lambda_variable, hol_term::new_exists(head_variable, hol_term::new_and(expected_predicate, hol_term::new_equals(
			hol_term::new_apply(hol_term::new_any_constant((unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2), head_var),
			hol_term::new_variable(lambda_variable)
		))));
		if (dst == nullptr) {
			free(*expected_predicate); free(expected_predicate);
			for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
				free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
			}
			return false;
		}
		for (unsigned int i = 0; i < excluded_tree_count; i++)
			excluded_trees[i]->reference_count++;
		for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
			free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
		}
		head_var->reference_count++;
		return true;
	}
}

inline bool remove_lambda(
		hol_term* src, hol_term*& dst)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	bool found_arg = false;
	array<pair<hol_term*, head_index>> scopes(8);
	if (!find_lambda(src, lambda_variable, scopes, found_arg))
		return false;

	if (found_arg) {
		/* construct the new head */
		unsigned int head_variable = scopes[scopes.length - 3].key->quantifier.variable;
		hol_term* operand = scopes[scopes.length - 2].key;
		head_index arg_position = scopes[scopes.length - 2].value;

		hol_term* new_operand;
		if (operand->type == hol_term_type::AND) {
			new_operand =  hol_term::new_and(make_replaced_array_view(make_array_view(operand->array.operands, operand->array.length), &HOL_GAP, arg_position.index));
			if (new_operand == nullptr) return false;
			for (unsigned int i = 0; i < new_operand->array.length; i++)
				new_operand->array.operands[i]->reference_count++;
		} else if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
			if (arg_position.position == head_position::LEFT) {
				new_operand = hol_term::new_exists(head_variable, hol_term::new_any_array(hol_term_type::AND, operand->any_array.all,
						make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
						make_replaced_array_view(make_array_view(operand->any_array.left.operands, operand->any_array.left.length), &HOL_GAP, arg_position.index),
						make_array_view(operand->any_array.right.operands, operand->any_array.right.length)));
			} else if (arg_position.position == head_position::RIGHT) {
				new_operand = hol_term::new_exists(head_variable, hol_term::new_any_array(hol_term_type::AND, operand->any_array.all,
						make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
						make_array_view(operand->any_array.left.operands, operand->any_array.left.length),
						make_replaced_array_view(make_array_view(operand->any_array.right.operands, operand->any_array.right.length), &HOL_GAP, arg_position.index)));
			} else {
				new_operand = hol_term::new_exists(head_variable, hol_term::new_any_array(hol_term_type::AND, operand->any_array.all,
						make_replaced_array_view(make_array_view(operand->any_array.any.operands, operand->any_array.any.length), &HOL_GAP, arg_position.index),
						make_array_view(operand->any_array.left.operands, operand->any_array.left.length),
						make_array_view(operand->any_array.right.operands, operand->any_array.right.length)));
			}
			if (new_operand == nullptr) return false;
			new_operand->any_array.all->reference_count++;
			for (unsigned int i = 0; i < new_operand->any_array.left.length; i++)
				new_operand->any_array.left.operands[i]->reference_count++;
			for (unsigned int i = 0; i < new_operand->any_array.right.length; i++)
				new_operand->any_array.right.operands[i]->reference_count++;
			for (unsigned int i = 0; i < new_operand->any_array.any.length; i++)
				new_operand->any_array.any.operands[i]->reference_count++;
		} else {
			new_operand = &HOL_GAP;
			new_operand->reference_count++;
		}

		hol_term* new_head = hol_term::new_exists(head_variable, new_operand);
		if (new_head == nullptr) {
			free(*new_operand); if (new_operand->reference_count == 0) free(new_operand);
			return false;
		}
		scopes.length -= 2;

		dst = substitute_scope<true>(scopes[scopes.length - 1].key, new_head, scopes);
		if (dst == nullptr) return false;
		if (dst->type == hol_term_type::LAMBDA && dst->quantifier.variable == lambda_variable) {
			free(*dst); if (dst->reference_count == 0) free(dst);
			return false;
		}
		return true;

	} else {
		if (src->type == hol_term_type::LAMBDA && src->quantifier.variable == lambda_variable) {
			dst = src->quantifier.operand;
			dst->reference_count++;
		} else {
			dst = src;
			dst->reference_count++;
		}
		return true;
	}
}

enum class substitution_setting {
	ARG2,
	EMPTY,
	NONE
};

inline bool find_conjunct(
		hol_term* src, hol_term* conjunct,
		array<pair<hol_term*, head_index>>& scopes,
		hol_term*& found_conjunct,
		bool& could_have_conjunct)
{
	array<hol_term*> intersection(2);
	intersect<built_in_predicates>(intersection, src, conjunct);
	if (intersection.length == 1 && (intersection[0] == src || *intersection[0] == *src)) {
		/* `src` is a subset of `conjunct` */
		found_conjunct = src;
		could_have_conjunct = true;
		free_all(intersection);
		return true;
	} else if (intersection.length != 0) {
		free_all(intersection);
		could_have_conjunct = true;
	}

	switch (src->type) {
	case hol_term_type::CONSTANT:
	case hol_term_type::VARIABLE:
	case hol_term_type::VARIABLE_PREIMAGE:
	case hol_term_type::PARAMETER:
	case hol_term_type::NUMBER:
	case hol_term_type::STRING:
	case hol_term_type::UINT_LIST:
	case hol_term_type::UNARY_APPLICATION:
	case hol_term_type::BINARY_APPLICATION:
	case hol_term_type::TRUE:
	case hol_term_type::FALSE:
	case hol_term_type::ANY_CONSTANT:
	case hol_term_type::ANY_CONSTANT_EXCEPT:
		return true;
	case hol_term_type::EQUALS:
		if (!find_conjunct(src->binary.left, conjunct, scopes, found_conjunct, could_have_conjunct))
			return false;
		if (found_conjunct != nullptr)
			return scopes.add({src, {head_position::NONE, 0}});
		if (!find_conjunct(src->binary.right, conjunct, scopes, found_conjunct, could_have_conjunct))
			return false;
		if (found_conjunct != nullptr)
			return scopes.add({src, {head_position::NONE, 1}});
		return true;
	case hol_term_type::NOT:
		return find_conjunct(src->unary.operand, conjunct, scopes, found_conjunct, could_have_conjunct)
			&& (found_conjunct == nullptr || scopes.add({src, {head_position::NONE, 0}}));
	case hol_term_type::AND:
	case hol_term_type::OR:
	case hol_term_type::IFF:
		for (unsigned int i = 0; i < src->array.length; i++) {
			if (!find_conjunct(src->array.operands[i], conjunct, scopes, found_conjunct, could_have_conjunct))
				return false;
			if (found_conjunct != nullptr)
				return scopes.add({src, {head_position::LEFT, i}});
		}
		return true;
	case hol_term_type::ANY_ARRAY:
		for (unsigned int i = 0; i < src->any_array.any.length; i++) {
			if (!find_conjunct(src->any_array.any.operands[i], conjunct, scopes, found_conjunct, could_have_conjunct))
				return false;
			if (found_conjunct != nullptr)
				return scopes.add({src, {head_position::ANY, i}});
		} for (unsigned int i = 0; i < src->any_array.left.length; i++) {
			if (!find_conjunct(src->any_array.left.operands[i], conjunct, scopes, found_conjunct, could_have_conjunct))
				return false;
			if (found_conjunct != nullptr)
				return scopes.add({src, {head_position::LEFT, i}});
		} for (unsigned int i = 0; i < src->any_array.right.length; i++) {
			if (!find_conjunct(src->any_array.right.operands[i], conjunct, scopes, found_conjunct, could_have_conjunct))
				return false;
			if (found_conjunct != nullptr)
				return scopes.add({src, {head_position::RIGHT, i}});
		}
		if (!find_conjunct(src->any_array.all, conjunct, scopes, found_conjunct, could_have_conjunct))
			return false;
		if (found_conjunct != nullptr)
			return scopes.add({src, {head_position::NONE, 0}});
		return true;
	case hol_term_type::IF_THEN:
		return find_conjunct(src->binary.right, conjunct, scopes, found_conjunct, could_have_conjunct)
			&& (found_conjunct == nullptr || scopes.add({src, {head_position::LEFT, 1}}));
	case hol_term_type::FOR_ALL:
	case hol_term_type::EXISTS:
	case hol_term_type::LAMBDA:
		return find_conjunct(src->quantifier.operand, conjunct, scopes, found_conjunct, could_have_conjunct)
			&& (found_conjunct == nullptr || scopes.add({src, {head_position::NONE, 0}}));
	case hol_term_type::ANY_QUANTIFIER:
		return find_conjunct(src->any_quantifier.operand, conjunct, scopes, found_conjunct, could_have_conjunct)
			&& (found_conjunct == nullptr || scopes.add({src, {head_position::NONE, 0}}));
	case hol_term_type::ANY:
	case hol_term_type::ANY_RIGHT:
	case hol_term_type::ANY_RIGHT_ONLY:
		if (src->any.included == nullptr)
			return true;
		return find_conjunct(src->any.included, conjunct, scopes, found_conjunct, could_have_conjunct)
			&& (found_conjunct == nullptr || scopes.add({src, {head_position::NONE, 0}}));
	}
	fprintf(stderr, "find_conjunct ERROR: Unrecognized hol_term_type.\n");
	return false;
}

template<substitution_setting SubstitutionSetting>
inline bool select_function(
		hol_term* src, hol_term*& dst)
{
	unsigned int lambda_variable = 0;
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);
	if (SubstitutionSetting == substitution_setting::ARG2) {
		if (src->type == hol_term_type::LAMBDA)
			lambda_variable = src->quantifier.variable;
	}

	array_map<unsigned int, hol_term*> scopes(8);
	auto gather_scope = [&scopes](hol_term* term) {
		if (term->type == hol_term_type::FOR_ALL || term->type == hol_term_type::EXISTS || term->type == hol_term_type::LAMBDA) {
			if (!scopes.ensure_capacity(scopes.size + 1))
				return false;
			scopes.keys[scopes.size] = term->quantifier.variable;
			scopes.values[scopes.size++] = term;
		}
		return true;
	};

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<false>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker, find_head<built_in_predicates>,
			[&scopes,lambda_variable,&max_variable](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				hol_term* old_head = head;
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
					head = head->any.included;

				while (head->type == hol_term_type::NOT)
					head = head->unary.operand;

				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) {
					head_variable = ++max_variable;
				} else {
#if !defined(NDEBUG)
					if (head->type != hol_term_type::EXISTS)
						fprintf(stderr, "select_function WARNING: Expected an existential quantification.\n");
#endif
					head_variable = head->quantifier.variable;
				}

				hol_term* head_var = hol_term::new_variable(head_variable);
				if (head_var == nullptr) return (hol_term*) nullptr;

				hol_term* expected_head;
				if (SubstitutionSetting == substitution_setting::NONE || SubstitutionSetting == substitution_setting::EMPTY) {
					expected_head = hol_term::new_exists(head_variable,
								hol_term::new_apply(
									hol_term::new_apply(
										hol_term::new_any_constant_except(make_array_view(hol_non_head_constants<built_in_predicates>::CONSTANTS, hol_non_head_constants<built_in_predicates>::CONSTANT_COUNT)),
										&HOL_ANY),
								head_var)
							);
					if (expected_head == nullptr) {
						free(*head_var); free(head_var);
						return (hol_term*) nullptr;
					}
					HOL_ANY.reference_count += 1;
				} else if (lambda_variable == 0) {
					expected_head = hol_term::new_exists(head_variable, hol_term::new_and(
								hol_term::new_apply(
									hol_term::new_apply(
										hol_term::new_any_constant_except(make_array_view(hol_non_head_constants<built_in_predicates>::CONSTANTS, hol_non_head_constants<built_in_predicates>::CONSTANT_COUNT)),
										&HOL_ANY),
								head_var),
								hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value, head_var), &HOL_ANY)
							));
					if (expected_head == nullptr) {
						free(*head_var); free(head_var);
						return (hol_term*) nullptr;
					}
					hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value.reference_count++;
					head_var->reference_count += 2 - 1;
					HOL_ANY.reference_count += 2;
				} else {
					expected_head = hol_term::new_exists(head_variable, hol_term::new_and(
								hol_term::new_apply(
									hol_term::new_apply(
										hol_term::new_any_constant_except(make_array_view(hol_non_head_constants<built_in_predicates>::CONSTANTS, hol_non_head_constants<built_in_predicates>::CONSTANT_COUNT)),
										&HOL_ANY),
								head_var),
								hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG1>::value, head_var), &HOL_ANY),
								hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value, head_var), hol_term::new_variable(lambda_variable))
							));
					if (expected_head == nullptr) {
						free(*head_var); free(head_var);
						return (hol_term*) nullptr;
					}
					hol_term::constants<(unsigned int) built_in_predicates::ARG1>::value.reference_count++;
					hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value.reference_count++;
					head_var->reference_count += 3 - 1;
					HOL_ANY.reference_count += 2;
				}

				array<hol_term*> intersection(2);
				intersect<built_in_predicates>(intersection, head, expected_head);
				free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
				if (intersection.length == 0) {
					return (hol_term*) nullptr;
				} else if (intersection.length != 1) {
					fprintf(stderr, "select_function ERROR: Intersection is not unique.\n");
					free_all(intersection);
					return (hol_term*) nullptr;
				}

				hol_term* function;
				if (SubstitutionSetting == substitution_setting::NONE || SubstitutionSetting == substitution_setting::EMPTY)
					function = intersection[0]->quantifier.operand->binary.left->binary.right;
				else function = intersection[0]->quantifier.operand->array.operands[0]->binary.left->binary.right;
				unsigned int function_variable;
				if (function->type == hol_term_type::ANY || function->type == hol_term_type::ANY_RIGHT) {
					if (function->any.included != nullptr) {
						free_all(intersection);
						return (hol_term*) nullptr;
					}
					/* the function variable is not known */
					unsigned int new_head_variable = ++max_variable;
					free_all(intersection);

					hol_term* new_head_var = hol_term::new_variable(new_head_variable);
					if (new_head_var == nullptr) return (hol_term*) nullptr;
					constexpr unsigned int excluded_tree_count = 2;
					hol_term** excluded_trees = (hol_term**) alloca(sizeof(hol_term) * (excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()));
					excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
								(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
								(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
							&HOL_ANY), new_head_var));
					excluded_trees[1] = hol_term::new_any(hol_term::new_exists(new_head_variable, &HOL_ANY));
					if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; new_head_var->reference_count++; }
					if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
					if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr) {
						if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
						free(*new_head_var); free(new_head_var);
						return (hol_term*) nullptr;
					}
					free(*new_head_var);

					for (unsigned int i = 0; i < hol_non_head_constants<built_in_predicates>::count(); i++) {
						excluded_trees[excluded_tree_count + i] = hol_non_head_constants<built_in_predicates>::get_terms()[i];
						excluded_trees[excluded_tree_count + i]->reference_count++;
					}

					hol_term* expected_predicate = hol_term::new_apply(
								hol_term::new_any(nullptr, excluded_trees, excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()), new_head_var);
					if (expected_predicate == nullptr) {
						for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
							free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
						}
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++)
						excluded_trees[i]->reference_count++;
					new_head_var->reference_count++;

					hol_term* dst = hol_term::new_exists(new_head_variable, hol_term::new_any_array(hol_term_type::AND,
							hol_term::new_any(nullptr, excluded_trees, excluded_tree_count), make_array_view(&expected_predicate, 1),
							make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0)));
					if (dst == nullptr) {
						free(*expected_predicate); free(expected_predicate);
						for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
							free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
						}
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < excluded_tree_count; i++)
						excluded_trees[i]->reference_count++;
					for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
						free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
					}
					if (old_head->type == hol_term_type::ANY || old_head->type == hol_term_type::ANY_RIGHT) {
						hol_term* temp = hol_term::new_any_right(dst, old_head->any.excluded_trees, old_head->any.excluded_tree_count);
						if (temp == nullptr) {
							free(*dst); if (dst->reference_count == 0) free(dst);
							return (hol_term*) nullptr;
						}
						for (unsigned int i = 0; i < old_head->any.excluded_tree_count; i++)
							old_head->any.excluded_trees[i]->reference_count++;
						dst = temp;
					}
					return dst;
				} else if (function->type == hol_term_type::VARIABLE) {
					/* the function variable is known */
					function_variable = function->variable;
				} else {
					free_all(intersection);
					return (hol_term*) nullptr;
				}

				/* find the scope of the function variable */
				hol_term* function_scope = scopes.get(function_variable);
				hol_term* function_operand = function_scope->quantifier.operand;
				hol_term* function_left;
				if (function_operand->type == hol_term_type::AND) {
					function_left = function_operand->array.operands[0];
				} else if (function_operand->type == hol_term_type::ANY_ARRAY && function_operand->any_array.oper == hol_term_type::AND) {
					if (function_operand->any_array.left.length != 0)
						function_left = function_operand->any_array.left.operands[0];
					else function_left = nullptr;
				} else if (function_operand->type == hol_term_type::ANY || function_operand->type == hol_term_type::ANY_RIGHT) {
					function_left = nullptr;
				} else {
					free_all(intersection);
					return (hol_term*) nullptr;
				}

				hol_term* set_definition = nullptr;
				if (function_left != nullptr) {
					if (function_left->type == hol_term_type::EQUALS) {
						set_definition = function_left->binary.right;
					} else if (function_left->type == hol_term_type::ANY || function_left->type == hol_term_type::ANY_RIGHT) {
						set_definition = function_left;
					} else {
						free_all(intersection);
						return (hol_term*) nullptr;
					}
					if (set_definition->type == hol_term_type::ANY_RIGHT && set_definition->any.included != nullptr && set_definition->any.included->type == hol_term_type::LAMBDA)
						set_definition = set_definition->any.included;
				}

				function_operand = nullptr;
				if (set_definition != nullptr) {
					if (set_definition->type == hol_term_type::LAMBDA && set_definition->quantifier.operand->type == hol_term_type::LAMBDA) {
						function_operand = set_definition->quantifier.operand->quantifier.operand;
					} else if (set_definition->type != hol_term_type::ANY && set_definition->type != hol_term_type::ANY_RIGHT) {
						free_all(intersection);
						return (hol_term*) nullptr;
					}
				}

				if (function_operand == nullptr) {
					free_all(intersection);
					unsigned int new_head_variable = ++max_variable;
					hol_term* new_head_var = hol_term::new_variable(new_head_variable);
					if (new_head_var == nullptr) return (hol_term*) nullptr;
					constexpr unsigned int excluded_tree_count = 2;
					hol_term** excluded_trees = (hol_term**) alloca(sizeof(hol_term) * (excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()));
					excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
								(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
								(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
							&HOL_ANY), new_head_var));
					excluded_trees[1] = hol_term::new_any(hol_term::new_exists(new_head_variable, &HOL_ANY));
					if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; new_head_var->reference_count++; }
					if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
					if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr) {
						if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
						free(*new_head_var); free(new_head_var);
						return (hol_term*) nullptr;
					}
					free(*new_head_var);

					for (unsigned int i = 0; i < hol_non_head_constants<built_in_predicates>::count(); i++) {
						excluded_trees[excluded_tree_count + i] = hol_non_head_constants<built_in_predicates>::get_terms()[i];
						excluded_trees[excluded_tree_count + i]->reference_count++;
					}

					hol_term* expected_predicate = hol_term::new_apply(
								hol_term::new_any(nullptr, excluded_trees, excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()), new_head_var);
					if (expected_predicate == nullptr) {
						for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
							free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
						}
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++)
						excluded_trees[i]->reference_count++;
					new_head_var->reference_count++;

					hol_term* dst = hol_term::new_exists(new_head_variable, hol_term::new_any_array(hol_term_type::AND,
							hol_term::new_any(nullptr, excluded_trees, excluded_tree_count), make_array_view(&expected_predicate, 1),
							make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0)));
					if (dst == nullptr) {
						free(*expected_predicate); free(expected_predicate);
						for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
							free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
						}
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < excluded_tree_count; i++)
						excluded_trees[i]->reference_count++;
					for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
						free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
					}
					if (old_head->type == hol_term_type::ANY || old_head->type == hol_term_type::ANY_RIGHT) {
						hol_term* temp = hol_term::new_any_right(dst, old_head->any.excluded_trees, old_head->any.excluded_tree_count);
						if (temp == nullptr) {
							free(*dst); if (dst->reference_count == 0) free(dst);
							return (hol_term*) nullptr;
						}
						for (unsigned int i = 0; i < old_head->any.excluded_tree_count; i++)
							old_head->any.excluded_trees[i]->reference_count++;
						dst = temp;
					}
					return dst;
				} else if (function_operand->type != hol_term_type::EXISTS && function_operand->type != hol_term_type::ANY && function_operand->type != hol_term_type::ANY_RIGHT) {
					free_all(intersection);
					return (hol_term*) nullptr;
				}

				/* replace the `arg2(h)=y` term with a trace placeholder */
				hol_term* to_replace = hol_term::new_equals(
						hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value, &HOL_ANY),
						hol_term::new_variable(set_definition->quantifier.operand->quantifier.variable));
				if (to_replace == nullptr) {
					free_all(intersection);
					return (hol_term*) nullptr;
				}
				hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value.reference_count++;
				HOL_ANY.reference_count++;

				hol_term* found_conjunct = nullptr;
				bool could_have_conjunct = false;
				hol_term* substituted;
				array<pair<hol_term*, head_index>> scopes(8);
				if (!find_conjunct(function_operand, to_replace, scopes, found_conjunct, could_have_conjunct) || !could_have_conjunct) {
					free_all(intersection);
					free(*to_replace); free(to_replace);
					return (hol_term*) nullptr;
				} else if (found_conjunct == nullptr) {
					free(*to_replace); free(to_replace);
					substituted = function_operand;
					function_operand->reference_count++;
				} else {
					free(*to_replace); free(to_replace);
					substituted = substitute_scope<false>(function_operand, &hol_term::constants<(unsigned int) built_in_predicates::TRACE>::value, scopes);
					if (substituted == nullptr) {
						free_all(intersection);
						return (hol_term*) nullptr;
					}
					hol_term::constants<(unsigned int) built_in_predicates::TRACE>::value.reference_count++;
				}

				auto process_inner_scope = [set_definition,&max_variable,&intersection](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
				{
					hol_term* old_head = head;
					if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
						head = head->any.included;

					unsigned int function_head_variable;
					if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) {
						function_head_variable = ++max_variable;
					} else if (head->type == hol_term_type::EXISTS) {
						function_head_variable = head->quantifier.variable;
					} else {
						return (hol_term*) nullptr;
					}

					hol_term* excluded_tree = hol_term::new_any(hol_term::new_exists(function_head_variable, &HOL_ANY));
					if (excluded_tree == nullptr)
						return (hol_term*) nullptr;
					HOL_ANY.reference_count++;

					hol_term* expected_arg_term;
					if (SubstitutionSetting == substitution_setting::ARG2) {
						expected_arg_term = hol_term::new_equals(
								hol_term::new_apply(
									hol_term::new_any_constant((unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3),
									hol_term::new_variable(function_head_variable)),
								hol_term::new_variable(set_definition->quantifier.variable));
					} else {
						expected_arg_term = hol_term::new_equals(
								hol_term::new_apply(
									hol_term::new_any_constant((unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
									hol_term::new_variable(set_definition->quantifier.variable)),
								hol_term::new_variable(function_head_variable));
					}
					if (expected_arg_term == nullptr) {
						free(*excluded_tree); free(excluded_tree);
						return (hol_term*) nullptr;
					}

					hol_term* expected_function_head;
					if (SubstitutionSetting == substitution_setting::ARG2) {
						expected_function_head = hol_term::new_exists(function_head_variable, hol_term::new_any_array(hol_term_type::AND,
								hol_term::new_any(nullptr, &excluded_tree, 1), make_array_view((hol_term**) nullptr, 0),
								make_array_view(&expected_arg_term, 1), make_array_view((hol_term**) nullptr, 0)));
					} else {
						expected_function_head = hol_term::new_exists(function_head_variable, hol_term::new_any_array(hol_term_type::AND,
								hol_term::new_any(nullptr, &excluded_tree, 1), make_array_view((hol_term**) nullptr, 0),
								make_array_view((hol_term**) nullptr, 0), make_array_view(&expected_arg_term, 1)));
					}
					if (expected_function_head == nullptr) {
						free(*excluded_tree); free(excluded_tree);
						free(*expected_arg_term); free(expected_arg_term);
						return (hol_term*) nullptr;
					}

					array<hol_term*> new_function_heads(2);
					intersect<built_in_predicates>(new_function_heads, head, expected_function_head);
					free(*expected_function_head); if (expected_function_head->reference_count == 0) free(expected_function_head);
					if (new_function_heads.length == 0) {
						return (hol_term*) nullptr;
					} else if (new_function_heads.length != 1) {
						fprintf(stderr, "select_function ERROR: Intersection is not unique.\n");
						free_all(new_function_heads);
						return (hol_term*) nullptr;
					}

					hol_term* new_head = nullptr;
					if (SubstitutionSetting != substitution_setting::NONE) {
						hol_term* dst_var;
						unsigned int dst_variable;
						if (SubstitutionSetting == substitution_setting::ARG2) {
							hol_term* operand = intersection[0]->quantifier.operand;
							hol_term* right = operand->array.operands[operand->array.length - 1];
							if (right->type == hol_term_type::ANY && right->any.included->type == hol_term_type::VARIABLE) {
								dst_var = right->any.included;
							} else if (right->type == hol_term_type::EQUALS && right->binary.left->type == hol_term_type::UNARY_APPLICATION
									&& right->binary.left->binary.left->type == hol_term_type::CONSTANT
									&& (right->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG1
									|| right->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG2
									|| right->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG3))
							{
								dst_var = right->binary.right;
							} else if (right->type == hol_term_type::EQUALS && right->binary.left->type == hol_term_type::UNARY_APPLICATION
									&& right->binary.left->binary.left->type == hol_term_type::CONSTANT
									&& (right->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG1_OF
									|| right->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG2_OF
									|| right->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG3_OF))
							{
								dst_var = right->binary.left->binary.right;
							} else {
								free_all(new_function_heads);
								return (hol_term*) nullptr;
							}
							dst_variable = dst_var->variable;
							dst_var->reference_count++;
						} else {
							dst_variable = ++max_variable;
							dst_var = hol_term::new_variable(dst_variable);
							if (dst_var == nullptr) {
								free_all(new_function_heads);
								return (hol_term*) nullptr;
							}
						}

						hol_term* arg_term = nullptr;
						hol_term* operand = new_function_heads[0]->quantifier.operand;
						if (operand->type == hol_term_type::AND) {
							if (SubstitutionSetting == substitution_setting::ARG2)
								arg_term = operand->array.operands[0];
							else arg_term = operand->array.operands[operand->array.length - 1];
						} else if (operand->type == hol_term_type::ANY_ARRAY) {
							if (SubstitutionSetting == substitution_setting::ARG2)
								arg_term = operand->any_array.left.operands[0];
							else arg_term = operand->any_array.right.operands[operand->any_array.right.length - 1];
						}

						hol_term* new_arg_term;
						if (SubstitutionSetting == substitution_setting::ARG2) {
							new_arg_term = hol_term::new_equals(arg_term->binary.left, dst_var);
							if (new_arg_term == nullptr) {
								free_all(new_function_heads);
								free(*dst_var); if (dst_var->reference_count == 0) free(dst_var);
								return (hol_term*) nullptr;
							}
							arg_term->binary.left->reference_count++;
						} else {
							new_arg_term = hol_term::new_equals(hol_term::new_apply(arg_term->binary.left->binary.left, dst_var), arg_term->binary.right);
							if (new_arg_term == nullptr) {
								free_all(new_function_heads);
								free(*dst_var); if (dst_var->reference_count == 0) free(dst_var);
								return (hol_term*) nullptr;
							}
							arg_term->binary.left->binary.left->reference_count++;
							arg_term->binary.right->reference_count++;
						}

						if (operand->type == hol_term_type::AND) {
							if (SubstitutionSetting == substitution_setting::ARG2) {
								new_head = hol_term::new_exists(function_head_variable, hol_term::new_and(make_prepended_array_view(new_arg_term, make_array_view(operand->array.operands + 1, operand->array.length - 1))));
								if (new_head == nullptr) {
									free_all(new_function_heads);
									free(*new_arg_term); free(new_arg_term);
									return (hol_term*) nullptr;
								}
								for (unsigned int i = 1; i < operand->array.length; i++)
									operand->array.operands[i]->reference_count++;
							} else {
								new_head = hol_term::new_exists(function_head_variable, hol_term::new_and(make_appended_array_view(make_array_view(operand->array.operands, operand->array.length - 1), new_arg_term)));
								if (new_head == nullptr) {
									free_all(new_function_heads);
									free(*new_arg_term); free(new_arg_term);
									return (hol_term*) nullptr;
								}
								for (unsigned int i = 0; i < operand->array.length - 1; i++)
									operand->array.operands[i]->reference_count++;
							}
						} else if (operand->type == hol_term_type::ANY_ARRAY) {
							if (SubstitutionSetting == substitution_setting::ARG2) {
								new_head = hol_term::new_exists(function_head_variable, hol_term::new_any_array(operand->any_array.oper, operand->any_array.all,
										make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
										make_prepended_array_view(new_arg_term, make_array_view(operand->any_array.left.operands + 1, operand->any_array.left.length - 1)),
										make_appended_array_view(make_array_view(operand->any_array.right.operands, operand->any_array.right.length - 1), new_arg_term)));
								if (new_head == nullptr) {
									free_all(new_function_heads);
									free(*new_arg_term); free(new_arg_term);
									return (hol_term*) nullptr;
								}
								operand->any_array.all->reference_count++;
								for (unsigned int i = 0; i < operand->any_array.any.length; i++)
									operand->any_array.any.operands[i]->reference_count++;
								for (unsigned int i = 1; i < operand->any_array.left.length; i++)
									operand->any_array.left.operands[i]->reference_count++;
								for (unsigned int i = 0; i < operand->any_array.right.length; i++)
									operand->any_array.right.operands[i]->reference_count++;
							} else {
								new_head = hol_term::new_exists(function_head_variable, hol_term::new_any_array(operand->any_array.oper, operand->any_array.all,
										make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
										make_array_view(operand->any_array.left.operands, operand->any_array.left.length),
										make_appended_array_view(make_array_view(operand->any_array.right.operands, operand->any_array.right.length - 1), new_arg_term)));
								if (new_head == nullptr) {
									free_all(new_function_heads);
									free(*new_arg_term); free(new_arg_term);
									return (hol_term*) nullptr;
								}
								operand->any_array.all->reference_count++;
								for (unsigned int i = 0; i < operand->any_array.any.length; i++)
									operand->any_array.any.operands[i]->reference_count++;
								for (unsigned int i = 0; i < operand->any_array.left.length; i++)
									operand->any_array.left.operands[i]->reference_count++;
								for (unsigned int i = 0; i < operand->any_array.right.length - 1; i++)
									operand->any_array.right.operands[i]->reference_count++;
							}
						}

						if (SubstitutionSetting == substitution_setting::EMPTY) {
							hol_term* temp = hol_term::new_exists(dst_variable, hol_term::new_and(
										hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::EMPTY>::value, hol_term::new_variable(dst_variable)),
										new_head));
							if (temp == nullptr) {
								free_all(new_function_heads);
								free(*new_head); free(new_head);
								return (hol_term*) nullptr;
							}
							hol_term::constants<(unsigned int) built_in_predicates::EMPTY>::value.reference_count++;
							new_head = temp;
						}
					} else {
						hol_term* operand = new_function_heads[0]->quantifier.operand;
						if (operand->type == hol_term_type::AND) {
							new_head = hol_term::new_exists(function_head_variable, hol_term::new_and(make_array_view(operand->array.operands, operand->array.length - 1)));
							if (new_head == nullptr) {
								free_all(new_function_heads);
								return (hol_term*) nullptr;
							}
							for (unsigned int i = 0; i + 1 < operand->array.length; i++)
								operand->array.operands[i]->reference_count++;
						} else if (operand->type == hol_term_type::ANY_ARRAY) {
							new_head = hol_term::new_exists(function_head_variable, hol_term::new_any_array(operand->any_array.oper, operand->any_array.all,
									make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
									make_array_view(operand->any_array.left.operands, operand->any_array.left.length),
									make_array_view(operand->any_array.right.operands, operand->any_array.right.length - 1)));
							if (new_head == nullptr) {
								free_all(new_function_heads);
								return (hol_term*) nullptr;
							}
							operand->any_array.all->reference_count++;
							for (unsigned int i = 0; i < operand->any_array.any.length; i++)
								operand->any_array.any.operands[i]->reference_count++;
							for (unsigned int i = 0; i < operand->any_array.left.length; i++)
								operand->any_array.left.operands[i]->reference_count++;
							for (unsigned int i = 0; i + 1 < operand->any_array.right.length; i++)
								operand->any_array.right.operands[i]->reference_count++;
						}
					}
					free_all(new_function_heads);

					if ((old_head->type == hol_term_type::ANY || old_head->type == hol_term_type::ANY_RIGHT) && can_have_free_variables(*new_head)) {
						hol_term* temp = hol_term::new_any_right(new_head, old_head->any.excluded_trees, old_head->any.excluded_tree_count);
						if (temp == nullptr) {
							free(*new_head); free(new_head);
							return (hol_term*) nullptr;
						}
						new_head = temp;
						for (unsigned int i = 0; i < old_head->any.excluded_tree_count; i++)
							old_head->any.excluded_trees[i]->reference_count++;
					}
					return new_head;
				};

				/* find the head scope of `substituted` */
				array<hol_term*> child_siblings(8); array<unsigned int> dst_variables(8);
				bool removed_quantifier, dummy = false, remove_negations = false;
				hol_term* new_operand;
				bool result = apply_head<true>(substituted, new_operand, dst_variables, child_siblings, 0, removed_quantifier, remove_negations, dummy,
						find_head_ignore_conjunct<built_in_predicates, (SubstitutionSetting == substitution_setting::ARG2 ? 0 : -1)>, process_inner_scope, no_op());
				free(*substituted); if (substituted->reference_count == 0) free(substituted);
				free_all(intersection);
				if (!result || new_operand == nullptr)
					return (hol_term*) nullptr;
				for (hol_term* sibling : child_siblings) {
					unsigned int index = siblings.index_of(sibling);
					if (index < siblings.length) siblings.remove(index);
				}

				if ((old_head->type == hol_term_type::ANY || old_head->type == hol_term_type::ANY_RIGHT) && can_have_free_variables(*new_operand)) {
					hol_term* temp = hol_term::new_any_right(new_operand, old_head->any.excluded_trees, old_head->any.excluded_tree_count);
					if (temp == nullptr) {
						free(*new_operand); if (new_operand->reference_count == 0) free(new_operand);
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < old_head->any.excluded_tree_count; i++)
						old_head->any.excluded_trees[i]->reference_count++;
					new_operand = temp;
				}
				return new_operand;
			}, gather_scope) && dst != nullptr;
}

inline bool select_antecedent(
		hol_term* src, hol_term*& dst)
{
	hol_term* expected = hol_term::new_if_then(&HOL_ANY, &HOL_ANY);
	if (expected == nullptr)
		return false;
	HOL_ANY.reference_count += 2;

	array<hol_term*> intersection(2);
	intersect<built_in_predicates>(intersection, src, expected);
	free(*expected); if (expected->reference_count == 0) free(expected);
	if (intersection.length == 0) {
		return false;
	} else if (intersection.length != 1) {
		fprintf(stderr, "select_antecedent ERROR: Intersection is not unique.\n");
		free_all(intersection); return false;
	}

	dst = intersection[0]->binary.left;
	dst->reference_count++;
	free_all(intersection);
	return true;
}

inline bool select_consequent(
		hol_term* src, hol_term*& dst)
{
	hol_term* expected = hol_term::new_if_then(&HOL_ANY, &HOL_ANY);
	if (expected == nullptr)
		return false;
	HOL_ANY.reference_count += 2;

	array<hol_term*> intersection(2);
	intersect<built_in_predicates>(intersection, src, expected);
	free(*expected); if (expected->reference_count == 0) free(expected);
	if (intersection.length == 0) {
		return false;
	} else if (intersection.length != 1) {
		fprintf(stderr, "select_antecedent ERROR: Intersection is not unique.\n");
		free_all(intersection); return false;
	}

	dst = intersection[0]->binary.right;
	dst->reference_count++;
	free_all(intersection);
	return true;
}

template<unsigned int Predicate>
inline bool require_only_predicate_in_set(
		hol_term* src, hol_term*& dst)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	hol_term* old_src = src;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
		src = src->quantifier.operand;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	if ((src->type == hol_term_type::ANY || src->type == hol_term_type::ANY_RIGHT) && src->any.included != nullptr && src->any.included->type == hol_term_type::EXISTS)
		src = src->any.included;

	hol_term* left; hol_term* set_definition;
	unsigned int set_variable, element_variable;
	if (!get_predicative_set_variables(src, lambda_variable, left, set_definition, set_variable, element_variable, max_variable))
		return false;

	hol_term* set_var = hol_term::new_variable(set_variable);
	if (set_var == nullptr)
		return false;

	hol_term* element_var = hol_term::new_variable(element_variable);
	if (element_var == nullptr) {
		free(*set_var); free(set_var);
		return false;
	}

	dst = hol_term::new_lambda(lambda_variable, hol_term::new_exists(set_variable, hol_term::new_and(
				hol_term::new_equals(
					set_var,
					hol_term::new_lambda(element_variable,
						hol_term::new_apply(&hol_term::constants<Predicate>::value,
						element_var)
					)
				),
				hol_term::new_exists(element_variable, hol_term::new_and(
					hol_term::new_apply(set_var, element_var),
					hol_term::new_apply(hol_term::new_variable(lambda_variable), element_var)
				))
			)));
	if (dst == nullptr) {
		free(*set_var); free(set_var);
		free(*element_var); free(element_var);
		return false;
	}
	set_var->reference_count += 2 - 1;
	element_var->reference_count += 3 - 1;
	hol_term::constants<Predicate>::value.reference_count++;

	if (!is_subset<built_in_predicates>(dst, old_src)) {
		free(*dst); free(dst);
		return false;
	}
	return true;
}

template<bool AllowAmbiguous>
inline bool require_one_or_two_conjuncts(
		hol_term* src, hol_term*& dst)
{
	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	return apply_head<false>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker, find_head<built_in_predicates>,
			[](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				hol_term* old_head = head;
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
					head = head->any.included;

				unsigned int negation_count = 0;
				while (head->type == hol_term_type::NOT) {
					negation_count++;
					head = head->unary.operand;
				}

				hol_term* dst = nullptr;
				// hol_term* expected_head = hol_term::new_exists(head_variable, hol_term::new_and(make_repeated_array_view(&HOL_ANY, 2)));
				// if (expected_head == nullptr)
				// 	return (hol_term*) nullptr;
				// HOL_ANY.reference_count += 2;

				// array<hol_term*> intersection(2);
				// intersect<built_in_predicates>(intersection, head, expected_head);
				// free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
				// if (intersection.length == 0) {
				// 	return (hol_term*) nullptr;
				// } else if (intersection.length != 1) {
				// 	free_all(intersection);
				// 	fprintf(stderr, "require_one_or_two_conjuncts ERROR: Intersection is not unique.\n");
				// 	return (hol_term*) nullptr;
				// }
				// dst = intersection[0];

				if (head->type == hol_term_type::EXISTS) {
					hol_term* operand = head->quantifier.operand;
					if (operand->type == hol_term_type::AND) {
						if (operand->array.length > 2) {
							return (hol_term*) nullptr;
						} else {
							old_head->reference_count++;
							return old_head;
						}
					} else if (operand->type == hol_term_type::ANY_ARRAY) {
						if (operand->any_array.left.length > 2 || operand->any_array.any.length > 2 || operand->any_array.right.length > 2)
							return (hol_term*) nullptr;

						/* try making the array length 2 */
						hol_term* expected_head = hol_term::new_exists(head_variable, hol_term::new_and(make_repeated_array_view(&HOL_ANY, 2)));
						if (expected_head == nullptr)
							return (hol_term*) nullptr;
						HOL_ANY.reference_count += 2;

						array<hol_term*> intersection(2);
						intersect<built_in_predicates>(intersection, head, expected_head);
						free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
						if (intersection.length > 1) {
							free_all(intersection);
							if (AllowAmbiguous) {
								old_head->reference_count++;
								return old_head;
							} else {
								fprintf(stderr, "require_one_or_two_conjuncts ERROR: Intersection is not unique.\n");
								return (hol_term*) nullptr;
							}
						}
						if (intersection.length != 0)
							dst = intersection[0];

						/* try making the array length 1 */
						if (operand->any_array.left.length <= 1 && operand->any_array.any.length <= 1 && operand->any_array.right.length <= 1) {
							array<hol_term*> conjunct_intersections(2);
							conjunct_intersections[0] = &HOL_ANY;
							HOL_ANY.reference_count++;
							conjunct_intersections.length = 1;
							if (operand->any_array.left.length != 0) {
								array<hol_term*> new_intersections(2);
								for (hol_term* prev : conjunct_intersections)
									intersect<built_in_predicates>(new_intersections, prev, operand->any_array.left.operands[0]);
								free_all(conjunct_intersections);
								swap(conjunct_intersections, new_intersections);
							} if (operand->any_array.right.length != 0) {
								array<hol_term*> new_intersections(2);
								for (hol_term* prev : conjunct_intersections)
									intersect<built_in_predicates>(new_intersections, prev, operand->any_array.right.operands[0]);
								free_all(conjunct_intersections);
								swap(conjunct_intersections, new_intersections);
							} if (operand->any_array.any.length != 0) {
								array<hol_term*> new_intersections(2);
								for (hol_term* prev : conjunct_intersections)
									intersect<built_in_predicates>(new_intersections, prev, operand->any_array.any.operands[0]);
								free_all(conjunct_intersections);
								swap(conjunct_intersections, new_intersections);
							}

							if (conjunct_intersections.length > 1 || (conjunct_intersections.length == 1 && dst != nullptr)) {
								if (dst != nullptr) {
									free(*dst); if (dst->reference_count == 0) free(dst);
								}
								free_all(conjunct_intersections);
								if (AllowAmbiguous) {
									old_head->reference_count++;
									return old_head;
								} else {
									fprintf(stderr, "require_one_or_two_conjuncts ERROR: Intersection is not unique.\n");
									return (hol_term*) nullptr;
								}
							} else if (conjunct_intersections.length == 1) {
								hol_term* conjunct = conjunct_intersections[0];
								if (conjunct == &HOL_ANY) {
									conjunct = operand->any_array.all;
									conjunct->reference_count++;
									HOL_ANY.reference_count--;
								}
								dst = hol_term::new_exists(head_variable, conjunct);
								if (dst == nullptr) {
									free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
									return (hol_term*) nullptr;
								}
							}
						}

					} else if (operand->type == hol_term_type::ANY || operand->type == hol_term_type::ANY_RIGHT) {
						if (AllowAmbiguous) {
							old_head->reference_count++;
							return old_head;
						} else {
							return (hol_term*) nullptr;
						}
					} else {
						old_head->reference_count++;
						return old_head;
					}
				} else if (AllowAmbiguous && (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT)) {
					old_head->reference_count++;
					return old_head;
				} else {
					return (hol_term*) nullptr;
				}

				for (unsigned int i = 0; i < negation_count; i++) {
					hol_term* temp = hol_term::new_not(dst);
					if (temp == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					dst = temp;
				}

				if ((old_head->type == hol_term_type::ANY || old_head->type == hol_term_type::ANY_RIGHT) && can_have_free_variables(*dst)) {
					hol_term* temp = hol_term::new_any_right(dst, old_head->any.excluded_trees, old_head->any.excluded_tree_count);
					if (temp == nullptr) {
						free(*dst); if (dst->reference_count == 0) free(dst);
						return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < old_head->any.excluded_tree_count; i++)
						old_head->any.excluded_trees[i]->reference_count++;
					dst = temp;
				}
				return dst;
			}, no_op()) && dst != nullptr;
}

inline bool is_preposition(const string& str) {
	return (str == "of" || str == "in" || str == "through" || str == "with"
		 || str == "to" || str == "on" || str == "for" || str == "by"
		 || str == "over" || str == "at" || str == "from" || str == "within"
		 || str == "as" || str == "near" || str == "onto" || str == "behind");
}

inline bool is_question_word(const string& str) {
	return (str == "who" || str == "what" || str == "where" || str == "when"
		 || str == "why" || str == "which" || str == "how" || str == "that");
}

inline bool is_article(const string& str) {
	return (str == "The" || str == "the" || str == "A" || str == "a");
}

template<bool AllowAny>
inline bool require_capitalized(
		hol_term* src, hol_term*& dst)
{
	if (AllowAny && (src->type == hol_term_type::ANY || src->type == hol_term_type::ANY_RIGHT)) {
		/* TODO: this isn't really the correct function application; the
		   correct approach is to implement a richer string wildcard (set) structure */
		dst = src;
		dst->reference_count++;
		return true;
	} else if (src->type == hol_term_type::STRING) {
		if (src->str.length == 0)
			return false;

		/* first tokenize the string */
		array<string> tokens(4);
		unsigned int start = 0;
		for (unsigned int i = 0; i < src->str.length; i++) {
			/* exclude punctuation */
			if (src->str[i] == '.' || src->str[i] == ',' || src->str[i] == '!' || src->str[i] == '?' || src->str[i] == ':' || src->str[i] == '(' || src->str[i] == ')')
				return false;

			if (isspace(src->str[i])) {
				if (!tokens.ensure_capacity(tokens.length + 2))
					return false;
				tokens[tokens.length].data = src->str.data + start;
				tokens[tokens.length].length = i - start;
				if (tokens[tokens.length].length == 0)
					return false;
				tokens.length++;
				start = i + 1;
			}
		}

		tokens[tokens.length].data = src->str.data + start;
		tokens[tokens.length].length = src->str.length - start;
		if (tokens[tokens.length].length == 0)
			return false;
		tokens.length++;

		/* check that each token is capitalized */
		if (tokens.length == 0)
			return false;
		if (!isupper(tokens[0][0]) || !isupper(tokens[tokens.length - 1][0]))
			return false;
		for (unsigned int i = 1; i + 1 < tokens.length; i++) {
			if (is_preposition(tokens[i]))
				continue;
			if (!isupper(tokens[i][0]) || is_article(tokens[i]))
				return false;
		}

		if (tokens.length == 1 && (is_question_word(tokens[0]) || is_preposition(tokens[0])))
			return false;

		dst = src;
		dst->reference_count++;
		return true;
	} else {
		return false;
	}
}

template<unsigned int ArgPredicate, bool InvertArg>
inline bool do_compute_has_arg_in_scope(
		hol_term* head_scope,
		unsigned int head_variable,
		grammatical_flag_value expected_value,
		grammatical_flag_value& value)
{
	hol_term* expected_arg;
	if (InvertArg)
		expected_arg = hol_term::new_any_right(hol_term::new_equals(hol_term::new_apply(hol_term::new_constant(ArgPredicate), &HOL_ANY), hol_term::new_variable(head_variable)));
	else expected_arg = hol_term::new_any_right(hol_term::new_equals(hol_term::new_apply(hol_term::new_constant(ArgPredicate), hol_term::new_variable(head_variable)), &HOL_ANY));
	if (expected_arg == nullptr)
		return false;
	HOL_ANY.reference_count++;

	if (head_scope->type == hol_term_type::ANY_ARRAY) {
		if (is_subset<built_in_predicates>(head_scope->any_array.all, expected_arg)) {
			free(*expected_arg); free(expected_arg);
			if (expected_value == grammatical_flag_value::FALSE)
				return false;
			value = grammatical_flag_value::TRUE;
			return true;
		} for (unsigned int i = 0; i < head_scope->any_array.left.length; i++) {
			if (is_subset<built_in_predicates>(head_scope->any_array.left.operands[i], expected_arg)) {
				free(*expected_arg); free(expected_arg);
				if (expected_value == grammatical_flag_value::FALSE)
					return false;
				value = grammatical_flag_value::TRUE;
				return true;
			}
		} for (unsigned int i = 0; i < head_scope->any_array.right.length; i++) {
			if (is_subset<built_in_predicates>(head_scope->any_array.right.operands[i], expected_arg)) {
				free(*expected_arg); free(expected_arg);
				if (expected_value == grammatical_flag_value::FALSE)
					return false;
				value = grammatical_flag_value::TRUE;
				return true;
			}
		} for (unsigned int i = 0; i < head_scope->any_array.any.length; i++) {
			if (is_subset<built_in_predicates>(head_scope->any_array.any.operands[i], expected_arg)) {
				free(*expected_arg); free(expected_arg);
				if (expected_value == grammatical_flag_value::FALSE)
					return false;
				value = grammatical_flag_value::TRUE;
				return true;
			}
		}

		if (has_intersection<built_in_predicates>(head_scope->any_array.all, expected_arg)) {
			value = expected_value;
			free(*expected_arg); free(expected_arg);
			return true;
		} for (unsigned int i = 0; i < head_scope->any_array.left.length; i++) {
			if (has_intersection<built_in_predicates>(head_scope->any_array.left.operands[i], expected_arg)) {
				value = expected_value;
				free(*expected_arg); free(expected_arg);
				return true;
			}
		} for (unsigned int i = 0; i < head_scope->any_array.right.length; i++) {
			if (has_intersection<built_in_predicates>(head_scope->any_array.right.operands[i], expected_arg)) {
				value = expected_value;
				free(*expected_arg); free(expected_arg);
				return true;
			}
		} for (unsigned int i = 0; i < head_scope->any_array.any.length; i++) {
			if (has_intersection<built_in_predicates>(head_scope->any_array.any.operands[i], expected_arg)) {
				value = expected_value;
				free(*expected_arg); free(expected_arg);
				return true;
			}
		}
		free(*expected_arg); free(expected_arg);
		if (expected_value == grammatical_flag_value::TRUE)
			return false;
		value = grammatical_flag_value::FALSE;
	} else if (head_scope->type == hol_term_type::AND) {
		for (unsigned int i = 0; i < head_scope->array.length; i++) {
			if (is_subset<built_in_predicates>(head_scope->array.operands[i], expected_arg)) {
				free(*expected_arg); free(expected_arg);
				if (expected_value == grammatical_flag_value::FALSE)
					return false;
				value = grammatical_flag_value::TRUE;
				return true;
			}
		}

		for (unsigned int i = 0; i < head_scope->array.length; i++) {
			if (has_intersection<built_in_predicates>(head_scope->array.operands[i], expected_arg)) {
				value = expected_value;
				free(*expected_arg); free(expected_arg);
				return true;
			}
		}
		free(*expected_arg); free(expected_arg);
		if (expected_value == grammatical_flag_value::TRUE)
			return false;
		value = grammatical_flag_value::FALSE;
	} else {
		if (is_subset<built_in_predicates>(head_scope, expected_arg)) {
			free(*expected_arg); free(expected_arg);
			if (expected_value == grammatical_flag_value::FALSE)
				return false;
			value = grammatical_flag_value::TRUE;
			return true;
		}

		if (has_intersection<built_in_predicates>(head_scope, expected_arg)) {
			value = expected_value;
			free(*expected_arg); free(expected_arg);
			return true;
		}
		free(*expected_arg); free(expected_arg);
		if (expected_value == grammatical_flag_value::TRUE)
			return false;
		value = grammatical_flag_value::FALSE;
	}
	return true;
}

template<unsigned int ArgPredicate, bool InvertArg = false>
inline bool do_compute_has_arg(hol_term* head,
		grammatical_flag_value expected_value,
		grammatical_flag_value& value)
{
	if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
		head = head->any.included;
	while (head->type == hol_term_type::NOT)
		head = head->unary.operand;

	if (head->type == hol_term_type::EXISTS) {
		return do_compute_has_arg_in_scope<ArgPredicate, InvertArg>(head->quantifier.operand, head->quantifier.variable, expected_value, value);
	} else {
		value = grammatical_flag_value::ANY;
		return true;
	}
}

template<unsigned int ArgPredicate, bool InvertArg = false>
inline bool do_compute_has_arg_in_set(
		hol_term* head,
		grammatical_flag_value expected_value,
		grammatical_flag_value& value)
{
	if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr) {
		head = head->any.included;
		if (head->type == hol_term_type::UNARY_APPLICATION) {
			value = expected_value;
			return true;
		}
	}
	if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) {
		value = expected_value;
		return true;
	} else if (head->type == hol_term_type::EXISTS) {
		hol_term* operand = head->quantifier.operand;
		hol_term* left;
		if (operand->type == hol_term_type::AND) {
			left = operand->array.operands[0];
		} else if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
			if (operand->any_array.left.length == 0) {
				value = expected_value;
				return true;
			}
			left = operand->any_array.left.operands[0];
		} else if (operand->type == hol_term_type::ANY || operand->type == hol_term_type::ANY_RIGHT) {
			value = expected_value;
			return true;
		} else {
			return false;
		}

		hol_term* set_definition;
		if (left->type == hol_term_type::EQUALS && left->binary.right->type == hol_term_type::LAMBDA) {
			set_definition = left->binary.right;
		} else if (left->type == hol_term_type::BINARY_APPLICATION && left->ternary.third->type == hol_term_type::LAMBDA) {
			set_definition = left->ternary.third;
		} else if (left->type == hol_term_type::ANY_RIGHT && left->any.included != nullptr && left->any.included->type == hol_term_type::LAMBDA) {
			set_definition = left->any.included;
		} else if (left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT) {
			value = expected_value;
			return true;
		} else {
			return false;
		}

		return do_compute_has_arg_in_scope<ArgPredicate, InvertArg>(set_definition->quantifier.operand, set_definition->quantifier.variable, expected_value, value);
	} else if (head->type == hol_term_type::UNARY_APPLICATION) {
		if (expected_value == grammatical_flag_value::TRUE)
			return false;
		value = grammatical_flag_value::FALSE;
		return true;
	} else {
		return false;
	}
}

template<typename Formula, typename FindHeadFunction, typename ComputeHasArgFunction>
inline bool compute_has_arg(const flagged_logical_form<Formula>& src,
		grammatical_flag_value expected_value, grammatical_flag_value& value,
		FindHeadFunction find_head_function,
		ComputeHasArgFunction compute_has_arg_function)
{
	head_index predicate_index; no_op apply;
	auto head_finder = make_array_finder(find_head_function);
	hol_term* head = find_head(src.root, predicate_index, head_finder, apply);
	if (head == nullptr)
		return false;

	bool head_is_array = false;
	hol_term* parent = head;
	if (parent != nullptr && (parent->type == hol_term_type::AND || parent->type == hol_term_type::OR)) {
		hol_term* head; head_index predicate_index;
		find_head<built_in_predicates>(parent->array.operands[0], head, predicate_index);
		if (head != nullptr)
			head_is_array = true;
	} else if (parent != nullptr && parent->type == hol_term_type::ANY_ARRAY && (parent->any_array.oper == hol_term_type::ANY_ARRAY || parent->any_array.oper == hol_term_type::AND || parent->any_array.oper == hol_term_type::OR)) {
		hol_term* head; head_index predicate_index;
		find_head<built_in_predicates>(parent->any_array.all, head, predicate_index);
		if (head != nullptr)
			head_is_array = true;
	}

	grammatical_flag_value value_i;
	value = grammatical_flag_value::ANY;
	bool all_must_be_true = true;
	if (head_is_array) {
		if (parent->type == hol_term_type::AND || parent->type == hol_term_type::OR) {
			for (unsigned int i = 0; i < parent->array.length; i++) {
				if (!compute_has_arg_function(parent->array.operands[i], (expected_value == grammatical_flag_value::TRUE ? grammatical_flag_value::TRUE : grammatical_flag_value::ANY), value_i))
					return false;
				if (value_i != grammatical_flag_value::TRUE)
					all_must_be_true = false;
				if (value_i == grammatical_flag_value::FALSE) {
					value = grammatical_flag_value::FALSE;
					return true;
				}
			}
		} else {
			if (!compute_has_arg_function(parent->any_array.all, (expected_value == grammatical_flag_value::TRUE ? grammatical_flag_value::TRUE : grammatical_flag_value::ANY), value_i))
				return false;
			if (value_i != grammatical_flag_value::TRUE)
				all_must_be_true = false;
			if (value_i == grammatical_flag_value::FALSE) {
				value = grammatical_flag_value::FALSE;
				return true;
			}

			for (unsigned int i = 0; i < parent->any_array.left.length; i++) {
				if (!compute_has_arg_function(parent->any_array.left.operands[i], (expected_value == grammatical_flag_value::TRUE ? grammatical_flag_value::TRUE : grammatical_flag_value::ANY), value_i))
					return false;
				if (value_i != grammatical_flag_value::TRUE)
					all_must_be_true = false;
				if (value_i == grammatical_flag_value::FALSE) {
					value = grammatical_flag_value::FALSE;
					return true;
				}
			} for (unsigned int i = 0; i < parent->any_array.right.length; i++) {
				if (!compute_has_arg_function(parent->any_array.right.operands[i], (expected_value == grammatical_flag_value::TRUE ? grammatical_flag_value::TRUE : grammatical_flag_value::ANY), value_i))
					return false;
				if (value_i != grammatical_flag_value::TRUE)
					all_must_be_true = false;
				if (value_i == grammatical_flag_value::FALSE) {
					value = grammatical_flag_value::FALSE;
					return true;
				}
			} for (unsigned int i = 0; i < parent->any_array.any.length; i++) {
				if (!compute_has_arg_function(parent->any_array.any.operands[i], (expected_value == grammatical_flag_value::TRUE ? grammatical_flag_value::TRUE : grammatical_flag_value::ANY), value_i))
					return false;
				if (value_i != grammatical_flag_value::TRUE)
					all_must_be_true = false;
				if (value_i == grammatical_flag_value::FALSE) {
					value = grammatical_flag_value::FALSE;
					return true;
				}
			}
		}
	} else {
		return compute_has_arg_function(head, expected_value, value);
	}

	if (expected_value == grammatical_flag_value::FALSE) {
		if (all_must_be_true) return false;
		value = grammatical_flag_value::FALSE;
	} else if (all_must_be_true) {
		if (value == grammatical_flag_value::FALSE) return false;
		value = grammatical_flag_value::TRUE;
	}
	return true;
}

template<typename Formula>
inline bool add_flag(
		const flagged_logical_form<Formula>& src,
		flagged_logical_form<Formula>& dst,
		grammatical_flag flag)
{
	if (src.flags.flags[(uint_fast8_t) flag] != grammatical_flag_value::FALSE
	 && src.flags.flags[(uint_fast8_t) flag] != grammatical_flag_value::ANY)
		return false;
	dst = src;
	dst.flags.flags[(uint_fast8_t) flag] = grammatical_flag_value::TRUE;
	return true;
}

template<typename Formula>
inline bool try_add_flag(
		const flagged_logical_form<Formula>& src,
		flagged_logical_form<Formula>& dst,
		grammatical_flag flag)
{
	dst = src;
	dst.flags.flags[(uint_fast8_t) flag] = grammatical_flag_value::TRUE;
	return true;
}

template<typename Formula>
inline bool remove_flag(
		const flagged_logical_form<Formula>& src,
		flagged_logical_form<Formula>& dst,
		grammatical_flag flag)
{
	if (src.flags.flags[(uint_fast8_t) flag] != grammatical_flag_value::TRUE
	 && src.flags.flags[(uint_fast8_t) flag] != grammatical_flag_value::ANY)
		return false;
	dst = src;
	dst.flags.flags[(uint_fast8_t) flag] = grammatical_flag_value::FALSE;
	return true;
}

template<typename Formula>
inline bool try_remove_flag(
		const flagged_logical_form<Formula>& src,
		flagged_logical_form<Formula>& dst,
		grammatical_flag flag)
{
	dst = src;
	dst.flags.flags[(uint_fast8_t) flag] = grammatical_flag_value::FALSE;
	return true;
}

template<typename Formula>
inline bool require_flag(
		const flagged_logical_form<Formula>& src,
		flagged_logical_form<Formula>& dst,
		grammatical_flag flag)
{
	if (src.flags.flags[(uint_fast8_t) flag] != grammatical_flag_value::TRUE
	 && src.flags.flags[(uint_fast8_t) flag] != grammatical_flag_value::ANY)
		return false;
	dst = src;
	dst.flags.flags[(uint_fast8_t) flag] = grammatical_flag_value::TRUE;
	return true;
}

template<typename Formula>
inline bool require_no_flag(
		const flagged_logical_form<Formula>& src,
		flagged_logical_form<Formula>& dst,
		grammatical_flag flag)
{
	if (src.flags.flags[(uint_fast8_t) flag] != grammatical_flag_value::FALSE
	 && src.flags.flags[(uint_fast8_t) flag] != grammatical_flag_value::ANY)
		return false;
	dst = src;
	dst.flags.flags[(uint_fast8_t) flag] = grammatical_flag_value::FALSE;
	return true;
}

template<typename Formula>
inline bool add_conjunction(
		const flagged_logical_form<Formula>& src,
		flagged_logical_form<Formula>& dst,
		grammatical_conjunction cnj)
{
	if (src.flags.cnj != grammatical_conjunction::NONE && src.flags.cnj != grammatical_conjunction::ANY)
		return false;
	dst = src;
	dst.flags.cnj = cnj;
	return true;
}

template<typename Formula>
inline bool remove_conjunction(
		const flagged_logical_form<Formula>& src,
		flagged_logical_form<Formula>& dst,
		grammatical_conjunction cnj)
{
	if (src.flags.cnj != cnj && src.flags.cnj != grammatical_conjunction::ANY)
		return false;
	dst = src;
	dst.flags.cnj = grammatical_conjunction::NONE;
	return true;
}

template<typename Formula>
inline bool require_no_conjunction(
		const flagged_logical_form<Formula>& src,
		flagged_logical_form<Formula>& dst,
		grammatical_conjunction cnj)
{
	if (src.flags.cnj == cnj)
		return false;
	dst = src;
	dst.flags.cnj = src.flags.cnj;
	return true;
}

template<typename Formula>
inline bool add_correlator(
		const flagged_logical_form<Formula>& src,
		flagged_logical_form<Formula>& dst,
		correlator corr)
{
	if (src.flags.corr != correlator::NONE && src.flags.corr != correlator::ANY)
		return false;
	dst = src;
	dst.flags.corr = corr;
	return true;
}

template<typename Formula>
inline bool remove_correlator(
		const flagged_logical_form<Formula>& src,
		flagged_logical_form<Formula>& dst,
		correlator corr)
{
	if (src.flags.corr != corr && src.flags.corr != correlator::ANY)
		return false;
	dst = src;
	dst.flags.corr = correlator::NONE;
	return true;
}

template<typename Formula>
inline bool add_correlated_by(
		const flagged_logical_form<Formula>& src,
		flagged_logical_form<Formula>& dst,
		correlator correlated_by)
{
	if (src.flags.correlated_by != correlator::NONE && src.flags.correlated_by != correlator::ANY)
		return false;
	dst = src;
	dst.flags.correlated_by = correlated_by;
	return true;
}

template<typename Formula>
inline bool add_coordination(
		const flagged_logical_form<Formula>& src,
		flagged_logical_form<Formula>& dst,
		coordination coord)
{
	if (src.flags.coord != coordination::NONE && src.flags.coord != coordination::ANY)
		return false;
	dst = src;
	dst.flags.coord = coord;
	return true;
}

template<typename Formula>
inline bool remove_coordination(
		const flagged_logical_form<Formula>& src,
		flagged_logical_form<Formula>& dst,
		coordination coord)
{
	if (!has_intersection(src.flags.coord, coord))
		return false;
	dst = src;
	dst.flags.coord = coordination::NONE;
	return true;
}

template<typename Formula>
inline bool apply_auxiliary(
		const flagged_logical_form<Formula>& src,
		flagged_logical_form<Formula>& dst,
		const auxiliary_flag expected_aux,
		auxiliary_flag dst_aux)
{
	if (!has_intersection(src.flags.aux, expected_aux))
		return false;
	dst = src;
	dst.flags.aux = dst_aux;
	if (src.flags.aux_or_subjunctive_or_inf_or_to_inf) {
		if (dst.flags.aux == auxiliary_flag::AUX) {
			dst.flags.aux_or_subjunctive_or_inf_or_to_inf = false;
		} else if (!has_intersection(dst.flags.aux, auxiliary_flag::AUX)
				&& !has_intersection(dst.flags.mood, grammatical_mood::SUBJUNCTIVE)
				&& !has_intersection(dst.flags.mood, grammatical_mood::BARE_INFINITIVE)
				&& !has_intersection(dst.flags.mood, grammatical_mood::TO_INFINITIVE))
		{
			dst.flags.aux_or_subjunctive_or_inf_or_to_inf = false;
		}
	}
	return true;
}

template<typename Formula>
inline bool require_auxiliary(
		const flagged_logical_form<Formula>& src,
		flagged_logical_form<Formula>& dst,
		auxiliary_flag aux)
{
	auxiliary_flag dst_aux;
	if (!intersect(dst_aux, src.flags.aux, aux))
		return false;
	dst = src;
	dst.flags.aux = dst_aux;
	if (src.flags.aux_or_subjunctive_or_inf_or_to_inf) {
		if (dst.flags.aux == auxiliary_flag::AUX) {
			dst.flags.aux_or_subjunctive_or_inf_or_to_inf = false;
		} else if (!has_intersection(dst.flags.aux, auxiliary_flag::AUX)
				&& !has_intersection(dst.flags.mood, grammatical_mood::SUBJUNCTIVE)
				&& !has_intersection(dst.flags.mood, grammatical_mood::BARE_INFINITIVE)
				&& !has_intersection(dst.flags.mood, grammatical_mood::TO_INFINITIVE))
		{
			dst.flags.aux_or_subjunctive_or_inf_or_to_inf = false;
		}
	}
	return true;
}

template<typename Formula>
inline bool add_mood(
		const flagged_logical_form<Formula>& src,
		flagged_logical_form<Formula>& dst,
		grammatical_mood mood)
{
	if (!has_intersection(grammatical_mood::INDICATIVE, src.flags.mood))
		return false;
	dst = src;
	dst.flags.mood = mood;
	return true;
}

template<typename Formula>
inline bool remove_mood(
		const flagged_logical_form<Formula>& src,
		flagged_logical_form<Formula>& dst,
		grammatical_mood mood)
{
	if (!has_intersection(mood, src.flags.mood))
		return false;
	dst = src;
	dst.flags.mood = grammatical_mood::INDICATIVE;
	if (src.flags.aux_or_subjunctive_or_inf_or_to_inf) {
		if (!has_intersection(dst.flags.aux, auxiliary_flag::AUX)) {
			dst.flags.aux_or_subjunctive_or_inf_or_to_inf = false;
		}
	}
	return true;
}

template<typename Formula>
inline bool try_remove_mood(
		const flagged_logical_form<Formula>& src,
		flagged_logical_form<Formula>& dst)
{
	dst = src;
	dst.flags.mood = grammatical_mood::INDICATIVE;
	if (src.flags.aux_or_subjunctive_or_inf_or_to_inf) {
		if (!has_intersection(dst.flags.aux, auxiliary_flag::AUX)) {
			dst.flags.aux_or_subjunctive_or_inf_or_to_inf = false;
		}
	}
	return true;
}

template<typename Formula>
inline bool require_mood(
		const flagged_logical_form<Formula>& src,
		flagged_logical_form<Formula>& dst,
		grammatical_mood mood)
{
	if (!has_intersection(mood, src.flags.mood))
		return false;
	dst = src;
	dst.flags.mood = mood;
	if (src.flags.aux_or_subjunctive_or_inf_or_to_inf) {
		if (dst.flags.mood == grammatical_mood::SUBJUNCTIVE || dst.flags.mood == grammatical_mood::BARE_INFINITIVE || dst.flags.mood == grammatical_mood::TO_INFINITIVE) {
			dst.flags.aux_or_subjunctive_or_inf_or_to_inf = false;
		} else if (!has_intersection(dst.flags.aux, auxiliary_flag::AUX)
				&& !has_intersection(dst.flags.mood, grammatical_mood::SUBJUNCTIVE)
				&& !has_intersection(dst.flags.mood, grammatical_mood::BARE_INFINITIVE)
				&& !has_intersection(dst.flags.mood, grammatical_mood::TO_INFINITIVE))
		{
			dst.flags.aux_or_subjunctive_or_inf_or_to_inf = false;
		}
	}
	return true;
}

template<typename Formula>
inline bool require_no_to_infinitive(
		const flagged_logical_form<Formula>& src,
		flagged_logical_form<Formula>& dst)
{
	grammatical_mood intersection;
	if (!intersect(intersection, src.flags.mood, grammatical_mood::NOT_TO_INFINITIVE))
		return false;
	dst = src;
	dst.flags.mood = intersection;
	if (src.flags.aux_or_subjunctive_or_inf_or_to_inf) {
		if (dst.flags.mood == grammatical_mood::SUBJUNCTIVE || dst.flags.mood == grammatical_mood::BARE_INFINITIVE || dst.flags.mood == grammatical_mood::TO_INFINITIVE) {
			dst.flags.aux_or_subjunctive_or_inf_or_to_inf = false;
		} else if (!has_intersection(dst.flags.aux, auxiliary_flag::AUX)
				&& !has_intersection(dst.flags.mood, grammatical_mood::SUBJUNCTIVE)
				&& !has_intersection(dst.flags.mood, grammatical_mood::BARE_INFINITIVE))
		{
			dst.flags.aux_or_subjunctive_or_inf_or_to_inf = false;
		}
	}
	return true;
}

template<typename Formula>
inline bool require_no_subjunctive(
		const flagged_logical_form<Formula>& src,
		flagged_logical_form<Formula>& dst)
{
	grammatical_mood intersection;
	if (!intersect(intersection, src.flags.mood, grammatical_mood::NOT_SUBJUNCTIVE))
		return false;
	dst = src;
	dst.flags.mood = intersection;
	if (src.flags.aux_or_subjunctive_or_inf_or_to_inf) {
		if (dst.flags.mood == grammatical_mood::SUBJUNCTIVE || dst.flags.mood == grammatical_mood::BARE_INFINITIVE || dst.flags.mood == grammatical_mood::TO_INFINITIVE) {
			dst.flags.aux_or_subjunctive_or_inf_or_to_inf = false;
		} else if (!has_intersection(dst.flags.aux, auxiliary_flag::AUX)
				&& !has_intersection(dst.flags.mood, grammatical_mood::BARE_INFINITIVE)
				&& !has_intersection(dst.flags.mood, grammatical_mood::TO_INFINITIVE))
		{
			dst.flags.aux_or_subjunctive_or_inf_or_to_inf = false;
		}
	}
	return true;
}

template<typename Formula>
inline bool require_aux_or_subjunctive_or_infinitive_or_to_infinitive(
		const flagged_logical_form<Formula>& src,
		flagged_logical_form<Formula>& dst)
{
	if (src.flags.aux == auxiliary_flag::AUX || src.flags.mood == grammatical_mood::SUBJUNCTIVE
	 || src.flags.mood == grammatical_mood::BARE_INFINITIVE || src.flags.mood == grammatical_mood::TO_INFINITIVE)
	{
		dst = src;
		return true;
	} else if (!has_intersection(src.flags.aux, auxiliary_flag::AUX) && !has_intersection(src.flags.mood, grammatical_mood::SUBJUNCTIVE)
			&& !has_intersection(src.flags.mood, grammatical_mood::TO_INFINITIVE) && !has_intersection(src.flags.mood, grammatical_mood::BARE_INFINITIVE))
	{
		return false;
	} else {
		dst = src;
		dst.flags.aux_or_subjunctive_or_inf_or_to_inf = true;
		return true;
	}
}


/* forward declarations for semantic feature functions */

template<int_fast8_t ConjunctIndex>
bool set_arg(hol_term*, hol_term*&, unsigned int);


template<typename Formula>
bool apply(typename flagged_logical_form<Formula>::function function,
		const flagged_logical_form<Formula>& src, flagged_logical_form<Formula>& dst)
{
	typedef typename flagged_logical_form<Formula>::function_type function_type;

	uint_fast8_t i;
	switch (function.type) {
	case function_type::EMPTY:
		dst.root = Formula::new_false();
		dst.flags.index_number = grammatical_num::NONE;
		dst.flags.concord_number = grammatical_num::NONE;
		dst.flags.comp = grammatical_comparison::NONE;
		dst.flags.cnj = grammatical_conjunction::NONE;
		dst.flags.corr = correlator::NONE;
		dst.flags.correlated_by = correlator::NONE;
		dst.flags.coord = coordination::NONE;
		dst.flags.aux = auxiliary_flag::NONE;
		dst.flags.mood = grammatical_mood::INDICATIVE;
		dst.flags.aux_or_subjunctive_or_inf_or_to_inf = false;
		dst.flags.is_first_token_capital = false;
		for (i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
			dst.flags.flags[i] = grammatical_flag_value::FALSE;
		return dst.root != nullptr;
	case function_type::IDENTITY:
	case function_type::IDENTITY_PREDICATIVE:
	case function_type::IDENTITY_ROOT:
		dst = src;
		return true;
	case function_type::SELECT_RIGHT_CONJUNCT:
		dst.flags = src.flags;
		return select_conjunct<-1>(src.root, dst.root);
	case function_type::REMOVE_RIGHT_CONJUNCT:
		dst.flags = src.flags;
		return remove_conjunct<-1>(src.root, dst.root);
	case function_type::SELECT_LEFT_CONJUNCT:
		dst.flags = src.flags;
		return select_conjunct<0>(src.root, dst.root);
	case function_type::SELECT_LEFT_CONJUNCT_AND_NEGATION:
		dst.flags = src.flags;
		return select_conjunct<0, true>(src.root, dst.root);
	case function_type::REMOVE_LEFT_CONJUNCT:
		dst.flags = src.flags;
		return remove_conjunct<0>(src.root, dst.root);
	case function_type::REMOVE_LEFT_CONJUNCT_AND_NEGATION:
		dst.flags = src.flags;
		return remove_conjunct<0, true>(src.root, dst.root);
	case function_type::REMOVE_SECOND_LEFT_CONJUNCT:
		dst.flags = src.flags;
		return remove_conjunct<1>(src.root, dst.root);
	case function_type::SELECT_SECOND_LEFT_SET_CONJUNCT:
		dst.flags = src.flags;
		return select_set_conjunct<1>(src.root, dst.root);
	case function_type::SELECT_SECOND_LEFT_SET_CONJUNCT_ROOT:
		dst.flags = src.flags;
		return select_set_conjunct<1, true>(src.root, dst.root);
	case function_type::REMOVE_SECOND_LEFT_SET_CONJUNCT:
		dst.flags = src.flags;
		return remove_set_conjunct<1>(src.root, dst.root);
	case function_type::SELECT_LEFT_CONJUNCT_IN_SET:
		dst.flags = src.flags;
		return select_conjunct_in_set<0>(src.root, dst.root);
	case function_type::REMOVE_LEFT_CONJUNCT_IN_SET:
		dst.flags = src.flags;
		return remove_conjunct_in_set<0, true>(src.root, dst.root);
	case function_type::SELECT_SECOND_LEFT_CONJUNCT_IN_SET:
		dst.flags = src.flags;
		return select_conjunct_in_set<1>(src.root, dst.root);
	case function_type::SELECT_RIGHT_CONJUNCT_IN_SET:
		dst.flags = src.flags;
		return select_conjunct_in_set<-1>(src.root, dst.root);
	case function_type::REMOVE_RIGHT_CONJUNCT_IN_SET:
		dst.flags = src.flags;
		return remove_conjunct_in_set<-1, true>(src.root, dst.root);
	case function_type::REMOVE_RIGHT_CONJUNCT_IN_SET_WITHOUT_PREDICATIVE:
		dst.flags = src.flags;
		return remove_conjunct_in_set<-1, false>(src.root, dst.root);
	case function_type::SELECT_RIGHT_SUBSET_IN_SET:
		dst.flags = src.flags;
		return select_subset_in_set<-1>(src.root, dst.root);
	case function_type::SELECT_ONLY_RIGHT_CONJUNCT_IN_SET_PREDICATIVE:
		dst.flags = src.flags;
		return select_only_conjunct_in_set_predicative<-1>(src.root, dst.root);
	case function_type::REQUIRE_NO_INVERSE:
		dst.flags = src.flags;
		return require_no_inverse(src.root, dst.root);
	case function_type::REQUIRE_LEFT_PREDICATE_SAME:
		dst.flags = src.flags;
		return require_left_predicate_same(src.root, dst.root);
	case function_type::REQUIRE_NO_PREDICATE_SAME:
		dst.flags = src.flags;
		return require_no_predicate_same(src.root, dst.root);
	case function_type::REQUIRE_LEFT_PREDICATE_INVERSE:
		dst.flags = src.flags;
		return require_left_predicate_inverse(src.root, dst.root);
	case function_type::REQUIRE_LEFT_PREDICATE_INVERSE_HAS:
		dst.flags = src.flags;
		return require_left_predicate_inverse_has(src.root, dst.root);
	case function_type::REQUIRE_LEFT_PREDICATE_EXIST:
		dst.flags = src.flags;
		return require_left_predicate_exist(src.root, dst.root);
	case function_type::REQUIRE_LEFT_GREATEST:
		dst.flags = src.flags;
		return require_left_greatest(src.root, dst.root);
	case function_type::REQUIRE_NO_LEFT_PREDICATE_EXIST:
		dst.flags = src.flags;
		return require_no_left_predicate_exist(src.root, dst.root);
	case function_type::REQUIRE_RIGHT_PREDICATE_IN_SET:
		dst.flags = src.flags;
		return require_predicate_in_set<-1>(src.root, dst.root);
	case function_type::REMOVE_INVERSE:
		dst.flags = src.flags;
		return remove_inverse(src.root, dst.root);
	case function_type::REMOVE_GREATEST:
		dst.flags = src.flags;
		return remove_greatest(src.root, dst.root);
	case function_type::REMOVE_RIGHT_TRACE:
		dst.flags = src.flags;
		return remove_constant<-1>(src.root, dst.root, &hol_term::constants<(unsigned int) built_in_predicates::TRACE>::value);
	case function_type::SELECT_RIGHT_ARG1_WITHOUT_HEAD:
		dst.flags = src.flags;
		return select_arg_without_head<-1, (unsigned int) built_in_predicates::ARG1, false>(src.root, dst.root);
	case function_type::SELECT_RIGHT_ARG2_WITHOUT_HEAD:
		dst.flags = src.flags;
		return select_arg_without_head<-1, (unsigned int) built_in_predicates::ARG2, false>(src.root, dst.root);
	case function_type::SELECT_RIGHT_ARG3_WITHOUT_HEAD:
		dst.flags = src.flags;
		return select_arg_without_head<-1, (unsigned int) built_in_predicates::ARG3, false>(src.root, dst.root);
	case function_type::SELECT_RIGHT_ARG1_OF_WITHOUT_HEAD:
		dst.flags = src.flags;
		return select_arg_without_head<-1, (unsigned int) built_in_predicates::ARG1_OF, true>(src.root, dst.root);
	case function_type::SELECT_RIGHT_ARG2_OF_WITHOUT_HEAD:
		dst.flags = src.flags;
		return select_arg_without_head<-1, (unsigned int) built_in_predicates::ARG2_OF, true>(src.root, dst.root);
	case function_type::SELECT_RIGHT_ARG3_OF_WITHOUT_HEAD:
		dst.flags = src.flags;
		return select_arg_without_head<-1, (unsigned int) built_in_predicates::ARG3_OF, true>(src.root, dst.root);
	case function_type::SELECT_RIGHT_ARG1_WITHOUT_HEAD_PREDICATIVE:
		dst.flags = src.flags;
		return select_arg_without_head_predicative<-1, (unsigned int) built_in_predicates::ARG1>(src.root, dst.root);
	case function_type::SELECT_RIGHT_ARG2_WITHOUT_HEAD_PREDICATIVE:
		dst.flags = src.flags;
		return select_arg_without_head_predicative<-1, (unsigned int) built_in_predicates::ARG2>(src.root, dst.root);
	case function_type::SELECT_RIGHT_ARG3_WITHOUT_HEAD_PREDICATIVE:
		dst.flags = src.flags;
		return select_arg_without_head_predicative<-1, (unsigned int) built_in_predicates::ARG3>(src.root, dst.root);
	case function_type::SELECT_RIGHT_SET_ARG1_WITHOUT_HEAD_PREDICATIVE:
		dst.flags = src.flags;
		return select_arg_without_head_predicative<-1, (unsigned int) built_in_predicates::ARG1, true>(src.root, dst.root);
	case function_type::SELECT_RIGHT_SET_ARG2_WITHOUT_HEAD_PREDICATIVE:
		dst.flags = src.flags;
		return select_arg_without_head_predicative<-1, (unsigned int) built_in_predicates::ARG2, true>(src.root, dst.root);
	case function_type::SELECT_RIGHT_SET_ARG3_WITHOUT_HEAD_PREDICATIVE:
		dst.flags = src.flags;
		return select_arg_without_head_predicative<-1, (unsigned int) built_in_predicates::ARG3, true>(src.root, dst.root);
	case function_type::SELECT_SINGLETON_ARG1_IN_SET_WITHOUT_HEAD_PREDICATIVE:
		dst.flags = src.flags;
		return select_singleton_arg_in_set_without_head_predicative<(unsigned int) built_in_predicates::ARG1, false, true>(src.root, dst.root);
	case function_type::SELECT_SINGLETON_ARG2_IN_SET_WITHOUT_HEAD_PREDICATIVE:
		dst.flags = src.flags;
		return select_singleton_arg_in_set_without_head_predicative<(unsigned int) built_in_predicates::ARG2, false, true>(src.root, dst.root);
	case function_type::SELECT_SINGLETON_ARG3_IN_SET_WITHOUT_HEAD_PREDICATIVE:
		dst.flags = src.flags;
		return select_singleton_arg_in_set_without_head_predicative<(unsigned int) built_in_predicates::ARG3, false, true>(src.root, dst.root);
	case function_type::SELECT_SINGLETON_ARG1_OF_IN_SET_WITHOUT_HEAD_PREDICATIVE:
		dst.flags = src.flags;
		return select_singleton_arg_in_set_without_head_predicative<(unsigned int) built_in_predicates::ARG1_OF, true, true>(src.root, dst.root);
	case function_type::SELECT_SINGLETON_ARG2_OF_IN_SET_WITHOUT_HEAD_PREDICATIVE:
		dst.flags = src.flags;
		return select_singleton_arg_in_set_without_head_predicative<(unsigned int) built_in_predicates::ARG2_OF, true, true>(src.root, dst.root);
	case function_type::SELECT_SINGLETON_ARG3_OF_IN_SET_WITHOUT_HEAD_PREDICATIVE:
		dst.flags = src.flags;
		return select_singleton_arg_in_set_without_head_predicative<(unsigned int) built_in_predicates::ARG3_OF, true, true>(src.root, dst.root);
	case function_type::SELECT_SINGLETON_ARG1_IN_SET_WITHOUT_HEAD_OUTER_SCOPE_PREDICATIVE:
		dst.flags = src.flags;
		return select_singleton_arg_in_set_without_head_predicative<(unsigned int) built_in_predicates::ARG1, false, false>(src.root, dst.root);
	case function_type::SELECT_SINGLETON_ARG2_IN_SET_WITHOUT_HEAD_OUTER_SCOPE_PREDICATIVE:
		dst.flags = src.flags;
		return select_singleton_arg_in_set_without_head_predicative<(unsigned int) built_in_predicates::ARG2, false, false>(src.root, dst.root);
	case function_type::SELECT_SINGLETON_ARG3_IN_SET_WITHOUT_HEAD_OUTER_SCOPE_PREDICATIVE:
		dst.flags = src.flags;
		return select_singleton_arg_in_set_without_head_predicative<(unsigned int) built_in_predicates::ARG3, false, false>(src.root, dst.root);
	case function_type::SELECT_SINGLETON_ARG1_OF_IN_SET_WITHOUT_HEAD_OUTER_SCOPE_PREDICATIVE:
		dst.flags = src.flags;
		return select_singleton_arg_in_set_without_head_predicative<(unsigned int) built_in_predicates::ARG1_OF, true, false>(src.root, dst.root);
	case function_type::SELECT_SINGLETON_ARG2_OF_IN_SET_WITHOUT_HEAD_OUTER_SCOPE_PREDICATIVE:
		dst.flags = src.flags;
		return select_singleton_arg_in_set_without_head_predicative<(unsigned int) built_in_predicates::ARG2_OF, true, false>(src.root, dst.root);
	case function_type::SELECT_SINGLETON_ARG3_OF_IN_SET_WITHOUT_HEAD_OUTER_SCOPE_PREDICATIVE:
		dst.flags = src.flags;
		return select_singleton_arg_in_set_without_head_predicative<(unsigned int) built_in_predicates::ARG3_OF, true, false>(src.root, dst.root);
	case function_type::REQUIRE_PAST:
		dst.flags = src.flags;
		return set_tense(src.root, dst.root, (unsigned int) built_in_predicates::PAST);
	case function_type::REMOVE_FUTURE:
		dst.flags = src.flags;
		return apply_tense_predicate(src.root, dst.root, FUTURE_PREDICATES, PRESENT_PREDICATES);
	case function_type::REQUIRE_NO_FUTURE:
		dst.flags = src.flags;
		return require_no_tense_predicates(src.root, dst.root, FUTURE_PREDICATES);
	case function_type::REMOVE_PERFECT:
		dst.flags = src.flags;
		return apply_tense_predicate(src.root, dst.root, PERFECT_PREDICATES, NON_PERFECT_PREDICATES);
	case function_type::REQUIRE_NO_PERFECT:
		dst.flags = src.flags;
		return require_no_tense_predicates(src.root, dst.root, PERFECT_PREDICATES);
	case function_type::REMOVE_PROGRESSIVE:
		dst.flags = src.flags;
		return apply_tense_predicate(src.root, dst.root, PROGRESSIVE_PREDICATES, NON_PROGRESSIVE_PREDICATES);
	case function_type::REMOVE_PRESENT_PROGRESSIVE:
		dst.flags = src.flags;
		return apply_tense_predicate(src.root, dst.root, PRESENT_PROGRESSIVE_PREDICATE, PRESENT_PREDICATE);
	case function_type::REMOVE_PAST_PROGRESSIVE:
		dst.flags = src.flags;
		return apply_tense_predicate(src.root, dst.root, PAST_PROGRESSIVE_PREDICATE, PAST_PREDICATE);
	case function_type::REQUIRE_NO_PROGRESSIVE:
		dst.flags = src.flags;
		return require_no_tense_predicates(src.root, dst.root, PROGRESSIVE_PREDICATES);
	case function_type::REMOVE_ASPECT:
		dst.flags = src.flags;
		return apply_tense_predicate(src.root, dst.root, ONLY_ASPECT_PREDICATES, PAST_OR_PRESENT);
	case function_type::TRY_REMOVE_ASPECT:
		dst.flags = src.flags;
		return apply_tense_predicate(src.root, dst.root, ASPECT_PREDICATES, PAST_OR_PRESENT);
	case function_type::REMOVE_NOT:
		dst.flags = src.flags;
		return remove_not(src.root, dst.root);
	case function_type::REQUIRE_NO_EMPTY_REF:
		dst.flags = src.flags;
		return require_no_empty_ref(src.root, dst.root);
	case function_type::REQUIRE_PREDICATIVE_UNIVERSAL:
		dst.flags = src.flags;
		return require_predicative_quantifier<hol_term_type::FOR_ALL>(src.root, dst.root);
	case function_type::REQUIRE_PREDICATIVE_EXISTENTIAL:
		dst.flags = src.flags;
		return require_predicative_quantifier<hol_term_type::EXISTS>(src.root, dst.root);
	case function_type::REPLACE_PREDICATIVE_LAMBDA_WITH_EXISTENTIAL:
		dst.flags = src.flags;
		return replace_predicative_lambda_with_existential(src.root, dst.root);
	case function_type::REPLACE_PREDICATIVE_UNIVERSAL_WITH_EXISTENTIAL:
		dst.flags = src.flags;
		return replace_predicative_quantifier<hol_term_type::FOR_ALL, hol_term_type::EXISTS>(src.root, dst.root);
	case function_type::REMOVE_PREDICATIVE_NOT:
		dst.flags = src.flags;
		return remove_predicative_not(src.root, dst.root);
	case function_type::PREDICATE_ONLY:
		dst.flags = src.flags;
		return predicate_only(src.root, dst.root);
	case function_type::PREDICATE:
		dst.flags = src.flags;
		return predicate(src.root, dst.root);
	case function_type::PREDICATE_AND_TENSE:
		dst.flags = src.flags;
		return predicate_and_tense(src.root, dst.root);
	case function_type::EMPTY_AND_TENSE:
		dst.flags = src.flags;
		return empty_and_tense(src.root, dst.root);
	case function_type::SELECT_PREDICATE_IN_SET:
		dst.flags = src.flags;
		return select_predicate_in_set(src.root, dst.root);
	case function_type::SELECT_CONSTANT_IN_SET:
		dst.flags = src.flags;
		return select_constant_in_set(src.root, dst.root);
	case function_type::SELECT_STRING_IN_SET:
		dst.flags = src.flags;
		return select_string_in_set(src.root, dst.root);
	case function_type::SELECT_NAME_IN_SET:
		dst.flags = src.flags;
		return select_name_in_set(src.root, dst.root);
	case function_type::SELECT_NUMBER_IN_SET:
		dst.flags = src.flags;
		return select_number_in_set(src.root, dst.root);
	case function_type::MARK_WIDE_SCOPE:
		dst.flags = src.flags;
		return mark_wide_scope(src.root, dst.root);
	case function_type::REQUIRE_WIDE_SCOPE:
		dst.flags = src.flags;
		return require_narrow_or_wide_scope<true>(src.root, dst.root);
	case function_type::REQUIRE_NARROW_SCOPE:
		dst.flags = src.flags;
		return require_narrow_or_wide_scope<false>(src.root, dst.root);
	case function_type::REMOVE_WIDE_SCOPE:
		dst.flags = src.flags;
		return remove_wide_scope(src.root, dst.root);
	case function_type::REQUIRE_CONSTANT_IN_SET:
		dst.flags = src.flags;
		return require_constant_in_set(src.root, dst.root);
	case function_type::REQUIRE_NO_CONSTANT_IN_SET:
		dst.flags = src.flags;
		return require_no_constant_in_set(src.root, dst.root);
	case function_type::REQUIRE_STRING_OR_NUMBER_IN_SET:
		dst.flags = src.flags;
		return require_string_or_number_in_set(src.root, dst.root);
	case function_type::REQUIRE_NAME_IN_SET:
		dst.flags = src.flags;
		return require_name_in_set(src.root, dst.root);
	case function_type::REQUIRE_MEASURE_IN_SET:
		dst.flags = src.flags;
		return require_measure_in_set(src.root, dst.root);
	case function_type::REQUIRE_SINGLETON:
		dst.flags = src.flags;
		return require_singleton(src.root, dst.root);
	case function_type::REQUIRE_NO_STRING_OR_NUMBER_OR_NAME_IN_SET:
		dst.flags = src.flags;
		return require_no_string_or_number_or_name_in_set(src.root, dst.root);
	case function_type::SIZE:
		dst.flags = src.flags;
		return size(src.root, dst.root, dst.flags);
	case function_type::RIGHT_ARG1:
		dst.flags = src.flags;
		return arg_function<(unsigned int) built_in_predicates::ARG1, -1>(src.root, dst.root, dst.flags);
	case function_type::SET_SIZE:
		dst.flags = src.flags;
		return set_size(src.root, dst.root);
	case function_type::REQUIRE_LEFT_ARG1:
		dst.flags = src.flags;
		return set_arg<0>(src.root, dst.root, (unsigned int) built_in_predicates::ARG1);
	case function_type::REQUIRE_LAMBDA:
		dst.flags = src.flags;
		return require_lambda(src.root, dst.root);
	case function_type::REQUIRE_NO_LAMBDA:
		dst.flags = src.flags;
		return require_no_lambda(src.root, dst.root);
	case function_type::REMOVE_LEFT_PREDICATE:
		dst.flags = src.flags;
		return remove_predicate<0>(src.root, dst.root);
	case function_type::FACTOR:
		dst.flags = src.flags;
		return factor(src.root, dst.root);
	case function_type::FACTOR_PREDICATIVE:
		dst.flags = src.flags;
		return factor_predicative(src.root, dst.root);
	case function_type::SELECT_LEFT_PREDICATE_AND_TENSE:
		dst.flags = src.flags;
		return select_predicate_and_tense<0>(src.root, dst.root);
	case function_type::SET_PREDICATE_EMPTY:
		dst.flags = src.flags;
		return set_predicate_empty<INT_FAST8_MAX>(src.root, dst.root);
	case function_type::SET_LEFT_PREDICATE_EMPTY:
		dst.flags = src.flags;
		return set_predicate_empty<0>(src.root, dst.root);
	case function_type::REQUIRE_NO_PREDICATE_EMPTY:
		dst.flags = src.flags;
		return require_no_predicate_empty(src.root, dst.root);
	case function_type::REQUIRE_CONJUNCTION:
		dst.flags = src.flags;
		return require_array<hol_term_type::AND, false>(src.root, dst.root, find_root);
	case function_type::REQUIRE_BINARY_CONJUNCTION:
		dst.flags = src.flags;
		return require_array<hol_term_type::AND, false, 2>(src.root, dst.root, find_root);
	case function_type::REQUIRE_DISJUNCTION:
		dst.flags = src.flags;
		return require_array<hol_term_type::OR, false>(src.root, dst.root, find_root);
	case function_type::REQUIRE_NEGATIVE_CONJUNCTION:
		dst.flags = src.flags;
		return require_array<hol_term_type::AND, true>(src.root, dst.root, find_root);
	case function_type::REQUIRE_HEAD_CONJUNCTION:
		dst.flags = src.flags;
		return require_array<hol_term_type::AND, false>(src.root, dst.root, find_head<built_in_predicates>);
	case function_type::REQUIRE_HEAD_BINARY_CONJUNCTION:
		dst.flags = src.flags;
		return require_array<hol_term_type::AND, false, 2>(src.root, dst.root, find_head<built_in_predicates>);
	case function_type::REQUIRE_HEAD_DISJUNCTION:
		dst.flags = src.flags;
		return require_array<hol_term_type::OR, false>(src.root, dst.root, find_head<built_in_predicates>);
	case function_type::REQUIRE_HEAD_NEGATIVE_CONJUNCTION:
		dst.flags = src.flags;
		return require_array<hol_term_type::AND, true>(src.root, dst.root, find_head<built_in_predicates>);
	case function_type::REQUIRE_NO_HEAD_ARRAY:
		dst.flags = src.flags;
		return require_no_array<hol_term_type::ANY_ARRAY, false>(src.root, dst.root, find_head<built_in_predicates>);
	case function_type::SELECT_LEFT_OPERAND:
		dst.flags = src.flags;
		return select_operand<0>(src.root, dst.root, find_root);
	case function_type::REMOVE_LEFT_OPERAND:
		dst.flags = src.flags;
		return remove_operand<0>(src.root, dst.root, find_root);
	case function_type::SELECT_LEFT_HEAD_OPERAND:
		dst.flags = src.flags;
		return select_operand<0>(src.root, dst.root, find_head<built_in_predicates>);
	case function_type::REMOVE_LEFT_HEAD_OPERAND:
		dst.flags = src.flags;
		return remove_operand<0>(src.root, dst.root, find_head<built_in_predicates>);
	case function_type::REPLACE_PREDICATIVE_SUBSET_WITH_EQUALITY:
		dst.flags = src.flags;
		return apply_to_predicative_set_function(src.root, dst.root, (unsigned int) built_in_predicates::SUBSET, (unsigned int) built_in_predicates::EQUALS);
	case function_type::REQUIRE_PREDICATE_OF_LAMBDA:
		dst.flags = src.flags;
		return require_predicate_of_lambda(src.root, dst.root);
	case function_type::SELECT_LAMBDA:
		dst.flags = src.flags;
		return select_lambda(src.root, dst.root);
	case function_type::REMOVE_LAMBDA:
		dst.flags = src.flags;
		return remove_lambda(src.root, dst.root);
	case function_type::SELECT_FUNCTION_WITH_SUBSTITUTION:
		dst.flags = src.flags;
		return select_function<substitution_setting::ARG2>(src.root, dst.root);
	case function_type::SELECT_FUNCTION_WITH_EMPTY_SUBSTITUTION:
		dst.flags = src.flags;
		return select_function<substitution_setting::EMPTY>(src.root, dst.root);
	case function_type::SELECT_FUNCTION_WITHOUT_SUBSTITUTION:
		dst.flags = src.flags;
		return select_function<substitution_setting::NONE>(src.root, dst.root);
	case function_type::SELECT_ANTECEDENT:
		dst.flags = src.flags;
		return select_antecedent(src.root, dst.root);
	case function_type::SELECT_CONSEQUENT:
		dst.flags = src.flags;
		return select_consequent(src.root, dst.root);
	case function_type::REQUIRE_REF_IN_SET:
		dst.flags = src.flags;
		return require_only_predicate_in_set<(unsigned int) built_in_predicates::REF>(src.root, dst.root);
	case function_type::REQUIRE_PLURAL_REF_IN_SET:
		dst.flags = src.flags;
		return require_only_predicate_in_set<(unsigned int) built_in_predicates::PLURAL_REF>(src.root, dst.root);
	case function_type::REQUIRE_ANIMATE_IN_SET:
		dst.flags = src.flags;
		return require_only_predicate_in_set<(unsigned int) built_in_predicates::ANIMATE>(src.root, dst.root);
	case function_type::REQUIRE_ONE_OR_TWO_CONJUNCTS:
		dst.flags = src.flags;
		return require_one_or_two_conjuncts<true>(src.root, dst.root);
	case function_type::REQUIRE_CAPITALIZED:
		dst.flags = src.flags;
		return require_capitalized<true>(src.root, dst.root);
	case function_type::ADD_SINGULAR:
		if (!has_intersection(src.flags.index_number, grammatical_num::NONE))
			return false;
		dst = src;
		dst.flags.index_number = grammatical_num::SINGULAR;
		return true;
	case function_type::ADD_PLURAL:
		if (!has_intersection(src.flags.index_number, grammatical_num::NONE))
			return false;
		dst = src;
		dst.flags.index_number = grammatical_num::PLURAL;
		return true;
	case function_type::TRY_ADD_SINGULAR:
		if (!has_intersection(src.flags.index_number, grammatical_num::SINGULAR_OR_NONE))
			return false;
		dst = src;
		dst.flags.index_number = grammatical_num::SINGULAR;
		return true;
	case function_type::TRY_ADD_PLURAL:
		if (!has_intersection(src.flags.index_number, grammatical_num::PLURAL_OR_NONE))
			return false;
		dst = src;
		dst.flags.index_number = grammatical_num::PLURAL;
		return true;
	case function_type::REQUIRE_SINGULAR:
		if (!has_intersection(src.flags.index_number, grammatical_num::SINGULAR))
			return false;
		dst = src;
		dst.flags.index_number = grammatical_num::SINGULAR;
		return true;
	case function_type::REQUIRE_PLURAL:
		if (!has_intersection(src.flags.index_number, grammatical_num::PLURAL))
			return false;
		dst = src;
		dst.flags.index_number = grammatical_num::PLURAL;
		return true;
	case function_type::TRY_REMOVE_NUMBER:
		dst = src;
		dst.flags.index_number = grammatical_num::NONE;
		return true;
	case function_type::ADD_CONCORD_SINGULAR:
		if (!has_intersection(src.flags.concord_number, grammatical_num::NONE))
			return false;
		dst = src;
		dst.flags.concord_number = grammatical_num::SINGULAR;
		return true;
	case function_type::ADD_CONCORD_PLURAL:
		if (!has_intersection(src.flags.concord_number, grammatical_num::NONE))
			return false;
		dst = src;
		dst.flags.concord_number = grammatical_num::PLURAL;
		return true;
	case function_type::ADD_THAT:
		return add_conjunction(src, dst, grammatical_conjunction::THAT);
	case function_type::REMOVE_THAT:
		return remove_conjunction(src, dst, grammatical_conjunction::THAT);
	case function_type::REQUIRE_NO_THAT:
		return require_no_conjunction(src, dst, grammatical_conjunction::THAT);
	case function_type::ADD_WHETHER:
		return add_conjunction(src, dst, grammatical_conjunction::WHETHER);
	case function_type::REMOVE_WHETHER:
		return remove_conjunction(src, dst, grammatical_conjunction::WHETHER);
	case function_type::ADD_IF:
		return add_conjunction(src, dst, grammatical_conjunction::IF);
	case function_type::REMOVE_IF:
		return remove_conjunction(src, dst, grammatical_conjunction::IF);
	case function_type::ADD_BECAUSE:
		return add_conjunction(src, dst, grammatical_conjunction::BECAUSE);
	case function_type::REMOVE_BECAUSE:
		return remove_conjunction(src, dst, grammatical_conjunction::BECAUSE);
	case function_type::ADD_FOR:
		return add_conjunction(src, dst, grammatical_conjunction::FOR);
	case function_type::REMOVE_FOR:
		return remove_conjunction(src, dst, grammatical_conjunction::FOR);
	case function_type::REQUIRE_NO_CONJUNCTION:
		if (src.flags.cnj != grammatical_conjunction::NONE && src.flags.cnj != grammatical_conjunction::ANY)
			return false;
		dst = src;
		dst.flags.cnj = grammatical_conjunction::NONE;
		return true;
	case function_type::ADD_IS_ADJUNCT:
		return add_flag(src, dst, grammatical_flag::IS_ADJUNCT);
	case function_type::TRY_REMOVE_IS_ADJUNCT:
		return try_remove_flag(src, dst, grammatical_flag::IS_ADJUNCT);
	case function_type::REQUIRE_NOT_ADJUNCT:
		return require_no_flag(src, dst, grammatical_flag::IS_ADJUNCT);
	case function_type::ADD_NULLABLE_SUBJECT:
		return add_flag(src, dst, grammatical_flag::NULLABLE_SUBJECT);
	case function_type::REMOVE_NULLABLE_SUBJECT:
		return remove_flag(src, dst, grammatical_flag::NULLABLE_SUBJECT);
	case function_type::TRY_REMOVE_NULLABLE_SUBJECT:
		return try_remove_flag(src, dst, grammatical_flag::NULLABLE_SUBJECT);
	case function_type::ADD_SUBORDINATE:
		return add_flag(src, dst, grammatical_flag::SUBORDINATE);
	case function_type::REMOVE_SUBORDINATE:
		return remove_flag(src, dst, grammatical_flag::SUBORDINATE);
	case function_type::TRY_REMOVE_SUBORDINATE:
		return try_remove_flag(src, dst, grammatical_flag::SUBORDINATE);
	case function_type::REQUIRE_NO_SUBORDINATE:
		return require_no_flag(src, dst, grammatical_flag::SUBORDINATE);
	case function_type::ADD_PREPOSITION:
		return add_flag(src, dst, grammatical_flag::PREPOSITION);
	case function_type::REQUIRE_PREPOSITION:
		return require_flag(src, dst, grammatical_flag::PREPOSITION);
	case function_type::REQUIRE_NO_PREPOSITION:
		return require_no_flag(src, dst, grammatical_flag::PREPOSITION);
	case function_type::ADD_PARTICLE:
		return add_flag(src, dst, grammatical_flag::PARTICLE);
	case function_type::ADD_AUX:
	{
		auxiliary_flag intersection;
		if (!intersect(intersection, src.flags.aux, auxiliary_flag::NONE | auxiliary_flag::REQ_AUX))
			return false;
		dst = src;
		if (intersection == auxiliary_flag::NONE) {
			dst.flags.aux = auxiliary_flag::AUX;
		} else if (intersection == auxiliary_flag::REQ_AUX) {
			dst.flags.aux = auxiliary_flag::REQ_SUBJECT;
		} else {
			dst.flags.aux = auxiliary_flag::AUX | auxiliary_flag::REQ_SUBJECT;
		}
		return true;
	}
	case function_type::TRY_REMOVE_AUX:
		return apply_auxiliary(src, dst, ~auxiliary_flag::REQ_AUX, auxiliary_flag::NONE);
	case function_type::ADD_REQ_AUX:
		return apply_auxiliary(src, dst, auxiliary_flag::NONE, auxiliary_flag::REQ_AUX);
	case function_type::TRY_ADD_REQ_AUX:
		return apply_auxiliary(src, dst, ~auxiliary_flag::REQ_NO_AUX, auxiliary_flag::REQ_AUX);
	case function_type::REQUIRE_NO_REQ_AUX:
		return require_auxiliary(src, dst, ~auxiliary_flag::REQ_AUX);
	case function_type::REMOVE_REQ_AUX:
		return apply_auxiliary(src, dst, auxiliary_flag::REQ_AUX, auxiliary_flag::NONE);
	case function_type::TRY_REMOVE_REQ_AUX:
		return apply_auxiliary(src, dst, ~auxiliary_flag::REQ_NO_AUX, auxiliary_flag::NONE);
	case function_type::ADD_REQ_NO_AUX:
		return apply_auxiliary(src, dst, auxiliary_flag::NONE, auxiliary_flag::REQ_NO_AUX);
	case function_type::REQUIRE_NO_REQ_NO_AUX:
		return require_auxiliary(src, dst, ~auxiliary_flag::REQ_NO_AUX);
	case function_type::REQUIRE_NO_REQ_SUBJECT:
		return require_auxiliary(src, dst, ~auxiliary_flag::REQ_SUBJECT);
	case function_type::REMOVE_REQ_SUBJECT:
		return apply_auxiliary(src, dst, auxiliary_flag::REQ_SUBJECT, auxiliary_flag::NONE);
	case function_type::TRY_REMOVE_REQ_SUBJECT:
		return apply_auxiliary(src, dst, auxiliary_flag::ANY, auxiliary_flag::NONE);
	case function_type::ADD_INFINITIVE:
		return add_mood(src, dst, grammatical_mood::BARE_INFINITIVE);
	case function_type::ADD_TO_INFINITIVE:
		return add_mood(src, dst, grammatical_mood::TO_INFINITIVE);
	case function_type::REMOVE_TO_INFINITIVE:
		return remove_mood(src, dst, grammatical_mood::TO_INFINITIVE);
	case function_type::REQUIRE_TO_INFINITIVE:
		return require_mood(src, dst, grammatical_mood::TO_INFINITIVE);
	case function_type::REQUIRE_NO_TO_INFINITIVE:
		return require_no_to_infinitive(src, dst);
	case function_type::ADD_SUBJUNCTIVE:
		return add_mood(src, dst, grammatical_mood::SUBJUNCTIVE);
	case function_type::REQUIRE_NO_SUBJUNCTIVE:
		return require_no_subjunctive(src, dst);
	case function_type::REQUIRE_AUX_OR_SUBJUNCTIVE_OR_INFINITIVE_OR_TO_INFINITIVE:
		return require_aux_or_subjunctive_or_infinitive_or_to_infinitive(src, dst);
	case function_type::ADD_BOTH:
		return add_correlator(src, dst, correlator::BOTH);
	case function_type::ADD_EITHER:
		return add_correlator(src, dst, correlator::EITHER);
	case function_type::ADD_NEITHER:
		return add_correlator(src, dst, correlator::NEITHER);
	case function_type::REMOVE_BOTH:
		return remove_correlator(src, dst, correlator::BOTH);
	case function_type::REMOVE_EITHER:
		return remove_correlator(src, dst, correlator::EITHER);
	case function_type::REMOVE_NEITHER:
		return remove_correlator(src, dst, correlator::NEITHER);
	case function_type::TRY_REMOVE_CORRELATOR:
		dst = src;
		dst.flags.corr = correlator::NONE;
		return true;
	case function_type::REQUIRE_NO_CORRELATOR:
	case function_type::REQUIRE_NO_CORRELATOR_PREDICATIVE:
		if (src.flags.corr != correlator::NONE && src.flags.corr != correlator::ANY)
			return false;
		dst = src;
		dst.flags.corr = correlator::NONE;
		return true;
	case function_type::ADD_CORRELATED_BY_BOTH:
		return add_correlated_by(src, dst, correlator::BOTH);
	case function_type::ADD_CORRELATED_BY_EITHER:
		return add_correlated_by(src, dst, correlator::EITHER);
	case function_type::ADD_CORRELATED_BY_NEITHER:
		return add_correlated_by(src, dst, correlator::NEITHER);
	case function_type::TRY_REMOVE_CORRELATED:
		dst = src;
		dst.flags.correlated_by = correlator::NONE;
		return true;
	case function_type::REQUIRE_NOT_CORRELATED:
		if (src.flags.correlated_by != correlator::NONE && src.flags.correlated_by != correlator::ANY)
			return false;
		dst = src;
		dst.flags.correlated_by = correlator::NONE;
		return true;
	case function_type::ADD_PAST_PARTICIPLE:
		return add_mood(src, dst, grammatical_mood::PAST_PARTICIPLE);
	case function_type::ADD_PRESENT_PARTICIPLE:
		return add_mood(src, dst, grammatical_mood::PRESENT_PARTICIPLE);
	case function_type::TRY_REMOVE_PARTICIPLE:
		return try_remove_mood(src, dst);
	case function_type::REQUIRE_PAST_PARTICIPLE:
		return require_mood(src, dst, grammatical_mood::PAST_PARTICIPLE);
	case function_type::REQUIRE_PRESENT_PARTICIPLE:
		return require_mood(src, dst, grammatical_mood::PRESENT_PARTICIPLE);
	case function_type::ADD_NEGATIVE:
	case function_type::ADD_NEGATIVE_PREDICATIVE:
		return add_flag(src, dst, grammatical_flag::NEGATIVE);
	case function_type::REQUIRE_NEGATIVE:
		return require_flag(src, dst, grammatical_flag::NEGATIVE);
	case function_type::ADD_ADV:
		return add_flag(src, dst, grammatical_flag::ADV);
	case function_type::REMOVE_ADV:
		return remove_flag(src, dst, grammatical_flag::ADV);
	case function_type::TRY_REMOVE_ADV:
		return try_remove_flag(src, dst, grammatical_flag::ADV);
	case function_type::REQUIRE_NO_ADV:
		return require_no_flag(src, dst, grammatical_flag::ADV);
	case function_type::ADD_TION:
		return add_flag(src, dst, grammatical_flag::TION);
	case function_type::ADD_LY:
		return add_flag(src, dst, grammatical_flag::LY);
	case function_type::ADD_GENITIVE:
		return add_flag(src, dst, grammatical_flag::GENITIVE);
	case function_type::TRY_REMOVE_GENITIVE:
		return try_remove_flag(src, dst, grammatical_flag::GENITIVE);
	case function_type::REQUIRE_NO_GENITIVE:
		return require_no_flag(src, dst, grammatical_flag::GENITIVE);
	case function_type::ADD_COMMA:
		return add_flag(src, dst, grammatical_flag::COMMA);
	case function_type::REMOVE_COMMA:
		return remove_flag(src, dst, grammatical_flag::COMMA);
	case function_type::REQUIRE_NO_COMMA:
		return require_no_flag(src, dst, grammatical_flag::COMMA);
	case function_type::ADD_WH_MINUS:
		return add_flag(src, dst, grammatical_flag::WH_MINUS);
	case function_type::REMOVE_WH_MINUS:
		return remove_flag(src, dst, grammatical_flag::WH_MINUS);
	case function_type::TRY_REMOVE_WH_MINUS:
		return try_remove_flag(src, dst, grammatical_flag::WH_MINUS);
	case function_type::REQUIRE_NO_WH_MINUS:
		return require_no_flag(src, dst, grammatical_flag::WH_MINUS);
	case function_type::HAS_ARG2:
		{
			grammatical_flag_value has_arg;
			if (!compute_has_arg(src, grammatical_flag_value::ANY, has_arg, find_head<built_in_predicates>, do_compute_has_arg<(unsigned int) built_in_predicates::ARG2>))
				return false;
			dst = src;
			dst.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2] = has_arg;
			return true;
		}
	case function_type::TRY_HAS_ARG2:
		{
			if (src.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2] == grammatical_flag_value::TRUE) {
				dst = src;
				return true;
			}
			grammatical_flag_value has_arg;
			if (!compute_has_arg(src, grammatical_flag_value::ANY, has_arg, find_head<built_in_predicates>, do_compute_has_arg<(unsigned int) built_in_predicates::ARG2>))
				return false;
			if (src.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2] == grammatical_flag_value::ANY && has_arg == grammatical_flag_value::FALSE)
				has_arg = grammatical_flag_value::ANY;
			dst = src;
			dst.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2] = has_arg;
			return true;
		}
	case function_type::HAS_ARG2_IN_SET:
		{
			unsigned int lambda_variable;
			if (src.root->type == hol_term_type::LAMBDA) {
				lambda_variable = src.root->quantifier.variable;
			} else if (src.root->type == hol_term_type::ANY || src.root->type == hol_term_type::ANY_RIGHT) {
				dst = src;
				dst.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2] = grammatical_flag_value::ANY;
				return true;
			} else {
				return false;
			}
			auto head_finder = predicative_head_finder<built_in_predicates>(lambda_variable);
			grammatical_flag_value has_arg;
			if (!compute_has_arg(src, grammatical_flag_value::ANY, has_arg, head_finder, do_compute_has_arg_in_set<(unsigned int) built_in_predicates::ARG2_OF, true>))
				return false;
			dst = src;
			dst.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2] = has_arg;
			return true;
		}
	case function_type::TRY_HAS_ARG2_IN_SET:
		{
			unsigned int lambda_variable;
			if (src.root->type == hol_term_type::LAMBDA) {
				lambda_variable = src.root->quantifier.variable;
			} else if (src.root->type == hol_term_type::ANY || src.root->type == hol_term_type::ANY_RIGHT) {
				dst = src;
				dst.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2] = grammatical_flag_value::ANY;
				return true;
			} else {
				return false;
			}
			auto head_finder = predicative_head_finder<built_in_predicates>(lambda_variable);
			if (src.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2] == grammatical_flag_value::TRUE) {
				dst = src;
				return true;
			}
			grammatical_flag_value has_arg;
			if (!compute_has_arg(src, grammatical_flag_value::ANY, has_arg, head_finder, do_compute_has_arg_in_set<(unsigned int) built_in_predicates::ARG2_OF, true>))
				return false;
			if (src.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2] == grammatical_flag_value::ANY && has_arg == grammatical_flag_value::FALSE)
				has_arg = grammatical_flag_value::ANY;
			dst = src;
			dst.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2] = has_arg;
			return true;
		}
	case function_type::TRY_ADD_HAS_ARG2:
		return try_add_flag(src, dst, grammatical_flag::HAS_ARG2);
	case function_type::ADD_MODIFIES_EVENT:
		return add_flag(src, dst, grammatical_flag::MODIFIES_EVENT);
	case function_type::TRY_REMOVE_MODIFIES_EVENT:
		return try_remove_flag(src, dst, grammatical_flag::MODIFIES_EVENT);
	case function_type::ADD_MEASURE:
		return add_flag(src, dst, grammatical_flag::MEASURE);
	case function_type::TRY_REMOVE_MEASURE:
		return try_remove_flag(src, dst, grammatical_flag::MEASURE);
	case function_type::REQUIRE_NO_MEASURE:
		return require_no_flag(src, dst, grammatical_flag::MEASURE);
	case function_type::ADD_EMPTY_VERB:
		return add_flag(src, dst, grammatical_flag::EMPTY_VERB);
	case function_type::TRY_REMOVE_EMPTY_VERB:
		return try_remove_flag(src, dst, grammatical_flag::EMPTY_VERB);
	case function_type::REMOVE_EMPTY_VERB:
		return remove_flag(src, dst, grammatical_flag::EMPTY_VERB);
	case function_type::REQUIRE_NO_EMPTY_VERB:
		return require_no_flag(src, dst, grammatical_flag::EMPTY_VERB);
	case function_type::ADD_PASSIVE:
		return add_flag(src, dst, grammatical_flag::PASSIVE);
	case function_type::REMOVE_PASSIVE:
		return remove_flag(src, dst, grammatical_flag::PASSIVE);
	case function_type::REQUIRE_NO_PASSIVE:
		return require_no_flag(src, dst, grammatical_flag::PASSIVE);
	case function_type::ADD_BE:
		return add_flag(src, dst, grammatical_flag::BE);
	case function_type::REMOVE_BE:
		return remove_flag(src, dst, grammatical_flag::BE);
	case function_type::TRY_REMOVE_BE:
		return try_remove_flag(src, dst, grammatical_flag::BE);
	case function_type::REQUIRE_NO_BE:
		return require_no_flag(src, dst, grammatical_flag::BE);
	case function_type::ADD_AND:
		return add_coordination(src, dst, coordination::AND);
	case function_type::ADD_OR:
		return add_coordination(src, dst, coordination::OR);
	case function_type::ADD_NOR:
		return add_coordination(src, dst, coordination::NOR);
	case function_type::REMOVE_AND:
		return remove_coordination(src, dst, coordination::AND);
	case function_type::REMOVE_OR:
		return remove_coordination(src, dst, coordination::OR);
	case function_type::REMOVE_NOR:
		return remove_coordination(src, dst, coordination::NOR);
	case function_type::REMOVE_COORD:
		return remove_coordination(src, dst, coordination::NOT_NONE);
	case function_type::ADD_COMPARATIVE:
		if (!has_intersection(src.flags.comp, grammatical_comparison::NONE))
			return false;
		dst = src;
		dst.flags.comp = grammatical_comparison::COMPARATIVE;
		return true;
	case function_type::ADD_SUPERLATIVE:
		if (!has_intersection(src.flags.comp, grammatical_comparison::NONE))
			return false;
		dst = src;
		dst.flags.comp = grammatical_comparison::SUPERLATIVE;
		return true;
	case function_type::REQUIRE_SUPERLATIVE:
		if (!has_intersection(src.flags.comp, grammatical_comparison::SUPERLATIVE))
			return false;
		dst = src;
		return true;
	case function_type::REQUIRE_NO_SUPERLATIVE:
		if (!has_intersection(src.flags.comp, grammatical_comparison::NONE))
			return false;
		dst = src;
		return true;
	}
	fprintf(stderr, "apply ERROR: Unrecognized transformation function.\n");
	return false;
}

template<
	typename FindFirstHeadFunction,
	typename FindSecondHeadFunction,
	typename OnRemapFunction>
inline hol_term* remap_to_invert_apply_head(
		hol_term* first, hol_term* second,
		FindFirstHeadFunction find_first_head,
		FindSecondHeadFunction find_second_head,
		OnRemapFunction on_remap_variables,
		unsigned int& max_variable,
		bool& first_head_is_array,
		bool& second_head_is_array)
{
	apply_head_inverter first_inverter; head_index first_predicate_index;
	apply_head_inverter second_inverter; head_index second_predicate_index;
/* TODO: for debugging; remove this */
#if defined(DEBUG_PARSER)
print("first:  ", stderr); print(*first, stderr, *debug_terminal_printer); print('\n', stderr);
print("second: ", stderr); print(*second, stderr, *debug_terminal_printer); print('\n', stderr);
#endif
	hol_term* first_head = find_head(first, first_predicate_index, find_first_head, first_inverter);
	hol_term* second_head = find_head(second, second_predicate_index, find_second_head, second_inverter);
	if (first_head == nullptr || second_head == nullptr)
		return nullptr;

/* TODO: for debugging; remove this */
#if defined(DEBUG_PARSER)
print("first_head:  ", stderr); print(*first_head, stderr, *debug_terminal_printer); print('\n', stderr);
print("second_head: ", stderr); print(*second_head, stderr, *debug_terminal_printer); print('\n', stderr);
#endif
	max_variable = max(first_inverter.max_variable, second_inverter.max_variable);
	max_bound_variable(*first_head, max_variable);
	max_bound_variable(*second_head, max_variable);

	array<hol_term*> second_scopes(8);
	if (!get_scopes(*second_head, second_scopes))
		return nullptr;

	array_map<const hol_term*, unsigned int> second_variable_map(8);
	for (unsigned int i = first_inverter.outer.length - 1; i > 0; i--) {
		const hol_term* node = first_inverter.outer[i - 1];
		if (node->type != hol_term_type::FOR_ALL && node->type != hol_term_type::EXISTS && node->type != hol_term_type::LAMBDA)
			continue;

		bool has_variable = false;
		for (const hol_term* scope : second_scopes) {
			if (scope->type != hol_term_type::FOR_ALL && scope->type != hol_term_type::EXISTS && scope->type != hol_term_type::LAMBDA)
				continue;
			if (scope->quantifier.variable != node->quantifier.variable)
				continue;

			if (!has_variable) {
				++max_variable;
				has_variable = true;
			}
			if (!second_variable_map.put(scope, max_variable))
				return nullptr;
		}
	}

	for (unsigned int i = second_inverter.outer.length - 1; i > 0; i--) {
		const hol_term* node = second_inverter.outer[i - 1];
		if (node->type != hol_term_type::FOR_ALL && node->type != hol_term_type::EXISTS && node->type != hol_term_type::LAMBDA)
			continue;
		if (node->quantifier.variable > max_variable)
			continue;

		if (!second_variable_map.put(node, ++max_variable))
			return nullptr;
	}

	hol_term* first_parent; hol_term* second_parent;
	unsigned int first_head_length = 0, second_head_length = 0, first_head_min_length = 0, second_head_min_length = 0;
	if (first_inverter.outer.length > 1) {
		first_parent = first_inverter.outer[first_inverter.outer.length - 2];
		if (first_parent->type == hol_term_type::AND || first_parent->type == hol_term_type::OR) {
			hol_term* head; head_index predicate_index;
			find_first_head(first_parent->array.operands[0], head, predicate_index);
			if (head != nullptr) {
				first_head_is_array = true;
				first_head_length = first_parent->array.length;
			}
		} else if (first_parent->type == hol_term_type::ANY_ARRAY && (first_parent->any_array.oper == hol_term_type::ANY_ARRAY || first_parent->any_array.oper == hol_term_type::AND || first_parent->any_array.oper == hol_term_type::OR)) {
			if (first_head == first_parent->any_array.all) {
				first_head_is_array = true;
				first_head_min_length = max(first_parent->any_array.any.length, max(first_parent->any_array.left.length, first_parent->any_array.right.length));
			} else {
				hol_term* head; head_index predicate_index;
				find_first_head(first_parent->any_array.all, head, predicate_index);
				if (head != nullptr) {
					first_head_is_array = true;
					first_head_min_length = max(first_parent->any_array.any.length, max(first_parent->any_array.left.length, first_parent->any_array.right.length));
				}
			}
		}
	} if (second_inverter.outer.length > 1) {
		second_parent = second_inverter.outer[second_inverter.outer.length - 2];
		if (second_parent->type == hol_term_type::AND || second_parent->type == hol_term_type::OR) {
			hol_term* head; head_index predicate_index;
			find_second_head(second_parent->array.operands[0], head, predicate_index);
			if (head != nullptr) {
				second_head_is_array = true;
				second_head_length = second_parent->array.length;
			}
		} else if (second_parent->type == hol_term_type::ANY_ARRAY && (second_parent->any_array.oper == hol_term_type::ANY_ARRAY || second_parent->any_array.oper == hol_term_type::AND || second_parent->any_array.oper == hol_term_type::OR)) {
			if (second_head == second_parent->any_array.all) {
				second_head_is_array = true;
				second_head_min_length = max(second_parent->any_array.any.length, max(second_parent->any_array.left.length, second_parent->any_array.right.length));
			} else {
				hol_term* head; head_index predicate_index;
				find_second_head(second_parent->any_array.all, head, predicate_index);
				if (head != nullptr) {
					second_head_is_array = true;
					second_head_min_length = max(second_parent->any_array.any.length, max(second_parent->any_array.left.length, second_parent->any_array.right.length));
				}
			}
		}
	}
	if ((first_head_length != 0 && second_head_length != 0 && first_head_length != second_head_length)
	 || (first_head_length != 0 && first_head_length < second_head_min_length)
	 || (second_head_length != 0 && second_head_length < first_head_min_length))
		return nullptr;

	if (first_head_is_array && second_head_is_array
	 && (first_parent->type == hol_term_type::AND || first_parent->type == hol_term_type::OR)
	 && (second_parent->type == hol_term_type::AND || first_parent->type == hol_term_type::OR))
	{
		first_inverter.outer.length--;
		second_inverter.outer.length--;
		for (unsigned int i = 0; i < first_parent->array.length; i++) {
			if (!on_remap_variables(first_parent->array.operands[i], second_parent->array.operands[i], first_inverter, second_inverter, second_variable_map, max_variable, first_head_is_array, second_head_is_array))
				return nullptr;
		}
	} else {
		if (!on_remap_variables(first_head, second_head, first_inverter, second_inverter, second_variable_map, max_variable, first_head_is_array, second_head_is_array))
			return nullptr;
	}

	return map_variables(second, second_variable_map);
}

template<typename InvertSecondFunction,
	typename FindFirstHeadFunction,
	typename FindSecondHeadFunction,
	typename OnRemapFunction>
inline bool invert_apply_head(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second,
		FindFirstHeadFunction find_first_head,
		FindSecondHeadFunction find_second_head,
		OnRemapFunction on_remap_variables,
		InvertSecondFunction invert_second_head)
{
	unsigned int max_variable;
	bool first_head_is_array = false, second_head_is_array = false;
	hol_term* remapped_second = remap_to_invert_apply_head(first, second, find_first_head, find_second_head, on_remap_variables, max_variable, first_head_is_array, second_head_is_array);
	if (remapped_second == nullptr)
		return false;

	apply_head_inverter first_inverter; head_index first_predicate_index;
	apply_head_inverter second_inverter; head_index second_predicate_index;
	hol_term* first_head = find_head(first, first_predicate_index, find_first_head, first_inverter);
	hol_term* second_head = find_head(remapped_second, second_predicate_index, find_second_head, second_inverter);
	if (first_head == nullptr || second_head == nullptr) {
		free(*remapped_second); if (remapped_second->reference_count == 0) free(remapped_second);
		return false;
	}

	hol_term* conjunct = nullptr;
	array<hol_term*> second_heads(8);
	array<array<hol_term*>> second_outer(8);
	bool any_right_only = true;
	bool could_have_wide_scope = false;
	if (second_inverter.outer.length > 1) {
		hol_term* parent = second_inverter.outer[second_inverter.outer.length - 2];
		second_inverter.outer.length--;
		/* check if the conjunction/disjunction is part of the head */
		if (parent->type == hol_term_type::AND || parent->type == hol_term_type::OR) {
			array<hol_term*>* new_heads = (array<hol_term*>*) malloc(sizeof(array<hol_term*>) * parent->array.length);
			array<hol_term*>* new_outer = (array<hol_term*>*) malloc(sizeof(array<hol_term*>) * parent->array.length);
			if (new_heads == nullptr || new_outer == nullptr) {
				fprintf(stderr, "invert_apply_head ERROR: Out of memory.\n");
				if (new_heads != nullptr) free(new_heads);
				free(*remapped_second); if (remapped_second->reference_count == 0) free(remapped_second);
				if (conjunct != nullptr) { free(*conjunct); if (conjunct->reference_count == 0) free(conjunct); }
				return false;
			}
			for (unsigned int i = 0; i < parent->array.length; i++) {
				if (!array_init(new_heads[i], 8)) {
					free(*remapped_second); if (remapped_second->reference_count == 0) free(remapped_second);
					if (conjunct != nullptr) { free(*conjunct); if (conjunct->reference_count == 0) free(conjunct); }
					for (unsigned int j = 0; j < i; j++) free(new_heads[j]);
					free(new_heads); free(new_outer);
					return false;
				}
			} for (unsigned int i = 0; i < parent->array.length; i++) {
				if (!array_init(new_outer[i], 8)) {
					free(*remapped_second); if (remapped_second->reference_count == 0) free(remapped_second);
					if (conjunct != nullptr) { free(*conjunct); if (conjunct->reference_count == 0) free(conjunct); }
					for (unsigned int j = 0; j < parent->array.length; j++) free(new_heads[j]);
					for (unsigned int j = 0; j < i; j++) free(new_outer[j]);
					free(new_heads); free(new_outer);
					return false;
				}
			}
			/* make sure this is an array of heads, rather than just an array */
			hol_term* temp_second_head; head_index temp_predicate_index;
			find_second_head(parent->array.operands[0], temp_second_head, temp_predicate_index);
			if (temp_second_head == nullptr) {
				for (unsigned int j = 0; j < parent->array.length; j++) { free(new_heads[j]); free(new_outer[j]); }
				free(new_heads); free(new_outer); new_heads = nullptr;
			}
			for (unsigned int i = 0; temp_second_head != nullptr && i < parent->array.length; i++) {
				hol_term* current_first_head = first_head;
				head_index current_first_predicate_index = first_predicate_index;
				if (first_head_is_array) {
					hol_term* first_parent = first_inverter.outer[first_inverter.outer.length - 2];
					if (first_parent->type == hol_term_type::AND || first_parent->type == hol_term_type::OR) {
						current_first_head = first_parent->array.operands[i];
					} else if (first_parent->type == hol_term_type::ANY_ARRAY && (first_parent->any_array.oper == hol_term_type::ANY_ARRAY || first_parent->any_array.oper == hol_term_type::AND || first_parent->any_array.oper == hol_term_type::OR)) {
						if (i < first_parent->any_array.left.length) {
							current_first_head = first_parent->any_array.left.operands[i];
						} else if (parent->array.length - i - 1 < first_parent->any_array.right.length) {
							current_first_head = first_parent->any_array.right.operands[first_parent->any_array.right.length - parent->array.length + i];
						} else {
							current_first_head = first_parent->any_array.all;
						}
					}
					find_first_head(current_first_head, current_first_head, current_first_predicate_index);
				}
				if (current_first_head == nullptr || !invert_second_head(new_heads[i], new_outer[i], current_first_head, parent->array.operands[i], first_inverter, second_inverter, current_first_predicate_index, second_predicate_index, conjunct, max_variable, any_right_only, could_have_wide_scope, true)) {
					for (unsigned int j = 0; j < i; j++) { free_all(new_heads[j]); free_all(new_outer[j]); }
					for (unsigned int j = 0; j < parent->array.length; j++) { free(new_heads[j]); free(new_outer[j]); }
					free(new_heads); free(new_outer);
					new_heads = nullptr; break;
				}
			}

			if (new_heads != nullptr) {
				bool success = apply_to_cartesian_product(new_heads, parent->array.length, [parent,new_heads,new_outer,&second_heads,&second_outer](const unsigned int* index_array) {
					if (!second_heads.ensure_capacity(second_heads.length + 1)
					 || !second_outer.ensure_capacity(second_outer.length + 1)
					 || !array_init(second_outer[second_outer.length], 4))
						return false;
					second_outer.length++;

					array<hol_term*>& outer_intersections = second_outer.last();
					outer_intersections[0] = &HOL_ANY;
					outer_intersections.length = 1;
					HOL_ANY.reference_count++;
					for (unsigned int i = 0; i < parent->array.length; i++) {
						array<hol_term*> new_outer_terms(4);
						for (hol_term* outer : outer_intersections)
							intersect<built_in_predicates>(new_outer_terms, outer, new_outer[i][index_array[i]]);
						free_all(outer_intersections);
						swap(new_outer_terms, outer_intersections);
					}

					hol_term* new_head;
					if (parent->type == hol_term_type::AND)
						new_head = hol_term::new_and(lookup_table_array_view<array<hol_term*>, hol_term*>(new_heads, index_array, parent->array.length));
					else new_head = hol_term::new_or(lookup_table_array_view<array<hol_term*>, hol_term*>(new_heads, index_array, parent->array.length));
					if (new_head == nullptr)
						return false;
					for (unsigned int i = 0; i < parent->array.length; i++)
						new_head->array.operands[i]->reference_count++;
					second_heads[second_heads.length++] = new_head;
					return true;
				});
				for (unsigned int j = 0; j < parent->array.length; j++) { free_all(new_heads[j]); free(new_heads[j]); free_all(new_outer[j]); free(new_outer[j]); }
				free(new_heads); free(new_outer);
				if (!success) {
					free(*remapped_second); if (remapped_second->reference_count == 0) free(remapped_second);
					if (conjunct != nullptr) { free(*conjunct); if (conjunct->reference_count == 0) free(conjunct); }
					for (array<hol_term*>& outer : second_outer) { free_all(outer); free(outer); }
					free_all(second_heads); return false;
				}
				second_head = parent;
			}
		} else if (parent->type == hol_term_type::ANY_ARRAY && (parent->any_array.oper == hol_term_type::ANY_ARRAY || parent->any_array.oper == hol_term_type::AND || parent->any_array.oper == hol_term_type::OR)) {
			array<hol_term*> new_all(8); array<hol_term*> new_all_outer(8);
			array<hol_term*>* new_left_array = (array<hol_term*>*) malloc(sizeof(array<hol_term*>) * parent->any_array.left.length);
			array<hol_term*>* new_left_outer = (array<hol_term*>*) malloc(sizeof(array<hol_term*>) * parent->any_array.left.length);
			array<hol_term*>* new_right_array = (array<hol_term*>*) malloc(sizeof(array<hol_term*>) * parent->any_array.right.length);
			array<hol_term*>* new_right_outer = (array<hol_term*>*) malloc(sizeof(array<hol_term*>) * parent->any_array.right.length);
			array<hol_term*>* new_any_array = (array<hol_term*>*) malloc(sizeof(array<hol_term*>) * parent->any_array.any.length);
			array<hol_term*>* new_any_outer = (array<hol_term*>*) malloc(sizeof(array<hol_term*>) * parent->any_array.any.length);
			if (new_left_array == nullptr || new_left_outer == nullptr || new_right_array == nullptr || new_right_outer == nullptr || new_any_array == nullptr || new_any_outer == nullptr) {
				fprintf(stderr, "invert_apply_head ERROR: Out of memory.\n");
				if (new_left_array != nullptr) free(new_left_array);
				if (new_left_outer != nullptr) free(new_left_outer);
				if (new_right_array != nullptr) free(new_right_array);
				if (new_right_outer != nullptr) free(new_right_outer);
				if (new_any_array != nullptr) free(new_any_array);
				free(*remapped_second); if (remapped_second->reference_count == 0) free(remapped_second);
				if (conjunct != nullptr) { free(*conjunct); if (conjunct->reference_count == 0) free(conjunct); }
				return false;
			}
			for (unsigned int i = 0; i < parent->any_array.left.length; i++) {
				if (!array_init(new_left_array[i], 8)) {
					free(*remapped_second); if (remapped_second->reference_count == 0) free(remapped_second);
					if (conjunct != nullptr) { free(*conjunct); if (conjunct->reference_count == 0) free(conjunct); }
					for (unsigned int j = 0; j < i; j++) free(new_left_array[j]);
					free(new_left_array); free(new_right_array); free(new_any_array);
					free(new_left_outer); free(new_right_outer); free(new_any_outer);
					return false;
				}
			} for (unsigned int i = 0; i < parent->any_array.left.length; i++) {
				if (!array_init(new_left_outer[i], 8)) {
					free(*remapped_second); if (remapped_second->reference_count == 0) free(remapped_second);
					if (conjunct != nullptr) { free(*conjunct); if (conjunct->reference_count == 0) free(conjunct); }
					for (unsigned int j = 0; j < parent->any_array.left.length; j++) free(new_left_array[j]);
					for (unsigned int j = 0; j < i; j++) free(new_left_outer[j]);
					free(new_left_array); free(new_right_array); free(new_any_array);
					free(new_left_outer); free(new_right_outer); free(new_any_outer);
					return false;
				}
			} for (unsigned int i = 0; i < parent->any_array.right.length; i++) {
				if (!array_init(new_right_array[i], 8)) {
					free(*remapped_second); if (remapped_second->reference_count == 0) free(remapped_second);
					if (conjunct != nullptr) { free(*conjunct); if (conjunct->reference_count == 0) free(conjunct); }
					for (unsigned int j = 0; j < parent->any_array.left.length; j++) { free(new_left_array[j]); free(new_left_outer[j]); }
					for (unsigned int j = 0; j < i; j++) free(new_right_array[j]);
					free(new_left_array); free(new_right_array); free(new_any_array);
					free(new_left_outer); free(new_right_outer); free(new_any_outer);
					return false;
				}
			} for (unsigned int i = 0; i < parent->any_array.right.length; i++) {
				if (!array_init(new_right_outer[i], 8)) {
					free(*remapped_second); if (remapped_second->reference_count == 0) free(remapped_second);
					if (conjunct != nullptr) { free(*conjunct); if (conjunct->reference_count == 0) free(conjunct); }
					for (unsigned int j = 0; j < parent->any_array.left.length; j++) { free(new_left_array[j]); free(new_left_outer[j]); }
					for (unsigned int j = 0; j < parent->any_array.right.length; j++) free(new_right_array[j]);
					for (unsigned int j = 0; j < i; j++) free(new_right_outer[j]);
					free(new_left_array); free(new_right_array); free(new_any_array);
					free(new_left_outer); free(new_right_outer); free(new_any_outer);
					return false;
				}
			} for (unsigned int i = 0; i < parent->any_array.any.length; i++) {
				if (!array_init(new_any_array[i], 8)) {
					free(*remapped_second); if (remapped_second->reference_count == 0) free(remapped_second);
					if (conjunct != nullptr) { free(*conjunct); if (conjunct->reference_count == 0) free(conjunct); }
					for (unsigned int j = 0; j < parent->any_array.left.length; j++) { free(new_left_array[j]); free(new_left_outer[j]); }
					for (unsigned int j = 0; j < parent->any_array.right.length; j++) { free(new_right_array[j]); free(new_right_outer[j]); }
					for (unsigned int j = 0; j < i; j++) free(new_any_array[j]);
					free(new_left_array); free(new_right_array); free(new_any_array);
					free(new_left_outer); free(new_right_outer); free(new_any_outer);
					return false;
				}
			} for (unsigned int i = 0; i < parent->any_array.any.length; i++) {
				if (!array_init(new_any_outer[i], 8)) {
					free(*remapped_second); if (remapped_second->reference_count == 0) free(remapped_second);
					if (conjunct != nullptr) { free(*conjunct); if (conjunct->reference_count == 0) free(conjunct); }
					for (unsigned int j = 0; j < parent->any_array.left.length; j++) { free(new_left_array[j]); free(new_left_outer[j]); }
					for (unsigned int j = 0; j < parent->any_array.right.length; j++) { free(new_right_array[j]); free(new_right_outer[j]); }
					for (unsigned int j = 0; j < parent->any_array.any.length; j++) free(new_any_array[j]);
					for (unsigned int j = 0; j < i; j++) free(new_any_outer[j]);
					free(new_left_array); free(new_right_array); free(new_any_array);
					free(new_left_outer); free(new_right_outer); free(new_any_outer);
					return false;
				}
			}

			if (!invert_second_head(new_all, new_all_outer, first_head, parent->any_array.all, first_inverter, second_inverter, first_predicate_index, second_predicate_index, conjunct, max_variable, any_right_only, could_have_wide_scope, true)) {
				for (unsigned int j = 0; j < parent->any_array.left.length; j++) { free_all(new_left_array[j]); free(new_left_array[j]); free_all(new_left_outer[j]); free(new_left_outer[j]); }
				for (unsigned int j = 0; j < parent->any_array.right.length; j++) { free_all(new_right_array[j]); free(new_right_array[j]); free_all(new_right_outer[j]); free(new_right_outer[j]); }
				for (unsigned int j = 0; j < parent->any_array.any.length; j++) { free_all(new_any_array[j]); free(new_any_array[j]); free_all(new_any_outer[j]); free(new_any_outer[j]); }
				free(new_left_array); free(new_right_array); free(new_any_array); free(new_left_outer); free(new_right_outer); free(new_any_outer);
				new_left_array = nullptr;
			}
			for (unsigned int i = 0; new_left_array != nullptr && i < parent->any_array.left.length; i++) {
				hol_term* current_first_head = first_head;
				head_index current_first_predicate_index = first_predicate_index;
				if (first_head_is_array) {
					hol_term* first_parent = first_inverter.outer[first_inverter.outer.length - 2];
					if (first_parent->type == hol_term_type::AND || first_parent->type == hol_term_type::OR) {
						current_first_head = first_parent->array.operands[i];
					} else if (first_parent->type == hol_term_type::ANY_ARRAY && (first_parent->any_array.oper == hol_term_type::ANY_ARRAY || first_parent->any_array.oper == hol_term_type::AND || first_parent->any_array.oper == hol_term_type::OR)) {
						if (i < first_parent->any_array.left.length) {
							current_first_head = first_parent->any_array.left.operands[i];
						} else {
							current_first_head = first_parent->any_array.all;
						}
					}
					find_first_head(current_first_head, current_first_head, current_first_predicate_index);
				}
				if (current_first_head == nullptr || !invert_second_head(new_left_array[i], new_left_outer[i], current_first_head, parent->any_array.left.operands[i], first_inverter, second_inverter, current_first_predicate_index, second_predicate_index, conjunct, max_variable, any_right_only, could_have_wide_scope, true)) {
					for (unsigned int j = 0; j < parent->any_array.left.length; j++) { free_all(new_left_array[j]); free(new_left_array[j]); free_all(new_left_outer[j]); free(new_left_outer[j]); }
					for (unsigned int j = 0; j < parent->any_array.right.length; j++) { free_all(new_right_array[j]); free(new_right_array[j]); free_all(new_right_outer[j]); free(new_right_outer[j]); }
					for (unsigned int j = 0; j < parent->any_array.any.length; j++) { free_all(new_any_array[j]); free(new_any_array[j]); free_all(new_any_outer[j]); free(new_any_outer[j]); }
					free(new_left_array); free(new_right_array); free(new_any_array); free(new_left_outer); free(new_right_outer); free(new_any_outer);
					free_all(new_all); free_all(new_all_outer); new_left_array = nullptr;
					break;
				}
			} for (unsigned int i = 0; new_left_array != nullptr && i < parent->any_array.right.length; i++) {
				hol_term* current_first_head = first_head;
				head_index current_first_predicate_index = first_predicate_index;
				if (first_head_is_array) {
					hol_term* first_parent = first_inverter.outer[first_inverter.outer.length - 2];
					if (first_parent->type == hol_term_type::AND || first_parent->type == hol_term_type::OR) {
						current_first_head = first_parent->array.operands[first_parent->array.length - parent->any_array.right.length + i];
					} else if (first_parent->type == hol_term_type::ANY_ARRAY && (first_parent->any_array.oper == hol_term_type::ANY_ARRAY || first_parent->any_array.oper == hol_term_type::AND || first_parent->any_array.oper == hol_term_type::OR)) {
						if (first_parent->any_array.right.length - i - 1 < parent->any_array.right.length) {
							current_first_head = first_parent->any_array.right.operands[parent->any_array.right.length - first_parent->any_array.right.length + i];
						} else {
							current_first_head = first_parent->any_array.all;
						}
					}
					find_first_head(current_first_head, current_first_head, current_first_predicate_index);
				}
				if (current_first_head == nullptr || !invert_second_head(new_right_array[i], new_right_outer[i], current_first_head, parent->any_array.right.operands[i], first_inverter, second_inverter, current_first_predicate_index, second_predicate_index, conjunct, max_variable, any_right_only, could_have_wide_scope, true)) {
					for (unsigned int j = 0; j < parent->any_array.left.length; j++) { free_all(new_left_array[j]); free(new_left_array[j]); free_all(new_left_outer[j]); free(new_left_outer[j]); }
					for (unsigned int j = 0; j < parent->any_array.right.length; j++) { free_all(new_right_array[j]); free(new_right_array[j]); free_all(new_right_outer[j]); free(new_right_outer[j]); }
					for (unsigned int j = 0; j < parent->any_array.any.length; j++) { free_all(new_any_array[j]); free(new_any_array[j]); free_all(new_any_outer[j]); free(new_any_outer[j]); }
					free(new_left_array); free(new_right_array); free(new_any_array); free(new_left_outer); free(new_right_outer); free(new_any_outer);
					free_all(new_all); free_all(new_all_outer); new_left_array = nullptr;
					break;
				}
			} for (unsigned int i = 0; new_left_array != nullptr && i < parent->any_array.any.length; i++) {
				hol_term* current_first_head = first_head;
				head_index current_first_predicate_index = first_predicate_index;
				if (first_head_is_array) {
					hol_term* first_parent = first_inverter.outer[first_inverter.outer.length - 2];
					if (first_parent->type == hol_term_type::ANY_ARRAY && (first_parent->any_array.oper == hol_term_type::ANY_ARRAY || first_parent->any_array.oper == hol_term_type::AND || first_parent->any_array.oper == hol_term_type::OR)) {
						current_first_head = first_parent->any_array.all;
					}
					find_first_head(current_first_head, current_first_head, current_first_predicate_index);
				}
				if (current_first_head == nullptr || !invert_second_head(new_any_array[i], new_any_outer[i], current_first_head, parent->any_array.any.operands[i], first_inverter, second_inverter, current_first_predicate_index, second_predicate_index, conjunct, max_variable, any_right_only, could_have_wide_scope, true)) {
					for (unsigned int j = 0; j < parent->any_array.left.length; j++) { free_all(new_left_array[j]); free(new_left_array[j]); free_all(new_left_outer[j]); free(new_left_outer[j]); }
					for (unsigned int j = 0; j < parent->any_array.right.length; j++) { free_all(new_right_array[j]); free(new_right_array[j]); free_all(new_right_outer[j]); free(new_right_outer[j]); }
					for (unsigned int j = 0; j < parent->any_array.any.length; j++) { free_all(new_any_array[j]); free(new_any_array[j]); free_all(new_any_outer[j]); free(new_any_outer[j]); }
					free(new_left_array); free(new_right_array); free(new_any_array); free(new_left_outer); free(new_right_outer); free(new_any_outer);
					free_all(new_all); free_all(new_all_outer); new_left_array = nullptr;
					break;
				}
			}
			if (new_left_array != nullptr) {
				bool success = true;
				for (unsigned int i = 0; i < new_all.length; i++) {
					hol_term* all = new_all[i];
					hol_term* all_outer = new_all_outer[i];
					success = apply_to_cartesian_product(new_left_array, parent->any_array.left.length, [all,all_outer,new_left_array,new_left_outer,new_right_array,new_right_outer,new_any_array,new_any_outer,&second_heads,&second_outer,parent](const unsigned int* left_index_array) {
						auto new_left = lookup_table_array_view<array<hol_term*>, hol_term*>(new_left_array, left_index_array, parent->any_array.left.length);
						bool is_subset_of_all = true;
						for (unsigned int j = 0; is_subset_of_all && j < new_left.size(); j++)
							if (!is_subset<built_in_predicates>(new_left[j], all)) is_subset_of_all = false;
						if (!is_subset_of_all) return true;
						return apply_to_cartesian_product(new_right_array, parent->any_array.right.length, [all,all_outer,new_left,new_left_outer,new_right_array,new_right_outer,new_any_array,new_any_outer,&second_heads,&second_outer,parent,left_index_array](const unsigned int* right_index_array) {
							auto new_right = lookup_table_array_view<array<hol_term*>, hol_term*>(new_right_array, right_index_array, parent->any_array.right.length);
							bool is_subset_of_all = true;
							for (unsigned int j = 0; is_subset_of_all && j < new_right.size(); j++)
								if (!is_subset<built_in_predicates>(new_right[j], all)) is_subset_of_all = false;
							if (!is_subset_of_all) return true;
							return apply_to_cartesian_product(new_any_array, parent->any_array.any.length, [all,all_outer,new_left,new_left_outer,new_right,new_right_outer,new_any_array,new_any_outer,&second_heads,&second_outer,parent,left_index_array,right_index_array](const unsigned int* any_index_array) {
								auto new_any = lookup_table_array_view<array<hol_term*>, hol_term*>(new_any_array, any_index_array, parent->any_array.any.length);
								bool is_subset_of_all = true;
								for (unsigned int j = 0; is_subset_of_all && j < new_any.size(); j++)
									if (!is_subset<built_in_predicates>(new_any[j], all)) is_subset_of_all = false;
								if (!is_subset_of_all) return true;

								if (!second_heads.ensure_capacity(second_heads.length + 1)
								 || !second_outer.ensure_capacity(second_outer.length + 1)
								 || !array_init(second_outer[second_outer.length], 4))
									return false;
								second_outer.length++;

								array<hol_term*>& outer_terms = second_outer.last();
								outer_terms[0] = all_outer;
								outer_terms.length = 1;
								all_outer->reference_count++;
								for (unsigned int i = 0; i < parent->any_array.left.length; i++) {
									array<hol_term*> new_outer_terms(4);
									for (hol_term* outer : outer_terms)
										intersect<built_in_predicates>(new_outer_terms, outer, new_left_outer[i][left_index_array[i]]);
									free_all(outer_terms);
									swap(new_outer_terms, outer_terms);
								} for (unsigned int i = 0; i < parent->any_array.right.length; i++) {
									array<hol_term*> new_outer_terms(4);
									for (hol_term* outer : outer_terms)
										intersect<built_in_predicates>(new_outer_terms, outer, new_right_outer[i][right_index_array[i]]);
									free_all(outer_terms);
									swap(new_outer_terms, outer_terms);
								} for (unsigned int i = 0; i < parent->any_array.any.length; i++) {
									array<hol_term*> new_outer_terms(4);
									for (hol_term* outer : outer_terms)
										intersect<built_in_predicates>(new_outer_terms, outer, new_any_outer[i][any_index_array[i]]);
									free_all(outer_terms);
									swap(new_outer_terms, outer_terms);
								}

								hol_term* new_head = hol_term::new_any_array(parent->any_array.oper, all, new_any, new_left, new_right);
								if (new_head == nullptr)
									return false;
								new_head->any_array.all->reference_count++;
								for (unsigned int i = 0; i < new_head->any_array.left.length; i++)
									new_head->any_array.left.operands[i]->reference_count++;
								for (unsigned int i = 0; i < new_head->any_array.right.length; i++)
									new_head->any_array.right.operands[i]->reference_count++;
								for (unsigned int i = 0; i < new_head->any_array.any.length; i++)
									new_head->any_array.any.operands[i]->reference_count++;
								second_heads[second_heads.length++] = new_head;
								return true;
							});
						});
					});
					if (!success) break;
				}
				for (unsigned int j = 0; j < parent->any_array.left.length; j++) { free_all(new_left_array[j]); free(new_left_array[j]); free_all(new_left_outer[j]); free(new_left_outer[j]); }
				for (unsigned int j = 0; j < parent->any_array.right.length; j++) { free_all(new_right_array[j]); free(new_right_array[j]); free_all(new_right_outer[j]); free(new_right_outer[j]); }
				for (unsigned int j = 0; j < parent->any_array.any.length; j++) { free_all(new_any_array[j]); free(new_any_array[j]); free_all(new_any_outer[j]); free(new_any_outer[j]); }
				free(new_left_array); free(new_right_array); free(new_any_array); free(new_left_outer); free(new_right_outer); free(new_any_outer); free_all(new_all); free_all(new_all_outer);
				if (!success || second_heads.length == 0) {
					free(*remapped_second); if (remapped_second->reference_count == 0) free(remapped_second);
					if (conjunct != nullptr) { free(*conjunct); if (conjunct->reference_count == 0) free(conjunct); }
					for (array<hol_term*>& outer : second_outer) { free_all(outer); free(outer); }
					free_all(second_heads); return false;
				}
				second_head = parent;
			}
		}
	}

	if (second_heads.length == 0) {
		array<hol_term*> outer(8);
		if (!invert_second_head(second_heads, outer, first_head, second_head, first_inverter, second_inverter, first_predicate_index, second_predicate_index, conjunct, max_variable, any_right_only, could_have_wide_scope, false)
		 || !second_outer.ensure_capacity(outer.length))
		{
			free(*remapped_second); if (remapped_second->reference_count == 0) free(remapped_second);
			if (conjunct != nullptr) { free(*conjunct); if (conjunct->reference_count == 0) free(conjunct); }
			free_all(second_heads); free_all(outer); return false;
		}
		for (unsigned int i = 0; i < outer.length; i++) {
			if (!array_init(second_outer[i], 1)) {
				for (unsigned int j = 0; j < i; j++) free(second_outer[j]);
				free(*remapped_second); if (remapped_second->reference_count == 0) free(remapped_second);
				if (conjunct != nullptr) { free(*conjunct); if (conjunct->reference_count == 0) free(conjunct); }
				free_all(second_heads); free_all(outer); return false;
			}
			second_outer[i][0] = outer[i];
			second_outer[i].length = 1;
			second_outer.length++;
		}
	}
	if (conjunct != nullptr) { free(*conjunct); if (conjunct->reference_count == 0) free(conjunct); }

	if (first_head_is_array) {
		hol_term* parent = first_inverter.outer[first_inverter.outer.length - 2];
		first_head = parent;
	}

	hol_term* first_outer = substitute_head<any_node_position::RIGHT>(first, first_head, &HOL_ZERO, true);
	if (first_outer == nullptr) {
		free(*remapped_second); if (remapped_second->reference_count == 0) free(remapped_second);
		return false;
	}

	array<hol_term*> inverted_logical_forms(8);
	for (unsigned int i = 0; i < second_heads.length; i++) {
		array<hol_term*> new_heads(8);
/* TODO: for debugging; remove this */
#if defined(DEBUG_PARSER)
fprintf(stderr, "first_head:       "); print(*first_head, stderr, *debug_terminal_printer); print('\n', stderr);
fprintf(stderr, "second_heads[%u]: ", i); print(*second_heads[i], stderr, *debug_terminal_printer); print('\n', stderr);
#endif
		intersect<built_in_predicates>(new_heads, first_head, second_heads[i]);
		if (new_heads.length == 0)
			continue;

		for (unsigned int j = 0; j < second_outer[i].length; j++) {
			hol_term* new_second_outer;
			if (any_right_only)
				new_second_outer = substitute_head<any_node_position::LEFT, true>(remapped_second, second_head, second_outer[i][j], could_have_wide_scope);
			else new_second_outer = substitute_head<any_node_position::LEFT, false>(remapped_second, second_head, second_outer[i][j], could_have_wide_scope);
			if (new_second_outer == nullptr) {
				free(*first_outer); if (first_outer->reference_count == 0) free(first_outer);
				free(*remapped_second); if (remapped_second->reference_count == 0) free(remapped_second);
				for (array<hol_term*>& outer : second_outer) { free_all(outer); free(outer); }
				free_all(second_heads); free_all(new_heads); free_all(inverted_logical_forms); return false;
			}

			array<hol_term*> new_outer(8);
/* TODO: for debugging; remove this */
#if defined(DEBUG_PARSER)
fprintf(stderr, "first_outer:      "); print(*first_outer, stderr, *debug_terminal_printer); print('\n', stderr);
fprintf(stderr, "new_second_outer: "); print(*new_second_outer, stderr, *debug_terminal_printer); print('\n', stderr);
#endif
			intersect<built_in_predicates>(new_outer, first_outer, new_second_outer);
			free(*new_second_outer); if (new_second_outer->reference_count == 0) free(new_second_outer);

			unsigned int index = 0;
			for (unsigned int k = 0; k < new_outer.length; k++) {
				hol_term* cleaned_outer = remove_any_nodes(new_outer[k], find_zero);
				if (cleaned_outer == nullptr) {
					free(*first_outer); if (first_outer->reference_count == 0) free(first_outer);
					free(*remapped_second); if (remapped_second->reference_count == 0) free(remapped_second);
					for (array<hol_term*>& outer : second_outer) { free_all(outer); free(outer); }
					free_all(second_heads); free_all(new_heads); free_all(inverted_logical_forms);
					for (unsigned int l = 0; l < index; l++) { free(*new_outer[l]); if (new_outer[l]->reference_count == 0) free(new_outer[l]); }
					for (unsigned int l = k; l < new_outer.length; l++) { free(*new_outer[l]); if (new_outer[l]->reference_count == 0) free(new_outer[l]); }
					return false;
				}
				free(*new_outer[k]); if (new_outer[k]->reference_count == 0) free(new_outer[k]);

				/* check if we already have `cleaned_outer` */
				bool is_duplicate = false;
				for (unsigned int l = 0; l < index; l++) {
					if (*cleaned_outer == *new_outer[l]) {
						is_duplicate = true;
						break;
					}
				}
				if (is_duplicate) {
					free(*cleaned_outer); if (cleaned_outer->reference_count == 0) free(cleaned_outer);
					new_outer[k] = new_outer[new_outer.length - 1];
					k--; new_outer.length--;
				} else {
					new_outer[index++] = cleaned_outer;
				}
			}
			new_outer.length = index;

			if (!inverted_logical_forms.ensure_capacity(inverted_logical_forms.length + new_outer.length * new_heads.length)) {
				free(*first_outer); if (first_outer->reference_count == 0) free(first_outer);
				free(*remapped_second); if (remapped_second->reference_count == 0) free(remapped_second);
				for (array<hol_term*>& outer : second_outer) { free_all(outer); free(outer); }
				free_all(second_heads); free_all(new_heads); free_all(new_outer); free_all(inverted_logical_forms);
				return false;
			}
			for (hol_term* outer : new_outer) {
				for (hol_term* head : new_heads) {
					inverted_logical_forms[inverted_logical_forms.length] = substitute_head<any_node_position::NONE>(outer, &HOL_ZERO, head);
					if (inverted_logical_forms[inverted_logical_forms.length] == nullptr) {
						free(*first_outer); if (first_outer->reference_count == 0) free(first_outer);
						free(*remapped_second); if (remapped_second->reference_count == 0) free(remapped_second);
						for (array<hol_term*>& outer : second_outer) { free_all(outer); free(outer); }
						free_all(second_heads); free_all(new_heads); free_all(new_outer); free_all(inverted_logical_forms);
						return false;
					}
					inverted_logical_forms.length++;
				}
			}
			free_all(new_outer);
		}
		free_all(new_heads);
	}
	free(*first_outer); if (first_outer->reference_count == 0) free(first_outer);
	free(*remapped_second); if (remapped_second->reference_count == 0) free(remapped_second);
	for (array<hol_term*>& outer : second_outer) { free_all(outer); free(outer); }
	free_all(second_heads);

	if (inverted_logical_forms.length == 0)
		return false;

#if defined(DEBUG_PARSER)
	bool is_disjoint = true;
	for (unsigned int i = 1; is_disjoint && i < inverted_logical_forms.length; i++) {
		for (unsigned int j = 0; j < i; j++) {
			if (has_intersection<built_in_predicates>(inverted_logical_forms[i], inverted_logical_forms[j])) {
				fprintf(stderr, "invert_apply_head WARNING: `inverted_logical_forms` is not pairwise-disjoint.\n");
/* TODO: for debugging; delete this */
fprintf(stderr, "inverted_logical_forms[%u]: ", j); print(*inverted_logical_forms[j], stderr, *debug_terminal_printer); print('\n', stderr);
fprintf(stderr, "inverted_logical_forms[%u]: ", i); print(*inverted_logical_forms[i], stderr, *debug_terminal_printer); print('\n', stderr);
has_intersection<built_in_predicates>(inverted_logical_forms[i], inverted_logical_forms[j]);
				is_disjoint = false; break;
			}
		}
	}
#endif

	inverse = (flagged_logical_form<hol_term>*) malloc(sizeof(flagged_logical_form<hol_term>) * inverted_logical_forms.length);
	if (inverse == nullptr) {
		free_all(inverted_logical_forms);
		return false;
	}
	for (unsigned int i = 0; i < inverted_logical_forms.length; i++) {
		inverse[i].flags = flags;
		inverse[i].root = inverted_logical_forms[i];
/* TODO: for debugging; remove this */
#if defined(DEBUG_PARSER)
fprintf(stderr, "inverse[%u]: ", i); print(inverse[i], stderr, *debug_terminal_printer); print('\n', stderr);
#endif
	}
	inverse_count = inverted_logical_forms.length;
	return true;
}

inline bool get_target_variable(
		unsigned int src_variable, unsigned int& target_var,
		const variable_set& target_var_set, unsigned int& max_variable)
{
	target_var = 0;
	switch (target_var_set.type) {
	case variable_set_type::SINGLETON:
		target_var = target_var_set.variable;
		break;
	case variable_set_type::ANY:
		if (index_of(src_variable, target_var_set.any.array, target_var_set.any.length) < target_var_set.any.length) {
			target_var = src_variable;
			break;
		}
		for (unsigned int i = 0; i < target_var_set.any.length; i++) {
			if (target_var_set.any.array[i] >= max_variable) {
				target_var = target_var_set.any.array[i];
				max_variable = target_var;
				break;
			}
		}
		break;
	case variable_set_type::ANY_EXCEPT:
		if (index_of(src_variable, target_var_set.any.array, target_var_set.any.length) == target_var_set.any.length) {
			target_var = src_variable;
			break;
		}
		target_var = max_variable;
		for (unsigned int i = 0; i < target_var_set.any.length; i++)
			target_var = max(target_var, target_var_set.any.array[i]);
		target_var++;
		max_variable = target_var;
		break;
	}
	return (target_var != 0);
}

bool remap_scopes(array_map<unsigned int, variable_set>& free_variable_map,
		apply_head_inverter& first_head_inverter, apply_head_inverter& second_head_inverter,
		array_map<const hol_term*, unsigned int>& second_variable_map, unsigned int& max_variable,
		bool first_head_is_array, bool second_head_is_array)
{
	unsigned int prev_first_inverter_index = first_head_inverter.outer.length;
	unsigned int prev_second_inverter_index = second_head_inverter.outer.length;
	while (free_variable_map.size != 0) {
		unsigned int index = 0;

		/* find the next inner-most scope in `second` whose variable is in `free_variable_map.keys` */
		unsigned int second_inverter_index;
		for (second_inverter_index = prev_second_inverter_index; second_inverter_index > 0; second_inverter_index--) {
			const hol_term* node = second_head_inverter.outer[second_inverter_index - 1];
			if (node->type == hol_term_type::FOR_ALL || node->type == hol_term_type::EXISTS || node->type == hol_term_type::LAMBDA) {
				index = free_variable_map.index_of(node->quantifier.variable);
				if (index < free_variable_map.size) break;
				prev_second_inverter_index = second_inverter_index;
			}

			if (second_inverter_index != prev_second_inverter_index) {
				hol_term* second_right = nullptr;
				if (node->type == hol_term_type::AND) {
					second_right = node->array.operands[node->array.length - 2];
				} else if (node->type == hol_term_type::ANY_ARRAY && node->any_array.oper == hol_term_type::AND && node->any_array.right.length >= 2) {
					second_right = node->any_array.right.operands[node->any_array.right.length - 2];
				}

				if (second_right != nullptr && second_right->type == hol_term_type::UNARY_APPLICATION
				 && second_right->binary.left->type == hol_term_type::VARIABLE
				 && second_right->binary.right->type == hol_term_type::VARIABLE)
				{
					index = free_variable_map.index_of(second_right->binary.right->variable);
					if (index < free_variable_map.size) break;
				}
			}
		}

		unsigned int second_variable = free_variable_map.keys[index];
		if (free_variable_map.values[index].type != variable_set_type::SINGLETON) {
			free(free_variable_map.values[index]);
			free_variable_map.remove_at(index);
			prev_second_inverter_index = second_inverter_index;
			continue;
		}
		unsigned int first_variable = free_variable_map.values[index].variable;
		free_variable_map.remove_at(index);

		index = second_variable_map.index_of(second_head_inverter.outer[second_inverter_index - 1]);
		if (index < second_variable_map.size) {
			second_variable_map.values[index] = first_variable;
			if (first_variable == second_variable)
				second_variable_map.remove_at(index);
		}

		/* find the scopes where `first_variable` and `second_variable` are declared */
		unsigned int first_inverter_index;
		for (first_inverter_index = prev_first_inverter_index; first_inverter_index > 0; first_inverter_index--) {
			const hol_term* node = first_head_inverter.outer[first_inverter_index - 1];
			if (node->type == hol_term_type::FOR_ALL || node->type == hol_term_type::EXISTS || node->type == hol_term_type::LAMBDA) {
				if (node->quantifier.variable == first_variable) break;
				prev_first_inverter_index = first_inverter_index;
			} else if (first_inverter_index != prev_first_inverter_index
					&& second_head_inverter.outer[second_inverter_index - 1]->type != hol_term_type::FOR_ALL
					&& second_head_inverter.outer[second_inverter_index - 1]->type != hol_term_type::EXISTS
					&& second_head_inverter.outer[second_inverter_index - 1]->type != hol_term_type::LAMBDA)
			{
				hol_term* second_right = nullptr;
				if (node->type == hol_term_type::AND) {
					second_right = node->array.operands[node->array.length - 2];
				} else if (node->type == hol_term_type::ANY_ARRAY && node->any_array.oper == hol_term_type::AND && node->any_array.right.length >= 2) {
					second_right = node->any_array.right.operands[node->any_array.right.length - 2];
				}

				if (second_right != nullptr && second_right->type == hol_term_type::UNARY_APPLICATION
				 && second_right->binary.left->type == hol_term_type::VARIABLE
				 && second_right->binary.right->type == hol_term_type::VARIABLE
				 && second_right->binary.right->variable == first_variable)
				{
					break;
				}
			}
		}

		/* ignore any negations or wide scopes from the previous scope */
		while (prev_first_inverter_index > first_inverter_index && (first_head_inverter.outer[prev_first_inverter_index - 2]->type == hol_term_type::NOT
			|| (first_head_inverter.outer[prev_first_inverter_index - 2]->type == hol_term_type::UNARY_APPLICATION
			 && first_head_inverter.outer[prev_first_inverter_index - 2]->binary.left->type == hol_term_type::CONSTANT
			 && first_head_inverter.outer[prev_first_inverter_index - 2]->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE)))
		{
			prev_first_inverter_index--;
		}
		while (prev_second_inverter_index > second_inverter_index && (second_head_inverter.outer[prev_second_inverter_index - 2]->type == hol_term_type::NOT
			|| (second_head_inverter.outer[prev_second_inverter_index - 2]->type == hol_term_type::UNARY_APPLICATION
			 && second_head_inverter.outer[prev_second_inverter_index - 2]->binary.left->type == hol_term_type::CONSTANT
			 && second_head_inverter.outer[prev_second_inverter_index - 2]->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE)))
		{
			prev_second_inverter_index--;
		}

		/* make sure the two scopes can intersect */
		hol_term* first_scope = substitute_head<any_node_position::NONE>(
				first_head_inverter.outer[first_inverter_index - 1], first_head_inverter.outer[prev_first_inverter_index - 1], &HOL_ZERO);
		hol_term* second_scope = substitute_head<any_node_position::NONE>(
				second_head_inverter.outer[second_inverter_index - 1], second_head_inverter.outer[prev_second_inverter_index - 1], &HOL_ZERO);
		if (first_scope == nullptr || second_scope == nullptr) {
			if (first_scope == nullptr) { free(*first_scope); free(first_scope); }
			return false;
		}

		array<pair<hol_term*, variable_map>> intersection(2);
		intersect<built_in_predicates, true, true>(intersection, first_scope, second_scope);
		if (intersection.length == 0) {
			free(*first_scope); if (first_scope->reference_count == 0) free(first_scope);
			free(*second_scope); if (second_scope->reference_count == 0) free(second_scope);
			return false;
		} else if (intersection.length != 1) {
			fprintf(stderr, "remap_scopes ERROR: Intersection is not unique.\n");
			free(*first_scope); if (first_scope->reference_count == 0) free(first_scope);
			free(*second_scope); if (second_scope->reference_count == 0) free(second_scope);
			free_all(intersection); return false;
		}

		const variable_map& var_map = intersection[0].value;
		for (const auto& entry : var_map.scope_map) {
			const variable_set& set = entry.value;
			unsigned int src_variable = entry.key.src->quantifier.variable;
			unsigned int target_var;
			if (!get_target_variable(src_variable, target_var, set, max_variable)
			 || !second_variable_map.ensure_capacity(second_variable_map.size + 1))
			{
				free(*first_scope); if (first_scope->reference_count == 0) free(first_scope);
				free(*second_scope); if (second_scope->reference_count == 0) free(second_scope);
				free_all(intersection); return false;
			}

			unsigned int index = second_variable_map.index_of(entry.key.src);
			if (index < second_variable_map.size) {
				second_variable_map.values[index] = target_var;
				if (src_variable == target_var)
					second_variable_map.remove_at(index);
			} else if (src_variable != target_var) {
				second_variable_map.keys[second_variable_map.size] = entry.key.src;
				second_variable_map.values[second_variable_map.size] = target_var;
				second_variable_map.size++;
			}
		} for (const auto& entry : var_map.free_variables) {
			const variable_set& set = entry.value;
			unsigned int src_variable = entry.key;
			if (!free_variable_map.ensure_capacity(free_variable_map.size + 1)) {
				free(*first_scope); if (first_scope->reference_count == 0) free(first_scope);
				free(*second_scope); if (second_scope->reference_count == 0) free(second_scope);
				free_all(intersection); return false;
			}
			unsigned int index = free_variable_map.index_of(src_variable);
			if (index < free_variable_map.size) {
				variable_set& new_set = *((variable_set*) alloca(sizeof(variable_map)));
				if (!intersect(new_set, set, free_variable_map.values[index])) {
					free(*first_scope); if (first_scope->reference_count == 0) free(first_scope);
					free(*second_scope); if (second_scope->reference_count == 0) free(second_scope);
					free_all(intersection); return false;
				}
				swap(free_variable_map.values[index], new_set);
				free(new_set);
			} else {
				free_variable_map.keys[free_variable_map.size] = src_variable;
				if (!init(free_variable_map.values[free_variable_map.size], set)) {
					free(*first_scope); if (first_scope->reference_count == 0) free(first_scope);
					free(*second_scope); if (second_scope->reference_count == 0) free(second_scope);
					free_all(intersection); return false;
				}
				free_variable_map.size++;
			}
		}
		free(*first_scope); if (first_scope->reference_count == 0) free(first_scope);
		free(*second_scope); if (second_scope->reference_count == 0) free(second_scope);
		free_all(intersection);

		prev_first_inverter_index = first_inverter_index;
		prev_second_inverter_index = second_inverter_index;

		if (first_head_is_array && prev_first_inverter_index == first_head_inverter.outer.length)
			prev_first_inverter_index--;
		if (second_head_is_array && prev_second_inverter_index == second_head_inverter.outer.length)
			prev_second_inverter_index--;
	}
	return true;
}

bool intersect(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		grammatical_flags flags,
		hol_term* first, hol_term* second)
{
	array<hol_term*> intersection(8);
	if (!intersect<built_in_predicates>(intersection, first, second))
		return false;
	inverse = (flagged_logical_form<hol_term>*) malloc(sizeof(flagged_logical_form<hol_term>) * intersection.length);
	if (inverse == nullptr) {
		fprintf(stderr, "intersect ERROR: Insufficient memory for `inverse`.\n");
		for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
		return false;
	}
	for (unsigned int i = 0; i < intersection.length; i++) {
		inverse[i].flags = flags;
		inverse[i].root = intersection[i];
	}
	inverse_count = intersection.length;
	return true;
}

template<typename FindHeadFunction>
bool intersect_with_head(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		grammatical_flags flags,
		hol_term* first, hol_term* second,
		FindHeadFunction find_head_function)
{
	head_index first_predicate_index, second_predicate_index; no_op apply;
	hol_term* first_head = find_head(first, first_predicate_index, find_head_function, apply);
	hol_term* second_head = find_head(second, second_predicate_index, find_head_function, apply);
	if (first_head == nullptr || second_head == nullptr)
		return false;

	if (first_head->type == hol_term_type::ANY_RIGHT && first_head->any.included != nullptr && first_head->any.included->type == hol_term_type::EXISTS)
		first_head = first_head->any.included;
	if (second_head->type == hol_term_type::ANY_RIGHT && second_head->any.included != nullptr && second_head->any.included->type == hol_term_type::EXISTS)
		second_head = second_head->any.included;


	hol_term* first_placeholder;
	if (first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) {
		first_placeholder = hol_term::new_any_right(&HOL_ZERO);
		if (first_placeholder == nullptr)
			return false;
		HOL_ZERO.reference_count++;
	} else {
		first_placeholder = &HOL_ZERO;
		HOL_ZERO.reference_count++;
	}

	if (first_head->type == hol_term_type::EXISTS) {
		while (second_head->type == hol_term_type::NOT)
			second_head = second_head->unary.operand;
	}

	hol_term* first_outer = substitute_head<any_node_position::NONE>(first, first_head, first_placeholder);
	free(*first_placeholder); if (first_placeholder->reference_count == 0) free(first_placeholder);
	if (first_outer == nullptr)
		return false;

	hol_term* second_outer = substitute_head<any_node_position::NONE>(second, second_head, &HOL_ZERO);
	if (second_outer == nullptr) {
		free(*first_outer); if (first_outer->reference_count == 0) free(first_outer);
		return false;
	}

	/* intersect the heads and the outer terms respectively */
	array<hol_term*> new_heads(4);
	intersect<built_in_predicates>(new_heads, first_head, second_head);
	if (new_heads.length == 0) {
		free(*first_outer); if (first_outer->reference_count == 0) free(first_outer);
		free(*second_outer); if (second_outer->reference_count == 0) free(second_outer);
		return false;
	}

	array<hol_term*> new_outer(4);
	intersect<built_in_predicates>(new_outer, first_outer, second_outer);
	free(*first_outer); if (first_outer->reference_count == 0) free(first_outer);
	free(*second_outer); if (second_outer->reference_count == 0) free(second_outer);
	if (new_outer.length == 0) {
		free_all(new_heads);
		return false;
	}

	array<hol_term*> intersection(new_heads.length * new_outer.length);
	for (hol_term* outer : new_outer) {
		for (hol_term* head : new_heads) {
			hol_term* new_term = substitute_head<any_node_position::NONE>(outer, &HOL_ZERO, head);
			if (new_term == nullptr) {
				free_all(new_heads); free_all(new_outer); free_all(intersection);
				return false;
			}
			intersection[intersection.length++] = new_term;
		}
	}
	free_all(new_heads);
	free_all(new_outer);

	inverse = (flagged_logical_form<hol_term>*) malloc(sizeof(flagged_logical_form<hol_term>) * intersection.length);
	if (inverse == nullptr) {
		fprintf(stderr, "intersect_with_head ERROR: Out of memory.\n");
		free_all(intersection); return false;
	}
	for (unsigned int i = 0; i < intersection.length; i++) {
		inverse[i].flags = flags;
		inverse[i].root = intersection[i];
	}
	inverse_count = intersection.length;
	return true;
}

template<int_fast8_t ConjunctIndex, bool SelectNegation = false>
inline bool invert_select_conjunct(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	auto on_remap_variables = [](hol_term* first_head, hol_term* second_head,
			apply_head_inverter& first_head_inverter, apply_head_inverter& second_head_inverter,
			array_map<const hol_term*, unsigned int>& second_variable_map, unsigned int& max_variable,
			bool first_head_is_array, bool second_head_is_array)
	{
		if ((first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) && first_head->any.included != nullptr && (first_head->any.included->type == hol_term_type::EXISTS || first_head->any.included->type == hol_term_type::NOT))
			first_head = first_head->any.included;
		if ((second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT) && second_head->any.included != nullptr && (second_head->any.included->type == hol_term_type::EXISTS || second_head->any.included->type == hol_term_type::NOT))
			second_head = second_head->any.included;

		while (first_head->type == hol_term_type::NOT)
			first_head = first_head->unary.operand;
		while (second_head->type == hol_term_type::NOT)
			second_head = second_head->unary.operand;

		unsigned int head_variable = 0;
		if (first_head->type == hol_term_type::EXISTS)
			head_variable = first_head->quantifier.variable;
		unsigned int second_head_variable;
		if (second_head->type == hol_term_type::EXISTS) {
			second_head_variable = second_head->quantifier.variable;
			if (head_variable == 0)
				head_variable = second_head_variable;
		}

		hol_term* expected_head;
		if (ConjunctIndex >= 0) {
			if (head_variable == 0) {
				expected_head = hol_term::new_any_quantifier(hol_quantifier_type::EXISTS, hol_term::new_any_array(hol_term_type::AND, &HOL_ANY,
						make_array_view((hol_term**) nullptr, 0), make_repeated_array_view(&HOL_ANY, ConjunctIndex + 1), make_array_view((hol_term**) nullptr, 0)));
			} else {
				expected_head = hol_term::new_exists(head_variable, hol_term::new_any_array(hol_term_type::AND, &HOL_ANY,
						make_array_view((hol_term**) nullptr, 0), make_repeated_array_view(&HOL_ANY, ConjunctIndex + 1), make_array_view((hol_term**) nullptr, 0)));
			}
			if (expected_head == nullptr)
				return false;
			HOL_ANY.reference_count += 2 + ConjunctIndex;
		} else {
			unsigned int index = (unsigned int) (-ConjunctIndex) - 1;
			if (head_variable == 0) {
				expected_head = hol_term::new_any_quantifier(hol_quantifier_type::EXISTS, hol_term::new_any_array(hol_term_type::AND, &HOL_ANY,
						make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0), make_repeated_array_view(&HOL_ANY, index + 1)));
			} else {
				expected_head = hol_term::new_exists(head_variable, hol_term::new_any_array(hol_term_type::AND, &HOL_ANY,
						make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0), make_repeated_array_view(&HOL_ANY, index + 1)));
			}
			if (expected_head == nullptr)
				return false;
			HOL_ANY.reference_count += 2 + index;
		}

		array<hol_term*> intersection(2);
		intersect<built_in_predicates>(intersection, first_head, expected_head);
		free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
		if (intersection.length == 0) {
			return false;
		} else if (intersection.length != 1) {
			fprintf(stderr, "invert_select_conjunct ERROR: Intersection is not unique.\n");
			for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
			return false;
		}

		hol_term* operand;
		if (intersection[0]->type == hol_term_type::ANY_QUANTIFIER)
			operand = intersection[0]->any_quantifier.operand;
		else operand = intersection[0]->quantifier.operand;

		hol_term* conjunct;
		if (operand->type == hol_term_type::ANY_ARRAY) {
			if (ConjunctIndex >= 0) {
				if (ConjunctIndex < operand->any_array.left.length)
					conjunct = operand->any_array.left.operands[ConjunctIndex];
				else conjunct = operand->any_array.all;
			} else {
				if (operand->any_array.right.length >= -ConjunctIndex)
					conjunct = operand->any_array.right.operands[operand->any_array.right.length + ConjunctIndex];
				else conjunct = operand->any_array.all;
			}
		} else {
			unsigned int index;
			if (ConjunctIndex >= 0) {
				index = ConjunctIndex;
			} else {
				index = operand->array.length + ConjunctIndex;
			}
			conjunct = operand->array.operands[index];
		}

		/* now get the conjunct from `second_head` */
		expected_head = hol_term::new_any_quantifier(hol_quantifier_type::EXISTS, hol_term::new_and(&HOL_ANY, &HOL_ANY));
		if (expected_head == nullptr) {
			for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
			return false;
		}
		HOL_ANY.reference_count += 2;

		array<hol_term*> second_intersection(2);
		intersect<built_in_predicates>(second_intersection, second_head, expected_head);
		free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
		if (second_intersection.length == 0) {
			for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
			return false;
		} else if (second_intersection.length != 1) {
			fprintf(stderr, "invert_select_conjunct ERROR: Intersection is not unique.\n");
			for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
			for (hol_term* term : second_intersection) { free(*term); if (term->reference_count == 0) free(term); }
			return false;
		}

		if (second_intersection[0]->type == hol_term_type::ANY_QUANTIFIER)
			operand = second_intersection[0]->any_quantifier.operand;
		else operand = second_intersection[0]->quantifier.operand;

		hol_term* second_conjunct = operand->array.operands[1];
		array<pair<hol_term*, variable_map>> conjunct_intersection(2);
		intersect<built_in_predicates, true, true>(conjunct_intersection, second_conjunct, conjunct);
		for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
		for (hol_term* term : second_intersection) { free(*term); if (term->reference_count == 0) free(term); }
		if (conjunct_intersection.length == 0) {
			return false;
		} else if (conjunct_intersection.length != 1) {
			fprintf(stderr, "invert_select_conjunct ERROR: Intersection modulo variable relabeling is not unique.\n");
			free_all(conjunct_intersection); return false;
		}

		/* make sure the variables in `second_head` map to the correct variables in `first_head` */
		const variable_map& var_map = conjunct_intersection[0].value;
		for (const auto& entry : var_map.scope_map) {
			const variable_set& set = entry.value;
			unsigned int src_variable = entry.key.src->quantifier.variable;
			unsigned int target_var;
			if (!get_target_variable(src_variable, target_var, set, max_variable)
			 || !second_variable_map.ensure_capacity(second_variable_map.size + 1))
			{
				free_all(conjunct_intersection);
				return false;
			}

			unsigned int index = second_variable_map.index_of(entry.key.src);
			if (index < second_variable_map.size) {
				second_variable_map.values[index] = target_var;
				if (src_variable == target_var)
					second_variable_map.remove_at(index);
			} else if (src_variable != target_var) {
				second_variable_map.keys[second_variable_map.size] = entry.key.src;
				second_variable_map.values[second_variable_map.size] = target_var;
				second_variable_map.size++;
			}
		}

		array_map<unsigned int, variable_set> free_variable_map(8);
		for (const auto& entry : var_map.free_variables) {
			const variable_set& set = entry.value;
			if (entry.key == second_head_variable)
				continue;

			unsigned int src_variable = entry.key;
			if (!free_variable_map.ensure_capacity(free_variable_map.size + 1)) {
				free_all(conjunct_intersection);
				return false;
			}
			unsigned int index = free_variable_map.index_of(src_variable);
			if (index < free_variable_map.size) {
				variable_set& new_set = *((variable_set*) alloca(sizeof(variable_map)));
				if (!intersect(new_set, set, free_variable_map.values[index])) {
					free_all(conjunct_intersection);
					return false;
				}
				swap(free_variable_map.values[index], new_set);
				free(new_set);
			} else {
				free_variable_map.keys[free_variable_map.size] = src_variable;
				if (!init(free_variable_map.values[free_variable_map.size], set)) {
					free_all(conjunct_intersection);
					return false;
				}
				free_variable_map.size++;
			}
		}
		free_all(conjunct_intersection);

		/* make sure we include excluded subtrees from outer nodes */
		for (hol_term* outer : first_head_inverter.outer) {
			if (outer->type == hol_term_type::ANY || outer->type == hol_term_type::ANY_RIGHT) {
				for (unsigned int i = 0; i < outer->any.excluded_tree_count; i++) {
					hol_term* excluded_subtree = outer->any.excluded_trees[i];
					if (excluded_subtree->type != hol_term_type::ANY && excluded_subtree->type != hol_term_type::ANY_RIGHT)
						continue;
					array<pair<hol_term*, variable_map>> new_conjunct_intersection(2);
					subtract<built_in_predicates, true>(new_conjunct_intersection, second_conjunct, excluded_subtree);
					if (new_conjunct_intersection.length == 0) {
						return false;
					} else if (new_conjunct_intersection.length != 1) {
						fprintf(stderr, "invert_select_conjunct ERROR: Intersection modulo variable relabeling is not unique.\n");
						free_all(new_conjunct_intersection); return false;
					}

					/* make sure the variables in `second_head` map to the correct variables in `first_head` */
					const variable_map& var_map = new_conjunct_intersection[0].value;
					for (const auto& entry : var_map.scope_map) {
						const variable_set& set = entry.value;
						unsigned int src_variable = entry.key.src->quantifier.variable;
						unsigned int target_var;
						if (!get_target_variable(src_variable, target_var, set, max_variable)
						 || !second_variable_map.ensure_capacity(second_variable_map.size + 1))
						{
							free_all(new_conjunct_intersection);
							return false;
						}

						unsigned int index = second_variable_map.index_of(entry.key.src);
						if (index < second_variable_map.size) {
							second_variable_map.values[index] = target_var;
							if (src_variable == target_var)
								second_variable_map.remove_at(index);
						} else if (src_variable != target_var) {
							second_variable_map.keys[second_variable_map.size] = entry.key.src;
							second_variable_map.values[second_variable_map.size] = target_var;
							second_variable_map.size++;
						}
					}
					free_all(new_conjunct_intersection);
				}
			}
		}

		/* make sure the initial lambda variables are correctly mapped */
		if (first_head_inverter.outer[0]->type == hol_term_type::LAMBDA && second_head_inverter.outer[0]->type == hol_term_type::LAMBDA) {
			if (!second_variable_map.ensure_capacity(second_variable_map.size + 1)) {
				for (auto entry : second_variable_map) free(entry.value);
				return false;
			}

			unsigned int first_lambda_variable = first_head_inverter.outer[0]->quantifier.variable;
			hol_term* second_lambda = second_head_inverter.outer[0];
			unsigned int index = second_variable_map.index_of(second_lambda);
			if (index < second_variable_map.size && first_lambda_variable == second_variable_map.values[index]) {
				/* `second_variable_map` should map `var` to itself */
				second_variable_map.remove_at(index);
			} else {
				/* `second_variable_map` should map `var` to `target_var` */
				second_variable_map.values[index] = first_lambda_variable;
				if (index == second_variable_map.size) {
					second_variable_map.keys[index] = second_lambda;
					second_variable_map.size++;
				}
			}
		}

		if (!remap_scopes(free_variable_map, first_head_inverter, second_head_inverter, second_variable_map, max_variable, first_head_is_array, second_head_is_array)) {
			for (auto entry : second_variable_map) free(entry.value);
			return false;
		}
		return true;
	};

	return invert_apply_head(inverse, inverse_count, flags, first, second,
		find_head<built_in_predicates>, find_head<built_in_predicates>, on_remap_variables,
		[second](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, const apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array) {
			any_right_only = false;
			hol_term* old_first_head = first_head;
			if ((first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) && first_head->any.included != nullptr && (first_head->any.included->type == hol_term_type::EXISTS || first_head->any.included->type == hol_term_type::NOT))
				first_head = first_head->any.included;
			hol_term* old_second_head = second_head;
			if ((second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT) && second_predicate_index.position != head_position::NONE)
				second_head = second_head->any.included;

			unsigned int first_min_negations = 0;
			unsigned int second_negations = 0;
			while (first_head->type == hol_term_type::NOT) {
				first_head = first_head->unary.operand;
				first_min_negations++;
			} while (second_head->type == hol_term_type::NOT) {
				second_head = second_head->unary.operand;
				second_negations++;
			}

			/* if `SelectNegation` is true, `first_negations` should be equal to `second_negations`,
			   otherwise `first_negations` should be equal to either `second_negations + 1` or `0` */
			unsigned int expected_first_negations = (SelectNegation ? second_negations : second_negations + 1);
			bool could_be_zero_negations = (!SelectNegation && second_negations == 0);
			if (first_min_negations > expected_first_negations)
				return false;

			if (second_head->type == hol_term_type::EXISTS && second_head->quantifier.operand->type == hol_term_type::AND) {
				hol_term* second_head_operand = second_head->quantifier.operand;
				if (first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT || (first_head->type == hol_term_type::EXISTS
				 && (first_head->quantifier.operand->type == hol_term_type::ANY || first_head->quantifier.operand->type == hol_term_type::ANY_RIGHT || first_head->quantifier.operand->type == hol_term_type::ANY_ARRAY)))
				{
					hol_term* head_var = hol_term::new_variable(second_head->quantifier.variable);
					if (head_var == nullptr) return false;
					constexpr unsigned int excluded_tree_count = 3;
					hol_term* excluded_trees[excluded_tree_count];
					excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
								(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
								(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
							&HOL_ANY), head_var));
					excluded_trees[1] = hol_term::new_any(hol_term::new_exists(second_head->quantifier.variable, &HOL_ANY));
					excluded_trees[2] = hol_term::new_any_right(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ANY));
					if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
					if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
					if (excluded_trees[2] != nullptr) { HOL_ANY.reference_count++; }
					if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr || excluded_trees[2] == nullptr) {
						if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
						if (excluded_trees[1] != nullptr) { free(*excluded_trees[1]); free(excluded_trees[1]); }
						free(*head_var); free(head_var);
						return false;
					}
					hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
					free(*head_var);

					hol_term* conjunct = hol_term::new_any(nullptr, excluded_trees, excluded_tree_count);
					if (conjunct == nullptr) {
						free(*excluded_trees[0]); free(excluded_trees[0]);
						free(*excluded_trees[1]); free(excluded_trees[1]);
						free(*excluded_trees[2]); free(excluded_trees[2]);
						return false;
					}

					hol_term* expected_predicate;
					hol_array_term* first_any = nullptr;
					if (first_head->type == hol_term_type::EXISTS) {
						hol_term* operand = first_head->quantifier.operand;
						hol_term* first_predicate = nullptr;
						if (operand->type == hol_term_type::AND) {
							if (first_predicate_index.position == head_position::LEFT)
								first_predicate = operand->array.operands[first_predicate_index.index];
						} else if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
							if (first_predicate_index.position == head_position::LEFT)
								first_predicate = operand->any_array.left.operands[first_predicate_index.index];
							else if (first_predicate_index.position == head_position::RIGHT)
								first_predicate = operand->any_array.right.operands[operand->any_array.right.length - first_predicate_index.index - 1];
							else if (first_predicate_index.position == head_position::ANY) {
								first_predicate = operand->any_array.any.operands[first_predicate_index.index];
								first_any = &operand->any_array.any;
							}
						} else if (first_predicate_index.position == head_position::LEFT && first_predicate_index.index == 0) {
							first_predicate = operand;
						}

						if (first_predicate != nullptr && first_predicate->type == hol_term_type::UNARY_APPLICATION
						 && first_predicate->binary.right->type == hol_term_type::VARIABLE && first_predicate->binary.right->variable == first_head->quantifier.variable)
						{
							array<hol_term*> new_predicates(2);
							intersect<built_in_predicates>(new_predicates, second_head_operand->array.operands[0], first_predicate);
							if (new_predicates.length == 0) {
								for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
									free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
								}
								return false;
							} else if (new_predicates.length != 1) {
								fprintf(stderr, "invert_select_arg_without_head_predicative WARNING: Intersection of predicates is not unique.\n");
								for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
									free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
								}
								free_all(new_predicates); return false;
							}
							expected_predicate = new_predicates[0];
						} else {
							expected_predicate = second_head_operand->array.operands[0];
							expected_predicate->reference_count++;
						}
					} else {
						expected_predicate = second_head_operand->array.operands[0];
						expected_predicate->reference_count++;
					}

					hol_term* conjunction = nullptr;
					if (ConjunctIndex >= 0) {
						if (first_any == nullptr) {
							conjunction = hol_term::new_any_array(hol_term_type::AND, conjunct,
									make_array_view(&expected_predicate, 1),
									make_appended_array_view(make_repeated_array_view(conjunct, ConjunctIndex), second_head_operand->array.operands[1]),
									make_array_view((hol_term**) nullptr, 0));
						} else {
							conjunction = hol_term::new_any_array(hol_term_type::AND, conjunct,
									make_replaced_array_view(make_array_view(first_any->operands, first_any->length), expected_predicate, first_predicate_index.index),
									make_appended_array_view(make_repeated_array_view(conjunct, ConjunctIndex), second_head_operand->array.operands[1]),
									make_array_view((hol_term**) nullptr, 0));
						}
					} else if (ConjunctIndex < 0) {
						unsigned int index = (unsigned int) (-ConjunctIndex) - 1;
						if (first_any == nullptr) {
							conjunction = hol_term::new_any_array(hol_term_type::AND, conjunct,
									make_array_view(&expected_predicate, 1),
									make_array_view((hol_term**) nullptr, 0),
									make_prepended_array_view(second_head_operand->array.operands[1], make_repeated_array_view(conjunct, index)));
						} else {
							conjunction = hol_term::new_any_array(hol_term_type::AND, conjunct,
									make_replaced_array_view(make_array_view(first_any->operands, first_any->length), expected_predicate, first_predicate_index.index),
									make_array_view((hol_term**) nullptr, 0),
									make_prepended_array_view(second_head_operand->array.operands[1], make_repeated_array_view(conjunct, index)));
						}
					}
					if (conjunction == nullptr) {
						free(*conjunct); free(conjunct);
						free(*expected_predicate); free(expected_predicate);
						return false;
					}
					conjunction->any_array.all->reference_count++;
					for (unsigned int i = 0; i < conjunction->any_array.left.length; i++)
						conjunction->any_array.left.operands[i]->reference_count++;
					for (unsigned int i = 0; i < conjunction->any_array.right.length; i++)
						conjunction->any_array.right.operands[i]->reference_count++;
					for (unsigned int i = 0; i < conjunction->any_array.any.length; i++)
						conjunction->any_array.any.operands[i]->reference_count++;
					free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
					free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);

					hol_term* new_second_head = hol_term::new_exists(second_head->quantifier.variable, conjunction);
					if (new_second_head == nullptr) {
						free(*conjunction); free(conjunction);
						return false;
					}

					unsigned int dst_start = 0, dst_end = 0;
					if (could_be_zero_negations && expected_first_negations == 0) {
						dst_start = dst.length;
						intersect<built_in_predicates>(dst, new_second_head, first_head);
						dst_end = dst.length;
					}

					if (!could_be_zero_negations && expected_first_negations > 0) {
						for (unsigned int i = 0; i < expected_first_negations; i++) {
							hol_term* temp = hol_term::new_not(new_second_head);
							if (temp == nullptr) {
								free(*new_second_head); free(new_second_head);
								return false;
							}
							new_second_head = temp;
						}
						intersect<built_in_predicates>(dst, new_second_head, first_head);
					}

					if (could_be_zero_negations && expected_first_negations > 0) {
						hol_term* temp = hol_term::new_any_right(new_second_head);
						if (temp == nullptr) {
							free(*new_second_head); free(new_second_head);
							return false;
						}
						new_second_head = temp;
						intersect<built_in_predicates>(dst, new_second_head, first_head);
					}
					free(*new_second_head); if (new_second_head->reference_count == 0) free(new_second_head);

					for (hol_term* new_head : dst) {
						if (!can_have_free_variables(*new_head))
							any_right_only = true;
					}

					if (!dst_outer.ensure_capacity(dst.length)) {
						free_all(dst);
						return false;
					}
					for (unsigned int i = 0; i < dst.length; i++)
						dst_outer[i] = &HOL_ZERO;
					dst_outer.length = dst.length;
					HOL_ZERO.reference_count += dst.length;

					if (old_first_head->type == hol_term_type::ANY || old_first_head->type == hol_term_type::ANY_RIGHT) {
						/* gather the other quantifiers outside the head in `second` */
						array<hol_term*> excluded_trees(old_first_head->any.excluded_tree_count + 4);
						for (unsigned int i = 0; i < old_first_head->any.excluded_tree_count; i++) {
							excluded_trees[i] = old_first_head->any.excluded_trees[i];
							excluded_trees[i]->reference_count++;
						}
						excluded_trees.length = old_first_head->any.excluded_tree_count;
						bool second_could_have_wide_scope = false;
						for (unsigned int i = second_inverter.outer.length - 1; i > 0; i--) {
							const hol_term* node = second_inverter.outer[i - 1];
							if (node->type == hol_term_type::ANY || node->type == hol_term_type::ANY_RIGHT) {
								bool wide_scope_excluded = false;
								for (unsigned int i = 0; i < node->any.excluded_tree_count; i++) {
									if ((node->any.excluded_trees[i]->type == hol_term_type::ANY || node->any.excluded_trees[i]->type == hol_term_type::ANY_RIGHT)
									 && node->any.excluded_trees[i]->any.included->type == hol_term_type::UNARY_APPLICATION
									 && node->any.excluded_trees[i]->any.included->binary.left->type == hol_term_type::CONSTANT
									 && node->any.excluded_trees[i]->any.included->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE
									 && *node->any.excluded_trees[i]->any.included->binary.right == HOL_ANY)
									{
										wide_scope_excluded = true;
										break;
									}
								}
								if (!wide_scope_excluded)
									second_could_have_wide_scope = true;
							}
							if (node->type != hol_term_type::FOR_ALL && node->type != hol_term_type::EXISTS && node->type != hol_term_type::LAMBDA)
								continue;
							if (!excluded_trees.ensure_capacity(excluded_trees.length + 2)) {
								free_all(excluded_trees); free_all(dst); free_all(dst_outer);
								return false;
							}

							if (node->type == hol_term_type::FOR_ALL) {
								excluded_trees[excluded_trees.length] = hol_term::new_any(hol_term::new_for_all(node->quantifier.variable, &HOL_ANY));
							} else if (node->type == hol_term_type::EXISTS) {
								excluded_trees[excluded_trees.length] = hol_term::new_any(hol_term::new_exists(node->quantifier.variable, &HOL_ANY));
							} else {
								excluded_trees[excluded_trees.length] = hol_term::new_any(hol_term::new_lambda(node->quantifier.variable, &HOL_ANY));
							}
							if (excluded_trees[excluded_trees.length] == nullptr) {
								free_all(excluded_trees); free_all(dst); free_all(dst_outer);
								return false;
							}
							HOL_ANY.reference_count++;
							excluded_trees.length++;
						}

						if (!excluded_trees.ensure_capacity(excluded_trees.length + 2)) {
							free_all(excluded_trees); free_all(dst); free_all(dst_outer);
							return false;
						}

						/* add excluded tree for when the head is not negated */
						hol_term* excluded_negated_quantifier = hol_term::new_any(hol_term::new_not(hol_term::new_exists(second_head->quantifier.variable, &HOL_ANY)));
						if (excluded_negated_quantifier == nullptr) {
							free_all(excluded_trees); free_all(dst); free_all(dst_outer);
							return false;
						}
						HOL_ANY.reference_count++;

						hol_term* excluded_wide_scope = hol_term::new_any_right(hol_term::new_apply(
								&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ANY));
						if (excluded_wide_scope == nullptr) {
							free_all(excluded_trees); free_all(dst); free_all(dst_outer);
							free(*excluded_negated_quantifier); free(excluded_negated_quantifier);
							return false;
						}
						HOL_ANY.reference_count++;
						hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;

						unsigned int old_excluded_count = excluded_trees.length;
						for (unsigned int i = 0; i < dst.length; i++) {
							if (dst[i]->type == hol_term_type::ANY || dst[i]->type == hol_term_type::ANY_RIGHT || !can_have_free_variables(*dst[i])) continue;
							if ((!is_array && second != second_head) || (is_array && second_inverter.outer.length != 1)) {
								if (i < dst_start || i >= dst_end) continue;
								if (dst[i]->type != hol_term_type::NOT)
									excluded_trees[excluded_trees.length++] = excluded_negated_quantifier;
								if (!second_could_have_wide_scope)
									excluded_trees[excluded_trees.length++] = excluded_wide_scope;
								hol_term* new_outer = hol_term::new_any_right(dst_outer[i], excluded_trees.data, excluded_trees.length);
								if (new_outer == nullptr) {
									free_all(excluded_trees); free_all(dst); free_all(dst_outer);
									return false;
								}
								dst_outer[i] = new_outer;
								for (unsigned int i = 0; i < excluded_trees.length; i++)
									excluded_trees[i]->reference_count++;
							} else {
								if (dst[i]->type != hol_term_type::NOT)
									excluded_trees[excluded_trees.length++] = excluded_negated_quantifier;
								if (i >= dst_start && i < dst_end)
									excluded_trees[excluded_trees.length++] = excluded_wide_scope;
								hol_term* new_outer = hol_term::new_any_right(dst_outer[i], excluded_trees.data, excluded_trees.length);
								if (new_outer == nullptr) {
									free_all(excluded_trees); free_all(dst); free_all(dst_outer);
									return false;
								}
								dst_outer[i] = new_outer;
								for (unsigned int i = 0; i < excluded_trees.length; i++)
									excluded_trees[i]->reference_count++;
							}
							excluded_trees.length = old_excluded_count;
						}
						free_all(excluded_trees);
						free(*excluded_negated_quantifier); if (excluded_negated_quantifier->reference_count == 0) free(excluded_negated_quantifier);
						free(*excluded_wide_scope); if (excluded_wide_scope->reference_count == 0) free(excluded_wide_scope);
					} else {
						hol_term* excluded_negation = hol_term::new_any(hol_term::new_not(hol_term::new_exists(second_head->quantifier.variable, &HOL_ANY)));
						if (excluded_negation == nullptr) {
							free_all(dst); free_all(dst_outer);
							return false;
						}
						HOL_ANY.reference_count++;

						for (unsigned int i = dst_start; i < dst_end; i++) {
							hol_term* new_outer = hol_term::new_any_right(dst_outer[i], &excluded_negation, 1);
							if (new_outer == nullptr) {
								free(*excluded_negation); if (excluded_negation->reference_count == 0) free(excluded_negation);
								free_all(dst); free_all(dst_outer); return false;
							}
							dst_outer[i] = new_outer;
							excluded_negation->reference_count++;
						}
						free(*excluded_negation); if (excluded_negation->reference_count == 0) free(excluded_negation);
					}
					return (dst.length > 0);
				} else if (first_head->type == hol_term_type::EXISTS && first_head->quantifier.operand->type == hol_term_type::AND) {
					hol_term* first_head_operand = first_head->quantifier.operand;

					if ((!could_be_zero_negations && first_min_negations != expected_first_negations)
					 || (could_be_zero_negations && (first_min_negations != expected_first_negations && first_min_negations != 0)))
						return false;

					int conjunct_index = ConjunctIndex;
					if (ConjunctIndex < 0) conjunct_index += first_head_operand->array.length;
#if !defined(NDEBUG)
					if (conjunct_index == (int) first_predicate_index.index)
						fprintf(stderr, "invert_select_conjunct ERROR: `conjunct_index` and `first_predicate_index` are the same.\n");
#endif

					array<hol_term*> predicates(8);
					array<hol_term*> conjuncts(8);
					intersect<built_in_predicates>(predicates, first_head_operand->array.operands[first_predicate_index.index], second_head_operand->array.operands[0]);
					intersect<built_in_predicates>(conjuncts, first_head_operand->array.operands[conjunct_index], second_head_operand->array.operands[1]);
					unsigned int intersection_count = predicates.length * conjuncts.length;
					if (!dst.ensure_capacity(dst.length + intersection_count) || !dst_outer.ensure_capacity(dst_outer.length + intersection_count)) {
						for (hol_term* term : predicates) { free(*term); if (term->reference_count == 0) free(term); }
						for (hol_term* term : conjuncts) { free(*term); if (term->reference_count == 0) free(term); }
						return false;
					}
					for (hol_term* conjunct : conjuncts) {
						static unsigned int ARGS[] = { (unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3 };
						hol_term* arg_trees[array_length(ARGS)];
						unsigned int arg_tree_count = 0;
						for (unsigned int i = 0; i < array_length(ARGS); i++) {
							arg_trees[arg_tree_count] = hol_term::new_any(hol_term::new_apply(hol_term::new_constant(ARGS[i]), hol_term::new_variable(second_head->quantifier.variable)));
							if (arg_trees[arg_tree_count] == nullptr) {
								for (unsigned int j = 0; j < i; j++) { free(*arg_trees[j]); free(arg_trees[j]); }
								for (hol_term* term : predicates) { free(*term); if (term->reference_count == 0) free(term); }
								for (hol_term* term : conjuncts) { free(*term); if (term->reference_count == 0) free(term); }
								return false;
							}
							if (has_intersection<built_in_predicates>(arg_trees[arg_tree_count], conjunct)) {
								arg_tree_count++;
							} else {
								free(*arg_trees[arg_tree_count]); free(arg_trees[arg_tree_count]);
							}
						}
						for (hol_term* predicate : predicates) {
							hol_term* conjunction;
							if (!new_hol_term(conjunction)) {
								for (hol_term* term : predicates) { free(*term); if (term->reference_count == 0) free(term); }
								for (hol_term* term : conjuncts) { free(*term); if (term->reference_count == 0) free(term); }
								for (unsigned int k = 0; k < arg_tree_count; k++) { free(*arg_trees[k]); free(arg_trees[k]); }
								return false;
							}
							conjunction->type = hol_term_type::AND;
							conjunction->reference_count = 1;
							conjunction->array.length = first_head_operand->array.length;
							conjunction->array.operands = (hol_term**) malloc(sizeof(hol_term*) * first_head_operand->array.length);
							if (conjunction->array.operands == nullptr) {
								for (hol_term* term : predicates) { free(*term); if (term->reference_count == 0) free(term); }
								for (hol_term* term : conjuncts) { free(*term); if (term->reference_count == 0) free(term); }
								for (unsigned int k = 0; k < arg_tree_count; k++) { free(*arg_trees[k]); free(arg_trees[k]); }
								free(conjunction); return false;
							}
							bool skip = false;
							for (unsigned int i = 0; i < first_head_operand->array.length; i++) {
								if (i == first_predicate_index.index) {
									conjunction->array.operands[i] = predicate;
								} else if (i == (unsigned int) conjunct_index) {
									conjunction->array.operands[i] = conjunct;
								} else {
									for (unsigned int k = 0; k < arg_tree_count; k++) {
										if (has_intersection<built_in_predicates>(arg_trees[k], first_head_operand->array.operands[i])) {
											for (unsigned int j = 0; j < i; j++) {
												free(*conjunction->array.operands[i]);
												if (conjunction->array.operands[i]->reference_count == 0)
													free(conjunction->array.operands[i]);
											}
											free(conjunction); skip = true; break;
										}
									}
									if (skip) break;
									conjunction->array.operands[i] = first_head_operand->array.operands[i];
								}
								conjunction->array.operands[i]->reference_count++;
							}
							if (skip) continue;

							hol_term* new_head = hol_term::new_exists(first_head->quantifier.variable, conjunction);
							if (new_head == nullptr) {
								free(*conjunction); free(conjunction);
								for (hol_term* term : predicates) { free(*term); if (term->reference_count == 0) free(term); }
								for (hol_term* term : conjuncts) { free(*term); if (term->reference_count == 0) free(term); }
								for (unsigned int k = 0; k < arg_tree_count; k++) { free(*arg_trees[k]); free(arg_trees[k]); }
								free_all(dst); free_all(dst_outer); return false;
							}

							/* check if there `new_head` can have any free variables; if not, then set `any_right_only` to true */
							if (!can_have_free_variables(*new_head))
								any_right_only = true;

							if (could_be_zero_negations) {
								dst[dst.length++] = new_head;
								new_head->reference_count++;
							}
							if (expected_first_negations > 0) {
								for (unsigned int i = 0; i < expected_first_negations; i++) {
									hol_term* temp = hol_term::new_not(new_head);
									if (temp == nullptr) {
										for (hol_term* term : predicates) { free(*term); if (term->reference_count == 0) free(term); }
										for (hol_term* term : conjuncts) { free(*term); if (term->reference_count == 0) free(term); }
										for (unsigned int k = 0; k < arg_tree_count; k++) { free(*arg_trees[k]); free(arg_trees[k]); }
										free(*new_head); if (new_head->reference_count == 0) free(new_head);
										free_all(dst); free_all(dst_outer); return false;
									}
									new_head = temp;
								}
								dst[dst.length++] = new_head;
							}

							for (unsigned int j = 0; j < dst.length; j++) {
								if (!any_right_only && (old_second_head->type == hol_term_type::ANY || old_second_head->type == hol_term_type::ANY_RIGHT)) {
									dst_outer[dst_outer.length] = hol_term::new_any_right(&HOL_ZERO, old_second_head->any.excluded_trees, old_second_head->any.excluded_tree_count);
									if (dst_outer[dst_outer.length] == nullptr) {
										for (hol_term* term : predicates) { free(*term); if (term->reference_count == 0) free(term); }
										for (hol_term* term : conjuncts) { free(*term); if (term->reference_count == 0) free(term); }
										for (unsigned int k = 0; k < arg_tree_count; k++) { free(*arg_trees[k]); free(arg_trees[k]); }
										free_all(dst); free_all(dst_outer); return false;
									}
									for (unsigned int i = 0; i < old_second_head->any.excluded_tree_count; i++)
										old_second_head->any.excluded_trees[i]->reference_count++;
								} else {
									dst_outer[dst_outer.length] = &HOL_ZERO;
								}
								HOL_ZERO.reference_count++;
								dst_outer.length++;
							}
						}
						for (unsigned int k = 0; k < arg_tree_count; k++) { free(*arg_trees[k]); free(arg_trees[k]); }
					}
					for (hol_term* term : predicates) { free(*term); if (term->reference_count == 0) free(term); }
					for (hol_term* term : conjuncts) { free(*term); if (term->reference_count == 0) free(term); }
					return (dst.length > 0);
				} else {
					fprintf(stderr, "invert_select_conjunct ERROR: Unexpected type of `first_head`.\n");
					return false;
				}
			} else {
				return false;
			}
		});
}

enum class syntactic_type {
	BOOLEAN,
	INDIVIDUAL,
	STRING,
	ARG2_STRING_OBJECT, /* the type of an event whose arg2 has type STRING */
	ARG1_INDIVIDUAL_OBJECT, /* the type of an event whose arg1 has type INDIVIDUAL */
	NAME_OBJECT, /* the type of an event whose arg1 has type INDIVIDUAL and arg2 has type STRING */
	SAME_OBJECT, /* the type of an event whose arg1 and arg2 have the same type */
	SAME_STRING_OBJECT, /* the type of an event whose arg1 and arg2 both have type STRING */
	OTHER_OBJECT /* the type of an event whose arg1 and arg2 both have type INDIVIDUAL */
};

template<typename Stream>
inline bool print(const syntactic_type& base, Stream& out) {
	switch (base) {
	case syntactic_type::BOOLEAN:
		return print("𝝄", out);
	case syntactic_type::INDIVIDUAL:
		return print("𝜾", out);
	case syntactic_type::STRING:
		return print("str", out);
	case syntactic_type::ARG2_STRING_OBJECT:
		return print("(name+same_str)", out);
	case syntactic_type::ARG1_INDIVIDUAL_OBJECT:
		return print("(name+other)", out);
	case syntactic_type::NAME_OBJECT:
		return print("name", out);
	case syntactic_type::SAME_OBJECT:
		return print("(same_str+other)", out);
	case syntactic_type::SAME_STRING_OBJECT:
		return print("same_str", out);
	case syntactic_type::OTHER_OBJECT:
		return print("other", out);
	}
	fprintf(stderr, "print ERROR: Unrecognized syntactic_type.\n");
	return false;
}

template<>
struct base_types<syntactic_type> {
	static const hol_type<syntactic_type> BOOLEAN;
	static const hol_type<syntactic_type> INDIVIDUAL;
	static const hol_type<syntactic_type> STRING;
	static const hol_type<syntactic_type> ARG2_STRING_OBJECT;
	static const hol_type<syntactic_type> ARG1_INDIVIDUAL_OBJECT;
	static const hol_type<syntactic_type> NAME_OBJECT;
	static const hol_type<syntactic_type> SAME_OBJECT;
	static const hol_type<syntactic_type> SAME_STRING_OBJECT;
	static const hol_type<syntactic_type> OTHER_OBJECT;
	static const hol_type<syntactic_type> ANY;
	static const hol_type<syntactic_type> NONE;
};

const hol_type<syntactic_type> base_types<syntactic_type>::BOOLEAN(syntactic_type::BOOLEAN);
const hol_type<syntactic_type> base_types<syntactic_type>::INDIVIDUAL(syntactic_type::INDIVIDUAL);
const hol_type<syntactic_type> base_types<syntactic_type>::STRING(syntactic_type::STRING);
const hol_type<syntactic_type> base_types<syntactic_type>::ARG2_STRING_OBJECT(syntactic_type::ARG2_STRING_OBJECT);
const hol_type<syntactic_type> base_types<syntactic_type>::ARG1_INDIVIDUAL_OBJECT(syntactic_type::ARG1_INDIVIDUAL_OBJECT);
const hol_type<syntactic_type> base_types<syntactic_type>::NAME_OBJECT(syntactic_type::NAME_OBJECT);
const hol_type<syntactic_type> base_types<syntactic_type>::SAME_OBJECT(syntactic_type::SAME_OBJECT);
const hol_type<syntactic_type> base_types<syntactic_type>::SAME_STRING_OBJECT(syntactic_type::SAME_STRING_OBJECT);
const hol_type<syntactic_type> base_types<syntactic_type>::OTHER_OBJECT(syntactic_type::OTHER_OBJECT);
const hol_type<syntactic_type> base_types<syntactic_type>::ANY(hol_type_kind::ANY);
const hol_type<syntactic_type> base_types<syntactic_type>::NONE(hol_type_kind::NONE);

bool is_ambiguous(const hol_type<syntactic_type>& type)
{
	switch (type.kind) {
	case hol_type_kind::BASE:
		return (type.base != syntactic_type::BOOLEAN && type.base != syntactic_type::STRING
			 && type.base != syntactic_type::NAME_OBJECT && type.base != syntactic_type::SAME_STRING_OBJECT
			 && type.base != syntactic_type::OTHER_OBJECT);
	case hol_type_kind::NONE:
		return false;
	case hol_type_kind::FUNCTION:
		return is_ambiguous(*type.function.left) || is_ambiguous(*type.function.right);
	case hol_type_kind::POLYMORPHIC:
		return is_ambiguous(*type.polymorphic.operand);
	case hol_type_kind::VARIABLE:
	case hol_type_kind::ANY:
		return true;
	}
	fprintf(stderr, "is_ambiguous ERROR: Unrecognized hol_type_kind.\n");
	return false;
}

inline bool intersect(syntactic_type& out, syntactic_type first, syntactic_type second)
{
	if (first == syntactic_type::INDIVIDUAL) {
		if (second == syntactic_type::ARG1_INDIVIDUAL_OBJECT || second == syntactic_type::ARG2_STRING_OBJECT
		 || second == syntactic_type::NAME_OBJECT || second == syntactic_type::SAME_OBJECT
		 || second == syntactic_type::SAME_STRING_OBJECT || second == syntactic_type::OTHER_OBJECT
		 || second == syntactic_type::INDIVIDUAL)
		{
			out = second;
		} else {
			return false;
		}
	} else if (second == syntactic_type::INDIVIDUAL) {
		if (first == syntactic_type::ARG1_INDIVIDUAL_OBJECT || first == syntactic_type::ARG2_STRING_OBJECT
		 || first == syntactic_type::NAME_OBJECT || first == syntactic_type::SAME_OBJECT
		 || first == syntactic_type::SAME_STRING_OBJECT || first == syntactic_type::OTHER_OBJECT)
		{
			out = first;
		} else {
			return false;
		}
	} else if (first == syntactic_type::ARG2_STRING_OBJECT) {
		if (second == syntactic_type::NAME_OBJECT || second == syntactic_type::SAME_STRING_OBJECT || second == syntactic_type::ARG2_STRING_OBJECT) {
			out = second;
		} else if (second == syntactic_type::SAME_OBJECT) {
			out = syntactic_type::SAME_STRING_OBJECT;
		} else if (second == syntactic_type::ARG1_INDIVIDUAL_OBJECT) {
			out = syntactic_type::NAME_OBJECT;
		} else {
			return false;
		}
	} else if (second == syntactic_type::ARG2_STRING_OBJECT) {
		if (first == syntactic_type::NAME_OBJECT || first == syntactic_type::SAME_STRING_OBJECT) {
			out = first;
		} else if (first == syntactic_type::SAME_OBJECT) {
			out = syntactic_type::SAME_STRING_OBJECT;
		} else if (first == syntactic_type::ARG1_INDIVIDUAL_OBJECT) {
			out = syntactic_type::NAME_OBJECT;
		} else {
			return false;
		}
	} else if (first == syntactic_type::ARG1_INDIVIDUAL_OBJECT) {
		if (second == syntactic_type::OTHER_OBJECT || second == syntactic_type::NAME_OBJECT || second == syntactic_type::ARG1_INDIVIDUAL_OBJECT) {
			out = second;
		} else if (second == syntactic_type::SAME_OBJECT) {
			out = syntactic_type::OTHER_OBJECT;
		} else {
			return false;
		}
	} else if (second == syntactic_type::ARG1_INDIVIDUAL_OBJECT) {
		if (first == syntactic_type::OTHER_OBJECT || first == syntactic_type::NAME_OBJECT) {
			out = first;
		} else if (first == syntactic_type::SAME_OBJECT) {
			out = syntactic_type::OTHER_OBJECT;
		} else {
			return false;
		}
	} else if (first == syntactic_type::SAME_OBJECT) {
		if (second == syntactic_type::SAME_STRING_OBJECT || second == syntactic_type::OTHER_OBJECT || second == syntactic_type::SAME_OBJECT) {
			out = second;
		} else {
			return false;
		}
	} else if (second == syntactic_type::SAME_OBJECT) {
		if (first == syntactic_type::SAME_STRING_OBJECT || first == syntactic_type::OTHER_OBJECT) {
			out = first;
		} else {
			return false;
		}
	} else if (first == second) {
		out = first;
	} else {
		return false;
	}
	return true;
}

inline bool intersect(
		hol_type<syntactic_type>& out, syntactic_type first,
		const hol_function_type<syntactic_type>& second)
{
	if (first == syntactic_type::INDIVIDUAL) {
		return init(out, *second.left, *second.right);
	} else {
		return false;
	}
}

template<built_in_predicates Arg>
inline hol_type<syntactic_type> get_expected_type(const hol_type<syntactic_type>& expected_type) {
	if (expected_type == base_types<syntactic_type>::NONE)
		return base_types<syntactic_type>::NONE;
	if (Arg == built_in_predicates::ARG1) {
		if (expected_type == base_types<syntactic_type>::ANY)
			return base_types<syntactic_type>::INDIVIDUAL;
		else if (expected_type == base_types<syntactic_type>::STRING)
			return base_types<syntactic_type>::SAME_STRING_OBJECT;
		else return base_types<syntactic_type>::ARG1_INDIVIDUAL_OBJECT;
	} else if (Arg == built_in_predicates::ARG2) {
		if (expected_type == base_types<syntactic_type>::ANY)
			return base_types<syntactic_type>::INDIVIDUAL;
		else if (expected_type == base_types<syntactic_type>::STRING)
			return base_types<syntactic_type>::ARG2_STRING_OBJECT;
		else return base_types<syntactic_type>::OTHER_OBJECT;
	} else if (Arg == built_in_predicates::ARG3) {
		return base_types<syntactic_type>::OTHER_OBJECT;
	} else if (Arg == built_in_predicates::ARG1_OF) {
		if (expected_type == base_types<syntactic_type>::ANY || expected_type == base_types<syntactic_type>::ARG2_STRING_OBJECT || expected_type == base_types<syntactic_type>::SAME_OBJECT)
			return base_types<syntactic_type>::ANY;
		else if (expected_type == base_types<syntactic_type>::SAME_STRING_OBJECT)
			return base_types<syntactic_type>::STRING;
		else return base_types<syntactic_type>::INDIVIDUAL;
	} else if (Arg == built_in_predicates::ARG2_OF) {
		if (expected_type == base_types<syntactic_type>::ANY || expected_type == base_types<syntactic_type>::SAME_OBJECT)
			return base_types<syntactic_type>::ANY;
		else if (expected_type == base_types<syntactic_type>::ARG2_STRING_OBJECT || expected_type == base_types<syntactic_type>::NAME_OBJECT || expected_type == base_types<syntactic_type>::SAME_STRING_OBJECT)
			return base_types<syntactic_type>::STRING;
		return base_types<syntactic_type>::INDIVIDUAL;
	} else if (Arg == built_in_predicates::ARG3_OF) {
		if (expected_type == base_types<syntactic_type>::SAME_OBJECT || expected_type == base_types<syntactic_type>::SAME_STRING_OBJECT || expected_type == base_types<syntactic_type>::NAME_OBJECT)
			return base_types<syntactic_type>::NONE;
		else return base_types<syntactic_type>::INDIVIDUAL;
	}
}

/* forward declaration */
bool check_type(hol_term*, unsigned int,
		pair<bool, size_t>, array<hol_term*>&,
		array_map<hol_term*, hol_type<syntactic_type>>&,
		array_map<unsigned int, hol_type<syntactic_type>>&,
		array<hol_type<syntactic_type>>&);

template<bool ExpectBound = false>
inline bool check_variable_type(unsigned int other_variable,
		hol_type<syntactic_type>& expected_other_type, const array<hol_term*>& outer_scopes,
		array_map<hol_term*, hol_type<syntactic_type>>& bound_variable_types,
		array_map<unsigned int, hol_type<syntactic_type>>& free_variable_types,
		array<hol_type<syntactic_type>>& type_variables)
{
	unsigned int i;
	hol_term* declaring_scope = nullptr;
	for (i = outer_scopes.length; i > 0 && declaring_scope == nullptr; i--) {
		if (outer_scopes[i - 1]->type != hol_term_type::EXISTS && outer_scopes[i - 1]->type != hol_term_type::FOR_ALL && outer_scopes[i - 1]->type != hol_term_type::LAMBDA) continue;
		if (outer_scopes[i - 1]->quantifier.variable == other_variable)
			declaring_scope = outer_scopes[i - 1];
	}

	if (ExpectBound && declaring_scope == nullptr)
		return false;

	bool contains;
	pair<bool, size_t> new_index(false, 0);
	if (declaring_scope != nullptr) {
		if (!bound_variable_types.ensure_capacity(bound_variable_types.size + 1)) return false;
		hol_type<syntactic_type>& other_var_type = bound_variable_types.get(declaring_scope, contains);
		if (contains)
			return expect_type<true>(other_var_type, expected_other_type, type_variables);
		else if (!init(bound_variable_types.values[bound_variable_types.size], expected_other_type))
			return false;
		bound_variable_types.keys[bound_variable_types.size] = declaring_scope;
		new_index = {true, bound_variable_types.size++};
	} else {
		if (!free_variable_types.ensure_capacity(free_variable_types.size + 1)) return false;
		hol_type<syntactic_type>& other_var_type = free_variable_types.get(other_variable, contains);
		if (contains)
			return expect_type<true>(other_var_type, expected_other_type, type_variables);
		else if (!init(free_variable_types.values[free_variable_types.size], expected_other_type))
			return false;
		free_variable_types.keys[free_variable_types.size] = other_variable;
		declaring_scope = outer_scopes[0];
		new_index = {false, free_variable_types.size++};
	}

	array<hol_term*> new_outer_scopes(i + 1);
	new_outer_scopes[new_outer_scopes.length++] = outer_scopes[0];
	for (unsigned int j = 1; j <= i; j++)
		new_outer_scopes[new_outer_scopes.length++] = outer_scopes[j];

	if (!check_type(declaring_scope->quantifier.operand, other_variable, new_index, new_outer_scopes, bound_variable_types, free_variable_types, type_variables))
		return false;

	array<pair<unsigned int, bool>> visited_variables(8);
	for (auto entry : bound_variable_types)
		if (!flatten_type_variable<true, false>(entry.value, visited_variables, type_variables)) return false;
	for (auto entry : free_variable_types)
		if (!flatten_type_variable<true, false>(entry.value, visited_variables, type_variables)) return false;
	free(expected_other_type);
	return init(expected_other_type, new_index.key ? bound_variable_types.values[new_index.value] : free_variable_types.values[new_index.value]);
}

template<built_in_predicates Arg>
inline bool check_arg_type(unsigned int other_variable,
		pair<bool, size_t> index, const array<hol_term*>& outer_scopes,
		array_map<hol_term*, hol_type<syntactic_type>>& bound_variable_types,
		array_map<unsigned int, hol_type<syntactic_type>>& free_variable_types,
		array<hol_type<syntactic_type>>& type_variables)
{
	hol_type<syntactic_type> expected_other_type = get_expected_type<Arg>(index.key ? bound_variable_types.values[index.value] : free_variable_types.values[index.value]);
	if (!check_variable_type(other_variable, expected_other_type, outer_scopes, bound_variable_types, free_variable_types, type_variables))
		return false;
	return expect_type<true>(get_expected_type<invert_arg<Arg>::value>(expected_other_type), index.key ? bound_variable_types.values[index.value] : free_variable_types.values[index.value], type_variables);
}

bool check_type(hol_term* term, unsigned int variable,
		pair<bool, size_t> index, array<hol_term*>& outer_scopes,
		array_map<hol_term*, hol_type<syntactic_type>>& bound_variable_types,
		array_map<unsigned int, hol_type<syntactic_type>>& free_variable_types,
		array<hol_type<syntactic_type>>& type_variables)
{
	hol_term* right;
	switch (term->type) {
	case hol_term_type::CONSTANT:
	case hol_term_type::VARIABLE_PREIMAGE:
	case hol_term_type::PARAMETER:
	case hol_term_type::NUMBER:
	case hol_term_type::STRING:
	case hol_term_type::UINT_LIST:
	case hol_term_type::LAMBDA:
	case hol_term_type::ANY:
	case hol_term_type::ANY_RIGHT:
	case hol_term_type::ANY_RIGHT_ONLY:
	case hol_term_type::ANY_CONSTANT:
	case hol_term_type::ANY_CONSTANT_EXCEPT:
	case hol_term_type::ANY_QUANTIFIER:
		return true;
	case hol_term_type::VARIABLE:
		/* we assume the expression `term` has type boolean (proposition) */
		if (term->variable == variable)
			return expect_type<true>(base_types<syntactic_type>::BOOLEAN, index.key ? bound_variable_types.values[index.value] : free_variable_types.values[index.value], type_variables);
		else return true;
	case hol_term_type::NOT:
		return check_type(term->unary.operand, variable, index, outer_scopes, bound_variable_types, free_variable_types, type_variables);
	case hol_term_type::AND:
	case hol_term_type::OR:
	case hol_term_type::IFF:
		for (unsigned int i = 0; i < term->array.length; i++) {
			if (!check_type(term->array.operands[i], variable, index, outer_scopes, bound_variable_types, free_variable_types, type_variables)) return false;
			if (!is_ambiguous(index.key ? bound_variable_types.values[index.value] : free_variable_types.values[index.value])) break;
		}
		return true;
	case hol_term_type::ANY_ARRAY:
		if (!check_type(term->any_array.all, variable, index, outer_scopes, bound_variable_types, free_variable_types, type_variables)) return false;
		if (!is_ambiguous(index.key ? bound_variable_types.values[index.value] : free_variable_types.values[index.value])) return true;
		for (unsigned int i = 0; i < term->any_array.left.length; i++) {
			if (!check_type(term->any_array.left.operands[i], variable, index, outer_scopes, bound_variable_types, free_variable_types, type_variables)) return false;
			if (!is_ambiguous(index.key ? bound_variable_types.values[index.value] : free_variable_types.values[index.value])) return true;
		} for (unsigned int i = 0; i < term->any_array.right.length; i++) {
			if (!check_type(term->any_array.right.operands[i], variable, index, outer_scopes, bound_variable_types, free_variable_types, type_variables)) return false;
			if (!is_ambiguous(index.key ? bound_variable_types.values[index.value] : free_variable_types.values[index.value])) return true;
		} for (unsigned int i = 0; i < term->any_array.any.length; i++) {
			if (!check_type(term->any_array.any.operands[i], variable, index, outer_scopes, bound_variable_types, free_variable_types, type_variables)) return false;
			if (!is_ambiguous(index.key ? bound_variable_types.values[index.value] : free_variable_types.values[index.value])) return true;
		}
		return true;
	case hol_term_type::IF_THEN:
		return check_type(term->binary.left, variable, index, outer_scopes, bound_variable_types, free_variable_types, type_variables)
			&& (!is_ambiguous(index.key ? bound_variable_types.values[index.value] : free_variable_types.values[index.value])
			 || check_type(term->binary.right, variable, index, outer_scopes, bound_variable_types, free_variable_types, type_variables));
	case hol_term_type::EQUALS:
		if (term->binary.left->type == hol_term_type::UNARY_APPLICATION
		 && term->binary.left->binary.left->type == hol_term_type::CONSTANT
		 && term->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG1
		 && term->binary.left->binary.right->type == hol_term_type::VARIABLE
		 && term->binary.right->type == hol_term_type::VARIABLE
		 && term->binary.right->variable == variable)
		{
			return check_arg_type<built_in_predicates::ARG1>(term->binary.left->binary.right->variable, index, outer_scopes, bound_variable_types, free_variable_types, type_variables);
		} else if (term->binary.left->type == hol_term_type::UNARY_APPLICATION
				&& term->binary.left->binary.left->type == hol_term_type::CONSTANT
				&& term->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG1
				&& term->binary.left->binary.right->type == hol_term_type::VARIABLE
				&& term->binary.left->binary.right->variable == variable
				&& term->binary.right->type == hol_term_type::VARIABLE)
		{
			return check_arg_type<built_in_predicates::ARG1_OF>(term->binary.right->variable, index, outer_scopes, bound_variable_types, free_variable_types, type_variables);
		} else if (term->binary.left->type == hol_term_type::UNARY_APPLICATION
				&& term->binary.left->binary.left->type == hol_term_type::CONSTANT
				&& term->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG2
				&& term->binary.left->binary.right->type == hol_term_type::VARIABLE
				&& term->binary.right->type == hol_term_type::VARIABLE
				&& term->binary.right->variable == variable)
		{
			return check_arg_type<built_in_predicates::ARG2>(term->binary.left->binary.right->variable, index, outer_scopes, bound_variable_types, free_variable_types, type_variables);
		} else if (term->binary.left->type == hol_term_type::UNARY_APPLICATION
				&& term->binary.left->binary.left->type == hol_term_type::CONSTANT
				&& term->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG2
				&& term->binary.left->binary.right->type == hol_term_type::VARIABLE
				&& term->binary.left->binary.right->variable == variable
				&& term->binary.right->type == hol_term_type::VARIABLE)
		{
			return check_arg_type<built_in_predicates::ARG2_OF>(term->binary.right->variable, index, outer_scopes, bound_variable_types, free_variable_types, type_variables);
		} else if (term->binary.left->type == hol_term_type::UNARY_APPLICATION
				&& term->binary.left->binary.left->type == hol_term_type::CONSTANT
				&& term->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG1_OF
				&& term->binary.left->binary.right->type == hol_term_type::VARIABLE
				&& term->binary.left->binary.right->variable == variable
				&& term->binary.right->type == hol_term_type::VARIABLE)
		{
			return check_arg_type<built_in_predicates::ARG1>(term->binary.right->variable, index, outer_scopes, bound_variable_types, free_variable_types, type_variables);
		} else if (term->binary.left->type == hol_term_type::UNARY_APPLICATION
				&& term->binary.left->binary.left->type == hol_term_type::CONSTANT
				&& term->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG1_OF
				&& term->binary.left->binary.right->type == hol_term_type::VARIABLE
				&& term->binary.right->type == hol_term_type::VARIABLE
				&& term->binary.right->variable == variable)
		{
			return check_arg_type<built_in_predicates::ARG1_OF>(term->binary.left->binary.right->variable, index, outer_scopes, bound_variable_types, free_variable_types, type_variables);
		} else if (term->binary.left->type == hol_term_type::UNARY_APPLICATION
				&& term->binary.left->binary.left->type == hol_term_type::CONSTANT
				&& term->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG2_OF
				&& term->binary.left->binary.right->type == hol_term_type::VARIABLE
				&& term->binary.left->binary.right->variable == variable
				&& term->binary.right->type == hol_term_type::VARIABLE)
		{
			return check_arg_type<built_in_predicates::ARG2>(term->binary.right->variable, index, outer_scopes, bound_variable_types, free_variable_types, type_variables);
		} else if (term->binary.left->type == hol_term_type::UNARY_APPLICATION
				&& term->binary.left->binary.left->type == hol_term_type::CONSTANT
				&& term->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG2_OF
				&& term->binary.left->binary.right->type == hol_term_type::VARIABLE
				&& term->binary.right->type == hol_term_type::VARIABLE
				&& term->binary.right->variable == variable)
		{
			return check_arg_type<built_in_predicates::ARG2_OF>(term->binary.left->binary.right->variable, index, outer_scopes, bound_variable_types, free_variable_types, type_variables);
		} else if (term->binary.left->type == hol_term_type::VARIABLE && term->binary.left->variable == variable) {
			right = term->binary.right;
		} else if (term->binary.right->type == hol_term_type::VARIABLE && term->binary.right->variable == variable) {
			right = term->binary.left;
		} else {
			return true;
		}

		if (right->type == hol_term_type::STRING) {
			hol_type<syntactic_type>& expected_type = (index.key ? bound_variable_types.values[index.value] : free_variable_types.values[index.value]);
			return expect_type<true>(base_types<syntactic_type>::STRING, expected_type, type_variables);
		} else if (right->type == hol_term_type::CONSTANT || right->type == hol_term_type::NUMBER) {
			hol_type<syntactic_type>& expected_type = (index.key ? bound_variable_types.values[index.value] : free_variable_types.values[index.value]);
			return expect_type<true>(base_types<syntactic_type>::INDIVIDUAL, expected_type, type_variables);
		} else if (right->type == hol_term_type::VARIABLE) {
			hol_type<syntactic_type>& expected_type = (index.key ? bound_variable_types.values[index.value] : free_variable_types.values[index.value]);
			return check_variable_type(right->variable, expected_type, outer_scopes, bound_variable_types, free_variable_types, type_variables);
		} else if (right->type == hol_term_type::LAMBDA) {
			bool contains;
			hol_type<syntactic_type>& type = bound_variable_types.get(right, contains);
			hol_type<syntactic_type>& expected_type = (index.key ? bound_variable_types.values[index.value] : free_variable_types.values[index.value]);
			if (contains)
				return expect_type<true>(type, expected_type, type_variables);
			if (!outer_scopes.add(right)
			 || !type_variables.ensure_capacity(type_variables.length + 1)
			 || !init(type_variables[type_variables.length], hol_type_kind::ANY)
			 || !expect_type<true>(hol_type<syntactic_type>(hol_type<syntactic_type>(type_variables.length), base_types<syntactic_type>::BOOLEAN), expected_type, type_variables)
			 || !bound_variable_types.ensure_capacity(bound_variable_types.size + 1))
				return false;
			bound_variable_types.keys[bound_variable_types.size] = right;
			bound_variable_types.values[bound_variable_types.size].kind = hol_type_kind::VARIABLE;
			bound_variable_types.values[bound_variable_types.size].variable = type_variables.length;
			bound_variable_types.size++;
			type_variables.length++;

			if (!check_type(right->quantifier.operand, right->quantifier.variable, {true, bound_variable_types.size - 1}, outer_scopes, bound_variable_types, free_variable_types, type_variables) || !outer_scopes.pop())
				return false;

			array<pair<unsigned int, bool>> visited_variables(8);
			for (auto entry : bound_variable_types)
				if (!flatten_type_variable<true, false>(entry.value, visited_variables, type_variables)) return false;
			for (auto entry : free_variable_types)
				if (!flatten_type_variable<true, false>(entry.value, visited_variables, type_variables)) return false;
		}
		return true;
	case hol_term_type::UNARY_APPLICATION:
		if (term->binary.right->type == hol_term_type::VARIABLE && term->binary.right->variable == variable) {
			hol_type<syntactic_type>& expected_type = (index.key ? bound_variable_types.values[index.value] : free_variable_types.values[index.value]);
			if (term->binary.left->type == hol_term_type::CONSTANT && term->binary.left->constant == (unsigned int) built_in_predicates::NAME) {
				return expect_type<true>(base_types<syntactic_type>::NAME_OBJECT, expected_type, type_variables);
			} else if (term->binary.left->type == hol_term_type::CONSTANT && term->binary.left->constant == (unsigned int) built_in_predicates::SAME) {
				return expect_type<true>(base_types<syntactic_type>::SAME_OBJECT, expected_type, type_variables);
			} else if (has_intersection<built_in_predicates>(hol_tense_constants<built_in_predicates>::get().constants, term->binary.left)) {
				return expect_type<true>(base_types<syntactic_type>::INDIVIDUAL, expected_type, type_variables);
			} else if (has_intersection<built_in_predicates>(&HOL_NAME, term->binary.left)) {
				if (has_intersection<built_in_predicates>(&HOL_SAME, term->binary.left))
					return expect_type<true>(base_types<syntactic_type>::INDIVIDUAL, expected_type, type_variables);
				else return expect_type<true>(base_types<syntactic_type>::ARG1_INDIVIDUAL_OBJECT, expected_type, type_variables);
			} else if (has_intersection<built_in_predicates>(&HOL_SAME, term->binary.left)) {
				return expect_type<true>(base_types<syntactic_type>::SAME_OBJECT, expected_type, type_variables);
			} else {
				return expect_type<true>(base_types<syntactic_type>::OTHER_OBJECT, expected_type, type_variables);
			}
		}
		return true;
	case hol_term_type::BINARY_APPLICATION:
		if (term->ternary.first->type == hol_term_type::CONSTANT && term->ternary.first->constant == (unsigned int) built_in_predicates::SUBSET
		 && term->ternary.second->type == hol_term_type::VARIABLE && term->ternary.second->variable == variable)
		{
			hol_type<syntactic_type>& expected_type = (index.key ? bound_variable_types.values[index.value] : free_variable_types.values[index.value]);
			if (term->ternary.third->type == hol_term_type::VARIABLE) {
				return check_variable_type(term->ternary.third->variable, expected_type, outer_scopes, bound_variable_types, free_variable_types, type_variables);
			} else if (term->ternary.third->type == hol_term_type::LAMBDA) {
				bool contains;
				hol_type<syntactic_type>& type = bound_variable_types.get(term->ternary.third, contains);
				if (contains)
					return expect_type<true>(type, expected_type, type_variables);
				if (!outer_scopes.add(term->ternary.third)
				 || !type_variables.ensure_capacity(type_variables.length + 1)
				 || !init(type_variables[type_variables.length], hol_type_kind::ANY)
				 || !expect_type<true>(hol_type<syntactic_type>(hol_type<syntactic_type>(type_variables.length), base_types<syntactic_type>::BOOLEAN), expected_type, type_variables)
				 || !bound_variable_types.ensure_capacity(bound_variable_types.size + 1))
					return false;
				bound_variable_types.keys[bound_variable_types.size] = term->ternary.third;
				bound_variable_types.values[bound_variable_types.size].kind = hol_type_kind::VARIABLE;
				bound_variable_types.values[bound_variable_types.size].variable = type_variables.length;
				bound_variable_types.size++;
				type_variables.length++;

				if (!check_type(term->ternary.third->quantifier.operand, term->ternary.third->quantifier.variable, {true, bound_variable_types.size - 1}, outer_scopes, bound_variable_types, free_variable_types, type_variables)
				 || !outer_scopes.pop())
					return false;

				array<pair<unsigned int, bool>> visited_variables(8);
				for (auto entry : bound_variable_types)
					if (!flatten_type_variable<true, false>(entry.value, visited_variables, type_variables)) return false;
				for (auto entry : free_variable_types)
					if (!flatten_type_variable<true, false>(entry.value, visited_variables, type_variables)) return false;
			}
		}
		return true;
	case hol_term_type::FOR_ALL:
	case hol_term_type::EXISTS:
		return outer_scopes.add(term)
			&& check_type(term->quantifier.operand, variable, index, outer_scopes, bound_variable_types, free_variable_types, type_variables)
			&& outer_scopes.pop();
	case hol_term_type::TRUE:
	case hol_term_type::FALSE:
		return true;
	}
	fprintf(stderr, "check_type ERROR: Unrecognized hol_term_type.\n");
	return false;
}

inline hol_type<syntactic_type> get_type(unsigned int variable, const array<hol_term*>& parent_scopes)
{
	hol_type<syntactic_type> expected_other_type(hol_type_kind::ANY);
	array_map<hol_term*, hol_type<syntactic_type>> bound_variable_types(8);
	array_map<unsigned int, hol_type<syntactic_type>> free_variable_types(8);
	array<hol_type<syntactic_type>> type_variables(8);
	if (!check_variable_type<true>(variable, expected_other_type, parent_scopes, bound_variable_types, free_variable_types, type_variables)) {
		for (auto entry : bound_variable_types) free(entry.value);
		for (auto entry : free_variable_types) free(entry.value);
		for (hol_type<syntactic_type>& entry : type_variables) free(entry);
		return base_types<syntactic_type>::NONE;
	}
	hol_type<syntactic_type> to_return = bound_variable_types.values[0];
	for (auto entry : bound_variable_types) free(entry.value);
	for (auto entry : free_variable_types) free(entry.value);
	for (hol_type<syntactic_type>& entry : type_variables) free(entry);
	return to_return;
}

hol_type<syntactic_type> get_type(hol_term* term, const array<hol_term*>& parent_scopes)
{
	if (term->type == hol_term_type::STRING) {
		return base_types<syntactic_type>::STRING;
	} else if (term->type == hol_term_type::CONSTANT || term->type == hol_term_type::NUMBER) {
		return base_types<syntactic_type>::INDIVIDUAL;
	} else if (term->type == hol_term_type::VARIABLE) {
		return get_type(term->variable, parent_scopes);
	} else {
		return base_types<syntactic_type>::NONE;
	}
}

template<int_fast8_t ConjunctIndex, bool RemoveNegation = false>
inline bool invert_remove_conjunct(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	auto on_remap_variables = [](hol_term* first_head, hol_term* second_head,
			apply_head_inverter& first_head_inverter, apply_head_inverter& second_head_inverter,
			array_map<const hol_term*, unsigned int>& second_variable_map, unsigned int max_variable,
			bool first_head_is_array, bool second_head_is_array)
	{
		if ((second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT) && second_head->any.included != nullptr) {
			second_head = second_head->any.included;
			if (!second_head_inverter.outer.add(second_head))
				return false;
		}

		while (first_head->type == hol_term_type::NOT) {
			first_head = first_head->unary.operand;
			if (!first_head_inverter.outer.add(first_head))
				return false;
		}
		while (second_head->type == hol_term_type::NOT) {
			second_head = second_head->unary.operand;
			if (!second_head_inverter.outer.add(second_head))
				return false;
		}

		/* make sure the non-right-leaning trees in `second` don't declare
		   variables that have already been declared in the right-leaning path
		   in `first` from the root to the head */
		array<unsigned int> declared_variables(8);
		for (hol_term* node : first_head_inverter.outer) {
			if (node->type == hol_term_type::EXISTS || node->type == hol_term_type::FOR_ALL || node->type == hol_term_type::LAMBDA) {
				if (!declared_variables.add(node->quantifier.variable)) {
					for (auto entry : second_variable_map) free(entry.value);
					return false;
				}
			}
		}
		array<hol_term*> second_scopes(16);
		for (unsigned int j = 0; j < second_head_inverter.outer.length; j++) {
			if (second_head_is_array && j + 2 >= second_head_inverter.outer.length)
				break;
			hol_term* node = second_head_inverter.outer[j];
			if (node->type == hol_term_type::AND || node->type == hol_term_type::OR || node->type == hol_term_type::IFF) {
				for (unsigned int i = 0; i + 1 < node->array.length; i++) {
					if (!get_scopes(*node->array.operands[i], second_scopes)) {
						for (auto entry : second_variable_map) free(entry.value);
						return false;
					}
				}
			} else if (node->type == hol_term_type::IF_THEN || node->type == hol_term_type::UNARY_APPLICATION || node->type == hol_term_type::EQUALS) {
				if (!get_scopes(*node->binary.left, second_scopes)) {
					for (auto entry : second_variable_map) free(entry.value);
					return false;
				}
			} else if (node->type == hol_term_type::BINARY_APPLICATION) {
				if (!get_scopes(*node->ternary.first, second_scopes)
				 || !get_scopes(*node->ternary.second, second_scopes))
				{
					for (auto entry : second_variable_map) free(entry.value);
					return false;
				}
			} else if (node->type == hol_term_type::ANY_ARRAY) {
				for (unsigned int i = 0; i < node->any_array.left.length; i++) {
					if (!get_scopes(*node->any_array.left.operands[i], second_scopes)) {
						for (auto entry : second_variable_map) free(entry.value);
						return false;
					}
				} for (unsigned int i = 0; i < node->any_array.any.length; i++) {
					if (!get_scopes(*node->any_array.any.operands[i], second_scopes)) {
						for (auto entry : second_variable_map) free(entry.value);
						return false;
					}
				} for (unsigned int i = 0; i + 1 < node->any_array.right.length; i++) {
					if (!get_scopes(*node->any_array.right.operands[i], second_scopes)) {
						for (auto entry : second_variable_map) free(entry.value);
						return false;
					}
				}
			}
		}
		for (hol_term* scope : second_scopes) {
			if ((scope->type == hol_term_type::EXISTS || scope->type == hol_term_type::FOR_ALL || scope->type == hol_term_type::LAMBDA)
			 && declared_variables.contains(scope->quantifier.variable)
			 && !second_variable_map.put(scope, ++max_variable))
			{
				for (auto entry : second_variable_map) free(entry.value);
				return false;
			}
		}


		/* make sure the initial lambda variables are correctly mapped */
		if (first_head_inverter.outer[0]->type == hol_term_type::LAMBDA) {
			if (second_head_inverter.outer[0]->type == hol_term_type::LAMBDA) {
				if (!second_variable_map.ensure_capacity(second_variable_map.size + 1)) {
					for (auto entry : second_variable_map) free(entry.value);
					return false;
				}

				unsigned int first_lambda_variable = first_head_inverter.outer[0]->quantifier.variable;
				hol_term* second_lambda = second_head_inverter.outer[0];
				unsigned int index = second_variable_map.index_of(second_lambda);
				if (index < second_variable_map.size && first_lambda_variable == second_variable_map.values[index]) {
					/* `second_variable_map` should map `var` to itself */
					second_variable_map.remove_at(index);
				} else {
					/* `second_variable_map` should map `var` to `target_var` */
					second_variable_map.values[index] = first_lambda_variable;
					if (index == second_variable_map.size) {
						second_variable_map.keys[index] = second_lambda;
						second_variable_map.size++;
					}
				}
			} else {
				/* the lambda is removed from `first` to `second` */
				array<hol_term*> second_scopes(8);
				if (!get_scopes(*second_head_inverter.outer[0], second_scopes)) {
					for (auto entry : second_variable_map) free(entry.value);
					return false;
				}
				unsigned int first_lambda_variable = first_head_inverter.outer[0]->quantifier.variable;
				for (hol_term* scope : second_scopes) {
					if (scope->quantifier.variable == first_lambda_variable) {
						if (!second_variable_map.ensure_capacity(second_variable_map.size + 1)) {
							for (auto entry : second_variable_map) free(entry.value);
							return false;
						}

						unsigned int index = second_variable_map.index_of(scope);
						if (index == second_variable_map.size || second_variable_map.values[index] == first_lambda_variable) {
							second_variable_map.keys[index] = scope;
							second_variable_map.values[index] = ++max_variable;
							if (index == second_variable_map.size)
								second_variable_map.size++;
						}
					}
				}
			}
		}

		if (second_head->type != hol_term_type::EXISTS)
			return false;
		if (first_head->type != hol_term_type::EXISTS)
			return true;

		hol_term* first_operand = first_head->quantifier.operand;
		hol_term* new_conjunction;
		if (first_operand->type == hol_term_type::ANY || first_operand->type == hol_term_type::ANY_RIGHT) {
			return true;
		} else if (first_operand->type == hol_term_type::ANY_ARRAY && first_operand->any_array.oper == hol_term_type::AND) {
			if (second_head->type == hol_term_type::EXISTS && second_head->quantifier.operand->type == hol_term_type::ANY_ARRAY)
				return false; /* NOTE: even though this intersection could exist, we prune it to avoid logical form outputs with ANY_ARRAYs */
			if (ConjunctIndex >= 0) {
				if (ConjunctIndex < first_operand->any_array.left.length) {
					new_conjunction = hol_term::new_any_array(hol_term_type::AND,
							first_operand->any_array.all, make_array_view(first_operand->any_array.any.operands, first_operand->any_array.any.length),
							make_excluded_array_view(first_operand->any_array.left.operands, first_operand->any_array.left.length, ConjunctIndex),
							make_array_view(first_operand->any_array.right.operands, first_operand->any_array.right.length));
					if (new_conjunction == nullptr)
						return false;
					new_conjunction->any_array.all->reference_count++;
					for (unsigned int i = 0; i < new_conjunction->any_array.left.length; i++)
						new_conjunction->any_array.left.operands[i]->reference_count++;
					for (unsigned int i = 0; i < new_conjunction->any_array.right.length; i++)
						new_conjunction->any_array.right.operands[i]->reference_count++;
					for (unsigned int i = 0; i < new_conjunction->any_array.any.length; i++)
						new_conjunction->any_array.any.operands[i]->reference_count++;
				} else {
					new_conjunction = first_operand;
					first_operand->reference_count++;
				}
			} else {
				if (-ConjunctIndex <= first_operand->any_array.right.length) {
					new_conjunction = hol_term::new_any_array(hol_term_type::AND,
							first_operand->any_array.all, make_array_view(first_operand->any_array.any.operands, first_operand->any_array.any.length),
							make_array_view(first_operand->any_array.left.operands, first_operand->any_array.left.length),
							make_excluded_array_view(first_operand->any_array.right.operands, first_operand->any_array.right.length, first_operand->any_array.right.length + ConjunctIndex));
					if (new_conjunction == nullptr)
						return false;
					new_conjunction->any_array.all->reference_count++;
					for (unsigned int i = 0; i < new_conjunction->any_array.left.length; i++)
						new_conjunction->any_array.left.operands[i]->reference_count++;
					for (unsigned int i = 0; i < new_conjunction->any_array.right.length; i++)
						new_conjunction->any_array.right.operands[i]->reference_count++;
					for (unsigned int i = 0; i < new_conjunction->any_array.any.length; i++)
						new_conjunction->any_array.any.operands[i]->reference_count++;
				} else {
					new_conjunction = first_operand;
					first_operand->reference_count++;
				}
			}
		} else if (first_operand->type == hol_term_type::AND) {
			unsigned int index = (ConjunctIndex >= 0) ? ConjunctIndex : (unsigned int) (first_operand->array.length + ConjunctIndex);
			if (first_operand->array.length == 2) {
				new_conjunction = (index == 0) ? first_operand->array.operands[1] : first_operand->array.operands[0];
				new_conjunction->reference_count++;
			} else {
				new_conjunction = hol_term::new_and(make_excluded_array_view(first_operand->array.operands, first_operand->array.length, index));
				if (new_conjunction == nullptr)
					return false;
				for (unsigned int i = 0; i < new_conjunction->array.length; i++)
					new_conjunction->array.operands[i]->reference_count++;
			}
		} else {
			return false;
		}

		hol_term* new_first_head = hol_term::new_exists(first_head->quantifier.variable, new_conjunction);
		if (new_first_head == nullptr) {
			free(*new_conjunction); if (new_conjunction->reference_count == 0) free(new_conjunction);
			return false;
		}

		array<pair<hol_term*, variable_map>> intersection(2);
		intersect<built_in_predicates, true, true>(intersection, new_first_head, second_head);
		free(*new_first_head); if (new_first_head->reference_count == 0) free(new_first_head);
		if (intersection.length == 0) {
			return false;
		} else if (intersection.length != 1) {
			fprintf(stderr, "invert_remove_conjunct ERROR: Intersection modulo variable relabeling is not unique.\n");
			free_all(intersection); return false;
		}

		/* make sure the variables in `second_head` map to the correct variables in `first_head` */
		const variable_map& var_map = intersection[0].value;
		for (const auto& entry : var_map.scope_map) {
			if (!second_variable_map.contains(entry.key.src))
				continue;

			unsigned int target_var = 0;
			if (entry.value.type == variable_set_type::ANY_EXCEPT && index_of(second_variable_map.get(entry.key.src), entry.value.any.array, entry.value.any.length) == entry.value.any.length)
				continue;
			if (!get_target_variable(entry.key.src->quantifier.variable, target_var, entry.value, max_variable)) {
				free_all(intersection);
				return false;
			}

			if (!second_variable_map.ensure_capacity(second_variable_map.size + 1)) {
				free_all(intersection);
				return false;
			}
			unsigned int index = second_variable_map.index_of(entry.key.src);
			if (target_var == second_variable_map.values[index]) {
				/* `second_variable_map` should map `var` to itself */
				second_variable_map.remove_at(index);
			} else {
				/* `second_variable_map` should map `var` to `target_var` */
				second_variable_map.values[index] = target_var;
				if (index == second_variable_map.size) {
					second_variable_map.keys[index] = entry.key.src;
					second_variable_map.size++;
				}
			}
		}

		array_map<unsigned int, variable_set> free_variable_map(8);
		for (const auto& entry : var_map.free_variables) {
			const variable_set& set = entry.value;
			unsigned int src_variable = entry.key;
			if (!free_variable_map.ensure_capacity(free_variable_map.size + 1)) {
				free_all(intersection);
				return false;
			}
			unsigned int index = free_variable_map.index_of(src_variable);
			if (index < free_variable_map.size) {
				variable_set& new_set = *((variable_set*) alloca(sizeof(variable_map)));
				if (!intersect(new_set, set, free_variable_map.values[index])) {
					free_all(intersection);
					return false;
				}
				swap(free_variable_map.values[index], new_set);
				free(new_set);
			} else {
				free_variable_map.keys[free_variable_map.size] = src_variable;
				if (!init(free_variable_map.values[free_variable_map.size], set)) {
					free_all(intersection);
					return false;
				}
				free_variable_map.size++;
			}
		}
		free_all(intersection);

		if (!remap_scopes(free_variable_map, first_head_inverter, second_head_inverter, second_variable_map, max_variable, first_head_is_array, second_head_is_array)) {
			for (auto entry : second_variable_map) free(entry.value);
			return false;
		}
		return true;
	};

	return invert_apply_head(inverse, inverse_count, flags, first, second,
		find_head<built_in_predicates>, find_head<built_in_predicates>, on_remap_variables,
		[](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array)
	{
		hol_term* old_second_head = second_head;
		if ((first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) && first_head->any.included != nullptr)
			first_head = first_head->any.included;
		if ((second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT) && second_head->any.included != nullptr)
			second_head = second_head->any.included;

		unsigned int first_min_negations = 0;
		unsigned int second_negations = 0;
		while (first_head->type == hol_term_type::NOT) {
			first_head = first_head->unary.operand;
			first_min_negations++;
		} while (second_head->type == hol_term_type::NOT) {
			second_head = second_head->unary.operand;
			second_negations++;
		}

		/* if `RemoveNegation` is true, `first_negations` should be equal to `second_negations + 1`,
			otherwise `first_negations` should be equal to `second_negations` */
		unsigned int expected_first_negations = (RemoveNegation ? second_negations + 1 : second_negations);
		if (first_min_negations > expected_first_negations)
			return false;

		if (second_head->type == hol_term_type::EXISTS) {
			hol_term* second_head_operand = second_head->quantifier.operand;
			hol_term* head_var = hol_term::new_variable(second_head->quantifier.variable);
			if (head_var == nullptr) return false;

			hol_term* any_wide_scope = hol_term::new_any_right(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ANY));
			if (any_wide_scope == nullptr) {
				free(*head_var); free(head_var);
				return false;
			}
			hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
			HOL_ANY.reference_count++;

			hol_term* duplicate_wide_scopes = hol_term::new_any_right(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, any_wide_scope));
			if (duplicate_wide_scopes == nullptr) {
				free(*head_var); free(head_var);
				free(*any_wide_scope); free(any_wide_scope);
				return false;
			}
			hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;

			hol_term* excluded_universal = hol_term::new_any_right(hol_term::new_any_quantifier(hol_quantifier_type::FOR_ALL, any_wide_scope));
			if (excluded_universal == nullptr) {
				free(*head_var); free(head_var);
				free(*duplicate_wide_scopes); free(duplicate_wide_scopes);
				return false;
			}
			any_wide_scope->reference_count++;

			static unsigned int ARGS[] = { (unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3 };
			static unsigned int ARGS_OF[] = { (unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF };
			unsigned int excluded_tree_count = 5;
			hol_term** excluded_trees = (hol_term**) alloca(sizeof(hol_term*) * (excluded_tree_count + 2 * array_length(ARGS)));
			if (excluded_trees == nullptr) {
				free(*head_var); free(head_var);
				free(*duplicate_wide_scopes); free(duplicate_wide_scopes);
				free(*excluded_universal); free(excluded_universal);
				return false;
			}
			excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
						(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
						(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
					&HOL_ANY), head_var));
			excluded_trees[1] = hol_term::new_any(hol_term::new_exists(second_head->quantifier.variable, &HOL_ANY));
			excluded_trees[2] = hol_term::new_apply(
					hol_term::new_any(nullptr, hol_non_head_constants<built_in_predicates>::get_terms(), hol_non_head_constants<built_in_predicates>::count()), head_var);
			excluded_trees[3] = duplicate_wide_scopes;
			excluded_trees[4] = excluded_universal;
			if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
			if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
			if (excluded_trees[2] != nullptr) { hol_non_head_constants<built_in_predicates>::increment_terms(); head_var->reference_count++; }
			if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr || excluded_trees[2] == nullptr) {
				if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
				if (excluded_trees[1] != nullptr) { free(*excluded_trees[1]); free(excluded_trees[1]); }
				free(*head_var); free(head_var);
				free(*duplicate_wide_scopes); free(duplicate_wide_scopes);
				free(*excluded_universal); free(excluded_universal);
				return false;
			}
			free(*head_var);

			for (unsigned int i = 0; i < array_length(ARGS); i++) {
				excluded_trees[excluded_tree_count] = hol_term::new_any(hol_term::new_apply(hol_term::new_constant(ARGS[i]), hol_term::new_variable(second_head->quantifier.variable)));
				if (excluded_trees[excluded_tree_count] == nullptr) {
					for (unsigned int j = 0; j < excluded_tree_count; j++) { free(*excluded_trees[j]); free(excluded_trees[j]); }
					return false;
				}
				excluded_trees[excluded_tree_count + 1] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_constant(ARGS_OF[i]), &HOL_ANY), hol_term::new_variable(second_head->quantifier.variable)));
				if (excluded_trees[excluded_tree_count] == nullptr) {
					for (unsigned int j = 0; j < excluded_tree_count; j++) { free(*excluded_trees[j]); free(excluded_trees[j]); }
					free(*excluded_trees[excluded_tree_count]); free(excluded_trees[excluded_tree_count]);
					return false;
				}
				HOL_ANY.reference_count++;

				if (has_intersection<built_in_predicates>(excluded_trees[excluded_tree_count], second_head_operand)
				 || has_intersection<built_in_predicates>(excluded_trees[excluded_tree_count + 1], second_head_operand))
				{
					excluded_tree_count += 2;
				} else {
					free(*excluded_trees[excluded_tree_count]); free(excluded_trees[excluded_tree_count]);
					free(*excluded_trees[excluded_tree_count + 1]); free(excluded_trees[excluded_tree_count + 1]);
				}
			}

			hol_term** second_head_operands;
			unsigned int second_head_length;
			if (second_head_operand->type == hol_term_type::AND) {
				second_head_operands = second_head_operand->array.operands;
				second_head_length = second_head_operand->array.length;
			} else if (second_head_operand->type != hol_term_type::ANY && second_head_operand->type != hol_term_type::ANY_RIGHT && second_head_operand->type != hol_term_type::ANY_ARRAY) {
				second_head_operands = &second_head_operand;
				second_head_length = 1;
			} else {
				for (unsigned int j = 0; j < excluded_tree_count; j++) { free(*excluded_trees[j]); free(excluded_trees[j]); }
				return false;
			}

			hol_term* conjunct = hol_term::new_any(nullptr, excluded_trees, excluded_tree_count);
			if (conjunct == nullptr) {
				for (unsigned int j = 0; j < excluded_tree_count; j++) { free(*excluded_trees[j]); free(excluded_trees[j]); }
				return false;
			}

			hol_term* conjunction;
			if (!new_hol_term(conjunction)) {
				free(*conjunct); free(conjunct);
				return false;
			}
			conjunction->type = hol_term_type::AND;
			conjunction->reference_count = 1;
			conjunction->array.length = second_head_length + 1;
			conjunction->array.operands = (hol_term**) malloc(sizeof(hol_term*) * (second_head_length + 1));
			if (conjunction->array.operands == nullptr) {
				free(*conjunct); free(conjunct);
				free(conjunction); return false;
			}
			int conjunct_index = ConjunctIndex;
			if (ConjunctIndex < 0) conjunct_index += second_head_length + 1;
			for (unsigned int i = 0; i < conjunction->array.length; i++) {
				if (i == (unsigned int) conjunct_index) {
					conjunction->array.operands[i] = conjunct;
				} else {
					unsigned int second_head_index = (i > (unsigned) conjunct_index) ? (i - 1) : i;
					conjunction->array.operands[i] = second_head_operands[second_head_index];
					conjunction->array.operands[i]->reference_count++;
				}
			}

			dst[dst.length] = hol_term::new_exists(second_head->quantifier.variable, conjunction);
			if (dst[dst.length] == nullptr) {
				free(*conjunction); free(conjunction);
				return false;
			}
			dst.length++;

			for (unsigned int i = 0; i < expected_first_negations; i++) {
				hol_term* temp = hol_term::new_not(dst.last());
				if (temp == nullptr) {
					free_all(dst);
					return false;
				}
				dst.last() = temp;
			}

			if (old_second_head->type == hol_term_type::ANY || old_second_head->type == hol_term_type::ANY_RIGHT) {
				hol_term* conjunct = nullptr;
				if (first_head->type == hol_term_type::EXISTS) {
					hol_term* operand = first_head->quantifier.operand;
					if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
						if (ConjunctIndex < 0 && (uint_fast8_t) (-ConjunctIndex) <= operand->any_array.right.length)
							conjunct = operand->any_array.right.operands[operand->any_array.right.length + ConjunctIndex];
						else if (ConjunctIndex >= 0 && (uint_fast8_t) ConjunctIndex < operand->any_array.left.length)
							conjunct = operand->any_array.left.operands[ConjunctIndex];
					} else if (operand->type == hol_term_type::AND) {
						conjunct = operand->array.operands[(ConjunctIndex < 0) ? (operand->array.length + ConjunctIndex) : ConjunctIndex];
					}
				}

				dst_outer[dst_outer.length] = &HOL_ZERO;
				if (conjunct == nullptr || can_have_free_variables(*conjunct))
					any_right_only = false;
			} else {
				hol_term* conjunct = nullptr;
				if (first_head->type == hol_term_type::EXISTS) {
					hol_term* operand = first_head->quantifier.operand;
					if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
						if (ConjunctIndex < 0 && (uint_fast8_t) (-ConjunctIndex) <= operand->any_array.right.length)
							conjunct = operand->any_array.right.operands[operand->any_array.right.length + ConjunctIndex];
						else if (ConjunctIndex >= 0 && (uint_fast8_t) ConjunctIndex < operand->any_array.left.length)
							conjunct = operand->any_array.left.operands[ConjunctIndex];
					} else if (operand->type == hol_term_type::AND) {
						conjunct = operand->array.operands[(ConjunctIndex < 0) ? (operand->array.length + ConjunctIndex) : ConjunctIndex];
					}
				}

				if (conjunct != nullptr && !can_have_free_variables(*conjunct)) {
					dst_outer[dst_outer.length] = &HOL_ZERO;
				} else if (old_second_head->type != hol_term_type::ANY
						&& old_second_head->type != hol_term_type::ANY_RIGHT
						&& second_head->type == hol_term_type::EXISTS && second_negations == 0)
				{
					/* we have to exclude negations and wide scope markers in front of the head */
					constexpr unsigned int excluded_quantifier_count = 2;
					hol_term* excluded_quantifiers[excluded_quantifier_count];
					excluded_quantifiers[0] = hol_term::new_any(hol_term::new_not(hol_term::new_exists(second_head->quantifier.variable, &HOL_ANY)));
					excluded_quantifiers[1] = hol_term::new_any_right(hol_term::new_apply(
							&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ANY));
					if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
					if (excluded_quantifiers[1] != nullptr) {
						hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
						HOL_ANY.reference_count++;
					}
					if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr) {
						free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]);
						free_all(dst); return false;
					}

					dst_outer[dst_outer.length] = hol_term::new_any_right(&HOL_ZERO, excluded_quantifiers, excluded_quantifier_count);
					if (dst_outer[dst_outer.length] == nullptr) {
						free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]);
						free(*excluded_quantifiers[1]); free(excluded_quantifiers[1]);
						free_all(dst); return false;
					}
					any_right_only = false;
				} else {
					dst_outer[dst_outer.length] = &HOL_ZERO;
					any_right_only = false;
				}
			}
			HOL_ZERO.reference_count++;
			dst_outer.length++;

			/* perform "syntactic type-checking" here */
			hol_term* removed_conjunct = nullptr;
			if (first_head->type == hol_term_type::EXISTS) {
				hol_term* operand = first_head->quantifier.operand;
				if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
					if (ConjunctIndex < 0 && (uint_fast8_t) (-ConjunctIndex) <= operand->any_array.right.length)
						removed_conjunct = operand->any_array.right.operands[operand->any_array.right.length + ConjunctIndex];
					else if (ConjunctIndex >= 0 && (uint_fast8_t) ConjunctIndex < operand->any_array.left.length)
						removed_conjunct = operand->any_array.left.operands[ConjunctIndex];
				} else if (operand->type == hol_term_type::AND) {
					removed_conjunct = operand->array.operands[(ConjunctIndex < 0) ? (operand->array.length + ConjunctIndex) : ConjunctIndex];
				}

				if (removed_conjunct != nullptr && removed_conjunct->type == hol_term_type::EXISTS) {
					operand = removed_conjunct->quantifier.operand;
					if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
						if (ConjunctIndex < 0 && (uint_fast8_t) (-ConjunctIndex) <= operand->any_array.right.length)
							removed_conjunct = operand->any_array.right.operands[operand->any_array.right.length + ConjunctIndex];
						else if (ConjunctIndex >= 0 && (uint_fast8_t) ConjunctIndex < operand->any_array.left.length)
							removed_conjunct = operand->any_array.left.operands[ConjunctIndex];
					} else if (operand->type == hol_term_type::AND) {
						removed_conjunct = operand->array.operands[(ConjunctIndex < 0) ? (operand->array.length + ConjunctIndex) : ConjunctIndex];
					} else {
						removed_conjunct = nullptr;
					}
				}
			}

			if (removed_conjunct != nullptr) {
				if (removed_conjunct->type == hol_term_type::EQUALS
				 && removed_conjunct->binary.left->type == hol_term_type::UNARY_APPLICATION
				 && removed_conjunct->binary.left->binary.left->type == hol_term_type::CONSTANT)
				{
					unsigned int old_second_length = second_inverter.outer.length;
					if (second_inverter.outer.last() != second_head && !second_inverter.outer.add(second_head))
						return false;

					array<hol_type<syntactic_type>> dummy(1);
					if (removed_conjunct->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG1
					 && removed_conjunct->binary.left->binary.right->type == hol_term_type::VARIABLE
					 && removed_conjunct->binary.left->binary.right->variable == second_head->quantifier.variable)
					{
						/* get the type of removed_conjunct->binary.right and make sure it agrees with the expected arg1 type of the predicate */
						hol_type<syntactic_type> predicate_type = get_type(second_head->quantifier.variable, second_inverter.outer);
						hol_type<syntactic_type> arg_type = get_type(removed_conjunct->binary.right, first_inverter.outer);
						if (!expect_type<true>(get_expected_type<built_in_predicates::ARG1>(arg_type), predicate_type, dummy)) return false;
					} else if (removed_conjunct->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG2
							&& removed_conjunct->binary.left->binary.right->type == hol_term_type::VARIABLE
							&& removed_conjunct->binary.left->binary.right->variable == second_head->quantifier.variable)
					{
						/* get the type of removed_conjunct->binary.right and make sure it agrees with the expected arg2 type of the predicate */
						hol_type<syntactic_type> predicate_type = get_type(second_head->quantifier.variable, second_inverter.outer);
						hol_type<syntactic_type> arg_type = get_type(removed_conjunct->binary.right, first_inverter.outer);
						if (!expect_type<true>(get_expected_type<built_in_predicates::ARG2>(arg_type), predicate_type, dummy)) return false;
					} else if (removed_conjunct->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG1_OF
							&& removed_conjunct->binary.right->type == hol_term_type::VARIABLE
							&& removed_conjunct->binary.right->variable == second_head->quantifier.variable)
					{
						/* get the type of removed_conjunct->binary.left->binary.right and make sure it agrees with the expected arg1 type of the predicate */
						hol_type<syntactic_type> predicate_type = get_type(second_head->quantifier.variable, second_inverter.outer);
						hol_type<syntactic_type> arg_type = get_type(removed_conjunct->binary.left->binary.right, first_inverter.outer);
						if (!expect_type<true>(get_expected_type<built_in_predicates::ARG1_OF>(arg_type), predicate_type, dummy)) return false;
					} else if (removed_conjunct->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG2_OF
							&& removed_conjunct->binary.right->type == hol_term_type::VARIABLE
							&& removed_conjunct->binary.right->variable == second_head->quantifier.variable)
					{
						/* get the type of removed_conjunct->binary.left->binary.right and make sure it agrees with the expected arg2 type of the predicate */
						hol_type<syntactic_type> predicate_type = get_type(second_head->quantifier.variable, second_inverter.outer);
						hol_type<syntactic_type> arg_type = get_type(removed_conjunct->binary.left->binary.right, first_inverter.outer);
						if (!expect_type<true>(get_expected_type<built_in_predicates::ARG2_OF>(arg_type), predicate_type, dummy)) return false;
					}
					second_inverter.outer.length = old_second_length;
				}
			}

			return true;
		} else {
			return false;
		}
	});
}

template<int_fast8_t ConjunctIndex, bool IsSecondRoot = false>
inline bool invert_select_set_conjunct(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	unsigned int max_variable = 0;
	max_bound_variable(*first, max_variable);

	unsigned int lambda_variable = 0;
	if (first->type == hol_term_type::LAMBDA) {
		lambda_variable = first->quantifier.variable;
	} else if (first->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	bool result = invert_apply_head(inverse, inverse_count, flags, first, second,
		predicative_head_finder<built_in_predicates>(lambda_variable), IsSecondRoot ? find_root : find_head<built_in_predicates>, no_op(),
		[](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, const apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array) {
			hol_term* old_first_head = first_head;
			if ((first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) && first_head->any.included != nullptr)
				first_head = first_head->any.included;

#if !defined(NDEBUG)
			if (first_head->type != hol_term_type::EXISTS || second_head->type != hol_term_type::EXISTS)
				fprintf(stderr, "invert_select_set_conjunct WARNING: Expected an existential quantification.\n");
#endif

			unsigned int set_variable = first_head->quantifier.variable;

			hol_term* excluded_quantifiers[3];
			excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(set_variable, &HOL_ANY));
			excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(set_variable, &HOL_ANY));
			excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(set_variable, &HOL_ANY));
			if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
			if (excluded_quantifiers[1] != nullptr) HOL_ANY.reference_count++;
			if (excluded_quantifiers[2] != nullptr) HOL_ANY.reference_count++;
			if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr) {
				if (excluded_quantifiers[0] != nullptr) { free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]); }
				if (excluded_quantifiers[1] != nullptr) { free(*excluded_quantifiers[1]); free(excluded_quantifiers[1]); }
				return false;
			}

			hol_term* expected_conjunct = hol_term::new_any(nullptr, excluded_quantifiers, array_length(excluded_quantifiers));
			if (expected_conjunct == nullptr) {
				for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
				return false;
			}

			if (ConjunctIndex >= 0) {
				dst[dst.length] = hol_term::new_exists(set_variable, hol_term::new_any_array(hol_term_type::AND, expected_conjunct,
						make_array_view((hol_term**) nullptr, 0), make_appended_array_view(make_repeated_array_view(expected_conjunct, ConjunctIndex), second_head->quantifier.operand), make_array_view((hol_term**) nullptr, 0)));
				if (dst[dst.length] == nullptr) {
					free(*expected_conjunct); free(expected_conjunct);
					return false;
				}
				second_head->quantifier.operand->reference_count++;
				expected_conjunct->reference_count += ConjunctIndex;
			} else {
				dst[dst.length] = hol_term::new_exists(set_variable, hol_term::new_any_array(hol_term_type::AND, expected_conjunct,
						make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0), make_prepended_array_view(second_head->quantifier.operand, make_repeated_array_view(expected_conjunct, (unsigned int) (-ConjunctIndex - 1)))));
				if (dst[dst.length] == nullptr) {
					free(*expected_conjunct); free(expected_conjunct);
					return false;
				}
				second_head->quantifier.operand->reference_count++;
				expected_conjunct->reference_count += (unsigned int) (-ConjunctIndex - 1);
			}
			dst.length++;
			if (old_first_head->type == hol_term_type::ANY || old_first_head->type == hol_term_type::ANY_RIGHT) {
				hol_term* excluded_wide_scope = hol_term::new_any_right(hol_term::new_apply(
						&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value,
						hol_term::new_any_right(hol_term::new_exists(second_head->quantifier.variable, &HOL_ANY))));
				if (excluded_wide_scope == nullptr)
					return false;
				hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
				HOL_ANY.reference_count++;

				dst_outer[dst_outer.length] = hol_term::new_any_right(&HOL_ZERO, &excluded_wide_scope, 1);
				if (dst_outer[dst_outer.length] == nullptr) {
					free(*excluded_wide_scope); free(excluded_wide_scope);
					return false;
				}
			} else {
				dst_outer[dst_outer.length] = &HOL_ZERO;
			}
			HOL_ZERO.reference_count++;
			dst_outer.length++;

			hol_term* right = (ConjunctIndex == -1) ? second_head->quantifier.operand : expected_conjunct;
			hol_term* wide_scope = hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ANY);
			if (wide_scope == nullptr) {
				free_all(dst); free_all(dst_outer);
				return false;
			}
			hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
			HOL_ANY.reference_count++;
			if (has_intersection<built_in_predicates>(wide_scope, right))
				could_have_wide_scope = true;
			free(*wide_scope); free(wide_scope);

			return true;
		});
	if (!result) return false;

	for (unsigned int i = 0; i < inverse_count; i++) {
		if (inverse[i].root->type != hol_term_type::LAMBDA) {
			hol_term* new_inverse = hol_term::new_lambda(lambda_variable, inverse[i].root);
			if (new_inverse == nullptr) {
				for (unsigned int j = 0; j < inverse_count; j++) free(inverse[j]);
				free(inverse); return false;
			}
			inverse[i].root = new_inverse;
		}
	}
	return true;
}

template<int_fast8_t ConjunctIndex>
inline bool invert_remove_set_conjunct(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	unsigned int max_variable = 0;
	max_bound_variable(*first, max_variable);

	unsigned int first_lambda_variable = 0;
	if (first->type == hol_term_type::LAMBDA) {
		first_lambda_variable = first->quantifier.variable;
		first = first->quantifier.operand;
	} else if (first->type == hol_term_type::ANY) {
		first_lambda_variable = ++max_variable;
	} else {
		return false;
	}

	unsigned int second_lambda_variable = 0;
	if (second->type == hol_term_type::LAMBDA) {
		second_lambda_variable = second->quantifier.variable;
		second = second->quantifier.operand;
	} else if (second->type == hol_term_type::ANY) {
		second_lambda_variable = ++max_variable;
	} else {
		return false;
	}

	auto on_remap_variables = [second_lambda_variable](hol_term* first_head, hol_term* second_head,
			apply_head_inverter& first_head_inverter, apply_head_inverter& second_head_inverter,
			array_map<const hol_term*, unsigned int>& second_variable_map, unsigned int max_variable,
			bool first_head_is_array, bool second_head_is_array)
	{
		if ((second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT) && second_head->any.included != nullptr) {
			second_head = second_head->any.included;
			if (!second_head_inverter.outer.add(second_head))
				return false;
		}

		while (first_head->type == hol_term_type::NOT) {
			first_head = first_head->unary.operand;
			if (!first_head_inverter.outer.add(first_head))
				return false;
		}
		while (second_head->type == hol_term_type::NOT) {
			second_head = second_head->unary.operand;
			if (!second_head_inverter.outer.add(second_head))
				return false;
		}

		if (second_head->type != hol_term_type::EXISTS)
			return false;
		if (first_head->type != hol_term_type::EXISTS)
			return true;

		hol_term* first_operand = first_head->quantifier.operand;
		hol_term* new_conjunction;
		if (first_operand->type == hol_term_type::ANY || first_operand->type == hol_term_type::ANY_RIGHT) {
			return true;
		} else if (first_operand->type == hol_term_type::ANY_ARRAY && first_operand->any_array.oper == hol_term_type::AND) {
			if (ConjunctIndex >= 0) {
				if (ConjunctIndex < first_operand->any_array.left.length) {
					new_conjunction = hol_term::new_any_array(hol_term_type::AND,
							first_operand->any_array.all, make_array_view(first_operand->any_array.any.operands, first_operand->any_array.any.length),
							make_excluded_array_view(first_operand->any_array.left.operands, first_operand->any_array.left.length, ConjunctIndex),
							make_array_view(first_operand->any_array.right.operands, first_operand->any_array.right.length));
					if (new_conjunction == nullptr)
						return false;
					new_conjunction->any_array.all->reference_count++;
					for (unsigned int i = 0; i < new_conjunction->any_array.left.length; i++)
						new_conjunction->any_array.left.operands[i]->reference_count++;
					for (unsigned int i = 0; i < new_conjunction->any_array.right.length; i++)
						new_conjunction->any_array.right.operands[i]->reference_count++;
					for (unsigned int i = 0; i < new_conjunction->any_array.any.length; i++)
						new_conjunction->any_array.any.operands[i]->reference_count++;
				} else {
					new_conjunction = first_operand;
					first_operand->reference_count++;
				}
			} else {
				if (-ConjunctIndex <= first_operand->any_array.right.length) {
					new_conjunction = hol_term::new_any_array(hol_term_type::AND,
							first_operand->any_array.all, make_array_view(first_operand->any_array.any.operands, first_operand->any_array.any.length),
							make_array_view(first_operand->any_array.left.operands, first_operand->any_array.left.length),
							make_excluded_array_view(first_operand->any_array.right.operands, first_operand->any_array.right.length, first_operand->any_array.right.length + ConjunctIndex));
					if (new_conjunction == nullptr)
						return false;
					new_conjunction->any_array.all->reference_count++;
					for (unsigned int i = 0; i < new_conjunction->any_array.left.length; i++)
						new_conjunction->any_array.left.operands[i]->reference_count++;
					for (unsigned int i = 0; i < new_conjunction->any_array.right.length; i++)
						new_conjunction->any_array.right.operands[i]->reference_count++;
					for (unsigned int i = 0; i < new_conjunction->any_array.any.length; i++)
						new_conjunction->any_array.any.operands[i]->reference_count++;
				} else {
					new_conjunction = first_operand;
					first_operand->reference_count++;
				}
			}
		} else if (first_operand->type == hol_term_type::AND) {
			unsigned int index = (ConjunctIndex >= 0) ? ConjunctIndex : (unsigned int) (first_operand->array.length + ConjunctIndex);
			if (first_operand->array.length == 2) {
				new_conjunction = (index == 0) ? first_operand->array.operands[1] : first_operand->array.operands[0];
				new_conjunction->reference_count++;
			} else {
				new_conjunction = hol_term::new_and(make_excluded_array_view(first_operand->array.operands, first_operand->array.length, index));
				if (new_conjunction == nullptr)
					return false;
				for (unsigned int i = 0; i < new_conjunction->array.length; i++)
					new_conjunction->array.operands[i]->reference_count++;
			}
		} else {
			return false;
		}

		hol_term* new_first_head = hol_term::new_exists(first_head->quantifier.variable, new_conjunction);
		if (new_first_head == nullptr) {
			free(*new_conjunction); if (new_conjunction->reference_count == 0) free(new_conjunction);
			return false;
		}

		array<pair<hol_term*, variable_map>> intersection(2);
		intersect<built_in_predicates, true, true>(intersection, new_first_head, second_head);
		free(*new_first_head); if (new_first_head->reference_count == 0) free(new_first_head);
		if (intersection.length == 0) {
			return false;
		} else if (intersection.length != 1) {
			fprintf(stderr, "invert_remove_set_conjunct ERROR: Intersection modulo variable relabeling is not unique.\n");
			free_all(intersection); return false;
		}

		/* make sure the variables in `second_head` map to the correct variables in `first_head` */
		const variable_map& var_map = intersection[0].value;
		for (const auto& entry : var_map.scope_map) {
			if (!second_variable_map.contains(entry.key.src))
				continue;

			unsigned int target_var = 0;
			if (entry.value.type == variable_set_type::ANY_EXCEPT && index_of(second_variable_map.get(entry.key.src), entry.value.any.array, entry.value.any.length) == entry.value.any.length)
				continue;
			if (!get_target_variable(entry.key.src->quantifier.variable, target_var, entry.value, max_variable)) {
				free_all(intersection);
				return false;
			}

			if (!second_variable_map.ensure_capacity(second_variable_map.size + 1)) {
				free_all(intersection);
				return false;
			}
			unsigned int index = second_variable_map.index_of(entry.key.src);
			if (target_var == second_variable_map.values[index]) {
				/* `second_variable_map` should map `var` to itself */
				second_variable_map.remove_at(index);
			} else {
				/* `second_variable_map` should map `var` to `target_var` */
				second_variable_map.values[index] = target_var;
				if (index == second_variable_map.size) {
					second_variable_map.keys[index] = entry.key.src;
					second_variable_map.size++;
				}
			}
		}

		array_map<unsigned int, variable_set> free_variable_map(8);
		for (const auto& entry : var_map.free_variables) {
			const variable_set& set = entry.value;
			unsigned int src_variable = entry.key;
			if (src_variable == second_lambda_variable)
				continue;
			if (!free_variable_map.ensure_capacity(free_variable_map.size + 1)) {
				free_all(intersection);
				return false;
			}
			unsigned int index = free_variable_map.index_of(src_variable);
			if (index < free_variable_map.size) {
				variable_set& new_set = *((variable_set*) alloca(sizeof(variable_map)));
				if (!intersect(new_set, set, free_variable_map.values[index])) {
					free_all(intersection);
					return false;
				}
				swap(free_variable_map.values[index], new_set);
				free(new_set);
			} else {
				free_variable_map.keys[free_variable_map.size] = src_variable;
				if (!init(free_variable_map.values[free_variable_map.size], set)) {
					free_all(intersection);
					return false;
				}
				free_variable_map.size++;
			}
		}
		free_all(intersection);

		if (!remap_scopes(free_variable_map, first_head_inverter, second_head_inverter, second_variable_map, max_variable, first_head_is_array, second_head_is_array)) {
			for (auto entry : second_variable_map) free(entry.value);
			return false;
		}
		return true;
	};

	bool result = invert_apply_head(inverse, inverse_count, flags, first, second,
		predicative_head_finder<built_in_predicates>(first_lambda_variable), predicative_head_finder<built_in_predicates>(second_lambda_variable), on_remap_variables,
		[](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, const apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array) {
			if ((first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) && first_head->any.included != nullptr)
				first_head = first_head->any.included;
			if ((second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT) && second_head->any.included != nullptr)
				second_head = second_head->any.included;

#if !defined(NDEBUG)
			if (first_head->type != hol_term_type::EXISTS || second_head->type != hol_term_type::EXISTS)
				fprintf(stderr, "invert_remove_set_conjunct WARNING: Expected an existential quantification.\n");
#endif

			unsigned int set_variable = first_head->quantifier.variable;

			hol_term* excluded_quantifiers[3];
			excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(set_variable, &HOL_ANY));
			excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(set_variable, &HOL_ANY));
			excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(set_variable, &HOL_ANY));
			if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
			if (excluded_quantifiers[1] != nullptr) HOL_ANY.reference_count++;
			if (excluded_quantifiers[2] != nullptr) HOL_ANY.reference_count++;
			if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr) {
				if (excluded_quantifiers[0] != nullptr) { free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]); }
				if (excluded_quantifiers[1] != nullptr) { free(*excluded_quantifiers[1]); free(excluded_quantifiers[1]); }
				return false;
			}

			hol_term* expected_conjunct = hol_term::new_any(nullptr, excluded_quantifiers, array_length(excluded_quantifiers));
			if (expected_conjunct == nullptr) {
				for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
				return false;
			}

			hol_term* conjunction;
			hol_term* operand = second_head->quantifier.operand;
			if (operand->type == hol_term_type::ANY_ARRAY) {
				if (ConjunctIndex >= 0) {
					conjunction = hol_term::new_any_array(hol_term_type::AND, operand->any_array.all, make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
							make_included_array_view(operand->any_array.left.operands, operand->any_array.left.length, expected_conjunct, ConjunctIndex), make_array_view(operand->any_array.right.operands, operand->any_array.right.length));
				} else {
					unsigned int index = (unsigned int) (operand->any_array.right.length + ConjunctIndex);
					conjunction = hol_term::new_any_array(hol_term_type::AND, operand->any_array.all, make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
							make_array_view(operand->any_array.left.operands, operand->any_array.left.length), make_included_array_view(operand->any_array.right.operands, operand->any_array.right.length, expected_conjunct, index));
				}
				if (conjunction == nullptr) {
					free(*expected_conjunct); free(expected_conjunct);
					return false;
				}
				conjunction->any_array.all->reference_count++;
				for (unsigned int i = 0; i < conjunction->any_array.left.length; i++)
					conjunction->any_array.left.operands[i]->reference_count++;
				for (unsigned int i = 0; i < conjunction->any_array.right.length; i++)
					conjunction->any_array.right.operands[i]->reference_count++;
				for (unsigned int i = 0; i < conjunction->any_array.any.length; i++)
					conjunction->any_array.any.operands[i]->reference_count++;
			} else {
				unsigned int index = (ConjunctIndex >= 0) ? ConjunctIndex : (unsigned int) (ConjunctIndex + operand->array.length);
				conjunction = hol_term::new_and(make_included_array_view(operand->array.operands, operand->array.length, expected_conjunct, index));
				if (conjunction == nullptr) {
					free(*expected_conjunct); free(expected_conjunct);
					return false;
				}
				for (unsigned int i = 0; i < operand->array.length; i++)
					operand->array.operands[i]->reference_count++;
			}

			dst[dst.length] = hol_term::new_exists(set_variable, conjunction);
			if (dst[dst.length] == nullptr) {
				free(*conjunction); free(conjunction);
				return false;
			}
			dst.length++;
			dst_outer[dst_outer.length++] = &HOL_ZERO;
			HOL_ZERO.reference_count++;
			return true;
		});
	if (!result) return false;

	for (unsigned int i = 0; i < inverse_count; i++) {
		if (inverse[i].root->type != hol_term_type::LAMBDA) {
			hol_term* new_inverse = hol_term::new_lambda(first_lambda_variable, inverse[i].root);
			if (new_inverse == nullptr) {
				for (unsigned int j = 0; j < inverse_count; j++) free(inverse[j]);
				free(inverse); return false;
			}
			inverse[i].root = new_inverse;
		}
	}
	return true;
}

template<int_fast8_t ConjunctIndex>
inline bool invert_select_conjunct_in_set(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	unsigned int max_variable = 0;
	max_bound_variable(*first, max_variable);

	unsigned int lambda_variable = 0;
	if (first->type == hol_term_type::LAMBDA) {
		lambda_variable = first->quantifier.variable;
	} else if (first->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	auto on_remap_variables = [](hol_term* first_head, hol_term* second_head,
			apply_head_inverter& first_head_inverter, apply_head_inverter& second_head_inverter,
			array_map<const hol_term*, unsigned int>& second_variable_map, unsigned int max_variable,
			bool first_head_is_array, bool second_head_is_array)
	{
		if ((second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT) && second_head->any.included != nullptr)
			second_head = second_head->any.included;
#if !defined(NDEBUG)
		if (second_head->type != hol_term_type::EXISTS || second_head->quantifier.operand->type != hol_term_type::AND)
			fprintf(stderr, "invert_select_conjunct_in_set WARNING: Expected an existentially-quantified conjunction.\n");
#endif

		if ((first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) && first_head->any.included != nullptr
		 && (first_head->any.included->type == hol_term_type::NOT || first_head->any.included->type == hol_term_type::EXISTS))
			first_head = first_head->any.included;

		hol_term* first_lambda = nullptr;
		hol_term* first_conjunct_in_set = nullptr;
		if (first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) {
			if (first_head->any.included != nullptr && first_head->any.included->type == hol_term_type::UNARY_APPLICATION
			 && first_head->any.included->binary.right->type == hol_term_type::VARIABLE)
			{
				/* make sure the element variable and the variable declared by
				   the lambda expression in the set definition are the same */
				unsigned int target_variable = first_head->any.included->binary.right->variable;
				if (!second_variable_map.ensure_capacity(second_variable_map.size + 1))
					return false;
				unsigned int index = second_variable_map.index_of(second_head);
				if (index < second_variable_map.size && target_variable == second_head->quantifier.variable) {
					/* `second_variable_map` should map `var` to itself */
					second_variable_map.remove_at(index);
				} else {
					/* `second_variable_map` should map `var` to `target_variable` */
					second_variable_map.values[index] = target_variable;
					if (index == second_variable_map.size) {
						second_variable_map.keys[index] = second_head;
						second_variable_map.size++;
					}
				}
			}
			return true; /* we don't need to relabel variables */
		} else {
#if !defined(NDEBUG)
			if (first_head->type != hol_term_type::EXISTS)
				fprintf(stderr, "invert_select_conjunct_in_set WARNING: Expected an existential quantification.\n");
#endif
			hol_term* first_operand = first_head->quantifier.operand;

			hol_term* first_left;
			if (first_operand->type == hol_term_type::AND) {
				first_left = first_operand->array.operands[0];
			} else if (first_operand->type == hol_term_type::ANY_ARRAY && first_operand->any_array.oper == hol_term_type::AND) {
				if (first_operand->any_array.left.length == 0)
					first_left = first_operand->any_array.all;
				else first_left = first_operand->any_array.left.operands[0];
			} else {
				return true;
			}

			if (first_left->type == hol_term_type::EQUALS && first_left->binary.right->type == hol_term_type::LAMBDA) {
				first_lambda = first_left->binary.right;
			} else if (first_left->type == hol_term_type::BINARY_APPLICATION && first_left->ternary.third->type == hol_term_type::LAMBDA) {
				first_lambda = first_left->ternary.third;
			} else if (first_left->type == hol_term_type::ANY_RIGHT && first_left->any.included != nullptr && first_left->any.included->type == hol_term_type::LAMBDA) {
				first_lambda = first_left->any.included;
			} else {
				return true;
			}

			hol_term* first_set_definition = first_lambda->quantifier.operand;
			if (first_set_definition->type == hol_term_type::AND) {
				unsigned int index = (ConjunctIndex < 0) ? (first_set_definition->array.length + ConjunctIndex) : ConjunctIndex;
				first_conjunct_in_set = first_set_definition->array.operands[index];
			} else if (first_set_definition->type == hol_term_type::ANY_ARRAY && first_set_definition->any_array.oper == hol_term_type::AND) {
				if (ConjunctIndex < 0) {
					if (-ConjunctIndex > first_set_definition->any_array.right.length)
						first_conjunct_in_set = first_set_definition->any_array.all;
					else first_conjunct_in_set = first_set_definition->any_array.right.operands[first_set_definition->any_array.right.length + ConjunctIndex];
				} else {
					if (ConjunctIndex < first_set_definition->any_array.left.length)
						first_conjunct_in_set = first_set_definition->any_array.left.operands[ConjunctIndex];
					else first_conjunct_in_set = first_set_definition->any_array.all;
				}
			} else {
				return true;
			}

			if (second_head->quantifier.operand->array.operands[0]->binary.left->type == hol_term_type::UNARY_APPLICATION
			 && second_head->quantifier.operand->array.operands[0]->binary.left->binary.right->type == hol_term_type::VARIABLE)
			{
				head_index predicate_index;
				hol_term* first_predicate = find_predicate<built_in_predicates>(first_lambda->quantifier.variable, first_set_definition, predicate_index);
				if (predicate_index.position == head_position::NONE && !(first_set_definition->type == hol_term_type::ANY_ARRAY && first_set_definition->any_array.any.length == 0)) {
					return false;
				} else if (first_predicate == nullptr) {
					if (first_set_definition->type == hol_term_type::AND) {
						first_predicate = first_set_definition->array.operands[predicate_index.index];
					} else if (first_set_definition->type == hol_term_type::ANY_ARRAY) {
						if (predicate_index.position == head_position::LEFT)
							first_predicate = first_set_definition->any_array.left.operands[predicate_index.index];
						else if (predicate_index.position == head_position::RIGHT)
							first_predicate = first_set_definition->any_array.right.operands[first_set_definition->any_array.right.length - predicate_index.index - 1];
						else if (predicate_index.position == head_position::ANY)
							first_predicate = first_set_definition->any_array.any.operands[predicate_index.index];
					} else {
						first_predicate = first_set_definition;
					}
				}

				if (first_predicate->type == hol_term_type::UNARY_APPLICATION) {
					if (first_predicate->binary.left->type == hol_term_type::UNARY_APPLICATION) {
						if (first_predicate->binary.left->binary.right->type == hol_term_type::VARIABLE) {
							/* make sure the variable arguments in the predicates are correctly mapped */
							unsigned int first_variable = first_predicate->binary.left->binary.right->variable;
							unsigned int second_variable = second_head->quantifier.operand->array.operands[0]->binary.left->binary.right->variable;

							hol_term* second_scope = nullptr;
							for (hol_term* scope : second_head_inverter.outer) {
								if ((scope->type == hol_term_type::EXISTS || scope->type == hol_term_type::FOR_ALL || scope->type == hol_term_type::LAMBDA) && scope->quantifier.variable == second_variable) {
									second_scope = scope;
									break;
								}
							}

							if (!second_variable_map.ensure_capacity(second_variable_map.size + 1))
								return false;
							unsigned int index = second_variable_map.index_of(second_scope);
							if (index < second_variable_map.size && first_variable == second_variable) {
								/* `second_variable_map` should map `var` to itself */
								second_variable_map.remove_at(index);
							} else {
								/* `second_variable_map` should map `var` to `first_variable` */
								second_variable_map.values[index] = first_variable;
								if (index == second_variable_map.size) {
									second_variable_map.keys[index] = second_head;
									second_variable_map.size++;
								}
							}
						} else if (first_predicate->binary.right->type != hol_term_type::ANY && first_predicate->binary.right->type != hol_term_type::ANY_RIGHT) {
							return false;
						}
					} else if (first_predicate->binary.right->type != hol_term_type::ANY && first_predicate->binary.right->type != hol_term_type::ANY_RIGHT) {
						return false;
					}
				} else if (first_predicate->type != hol_term_type::ANY && first_predicate->type != hol_term_type::ANY_RIGHT) {
					return false;
				}
			}
		}

		array<pair<hol_term*, variable_map>> intersection(2);
		intersect<built_in_predicates, true, true>(intersection, first_conjunct_in_set, second_head->quantifier.operand->array.operands[1]);
		if (intersection.length == 0) {
			return false;
		} else if (intersection.length != 1) {
			fprintf(stderr, "invert_select_conjunct_in_set ERROR: Intersection modulo variable relabeling is not unique.\n");
			free_all(intersection); return false;
		}

		/* make sure the variables in `second_head` map to the correct variables in `first_head` */
		const variable_map& var_map = intersection[0].value;
		for (const auto& entry : var_map.scope_map) {
			if (!second_variable_map.contains(entry.key.src))
				continue;

			unsigned int target_var = 0;
			if (!get_target_variable(entry.key.src->quantifier.variable, target_var, entry.value, max_variable)) {
				for (auto entry : second_variable_map) free(entry.value);
				free_all(intersection); return false;
			}

			if (!second_variable_map.ensure_capacity(second_variable_map.size + 1)) {
				free_all(intersection);
				return false;
			}
			unsigned int index = second_variable_map.index_of(entry.key.src);
			if (target_var == second_variable_map.values[index]) {
				/* `second_variable_map` should map `var` to itself */
				second_variable_map.remove_at(index);
			} else {
				/* `second_variable_map` should map `var` to `target_var` */
				second_variable_map.values[index] = target_var;
				if (index == second_variable_map.size) {
					second_variable_map.keys[index] = entry.key.src;
					second_variable_map.size++;
				}
			}
		}

		array_map<unsigned int, variable_set> free_variable_map(8);
		for (const auto& entry : var_map.free_variables) {
			const variable_set& set = entry.value;
			if (set.type == variable_set_type::SINGLETON && set.variable == first_lambda->quantifier.variable) {
				hol_term* scope = nullptr;
				for (unsigned int i = 0; i < second_head_inverter.outer.length; i++)
					if (second_head_inverter.outer[i]->type == hol_term_type::EXISTS && second_head_inverter.outer[i]->quantifier.variable == entry.key) { scope = second_head_inverter.outer[i]; break; }
				if (scope != nullptr && !second_variable_map.put(scope, set.variable)) {
					free_all(intersection);
					return false;
				}
				continue;
			}

			unsigned int src_variable = entry.key;
			if (!free_variable_map.ensure_capacity(free_variable_map.size + 1)) {
				for (auto entry : second_variable_map) free(entry.value);
				free_all(intersection); return false;
			}
			unsigned int index = free_variable_map.index_of(src_variable);
			if (index < free_variable_map.size) {
				variable_set& new_set = *((variable_set*) alloca(sizeof(variable_map)));
				if (!intersect(new_set, set, free_variable_map.values[index])) {
					for (auto entry : second_variable_map) free(entry.value);
					free_all(intersection); return false;
				}
				swap(free_variable_map.values[index], new_set);
				free(new_set);
			} else {
				free_variable_map.keys[free_variable_map.size] = src_variable;
				if (!init(free_variable_map.values[free_variable_map.size], set)) {
					for (auto entry : second_variable_map) free(entry.value);
					free_all(intersection); return false;
				}
				free_variable_map.size++;
			}
		}
		free_all(intersection);

		if (!remap_scopes(free_variable_map, first_head_inverter, second_head_inverter, second_variable_map, max_variable, first_head_is_array, second_head_is_array)) {
			for (auto entry : second_variable_map) free(entry.value);
			return false;
		}
		return true;
	};

	bool result = invert_apply_head(inverse, inverse_count, flags, first, second,
		predicative_head_finder<built_in_predicates>(lambda_variable), find_head<built_in_predicates>, on_remap_variables,
		[](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, const apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array)
		{
			if ((second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT) && second_head->any.included != nullptr)
				second_head = second_head->any.included;
#if !defined(NDEBUG)
			if (second_head->type != hol_term_type::EXISTS || second_head->quantifier.operand->type != hol_term_type::AND)
				fprintf(stderr, "invert_select_conjunct_in_set WARNING: Expected an existentially-quantified conjunction.\n");
#endif

			if ((first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) && first_head->any.included != nullptr
			 && (first_head->any.included->type == hol_term_type::NOT || first_head->any.included->type == hol_term_type::EXISTS))
				first_head = first_head->any.included;

			unsigned int set_variable;
			if (first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) {
				set_variable = ++max_variable;
			} else {
#if !defined(NDEBUG)
				if (first_head->type != hol_term_type::EXISTS)
					fprintf(stderr, "invert_select_conjunct_in_set WARNING: Expected an existential quantification.\n");
#endif
				set_variable = first_head->quantifier.variable;
			}

			unsigned int element_variable = second_head->quantifier.variable;
			hol_term* head_var = hol_term::new_variable(element_variable);
			if (head_var == nullptr) return false;
			constexpr unsigned int excluded_tree_count = 5;
			hol_term* excluded_trees[excluded_tree_count];
			excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
						(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
						(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
					&HOL_ANY), head_var));
			excluded_trees[1] = hol_term::new_any(hol_term::new_lambda(element_variable, &HOL_ANY));
			excluded_trees[2] = hol_term::new_any(hol_term::new_exists(set_variable, &HOL_ANY));
			excluded_trees[3] = hol_term::new_any(hol_term::new_for_all(set_variable, &HOL_ANY));
			excluded_trees[4] = hol_term::new_any(hol_term::new_lambda(set_variable, &HOL_ANY));
			if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
			if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
			if (excluded_trees[2] != nullptr) { HOL_ANY.reference_count++; }
			if (excluded_trees[3] != nullptr) { HOL_ANY.reference_count++; }
			if (excluded_trees[4] != nullptr) { HOL_ANY.reference_count++; }
			if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr || excluded_trees[2] == nullptr || excluded_trees[3] == nullptr || excluded_trees[4] == nullptr) {
				if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
				if (excluded_trees[1] != nullptr) { free(*excluded_trees[1]); free(excluded_trees[1]); }
				if (excluded_trees[2] != nullptr) { free(*excluded_trees[2]); free(excluded_trees[2]); }
				if (excluded_trees[3] != nullptr) { free(*excluded_trees[3]); free(excluded_trees[3]); }
				free(*head_var); free(head_var);
				return false;
			}
			free(*head_var);

			hol_term* expected_conjunct = hol_term::new_any(nullptr, excluded_trees, excluded_tree_count);
			if (expected_conjunct == nullptr) {
				free(*excluded_trees[0]); free(excluded_trees[0]);
				free(*excluded_trees[1]); free(excluded_trees[1]);
				free(*excluded_trees[2]); free(excluded_trees[2]);
				free(*excluded_trees[3]); free(excluded_trees[3]);
				free(*excluded_trees[4]); free(excluded_trees[4]);
				return false;
			}

			hol_term* first_left = nullptr;
			hol_term* first_set_definition = nullptr;
			array<hol_term*> new_predicates(2);
			if (has_intersection<built_in_predicates>(second_head->quantifier.operand->array.operands[0]->binary.left, &hol_term::constants<(unsigned int) built_in_predicates::NAMED_ENTITY>::value)) {
				/* find the quantified variable of the scope in the set definition of `first_head` (e.g. named entity) */
				unsigned int scope_variable = 0;
				if (first_head->type == hol_term_type::EXISTS) {
					hol_term* first_operand = first_head->quantifier.operand;
					if (first_operand->type == hol_term_type::AND) {
						first_left = first_operand->array.operands[0];
					} else if (first_operand->type == hol_term_type::ANY_ARRAY && first_operand->any_array.oper == hol_term_type::AND) {
						if (first_operand->any_array.left.length == 0)
							first_left = first_operand->any_array.all;
						else first_left = first_operand->any_array.left.operands[0];
					}

					hol_term* first_lambda = nullptr;
					if (first_left != nullptr) {
						if (first_left->type == hol_term_type::EQUALS && first_left->binary.right->type == hol_term_type::LAMBDA) {
							first_lambda = first_left->binary.right;
						} else if (first_left->type == hol_term_type::BINARY_APPLICATION && first_left->ternary.third->type == hol_term_type::LAMBDA) {
							first_lambda = first_left->ternary.third;
						} else if (first_left->type == hol_term_type::ANY_RIGHT && first_left->any.included != nullptr && first_left->any.included->type == hol_term_type::LAMBDA) {
							first_lambda = first_left->any.included;
						}
					}

					if (first_lambda != nullptr) {
						first_set_definition = first_lambda->quantifier.operand;
						head_index predicate_index;
						hol_term* predicate = find_scope<built_in_predicates, (unsigned int) built_in_predicates::NAME>(first_lambda->quantifier.variable, first_set_definition, predicate_index);
						if (predicate != nullptr)
							scope_variable = predicate->quantifier.variable;
					}
				} if (scope_variable == 0) {
					scope_variable = ++max_variable;
				}

				hol_term* scope_var = hol_term::new_variable(scope_variable);
				if (scope_var == nullptr) {
					free(*expected_conjunct); free(expected_conjunct);
					return false;
				}

				new_predicates[new_predicates.length] = hol_term::new_exists(scope_variable, hol_term::new_and(
					hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::NAME>::value, scope_var),
					hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG1_OF>::value, head_var), scope_var),
					hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value, scope_var), expected_conjunct)
				));
				if (new_predicates[new_predicates.length] == nullptr) {
					free(*expected_conjunct); free(expected_conjunct);
					free(*scope_var); free(scope_var); return false;
				}
				hol_term::constants<(unsigned int) built_in_predicates::NAME>::value.reference_count++;
				scope_var->reference_count += 3 - 1;
				hol_term::constants<(unsigned int) built_in_predicates::ARG1_OF>::value.reference_count++;
				head_var->reference_count++;
				hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value.reference_count++;
				expected_conjunct->reference_count++;
				new_predicates.length++;
			} if (*second_head->quantifier.operand->array.operands[0]->binary.left != hol_term::constants<(unsigned int) built_in_predicates::NAMED_ENTITY>::value) {
				/* find the predicate in the set definition of `first_head` */
				hol_term* first_predicate = nullptr;
				if (first_head->type == hol_term_type::EXISTS) {
					hol_term* first_operand = first_head->quantifier.operand;
					if (first_operand->type == hol_term_type::AND) {
						first_left = first_operand->array.operands[0];
					} else if (first_operand->type == hol_term_type::ANY_ARRAY && first_operand->any_array.oper == hol_term_type::AND) {
						if (first_operand->any_array.left.length == 0)
							first_left = first_operand->any_array.all;
						else first_left = first_operand->any_array.left.operands[0];
					}

					hol_term* first_lambda = nullptr;
					if (first_left != nullptr) {
						hol_term* first_left_temp = first_left;
						if (first_left->type == hol_term_type::EQUALS) {
							first_left_temp = first_left->binary.right;
						} else if (first_left->type == hol_term_type::BINARY_APPLICATION) {
							first_left_temp = first_left->ternary.third;
						}

						if (first_left_temp->type == hol_term_type::ANY_RIGHT && first_left_temp->any.included != nullptr)
							first_left_temp = first_left_temp->any.included;
						if (first_left_temp->type == hol_term_type::LAMBDA)
							first_lambda = first_left_temp;
					}

					if (first_lambda != nullptr) {
						first_set_definition = first_lambda->quantifier.operand;
						head_index predicate_index;
						first_predicate = find_predicate<built_in_predicates>(first_lambda->quantifier.variable, first_set_definition, predicate_index);
						if (predicate_index.position == head_position::NONE && !(first_set_definition->type == hol_term_type::ANY_ARRAY && first_set_definition->any_array.any.length == 0)) {
							free(*expected_conjunct); if (expected_conjunct->reference_count == 0) free(expected_conjunct);
							free_all(new_predicates); return false;
						} else if (first_predicate == nullptr) {
							if (first_set_definition->type == hol_term_type::AND) {
								first_predicate = first_set_definition->array.operands[predicate_index.index];
							} else if (first_set_definition->type == hol_term_type::ANY_ARRAY) {
								if (predicate_index.position == head_position::LEFT)
									first_predicate = first_set_definition->any_array.left.operands[predicate_index.index];
								else if (predicate_index.position == head_position::RIGHT)
									first_predicate = first_set_definition->any_array.right.operands[first_set_definition->any_array.right.length - predicate_index.index - 1];
								else if (predicate_index.position == head_position::ANY)
									first_predicate = first_set_definition->any_array.any.operands[predicate_index.index];
							} else {
								first_predicate = first_set_definition;
							}
						}
					}
				}

				if (first_predicate != nullptr && first_predicate->type == hol_term_type::UNARY_APPLICATION) {
					intersect<built_in_predicates>(new_predicates, first_predicate, second_head->quantifier.operand->array.operands[0]);
				} else {
					new_predicates[new_predicates.length] = second_head->quantifier.operand->array.operands[0];
					new_predicates[new_predicates.length++]->reference_count++;
				}
			}

			bool intersection_can_have_free_variables = true;
			if (first_set_definition != nullptr) {
				if (can_have_free_variables(*second_head->quantifier.operand->array.operands[1])) {
					intersection_can_have_free_variables = true;
				} else if (first_set_definition->type == hol_term_type::AND) {
					unsigned int index = (ConjunctIndex < 0) ? (ConjunctIndex + first_set_definition->array.length) : ConjunctIndex;
					bool found_conjunct_with_possible_free_variables = false;
					for (unsigned int i = 0; i < first_set_definition->array.length; i++) {
						if (i == index) continue;
						if (can_have_free_variables(*first_set_definition->array.operands[i])) {
							found_conjunct_with_possible_free_variables = true;
							break;
						}
					}
					if (!found_conjunct_with_possible_free_variables)
						intersection_can_have_free_variables = false;
				} else {
					if (!can_have_free_variables(*first_set_definition))
						intersection_can_have_free_variables = false;
				}
			}

			for (hol_term* new_predicate : new_predicates) {
				hol_term* conjunction = nullptr;
				if (ConjunctIndex >= 0) {
					conjunction = hol_term::new_any_array(hol_term_type::AND, expected_conjunct,
							make_array_view(&new_predicate, 1),
							make_appended_array_view(make_repeated_array_view(expected_conjunct, ConjunctIndex), second_head->quantifier.operand->array.operands[1]),
							make_array_view((hol_term**) nullptr, 0));
				} else if (ConjunctIndex < 0) {
					unsigned int index = (unsigned int) (-ConjunctIndex) - 1;
					conjunction = hol_term::new_any_array(hol_term_type::AND, expected_conjunct,
							make_array_view(&new_predicate, 1),
							make_array_view((hol_term**) nullptr, 0),
							make_prepended_array_view(second_head->quantifier.operand->array.operands[1], make_repeated_array_view(expected_conjunct, index)));
				}
				if (conjunction == nullptr) {
					free(*expected_conjunct); if (expected_conjunct->reference_count == 0) free(expected_conjunct);
					free_all(new_predicates); return false;
				}
				conjunction->any_array.all->reference_count++;
				for (unsigned int i = 0; i < conjunction->any_array.left.length; i++)
					conjunction->any_array.left.operands[i]->reference_count++;
				for (unsigned int i = 0; i < conjunction->any_array.right.length; i++)
					conjunction->any_array.right.operands[i]->reference_count++;
				for (unsigned int i = 0; i < conjunction->any_array.any.length; i++)
					conjunction->any_array.any.operands[i]->reference_count++;

				hol_term* excluded_quantifiers[3];
				excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(set_variable, &HOL_ANY));
				excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(set_variable, &HOL_ANY));
				excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(set_variable, &HOL_ANY));
				if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
				if (excluded_quantifiers[1] != nullptr) HOL_ANY.reference_count++;
				if (excluded_quantifiers[2] != nullptr) HOL_ANY.reference_count++;
				if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr) {
					if (excluded_quantifiers[0] != nullptr) { free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]); }
					if (excluded_quantifiers[1] != nullptr) { free(*excluded_quantifiers[1]); free(excluded_quantifiers[1]); }
					free(*expected_conjunct); if (expected_conjunct->reference_count == 0) free(expected_conjunct);
					free_all(new_predicates); return false;
				}

				hol_term* set_definition;
				if (first_left != nullptr && first_left->type == hol_term_type::EQUALS) {
					set_definition = hol_term::new_equals(first_left->binary.left, hol_term::new_lambda(element_variable, conjunction));
				} else if (first_left != nullptr && first_left->type == hol_term_type::BINARY_APPLICATION) {
					set_definition = hol_term::new_apply(first_left->ternary.first, first_left->ternary.second, hol_term::new_lambda(element_variable, conjunction));
				} else {
					set_definition = hol_term::new_any_right(hol_term::new_lambda(element_variable, conjunction), excluded_quantifiers, array_length(excluded_quantifiers));
				}
				if (set_definition == nullptr) {
					free(*conjunction); free(conjunction);
					for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
					free(*expected_conjunct); if (expected_conjunct->reference_count == 0) free(expected_conjunct);
					free_all(new_predicates); return false;
				}
				if (first_left != nullptr && first_left->type == hol_term_type::EQUALS) {
					first_left->binary.left->reference_count++;
				} else if (first_left != nullptr && first_left->type == hol_term_type::BINARY_APPLICATION) {
					first_left->ternary.first->reference_count++;
					first_left->ternary.second->reference_count++;
				} else {
					for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++)
						excluded_quantifiers[i]->reference_count++;
				}

				hol_term* outer_conjunct = hol_term::new_any(nullptr, excluded_quantifiers, array_length(excluded_quantifiers));
				if (outer_conjunct == nullptr) {
					free(*set_definition); free(set_definition);
					for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
					free(*expected_conjunct); if (expected_conjunct->reference_count == 0) free(expected_conjunct);
					free_all(new_predicates); return false;
				}

				hol_term* new_head = hol_term::new_exists(set_variable, hol_term::new_any_array(hol_term_type::AND, outer_conjunct,
						make_array_view((hol_term**) nullptr, 0), make_array_view(&set_definition, 1), make_array_view((hol_term**) nullptr, 0)));
				if (new_head == nullptr) {
					free(*set_definition); free(set_definition);
					free(*outer_conjunct); free(outer_conjunct);
					free(*expected_conjunct); if (expected_conjunct->reference_count == 0) free(expected_conjunct);
					free_all(new_predicates); return false;
				}
				could_have_wide_scope = true;

				dst[dst.length++] = new_head;
				if (intersection_can_have_free_variables) {
					dst_outer[dst_outer.length] = hol_term::new_any_right(&HOL_ZERO);
					if (dst_outer[dst_outer.length] == nullptr) {
						free_all(dst); free_all(dst_outer);
						free(*expected_conjunct); if (expected_conjunct->reference_count == 0) free(expected_conjunct);
						free_all(new_predicates); return false;
					}
				} else {
					dst_outer[dst_outer.length] = &HOL_ZERO;
				}
				HOL_ZERO.reference_count++;
				dst_outer.length++;
			}
			free(*expected_conjunct); if (expected_conjunct->reference_count == 0) free(expected_conjunct);
			free_all(new_predicates);
			return true;
		});
	if (!result) return false;

	for (unsigned int i = 0; i < inverse_count; i++) {
		if (inverse[i].root->type != hol_term_type::LAMBDA) {
			hol_term* new_inverse = hol_term::new_lambda(lambda_variable, inverse[i].root);
			if (new_inverse == nullptr) {
				for (unsigned int j = 0; j < inverse_count; j++) free(inverse[j]);
				free(inverse); return false;
			}
			inverse[i].root = new_inverse;
		}
	}
	return true;
}

template<int_fast8_t ConjunctIndex, bool Predicative>
inline bool invert_remove_conjunct_in_set(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	unsigned int max_variable = 0;
	max_bound_variable(*first, max_variable);

	unsigned int first_lambda_variable = 0;
	if (first->type == hol_term_type::LAMBDA) {
		first_lambda_variable = first->quantifier.variable;
		first = first->quantifier.operand;
	} else if (first->type == hol_term_type::ANY) {
		first_lambda_variable = ++max_variable;
	} else {
		return false;
	}

	unsigned int second_lambda_variable = 0;
	if (Predicative) {
		if (second->type == hol_term_type::LAMBDA) {
			second_lambda_variable = second->quantifier.variable;
			second = second->quantifier.operand;
		} else if (second->type == hol_term_type::ANY) {
			second_lambda_variable = ++max_variable;
		} else {
			return false;
		}
	}

	auto on_remap_variables = [](hol_term* first_head, hol_term* second_head,
			apply_head_inverter& first_head_inverter, apply_head_inverter& second_head_inverter,
			array_map<const hol_term*, unsigned int>& second_variable_map, unsigned int max_variable,
			bool first_head_is_array, bool second_head_is_array)
	{
		if ((second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT) && second_head->any.included != nullptr)
			second_head = second_head->any.included;

		if ((first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) && first_head->any.included != nullptr
		 && (first_head->any.included->type == hol_term_type::NOT || first_head->any.included->type == hol_term_type::EXISTS))
			first_head = first_head->any.included;

		hol_term* first_lambda = nullptr;
		hol_term* first_set_definition = nullptr;
		if (first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) {
			return true; /* we don't need to relabel variables */
		} else {
#if !defined(NDEBUG)
			if (first_head->type != hol_term_type::EXISTS)
				fprintf(stderr, "invert_remove_conjunct_in_set WARNING: Expected an existential quantification.\n");
#endif
			hol_term* operand = first_head->quantifier.operand;

			hol_term* left;
			if (operand->type == hol_term_type::AND) {
				left = operand->array.operands[0];
			} else if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
				if (operand->any_array.left.length == 0)
					left = operand->any_array.all;
				else left = operand->any_array.left.operands[0];
			} else {
				return true;
			}

			if (left->type == hol_term_type::EQUALS && left->binary.right->type == hol_term_type::LAMBDA) {
				first_lambda = left->binary.right;
			} else if (left->type == hol_term_type::BINARY_APPLICATION && left->ternary.third->type == hol_term_type::LAMBDA) {
				first_lambda = left->ternary.third;
			} else if (left->type == hol_term_type::ANY_RIGHT && left->any.included != nullptr && left->any.included->type == hol_term_type::LAMBDA) {
				first_lambda = left->any.included;
			} else {
				return true;
			}

			first_set_definition = first_lambda->quantifier.operand;
		}

#if !defined(NDEBUG)
		if (second_head->type != hol_term_type::EXISTS)
			fprintf(stderr, "invert_remove_conjunct_in_set WARNING: Expected an existential quantification.\n");
#endif
		hol_term* operand = second_head->quantifier.operand;

		hol_term* second_set_definition;
		if (Predicative) {
			hol_term* left;
			if (operand->type == hol_term_type::AND) {
				left = operand->array.operands[0];
			} else if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
				if (operand->any_array.left.length == 0)
					left = operand->any_array.all;
				else left = operand->any_array.left.operands[0];
			} else {
				return true;
			}

			hol_term* lambda;
			if (left->type == hol_term_type::EQUALS && left->binary.right->type == hol_term_type::LAMBDA) {
				lambda = left->binary.right;
			} else if (left->type == hol_term_type::BINARY_APPLICATION && left->ternary.third->type == hol_term_type::LAMBDA) {
				lambda = left->ternary.third;
			} else if (left->type == hol_term_type::ANY_RIGHT && left->any.included != nullptr && left->any.included->type == hol_term_type::LAMBDA) {
				lambda = left->any.included;
			} else {
				return true;
			}

			second_set_definition = lambda->quantifier.operand;
		} else {
			second_set_definition = operand;
		}

		if (second_set_definition->type == hol_term_type::ANY_ARRAY)
			return false;

		/* make sure the non-right-leaning trees in `second` don't declare
		   variables that have already been declared in the right-leaning path
		   in `first` from the root to the head, excluding the head */
		array<unsigned int> declared_variables(8);
		for (unsigned int i = 0; i + 1 < first_head_inverter.outer.length; i++) {
			hol_term* node = first_head_inverter.outer[i];
			if (node->type == hol_term_type::EXISTS || node->type == hol_term_type::FOR_ALL || node->type == hol_term_type::LAMBDA) {
				if (!declared_variables.add(node->quantifier.variable)) {
					for (auto entry : second_variable_map) free(entry.value);
					return false;
				}
			}
		}
		array<hol_term*> second_scopes(16);
		for (hol_term* node : second_head_inverter.outer) {
			if (node->type == hol_term_type::AND || node->type == hol_term_type::OR || node->type == hol_term_type::IFF) {
				for (unsigned int i = 0; i + 1 < node->array.length; i++) {
					if (!get_scopes(*node->array.operands[i], second_scopes)) {
						for (auto entry : second_variable_map) free(entry.value);
						return false;
					}
				}
			} else if (node->type == hol_term_type::IF_THEN || node->type == hol_term_type::UNARY_APPLICATION || node->type == hol_term_type::EQUALS) {
				if (!get_scopes(*node->binary.left, second_scopes)) {
					for (auto entry : second_variable_map) free(entry.value);
					return false;
				}
			} else if (node->type == hol_term_type::BINARY_APPLICATION) {
				if (!get_scopes(*node->ternary.first, second_scopes)
				 || !get_scopes(*node->ternary.second, second_scopes))
				{
					for (auto entry : second_variable_map) free(entry.value);
					return false;
				}
			} else if (node->type == hol_term_type::ANY_ARRAY) {
				for (unsigned int i = 0; i < node->any_array.left.length; i++) {
					if (!get_scopes(*node->any_array.left.operands[i], second_scopes)) {
						for (auto entry : second_variable_map) free(entry.value);
						return false;
					}
				} for (unsigned int i = 0; i < node->any_array.any.length; i++) {
					if (!get_scopes(*node->any_array.any.operands[i], second_scopes)) {
						for (auto entry : second_variable_map) free(entry.value);
						return false;
					}
				} for (unsigned int i = 0; i + 1 < node->any_array.right.length; i++) {
					if (!get_scopes(*node->any_array.right.operands[i], second_scopes)) {
						for (auto entry : second_variable_map) free(entry.value);
						return false;
					}
				}
			}
		}
		for (hol_term* scope : second_scopes) {
			if ((scope->type == hol_term_type::EXISTS || scope->type == hol_term_type::FOR_ALL || scope->type == hol_term_type::LAMBDA)
			 && declared_variables.contains(scope->quantifier.variable)
			 && !second_variable_map.put(scope, ++max_variable))
			{
				for (auto entry : second_variable_map) free(entry.value);
				return false;
			}
		}

		hol_term* new_first_set_definition;
		if (first_set_definition->type == hol_term_type::AND) {
			unsigned int index = (ConjunctIndex < 0) ? (first_set_definition->array.length + ConjunctIndex) : ConjunctIndex;
			if (first_set_definition->array.length == 2) {
				new_first_set_definition = first_set_definition->array.operands[index == 0 ? 1 : 0];
				new_first_set_definition->reference_count++;
			} else {
				new_first_set_definition = hol_term::new_and(make_excluded_array_view(first_set_definition->array.operands, first_set_definition->array.length, index));
				if (new_first_set_definition == nullptr) return false;
				for (unsigned int i = 0; i < new_first_set_definition->array.length; i++)
					new_first_set_definition->array.operands[i]->reference_count++;
			}
		} else if (first_set_definition->type == hol_term_type::ANY_ARRAY && first_set_definition->any_array.oper == hol_term_type::AND) {
			if (ConjunctIndex < 0 && -ConjunctIndex <= first_set_definition->any_array.right.length) {
				unsigned int index = first_set_definition->any_array.right.length + ConjunctIndex;
				new_first_set_definition = hol_term::new_any_array(first_set_definition->any_array.oper, first_set_definition->any_array.all,
						make_array_view(first_set_definition->any_array.any.operands, first_set_definition->any_array.any.length),
						make_array_view(first_set_definition->any_array.left.operands, first_set_definition->any_array.left.length),
						make_excluded_array_view(first_set_definition->any_array.right.operands, first_set_definition->any_array.right.length, index));
				if (new_first_set_definition == nullptr) return false;
				new_first_set_definition->any_array.all->reference_count++;
				for (unsigned int i = 0; i < new_first_set_definition->any_array.left.length; i++)
					new_first_set_definition->any_array.left.operands[i]->reference_count++;
				for (unsigned int i = 0; i < new_first_set_definition->any_array.right.length; i++)
					new_first_set_definition->any_array.right.operands[i]->reference_count++;
				for (unsigned int i = 0; i < new_first_set_definition->any_array.any.length; i++)
					new_first_set_definition->any_array.any.operands[i]->reference_count++;
			} else if (ConjunctIndex >= 0 && (unsigned int) ConjunctIndex < first_set_definition->any_array.left.length) {
				unsigned int index = ConjunctIndex;
				new_first_set_definition = hol_term::new_any_array(first_set_definition->any_array.oper, first_set_definition->any_array.all,
						make_array_view(first_set_definition->any_array.any.operands, first_set_definition->any_array.any.length),
						make_excluded_array_view(first_set_definition->any_array.left.operands, first_set_definition->any_array.left.length, index),
						make_array_view(first_set_definition->any_array.right.operands, first_set_definition->any_array.right.length));
				if (new_first_set_definition == nullptr) return false;
				new_first_set_definition->any_array.all->reference_count++;
				for (unsigned int i = 0; i < new_first_set_definition->any_array.left.length; i++)
					new_first_set_definition->any_array.left.operands[i]->reference_count++;
				for (unsigned int i = 0; i < new_first_set_definition->any_array.right.length; i++)
					new_first_set_definition->any_array.right.operands[i]->reference_count++;
				for (unsigned int i = 0; i < new_first_set_definition->any_array.any.length; i++)
					new_first_set_definition->any_array.any.operands[i]->reference_count++;
			} else {
				new_first_set_definition = first_set_definition;
				first_set_definition->reference_count++;
			}
		} else {
			return true;
		}

		array<pair<hol_term*, variable_map>> intersection(2);
		intersect<built_in_predicates, true, true>(intersection, new_first_set_definition, second_set_definition);
		free(*new_first_set_definition); if (new_first_set_definition->reference_count == 0) free(new_first_set_definition);
		if (intersection.length == 0) {
			return false;
		} else if (intersection.length != 1) {
			fprintf(stderr, "invert_remove_conjunct_in_set ERROR: Intersection modulo variable relabeling is not unique.\n");
			free_all(intersection); return false;
		}

		/* make sure the variables in `second_head` map to the correct variables in `first_head` */
		const variable_map& var_map = intersection[0].value;
		for (const auto& entry : var_map.scope_map) {
			if (!second_variable_map.contains(entry.key.src))
				continue;

			unsigned int target_var = 0;
			if (!get_target_variable(entry.key.src->quantifier.variable, target_var, entry.value, max_variable)) {
				for (auto entry : second_variable_map) free(entry.value);
				free_all(intersection); return false;
			}

			if (!second_variable_map.ensure_capacity(second_variable_map.size + 1)) {
				free_all(intersection);
				return false;
			}
			unsigned int index = second_variable_map.index_of(entry.key.src);
			if (target_var == second_variable_map.values[index]) {
				/* `second_variable_map` should map `var` to itself */
				second_variable_map.remove_at(index);
			} else {
				/* `second_variable_map` should map `var` to `target_var` */
				second_variable_map.values[index] = target_var;
				if (index == second_variable_map.size) {
					second_variable_map.keys[index] = entry.key.src;
					second_variable_map.size++;
				}
			}
		}

		array_map<unsigned int, variable_set> free_variable_map(8);
		for (const auto& entry : var_map.free_variables) {
			const variable_set& set = entry.value;
			if (set.type == variable_set_type::SINGLETON && set.variable == first_lambda->quantifier.variable) {
				hol_term* scope = nullptr;
				for (unsigned int i = 0; i < second_head_inverter.outer.length; i++)
					if (second_head_inverter.outer[i]->type == hol_term_type::EXISTS && second_head_inverter.outer[i]->quantifier.variable == entry.key) { scope = second_head_inverter.outer[i]; break; }
				if (scope != nullptr && !second_variable_map.put(scope, set.variable)) {
					free_all(intersection);
					return false;
				}
				continue;
			}

			unsigned int src_variable = entry.key;
			if (!free_variable_map.ensure_capacity(free_variable_map.size + 1)) {
				for (auto entry : second_variable_map) free(entry.value);
				free_all(intersection); return false;
			}
			unsigned int index = free_variable_map.index_of(src_variable);
			if (index < free_variable_map.size) {
				variable_set& new_set = *((variable_set*) alloca(sizeof(variable_map)));
				if (!intersect(new_set, set, free_variable_map.values[index])) {
					for (auto entry : second_variable_map) free(entry.value);
					free_all(intersection); return false;
				}
				swap(free_variable_map.values[index], new_set);
				free(new_set);
			} else {
				free_variable_map.keys[free_variable_map.size] = src_variable;
				if (!init(free_variable_map.values[free_variable_map.size], set)) {
					for (auto entry : second_variable_map) free(entry.value);
					free_all(intersection); return false;
				}
				free_variable_map.size++;
			}
		}
		free_all(intersection);

		if (!remap_scopes(free_variable_map, first_head_inverter, second_head_inverter, second_variable_map, max_variable, first_head_is_array, second_head_is_array)) {
			for (auto entry : second_variable_map) free(entry.value);
			return false;
		}
		return true;
	};

	auto invert_second_head = [](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, const apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array) {
			if ((first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) && first_head->any.included != nullptr)
				first_head = first_head->any.included;
			hol_term* old_second_head = second_head;
			if ((second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT) && second_head->any.included != nullptr)
				second_head = second_head->any.included;

#if !defined(NDEBUG)
			if (second_head->type != hol_term_type::EXISTS)
				fprintf(stderr, "invert_remove_conjunct_in_set WARNING: Expected an existential quantification.\n");
#endif

			hol_term* inner_operand; hol_term* operand; hol_term* left;
			unsigned int set_variable; unsigned int element_variable;
			if (Predicative) {
				operand = second_head->quantifier.operand;
				set_variable = second_head->quantifier.variable;

				hol_term* right = nullptr;
				if (operand->type == hol_term_type::AND) {
					left = operand->array.operands[0];
					right = operand->array.operands[operand->array.length - 1];
				} else if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.left.length != 0) {
					left = operand->any_array.left.operands[0];
					if (operand->any_array.right.length != 0)
						right = operand->any_array.right.operands[operand->any_array.right.length - 1];
				} else {
					return false;
				}

				if (left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT) {
					inner_operand = left->any.included->quantifier.operand;
					element_variable = left->any.included->quantifier.variable;
				} else if (left->type == hol_term_type::EQUALS) {
					inner_operand = left->binary.right->quantifier.operand;
					element_variable = left->binary.right->quantifier.variable;
				} else {
					inner_operand = left->ternary.third->quantifier.operand;
					element_variable = left->ternary.third->quantifier.variable;
				}

				if (right != nullptr) {
					if (right->type == hol_term_type::ANY_RIGHT) {
						/* check if wide scopes are excluded */
						bool wide_scope_excluded = false;
						for (unsigned int i = 0; i < right->any.excluded_tree_count; i++) {
							hol_term* excluded = right->any.excluded_trees[i];
							if ((excluded->type == hol_term_type::ANY || excluded->type == hol_term_type::ANY_RIGHT)
							 && excluded->any.included != nullptr && excluded->any.included->type == hol_term_type::UNARY_APPLICATION
							 && excluded->any.included->binary.left->type == hol_term_type::CONSTANT
							 && excluded->any.included->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE
							 && *excluded->any.included->binary.right == HOL_ANY)
							{
								wide_scope_excluded = true;
								break;
							}
						}
						if (!wide_scope_excluded)
							could_have_wide_scope = true;
					} else if (right->type == hol_term_type::UNARY_APPLICATION && right->binary.left->type == hol_term_type::CONSTANT && right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
						could_have_wide_scope = true;
					} else {
						while (right->type == hol_term_type::NOT)
							right = right->unary.operand;
						if (right->type == hol_term_type::ANY_RIGHT) {
							/* check if wide scopes are excluded */
							bool wide_scope_excluded = false;
							for (unsigned int i = 0; i < right->any.excluded_tree_count; i++) {
								hol_term* excluded = right->any.excluded_trees[i];
								if ((excluded->type == hol_term_type::ANY || excluded->type == hol_term_type::ANY_RIGHT)
								 && excluded->any.included != nullptr && excluded->any.included->type == hol_term_type::UNARY_APPLICATION
								 && excluded->any.included->binary.left->type == hol_term_type::CONSTANT
								 && excluded->any.included->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE
								 && *excluded->any.included->binary.right == HOL_ANY)
								{
									wide_scope_excluded = true;
									break;
								}
							}
							if (!wide_scope_excluded)
								could_have_wide_scope = true;
						} else if (right->type == hol_term_type::EXISTS && right->quantifier.operand->type == hol_term_type::AND) {
							right = right->quantifier.operand->array.operands[right->quantifier.operand->array.length - 1];
						} else if (right->type == hol_term_type::FOR_ALL && right->quantifier.operand->type == hol_term_type::IF_THEN) {
							right = right->quantifier.operand->binary.right;
						}
						if (right->type == hol_term_type::ANY_RIGHT) {
							/* check if wide scopes are excluded */
							bool wide_scope_excluded = false;
							for (unsigned int i = 0; i < right->any.excluded_tree_count; i++) {
								hol_term* excluded = right->any.excluded_trees[i];
								if ((excluded->type == hol_term_type::ANY || excluded->type == hol_term_type::ANY_RIGHT)
								 && excluded->any.included != nullptr && excluded->any.included->type == hol_term_type::UNARY_APPLICATION
								 && excluded->any.included->binary.left->type == hol_term_type::CONSTANT
								 && excluded->any.included->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE
								 && *excluded->any.included->binary.right == HOL_ANY)
								{
									wide_scope_excluded = true;
									break;
								}
							}
							if (!wide_scope_excluded)
								could_have_wide_scope = true;
						} else if (right->type == hol_term_type::UNARY_APPLICATION && right->binary.left->type == hol_term_type::CONSTANT && right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
							could_have_wide_scope = true;
						}
					}
				}
			} else {
				inner_operand = second_head->quantifier.operand;
				element_variable = second_head->quantifier.variable;
				if (first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) {
					set_variable = ++max_variable;
				} else {
					set_variable = first_head->quantifier.variable;
				}
			}

			hol_term* head_var = hol_term::new_variable(element_variable);
			if (head_var == nullptr) return false;
			unsigned int excluded_tree_count = (inner_operand->type == hol_term_type::TRUE) ? 4 : 3;
			hol_term** excluded_trees = (hol_term**) alloca(sizeof(hol_term*) * excluded_tree_count);
			excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
						(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
						(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
					&HOL_ANY), head_var));
			excluded_trees[1] = hol_term::new_any(hol_term::new_lambda(element_variable, &HOL_ANY));
			excluded_trees[2] = hol_term::new_any(hol_term::new_exists(set_variable, &HOL_ANY));
			if (inner_operand->type == hol_term_type::TRUE)
				excluded_trees[3] = hol_term::new_any_array(hol_term_type::AND, &HOL_ANY, make_array_view((hol_term**) nullptr, 0), make_repeated_array_view(&HOL_ANY, 2), make_array_view((hol_term**) nullptr, 0));
			if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
			if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
			if (excluded_trees[2] != nullptr) { HOL_ANY.reference_count++; }
			if (inner_operand->type == hol_term_type::TRUE && excluded_trees[3] != nullptr) { HOL_ANY.reference_count += 3; }
			if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr || excluded_trees[2] == nullptr
			 || (inner_operand->type == hol_term_type::TRUE && excluded_trees[3] == nullptr))
			{
				if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
				if (excluded_trees[1] != nullptr) { free(*excluded_trees[1]); free(excluded_trees[1]); }
				if (excluded_trees[2] != nullptr) { free(*excluded_trees[2]); free(excluded_trees[2]); }
				free(*head_var); free(head_var);
				return false;
			}
			free(*head_var);

			hol_term* expected_conjunct = hol_term::new_any(nullptr, excluded_trees, excluded_tree_count);
			if (expected_conjunct == nullptr) {
				free(*excluded_trees[0]); free(excluded_trees[0]);
				free(*excluded_trees[1]); free(excluded_trees[1]);
				free(*excluded_trees[2]); free(excluded_trees[2]);
				if (inner_operand->type == hol_term_type::TRUE) {
					free(*excluded_trees[3]); free(excluded_trees[3]);
				}
				return false;
			}

			hol_term* conjunction = nullptr;
			if (inner_operand->type == hol_term_type::AND) {
				unsigned int index = (unsigned int) ((ConjunctIndex < 0) ? (ConjunctIndex + inner_operand->array.length + 1) : ConjunctIndex);
				conjunction = hol_term::new_and(make_included_array_view(inner_operand->array.operands, inner_operand->array.length, expected_conjunct, index));
				if (conjunction == nullptr) {
					free(*expected_conjunct); free(expected_conjunct);
					return false;
				}
				for (unsigned int i = 0; i < inner_operand->array.length; i++)
					inner_operand->array.operands[i]->reference_count++;
			} else if (inner_operand->type == hol_term_type::ANY_ARRAY) {
				/* TODO: we can avoid constructing `expected_conjunct` in this case */
				if (ConjunctIndex >= 0 && (unsigned int) ConjunctIndex < inner_operand->any_array.left.length) {
					conjunction = hol_term::new_any_array(hol_term_type::AND, inner_operand->any_array.all,
							make_array_view(inner_operand->any_array.any.operands, inner_operand->any_array.any.length),
							make_included_array_view(inner_operand->any_array.left.operands, inner_operand->any_array.left.length, expected_conjunct, ConjunctIndex),
							make_array_view(inner_operand->any_array.right.operands, inner_operand->any_array.right.length));
					if (conjunction == nullptr) {
						free(*expected_conjunct); free(expected_conjunct);
						return false;
					}
					conjunction->any_array.all->reference_count++;
					for (unsigned int i = 0; i < conjunction->any_array.left.length; i++)
						conjunction->any_array.left.operands[i]->reference_count++;
					for (unsigned int i = 0; i < conjunction->any_array.right.length; i++)
						conjunction->any_array.right.operands[i]->reference_count++;
					for (unsigned int i = 0; i < conjunction->any_array.any.length; i++)
						conjunction->any_array.any.operands[i]->reference_count++;
					free(*expected_conjunct); if (expected_conjunct->reference_count == 0) free(expected_conjunct);
				} else if (ConjunctIndex < 0 && -ConjunctIndex < inner_operand->any_array.right.length + 1) {
					unsigned int index = (unsigned int) (inner_operand->any_array.right.length + ConjunctIndex + 1);
					conjunction = hol_term::new_any_array(hol_term_type::AND, inner_operand->any_array.all,
							make_array_view(inner_operand->any_array.any.operands, inner_operand->any_array.any.length),
							make_array_view(inner_operand->any_array.left.operands, inner_operand->any_array.left.length),
							make_included_array_view(inner_operand->any_array.right.operands, inner_operand->any_array.right.length, expected_conjunct, index));
					if (conjunction == nullptr) {
						free(*expected_conjunct); free(expected_conjunct);
						return false;
					}
					conjunction->any_array.all->reference_count++;
					for (unsigned int i = 0; i < conjunction->any_array.left.length; i++)
						conjunction->any_array.left.operands[i]->reference_count++;
					for (unsigned int i = 0; i < conjunction->any_array.right.length; i++)
						conjunction->any_array.right.operands[i]->reference_count++;
					for (unsigned int i = 0; i < conjunction->any_array.any.length; i++)
						conjunction->any_array.any.operands[i]->reference_count++;
					free(*expected_conjunct); if (expected_conjunct->reference_count == 0) free(expected_conjunct);
				} else {
					free(*expected_conjunct); free(expected_conjunct);
					conjunction = inner_operand;
					conjunction->reference_count++;
				}
			} else if (inner_operand->type == hol_term_type::TRUE) {
				conjunction = expected_conjunct;
			} else {
				unsigned int index = (unsigned int) ((ConjunctIndex < 0) ? (ConjunctIndex + inner_operand->array.length + 1) : ConjunctIndex);
				if (index == 0)
					conjunction = hol_term::new_and(expected_conjunct, inner_operand);
				else conjunction = hol_term::new_and(inner_operand, expected_conjunct);
				if (conjunction == nullptr) {
					free(*expected_conjunct); free(expected_conjunct);
					return false;
				}
				inner_operand->reference_count++;
			}

			hol_term* set_definition;
			if (Predicative) {
				if (left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT) {
					set_definition = hol_term::new_any_right(hol_term::new_lambda(element_variable, conjunction), left->any.excluded_trees, left->any.excluded_tree_count);
					if (set_definition == nullptr) {
						free(*conjunction); free(conjunction);
						return false;
					}
					for (unsigned int i = 0; i < left->any.excluded_tree_count; i++)
						left->any.excluded_trees[i]->reference_count++;
				} else if (left->type == hol_term_type::EQUALS) {
					set_definition = hol_term::new_equals(left->binary.left, hol_term::new_lambda(element_variable, conjunction));
					if (set_definition == nullptr) {
						free(*conjunction); free(conjunction);
						return false;
					}
					left->binary.left->reference_count++;
				} else {
					set_definition = hol_term::new_apply(left->ternary.first, left->ternary.second, hol_term::new_lambda(element_variable, conjunction));
					if (set_definition == nullptr) {
						free(*conjunction); free(conjunction);
						return false;
					}
					left->ternary.first->reference_count++;
					left->ternary.second->reference_count++;
				}

				if (operand->type == hol_term_type::AND) {
					dst[dst.length] = hol_term::new_exists(set_variable, hol_term::new_and(make_prepended_array_view(set_definition,
							make_array_view(operand->array.operands + 1, operand->array.length - 1))));
					if (dst[dst.length] == nullptr) {
						free(*set_definition); free(set_definition);
						return false;
					}
					for (unsigned int i = 1; i < operand->array.length; i++)
						operand->array.operands[i]->reference_count++;
				} else {
					dst[dst.length] = hol_term::new_exists(set_variable, hol_term::new_any_array(hol_term_type::AND, operand->any_array.all,
							make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
							make_prepended_array_view(set_definition, make_array_view(operand->any_array.left.operands + 1, operand->any_array.left.length - 1)),
							make_array_view(operand->any_array.right.operands, operand->any_array.right.length)));
					if (dst[dst.length] == nullptr) {
						free(*set_definition); free(set_definition);
						return false;
					}
					operand->any_array.all->reference_count++;
					for (unsigned int i = 0; i < operand->any_array.any.length; i++)
						operand->any_array.any.operands[i]->reference_count++;
					for (unsigned int i = 1; i < operand->any_array.left.length; i++)
						operand->any_array.left.operands[i]->reference_count++;
					for (unsigned int i = 0; i < operand->any_array.right.length; i++)
						operand->any_array.right.operands[i]->reference_count++;
				}
				dst.length++;
			} else {
				hol_term* right = nullptr;
				if (first_head->type == hol_term_type::EXISTS) {
					hol_term* operand = first_head->quantifier.operand;
					if (operand->type == hol_term_type::AND) {
						if (operand->array.length != 2) {
							free(*conjunction); free(conjunction);
							return false;
						}
						right = operand->array.operands[operand->array.length - 1];
					} else if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
						if (operand->any_array.right.length != 0)
							right = operand->any_array.right.operands[operand->any_array.right.length - 1];
					} else if (operand->type != hol_term_type::ANY && operand->type != hol_term_type::ANY_RIGHT) {
						free(*conjunction); free(conjunction);
						return false;
					}
				}

				if (right == nullptr) {
					hol_term* excluded_quantifier = hol_term::new_any(hol_term::new_exists(set_variable, &HOL_ANY));
					if (excluded_quantifier == nullptr) {
						free(*conjunction); free(conjunction);
						return false;
					}
					HOL_ANY.reference_count++;

					right = hol_term::new_any(nullptr, &excluded_quantifier, 1);
					if (right == nullptr) {
						free(*conjunction); free(conjunction);
						free(*excluded_quantifier); free(excluded_quantifier);
						return false;
					}
				} else {
					right->reference_count++;
				}

				dst[dst.length] = hol_term::new_exists(set_variable, hol_term::new_and(
						hol_term::new_equals(hol_term::new_variable(set_variable), hol_term::new_lambda(element_variable, conjunction)), right));
				if (dst[dst.length] == nullptr) {
					free(*conjunction); free(conjunction);
					free(*right); if (right->reference_count == 0) free(right);
					return false;
				}
				dst.length++;
			}

			hol_term* first_conjunct = nullptr;
			if (first_head->type == hol_term_type::EXISTS) {
				hol_term* left = nullptr;
				hol_term* operand = first_head->quantifier.operand;
				if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
					if (operand->any_array.left.length != 0)
						left = operand->any_array.left.operands[0];
				} else if (operand->type == hol_term_type::AND) {
					left = operand->array.operands[0];
				} else if (operand->type != hol_term_type::ANY && operand->type != hol_term_type::ANY_RIGHT) {
					return false;
				}

				hol_term* set_definition = nullptr;
				if (left != nullptr) {
					if (left->type == hol_term_type::ANY_RIGHT && left->any.included != nullptr) {
						set_definition = left->any.included;
					} else if (left->type == hol_term_type::EQUALS) {
						set_definition = left->binary.right;
					} else if (left->type == hol_term_type::BINARY_APPLICATION) {
						set_definition = left->ternary.third;
					}
				}

				if (set_definition != nullptr) {
					if (set_definition->type == hol_term_type::ANY_RIGHT && set_definition->any.included != nullptr)
						set_definition = set_definition->any.included;
					if (set_definition->type == hol_term_type::LAMBDA) {
						set_definition = set_definition->quantifier.operand;
						if (set_definition->type == hol_term_type::ANY_ARRAY && set_definition->any_array.oper == hol_term_type::AND) {
							if (ConjunctIndex < 0 && (uint_fast8_t) (-ConjunctIndex) <= set_definition->any_array.right.length)
								first_conjunct = set_definition->any_array.right.operands[set_definition->any_array.right.length + ConjunctIndex];
							else if (ConjunctIndex >= 0 && (uint_fast8_t) ConjunctIndex < set_definition->any_array.left.length)
								first_conjunct = set_definition->any_array.left.operands[ConjunctIndex];
						} else if (set_definition->type == hol_term_type::AND) {
							first_conjunct = set_definition->array.operands[(ConjunctIndex < 0) ? (set_definition->array.length + ConjunctIndex) : ConjunctIndex];
						}
					}
				}
			}

			if (old_second_head->type == hol_term_type::ANY || old_second_head->type == hol_term_type::ANY_RIGHT
			 || first_conjunct == nullptr || can_have_free_variables(*first_conjunct))
			{
				any_right_only = false;
			}

			bool second_could_have_wide_scope = false;
			for (unsigned int i = second_inverter.outer.length - 1; i > 0; i--) {
				const hol_term* node = second_inverter.outer[i - 1];
				if (node->type == hol_term_type::ANY || node->type == hol_term_type::ANY_RIGHT) {
					bool wide_scope_excluded = false;
					for (unsigned int i = 0; i < node->any.excluded_tree_count; i++) {
						if ((node->any.excluded_trees[i]->type == hol_term_type::ANY || node->any.excluded_trees[i]->type == hol_term_type::ANY_RIGHT)
							&& node->any.excluded_trees[i]->any.included->type == hol_term_type::UNARY_APPLICATION
							&& node->any.excluded_trees[i]->any.included->binary.left->type == hol_term_type::CONSTANT
							&& node->any.excluded_trees[i]->any.included->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE
							&& *node->any.excluded_trees[i]->any.included->binary.right == HOL_ANY)
						{
							wide_scope_excluded = true;
							break;
						}
					}
					if (!wide_scope_excluded)
						second_could_have_wide_scope = true;
				}
			}

			if (!second_could_have_wide_scope) {
				hol_term* excluded_trees[2];
				unsigned int excluded_tree_count = 1;
				excluded_trees[0] = hol_term::new_any_right(hol_term::new_apply(
						&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value,
						hol_term::new_any_right(hol_term::new_exists(set_variable, &HOL_ANY))));
				if (excluded_trees[0] == nullptr)
					return false;
				hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
				HOL_ANY.reference_count++;

				for (unsigned int i = second_inverter.outer.length - 1; i > 0; i--) {
					if (second_inverter.outer[i - 1]->type == hol_term_type::EXISTS || second_inverter.outer[i - 1]->type == hol_term_type::FOR_ALL || second_inverter.outer[i - 1]->type == hol_term_type::LAMBDA) {
						excluded_trees[1] = hol_term::new_any(hol_term::new_exists(second_inverter.outer[i - 1]->quantifier.variable, &HOL_ANY));
						if (excluded_trees[1] == nullptr) {
							free(*excluded_trees[0]); free(excluded_trees[0]);
							return false;
						}
						HOL_ANY.reference_count++;
						excluded_tree_count++;
						break;
					}
				}

				dst_outer[dst_outer.length] = hol_term::new_any_right(&HOL_ZERO, excluded_trees, excluded_tree_count);
				if (dst_outer[dst_outer.length] == nullptr) {
					for (unsigned int i = 0; i < excluded_tree_count; i++) {
						free(*excluded_trees[i]); free(excluded_trees[i]);
					}
					return false;
				}
				HOL_ZERO.reference_count++;
				dst_outer.length++;
			} else {
				dst_outer[dst_outer.length] = &HOL_ZERO;
				HOL_ZERO.reference_count++;
				dst_outer.length++;
			}
			return true;
		};

	bool result;
	if (Predicative) {
		result = invert_apply_head(inverse, inverse_count, flags, first, second,
			predicative_head_finder<built_in_predicates>(first_lambda_variable),
			predicative_head_finder<built_in_predicates>(second_lambda_variable), on_remap_variables, invert_second_head);
	} else {
		result = invert_apply_head(inverse, inverse_count, flags, first, second,
			predicative_head_finder<built_in_predicates>(first_lambda_variable),
			find_head<built_in_predicates>, on_remap_variables, invert_second_head);
	}
	if (!result) return false;

	for (unsigned int i = 0; i < inverse_count; i++) {
		hol_term* new_inverse = hol_term::new_lambda(first_lambda_variable, inverse[i].root);
		if (new_inverse == nullptr) {
			for (unsigned int j = 0; j < inverse_count; j++) free(inverse[j]);
			free(inverse); return false;
		}
		inverse[i].root = new_inverse;
	}
	return true;
}

template<int_fast8_t ConjunctIndex>
inline bool invert_select_subset_in_set(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	unsigned int max_variable = 0;
	max_bound_variable(*first, max_variable);

	unsigned int first_lambda_variable = 0;
	if (first->type == hol_term_type::LAMBDA) {
		first_lambda_variable = first->quantifier.variable;
		first = first->quantifier.operand;
	} else if (first->type == hol_term_type::ANY) {
		first_lambda_variable = ++max_variable;
	} else {
		return false;
	}

	unsigned int second_lambda_variable = 0;
	if (second->type == hol_term_type::LAMBDA) {
		second_lambda_variable = second->quantifier.variable;
		second = second->quantifier.operand;
	} else if (second->type == hol_term_type::ANY) {
		second_lambda_variable = ++max_variable;
	} else {
		return false;
	}

	auto on_remap_variables = [](hol_term* first_head, hol_term* second_head,
			apply_head_inverter& first_head_inverter, apply_head_inverter& second_head_inverter,
			array_map<const hol_term*, unsigned int>& second_variable_map, unsigned int& max_variable,
			bool first_head_is_array, bool second_head_is_array)
	{
		if ((first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) && first_head->any.included != nullptr) {
			first_head = first_head->any.included;
			if (!first_head_inverter.outer.add(first_head))
				return false;
		} if ((second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT) && second_head->any.included != nullptr) {
			second_head = second_head->any.included;
			if (!second_head_inverter.outer.add(second_head))
				return false;
		}

#if !defined(NDEBUG)
		if (second_head->type != hol_term_type::EXISTS || (second_head->quantifier.operand->type != hol_term_type::ANY_ARRAY && second_head->quantifier.operand->type != hol_term_type::AND))
			fprintf(stderr, "invert_select_subset_in_set WARNING: Expected an existentially-quantified conjunction.\n");
#endif

		unsigned int first_superset_variable;
		if (first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) {
			first_superset_variable = 0;
		} else {
#if !defined(NDEBUG)
			if (first_head->type != hol_term_type::EXISTS)
				fprintf(stderr, "invert_select_subset_in_set WARNING: Expected an existential quantification.\n");
#endif
			hol_term* left = nullptr;
			hol_term* operand = first_head->quantifier.operand;
			if (operand->type == hol_term_type::ANY || operand->type == hol_term_type::ANY_RIGHT) {
				first_superset_variable = 0;
			} else if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
				if (operand->any_array.left.length == 0) {
					left = operand->any_array.all;
				} else {
					left = operand->any_array.left.operands[0];
				}
			} else if (operand->type == hol_term_type::AND) {
				left = operand->array.operands[0];
			} else {
				return false;
			}

			hol_term* set_definition = nullptr;
			if (left != nullptr) {
				if (left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT) {
					first_superset_variable = 0;
				} else if (left->type == hol_term_type::EQUALS) {
					set_definition = left->binary.right;
				} else if (left->type == hol_term_type::BINARY_APPLICATION) {
					set_definition = left->ternary.third;
				} else {
					return false;
				}
			}

			hol_term* inner_operand = nullptr;
			if (set_definition != nullptr) {
				if (set_definition->type == hol_term_type::ANY || set_definition->type == hol_term_type::ANY_RIGHT) {
					first_superset_variable = 0;
				} else if (set_definition->type == hol_term_type::ANY_QUANTIFIER && has_intersection(set_definition->any_quantifier.quantifier, hol_quantifier_type::LAMBDA)) {
					inner_operand = set_definition->any_quantifier.operand;
				} else if (set_definition->type == hol_term_type::LAMBDA) {
					inner_operand = set_definition->any_quantifier.operand;
				} else {
					return false;
				}
			}

			hol_term* inner_conjunct = nullptr;
			if (inner_operand != nullptr) {
				if (inner_operand->type == hol_term_type::ANY || inner_operand->type == hol_term_type::ANY_RIGHT) {
					first_superset_variable = 0;
				} else if (inner_operand->type == hol_term_type::ANY_ARRAY && inner_operand->any_array.oper == hol_term_type::AND) {
					if (ConjunctIndex >= 0){
						if (ConjunctIndex < inner_operand->any_array.left.length)
							inner_conjunct = inner_operand->any_array.left.operands[ConjunctIndex];
						else inner_conjunct = inner_operand->any_array.all;
					} else {
						if (-ConjunctIndex <= inner_operand->any_array.right.length)
							inner_conjunct = inner_operand->any_array.right.operands[inner_operand->any_array.right.length + ConjunctIndex];
						else inner_conjunct = inner_operand->any_array.all;
					}
				} else if (inner_operand->type == hol_term_type::AND) {
					if (ConjunctIndex >= 0)
						inner_conjunct = inner_operand->array.operands[ConjunctIndex];
					else inner_conjunct = inner_operand->array.operands[inner_operand->array.length + ConjunctIndex];
				} else {
					inner_conjunct = inner_operand;
				}
			}

			if (inner_conjunct != nullptr) {
				if (inner_conjunct->type == hol_term_type::ANY || inner_conjunct->type == hol_term_type::ANY_RIGHT) {
					first_superset_variable = 0;
				} else if (inner_conjunct->type == hol_term_type::UNARY_APPLICATION) {
					hol_term* superset_var = inner_conjunct->binary.left;
					if (superset_var->type == hol_term_type::VARIABLE) {
						first_superset_variable = superset_var->variable;
					} else {
						first_superset_variable = 0;
					}
				} else {
					return false;
				}
			}
		}

		if (first_superset_variable != 0) {
			/* make sure `second_superset_variable` maps to `first_superset_variable` */
			array_map<unsigned int, variable_set> free_variable_map(4);
			free_variable_map.keys[0] = second_head->quantifier.variable;
			free_variable_map.values[0].type = variable_set_type::SINGLETON;
			free_variable_map.values[0].variable = first_superset_variable;
			free_variable_map.size = 1;

			hol_term* second_right;
			hol_term* operand = second_head->quantifier.operand;
			if (operand->type == hol_term_type::AND) {
				second_right = operand->array.operands[operand->array.length - 1];
				if (!second_head_inverter.outer.add(second_right)) {
					for (auto entry : second_variable_map) free(entry.value);
					return false;
				}
			} else if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND && operand->any_array.right.length != 0) {
				second_right = operand->any_array.right.operands[operand->any_array.right.length - 1];
				if (!second_head_inverter.outer.add(second_right)) {
					for (auto entry : second_variable_map) free(entry.value);
					return false;
				}
			} else {
				return true;
			}

			if (!remap_scopes(free_variable_map, first_head_inverter, second_head_inverter, second_variable_map, max_variable, first_head_is_array, second_head_is_array)) {
				for (auto entry : second_variable_map) free(entry.value);
				return false;
			}
		}
		return true;
	};

	bool result = invert_apply_head(inverse, inverse_count, flags, first, second,
		predicative_head_finder<built_in_predicates>(first_lambda_variable), predicative_head_finder<built_in_predicates>(second_lambda_variable), on_remap_variables,
		[first_lambda_variable,second_lambda_variable](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, const apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array) {
			if ((first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) && first_head->any.included != nullptr)
				first_head = first_head->any.included;
			if ((second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT) && second_head->any.included != nullptr)
				second_head = second_head->any.included;

#if !defined(NDEBUG)
			if (second_head->type != hol_term_type::EXISTS || (second_head->quantifier.operand->type != hol_term_type::ANY_ARRAY && second_head->quantifier.operand->type != hol_term_type::AND))
				fprintf(stderr, "invert_select_subset_in_set WARNING: Expected an existentially-quantified conjunction.\n");
#endif

			hol_term* left = nullptr;
			unsigned int first_set_variable, first_element_variable;
			if (first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) {
				first_set_variable = ++max_variable;
				first_element_variable = 0;
			} else {
#if !defined(NDEBUG)
				if (first_head->type != hol_term_type::EXISTS)
					fprintf(stderr, "invert_select_subset_in_set WARNING: Expected an existential quantification.\n");
#endif
				first_set_variable = first_head->quantifier.variable;
				hol_term* operand = first_head->quantifier.operand;

				if (operand->type == hol_term_type::ANY || operand->type == hol_term_type::ANY_RIGHT) {
					first_element_variable = 0;
				} else if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
					if (operand->any_array.left.length == 0) {
						left = operand->any_array.all;
					} else {
						left = operand->any_array.left.operands[0];
					}
				} else if (operand->type == hol_term_type::AND) {
					left = operand->array.operands[0];
				} else {
					return false;
				}

				hol_term* set_definition = nullptr;
				if (left != nullptr) {
					if (left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT) {
						first_element_variable = 0;
					} else if (left->type == hol_term_type::BINARY_APPLICATION) {
						set_definition = left->ternary.third;
					} else {
						return false;
					}
				}

				if (set_definition != nullptr) {
					if (set_definition->type == hol_term_type::ANY || set_definition->type == hol_term_type::ANY_RIGHT) {
						first_element_variable = 0;
					} else if (set_definition->type == hol_term_type::ANY_QUANTIFIER && has_intersection(set_definition->any_quantifier.quantifier, hol_quantifier_type::LAMBDA)) {
						first_element_variable = 0;
					} else if (set_definition->type == hol_term_type::LAMBDA) {
						first_element_variable = set_definition->quantifier.variable;
					} else {
						return false;
					}
				}

				if (first_element_variable == 0) {
					/* try to get the variable from the right conjunct in the set scope */
					hol_term* right = nullptr;
					if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
						if (operand->any_array.right.length == 0) {
							right = operand->any_array.all;
						} else {
							right = operand->any_array.right.operands[operand->any_array.right.length - 1];
						}
					} else if (operand->type == hol_term_type::AND) {
						right = operand->array.operands[operand->array.length - 1];
					}

					if (right != nullptr) {
						if ((right->type == hol_term_type::ANY || right->type == hol_term_type::ANY_RIGHT) && right->any.included != nullptr)
							right = right->any.included;
						if (right->type == hol_term_type::NOT)
							right = right->unary.operand;

						if (right->type == hol_term_type::FOR_ALL && right->quantifier.operand->type == hol_term_type::IF_THEN
							&& right->quantifier.operand->binary.right->type == hol_term_type::UNARY_APPLICATION
							&& right->quantifier.operand->binary.right->binary.left->type == hol_term_type::VARIABLE
							&& right->quantifier.operand->binary.right->binary.left->variable == first_lambda_variable
							&& right->quantifier.operand->binary.right->binary.right->type == hol_term_type::VARIABLE)
						{
							first_element_variable = right->quantifier.operand->binary.right->binary.right->variable;
						} else if (right->type == hol_term_type::EXISTS && right->quantifier.operand->type == hol_term_type::AND && right->quantifier.operand->array.length == 2
								&& right->quantifier.operand->array.operands[1]->type == hol_term_type::UNARY_APPLICATION
								&& right->quantifier.operand->array.operands[1]->binary.left->type == hol_term_type::VARIABLE
								&& right->quantifier.operand->array.operands[1]->binary.left->variable == first_lambda_variable
								&& right->quantifier.operand->array.operands[1]->binary.right->type == hol_term_type::VARIABLE)
						{
							first_element_variable = right->quantifier.operand->array.operands[1]->binary.right->variable;
						} else if (right->type == hol_term_type::AND && right->array.length == 2
								&& right->array.operands[1]->type == hol_term_type::UNARY_APPLICATION
								&& right->array.operands[1]->binary.left->type == hol_term_type::VARIABLE
								&& right->array.operands[1]->binary.left->variable == first_lambda_variable
								&& right->array.operands[1]->binary.right->type == hol_term_type::VARIABLE)
						{
							first_element_variable = right->array.operands[1]->binary.right->variable;
						} else if (right->type == hol_term_type::UNARY_APPLICATION
								&& right->binary.left->type == hol_term_type::VARIABLE
								&& right->binary.left->variable == first_lambda_variable
								&& right->binary.right->type == hol_term_type::VARIABLE)
						{
							first_element_variable = right->array.operands[1]->binary.right->variable;
						} else {
							return false;
						}
					}
				}
			}

			if (first_element_variable == 0) {
				/* we couldn't find the first element variable from `first_head`, so get it from `second_head` */
				hol_term* operand = second_head->quantifier.operand;

				hol_term* right;
				if (operand->type == hol_term_type::ANY || operand->type == hol_term_type::ANY_RIGHT) {
					right = nullptr;
				} else if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
					if (operand->any_array.right.length == 0) {
						right = operand->any_array.all;
					} else {
						right = operand->any_array.right.operands[operand->any_array.right.length - 1];
					}
				} else if (operand->type == hol_term_type::AND) {
					right = operand->array.operands[operand->array.length - 1];
				} else {
					return false;
				}

				if (right != nullptr) {
					if ((right->type == hol_term_type::ANY || right->type == hol_term_type::ANY_RIGHT) && right->any.included != nullptr)
						right = right->any.included;
					if (right->type == hol_term_type::NOT)
						right = right->unary.operand;

					if (right->type == hol_term_type::FOR_ALL && right->quantifier.operand->type == hol_term_type::IF_THEN
						&& right->quantifier.operand->binary.right->type == hol_term_type::UNARY_APPLICATION
						&& right->quantifier.operand->binary.right->binary.left->type == hol_term_type::VARIABLE
						&& right->quantifier.operand->binary.right->binary.left->variable == second_lambda_variable
						&& right->quantifier.operand->binary.right->binary.right->type == hol_term_type::VARIABLE)
					{
						first_element_variable = right->quantifier.operand->binary.right->binary.right->variable;
					} else if (right->type == hol_term_type::EXISTS && right->quantifier.operand->type == hol_term_type::AND && right->quantifier.operand->array.length == 2
							&& right->quantifier.operand->array.operands[1]->type == hol_term_type::UNARY_APPLICATION
							&& right->quantifier.operand->array.operands[1]->binary.left->type == hol_term_type::VARIABLE
							&& right->quantifier.operand->array.operands[1]->binary.left->variable == second_lambda_variable
							&& right->quantifier.operand->array.operands[1]->binary.right->type == hol_term_type::VARIABLE)
					{
						first_element_variable = right->quantifier.operand->array.operands[1]->binary.right->variable;
					} else if (right->type == hol_term_type::AND && right->array.length == 2
							&& right->array.operands[1]->type == hol_term_type::UNARY_APPLICATION
							&& right->array.operands[1]->binary.left->type == hol_term_type::VARIABLE
							&& right->array.operands[1]->binary.left->variable == second_lambda_variable
							&& right->array.operands[1]->binary.right->type == hol_term_type::VARIABLE)
					{
						first_element_variable = right->array.operands[1]->binary.right->variable;
					} else if (right->type == hol_term_type::UNARY_APPLICATION
							&& right->binary.left->type == hol_term_type::VARIABLE
							&& right->binary.left->variable == second_lambda_variable
							&& right->binary.right->type == hol_term_type::VARIABLE)
					{
						first_element_variable = right->array.operands[1]->binary.right->variable;
					} else {
						return false;
					}
				}
			}

			hol_term* excluded_quantifiers[3];
			excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(first_set_variable, &HOL_ANY));
			excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(first_set_variable, &HOL_ANY));
			excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(first_set_variable, &HOL_ANY));
			if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
			if (excluded_quantifiers[1] != nullptr) HOL_ANY.reference_count++;
			if (excluded_quantifiers[2] != nullptr) HOL_ANY.reference_count++;
			if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr) {
				if (excluded_quantifiers[0] != nullptr) { free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]); }
				if (excluded_quantifiers[1] != nullptr) { free(*excluded_quantifiers[1]); free(excluded_quantifiers[1]); }
				return false;
			}

			hol_term* wildcard = hol_term::new_any(nullptr, excluded_quantifiers, array_length(excluded_quantifiers));
			if (wildcard == nullptr) {
				for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
				return false;
			}

			unsigned int second_set_variable = second_head->quantifier.variable;
			hol_term* subset_term = hol_term::new_apply(hol_term::new_variable(second_set_variable), hol_term::new_variable(first_element_variable));
			if (subset_term == nullptr) {
				free(*wildcard); free(wildcard);
				return false;
			}

			hol_term* new_inner_operand;
			if (ConjunctIndex >= 0) {
				new_inner_operand = hol_term::new_any_array(hol_term_type::AND, wildcard, make_array_view((hol_term**) nullptr, 0),
						make_appended_array_view(make_repeated_array_view(wildcard, ConjunctIndex), subset_term),
						make_array_view((hol_term**) nullptr, 0));
				if (new_inner_operand == nullptr) {
					free(*wildcard); free(wildcard);
					free(*subset_term); free(subset_term);
					return false;
				}
				wildcard->reference_count += 1 + ConjunctIndex;
			} else {
				new_inner_operand = hol_term::new_any_array(hol_term_type::AND, wildcard,
						make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0),
						make_prepended_array_view(subset_term, make_repeated_array_view(wildcard, -ConjunctIndex - 1)));
				if (new_inner_operand == nullptr) {
					free(*wildcard); free(wildcard);
					free(*subset_term); free(subset_term);
					return false;
				}
				wildcard->reference_count += -ConjunctIndex;
			}

			hol_term* new_left = hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::SUBSET>::value,
					hol_term::new_variable(first_set_variable), hol_term::new_lambda(first_element_variable, new_inner_operand));
			if (new_left == nullptr) {
				free(*new_inner_operand); free(new_inner_operand);
				free(*wildcard); if (wildcard->reference_count == 0) free(wildcard);
				return false;
			}
			hol_term::constants<(unsigned int) built_in_predicates::SUBSET>::value.reference_count++;

			hol_term* new_head = hol_term::new_exists(first_set_variable, hol_term::new_any_array(hol_term_type::AND,
					wildcard, make_array_view((hol_term**) nullptr, 0), make_array_view(&new_left, 1), make_array_view((hol_term**) nullptr, 0)));
			if (new_head == nullptr) {
				free(*new_left); free(new_left);
				free(*wildcard); if (wildcard->reference_count == 0) free(wildcard);
				return false;
			}
			dst[dst.length++] = new_head;

			hol_term* new_right = hol_term::new_any_right_only(&HOL_ZERO);
			if (new_right == nullptr)
				return false;
			HOL_ZERO.reference_count++;

			hol_term* second_operand = second_head->quantifier.operand;
			if (second_operand->type == hol_term_type::ANY_ARRAY && second_operand->any_array.oper == hol_term_type::AND) {
				dst_outer[dst_outer.length] = hol_term::new_any_array(second_operand->any_array.oper, second_operand->any_array.all,
						make_array_view(second_operand->any_array.any.operands, second_operand->any_array.any.length),
						make_array_view(second_operand->any_array.left.operands, second_operand->any_array.left.length),
						make_appended_array_view(make_array_view(second_operand->any_array.right.operands, second_operand->any_array.right.length - 1), new_right));
				if (dst_outer[dst_outer.length] == nullptr) {
					free(*new_right); free(new_right);
					return false;
				}
				dst_outer.length++;
				second_operand->any_array.all->reference_count++;
				for (unsigned int i = 0; i < second_operand->any_array.any.length; i++)
					second_operand->any_array.any.operands[i]->reference_count++;
				for (unsigned int i = 0; i < second_operand->any_array.left.length; i++)
					second_operand->any_array.left.operands[i]->reference_count++;
				for (unsigned int i = 0; i < second_operand->any_array.right.length - 1; i++)
					second_operand->any_array.right.operands[i]->reference_count++;
			} else {
				dst_outer[dst_outer.length] = hol_term::new_exists(second_set_variable, hol_term::new_and(make_appended_array_view(make_array_view(second_operand->array.operands, second_operand->array.length - 1), new_right)));
				if (dst_outer[dst_outer.length] == nullptr) {
					free(*new_right); free(new_right);
					return false;
				}
				dst_outer.length++;
				for (unsigned int i = 0; i < second_operand->array.length - 1; i++)
					second_operand->array.operands[i]->reference_count++;
			}
			return true;
		});
	if (!result) return false;

	for (unsigned int i = 0; i < inverse_count; i++) {
		hol_term* new_inverse = hol_term::new_lambda(first_lambda_variable, inverse[i].root);
		if (new_inverse == nullptr) {
			for (unsigned int j = 0; j < inverse_count; j++) free(inverse[j]);
			free(inverse); return false;
		}
		inverse[i].root = new_inverse;
	}
	return true;
}

template<int_fast8_t ConjunctIndex>
inline bool invert_select_only_conjunct_in_set_predicative(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	unsigned int max_variable = 0;
	max_bound_variable(*first, max_variable);

	unsigned int first_lambda_variable = 0;
	if (first->type == hol_term_type::LAMBDA) {
		first_lambda_variable = first->quantifier.variable;
		first = first->quantifier.operand;
	} else if (first->type == hol_term_type::ANY) {
		first_lambda_variable = ++max_variable;
	} else {
		return false;
	}

	unsigned int second_lambda_variable = 0;
	if (second->type == hol_term_type::LAMBDA) {
		second_lambda_variable = second->quantifier.variable;
		second = second->quantifier.operand;
	} else if (second->type == hol_term_type::ANY) {
		second_lambda_variable = ++max_variable;
	} else {
		return false;
	}

	bool result = invert_apply_head(inverse, inverse_count, flags, first, second,
		predicative_head_finder<built_in_predicates>(first_lambda_variable), predicative_head_finder<built_in_predicates>(second_lambda_variable), no_op(),
		[](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, const apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array) {
			if ((first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) && first_head->any.included != nullptr)
				first_head = first_head->any.included;
			if ((second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT) && second_head->any.included != nullptr)
				second_head = second_head->any.included;

#if !defined(NDEBUG)
			if (second_head->type != hol_term_type::EXISTS)
				fprintf(stderr, "invert_select_only_conjunct_in_set_predicative WARNING: Expected an existential quantification.\n");
#endif

			hol_term* operand = second_head->quantifier.operand;
			unsigned int set_variable = second_head->quantifier.variable;

			hol_term* left;
			if (operand->type == hol_term_type::AND) {
				left = operand->array.operands[0];
			} else if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.left.length != 0) {
				left = operand->any_array.left.operands[0];
			} else {
				return false;
			}

			hol_term* inner_operand;
			unsigned int element_variable;
			if (left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT) {
				inner_operand = left->any.included->quantifier.operand;
				element_variable = left->any.included->quantifier.variable;
			} else if (left->type == hol_term_type::EQUALS) {
				inner_operand = left->binary.right->quantifier.operand;
				element_variable = left->binary.right->quantifier.variable;
			} else {
				inner_operand = left->ternary.third->quantifier.operand;
				element_variable = left->ternary.third->quantifier.variable;
			}

			hol_term* head_var = hol_term::new_variable(element_variable);
			if (head_var == nullptr) return false;
			unsigned int excluded_tree_count = (inner_operand->type == hol_term_type::TRUE) ? 3 : 2;
			hol_term** excluded_trees = (hol_term**) alloca(sizeof(hol_term*) * excluded_tree_count);
			excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
						(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
						(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
					&HOL_ANY), head_var));
			excluded_trees[1] = hol_term::new_any(hol_term::new_lambda(element_variable, &HOL_ANY));
			if (inner_operand->type == hol_term_type::TRUE)
				excluded_trees[2] = hol_term::new_any_array(hol_term_type::AND, &HOL_ANY, make_array_view((hol_term**) nullptr, 0), make_repeated_array_view(&HOL_ANY, 2), make_array_view((hol_term**) nullptr, 0));
			if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
			if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
			if (inner_operand->type == hol_term_type::TRUE && excluded_trees[2] != nullptr) { HOL_ANY.reference_count += 3; }
			if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr
			 || (inner_operand->type == hol_term_type::TRUE && excluded_trees[2] == nullptr))
			{
				if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
				if (excluded_trees[1] != nullptr) { free(*excluded_trees[1]); free(excluded_trees[1]); }
				free(*head_var); free(head_var);
				return false;
			}
			free(*head_var);

			hol_term* expected_conjunct = hol_term::new_any(nullptr, excluded_trees, excluded_tree_count);
			if (expected_conjunct == nullptr) {
				free(*excluded_trees[0]); free(excluded_trees[0]);
				free(*excluded_trees[1]); free(excluded_trees[1]);
				if (inner_operand->type == hol_term_type::TRUE) {
					free(*excluded_trees[2]); free(excluded_trees[2]);
				}
				return false;
			}

			hol_term* conjunction = nullptr;
			if (ConjunctIndex >= 0) {
				conjunction = hol_term::new_any_array(hol_term_type::AND, expected_conjunct,
						make_array_view((hol_term**) nullptr, 0),
						make_appended_array_view(make_repeated_array_view(expected_conjunct, ConjunctIndex), inner_operand),
						make_array_view((hol_term**) nullptr, 0));
				if (conjunction == nullptr) {
					free(*expected_conjunct); free(expected_conjunct);
					return false;
				}
				inner_operand->reference_count++;
				expected_conjunct->reference_count += ConjunctIndex;
			} else {
				conjunction = hol_term::new_any_array(hol_term_type::AND, expected_conjunct,
						make_array_view((hol_term**) nullptr, 0),
						make_array_view((hol_term**) nullptr, 0),
						make_prepended_array_view(inner_operand, make_repeated_array_view(expected_conjunct, (-ConjunctIndex) - 1)));
				if (conjunction == nullptr) {
					free(*expected_conjunct); free(expected_conjunct);
					return false;
				}
				inner_operand->reference_count++;
				expected_conjunct->reference_count += (-ConjunctIndex) - 1;
			}

			hol_term* set_definition;
			if (left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT) {
				set_definition = hol_term::new_any_right(hol_term::new_lambda(element_variable, conjunction), left->any.excluded_trees, left->any.excluded_tree_count);
				if (set_definition == nullptr) {
					free(*conjunction); free(conjunction);
					return false;
				}
				for (unsigned int i = 0; i < left->any.excluded_tree_count; i++)
					left->any.excluded_trees[i]->reference_count++;
			} else if (left->type == hol_term_type::EQUALS) {
				set_definition = hol_term::new_equals(left->binary.left, hol_term::new_lambda(element_variable, conjunction));
				if (set_definition == nullptr) {
					free(*conjunction); free(conjunction);
					return false;
				}
				left->binary.left->reference_count++;
			} else {
				set_definition = hol_term::new_apply(left->ternary.first, left->ternary.second, hol_term::new_lambda(element_variable, conjunction));
				if (set_definition == nullptr) {
					free(*conjunction); free(conjunction);
					return false;
				}
				left->ternary.first->reference_count++;
				left->ternary.second->reference_count++;
			}

			if (operand->type == hol_term_type::AND) {
				dst[dst.length] = hol_term::new_exists(set_variable, hol_term::new_and(make_prepended_array_view(set_definition,
						make_array_view(operand->array.operands + 1, operand->array.length - 1))));
				if (dst[dst.length] == nullptr) {
					free(*set_definition); free(set_definition);
					return false;
				}
				for (unsigned int i = 1; i < operand->array.length; i++)
					operand->array.operands[i]->reference_count++;
			} else {
				dst[dst.length] = hol_term::new_exists(set_variable, hol_term::new_any_array(hol_term_type::AND, operand->any_array.all,
						make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
						make_prepended_array_view(set_definition, make_array_view(operand->any_array.left.operands + 1, operand->any_array.left.length - 1)),
						make_array_view(operand->any_array.right.operands, operand->any_array.right.length)));
				if (dst[dst.length] == nullptr) {
					free(*set_definition); free(set_definition);
					return false;
				}
				operand->any_array.all->reference_count++;
				for (unsigned int i = 0; i < operand->any_array.any.length; i++)
					operand->any_array.any.operands[i]->reference_count++;
				for (unsigned int i = 1; i < operand->any_array.left.length; i++)
					operand->any_array.left.operands[i]->reference_count++;
				for (unsigned int i = 0; i < operand->any_array.right.length; i++)
					operand->any_array.right.operands[i]->reference_count++;
			}
			dst.length++;

			dst_outer[dst_outer.length] = hol_term::new_any_right(&HOL_ZERO);
			if (dst_outer[dst_outer.length] == nullptr) {
				free_all(dst);
				return false;
			}
			HOL_ZERO.reference_count++;
			dst_outer.length++;
			return true;
		});
	if (!result) return false;

	for (unsigned int i = 0; i < inverse_count; i++) {
		hol_term* new_inverse = hol_term::new_lambda(first_lambda_variable, inverse[i].root);
		if (new_inverse == nullptr) {
			for (unsigned int j = 0; j < inverse_count; j++) free(inverse[j]);
			free(inverse); return false;
		}
		inverse[i].root = new_inverse;
	}
	return true;
}

template<unsigned int Predicate, int_fast8_t PredicateIndex>
inline hol_term* do_invert_remove_higher_order_predicate(hol_term* second_head)
{
	unsigned int negation_count = 0;
	while (second_head->type == hol_term_type::NOT) {
		second_head = second_head->unary.operand;
		negation_count++;
	}

	unsigned int head_variable;
	if (second_head->type == hol_term_type::EXISTS) {
		head_variable = second_head->quantifier.variable;
	} else {
		unsigned int max_variable = 0;
		max_bound_variable(*second_head, max_variable);
		head_variable = ++max_variable;
	}

	hol_term* predicate = nullptr;
	head_index second_predicate_index;
	if (second_head->type == hol_term_type::EXISTS) {
		hol_term* operand = second_head->quantifier.operand;
		find_predicate<built_in_predicates>(head_variable, operand, second_predicate_index);
		if (second_predicate_index.position == head_position::NONE)
			return nullptr;
		if (operand->type == hol_term_type::AND) {
			predicate = operand->array.operands[second_predicate_index.index];
		} else if (operand->type == hol_term_type::ANY_ARRAY) {
			if (second_predicate_index.position == head_position::LEFT) {
				predicate = operand->any_array.left.operands[second_predicate_index.index];
			} else if (second_predicate_index.position == head_position::ANY) {
				predicate = operand->any_array.any.operands[second_predicate_index.index];
			} else if (second_predicate_index.position == head_position::RIGHT) {
				predicate = operand->any_array.right.operands[operand->any_array.right.length - second_predicate_index.index - 1];
			}
		} else {
			if (second_predicate_index.position != head_position::LEFT || second_predicate_index.index != 0)
				return nullptr;
			predicate = operand;
		}
	} else if (second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT) {
		second_predicate_index = {head_position::LEFT, 0};
	} else {
		return nullptr;
	}

	hol_term* expected_predicate;
	if (predicate == nullptr || predicate->type == hol_term_type::ANY || predicate->type == hol_term_type::ANY_RIGHT) {
		hol_term* head_var = hol_term::new_variable(head_variable);
		if (head_var == nullptr) return (hol_term*) nullptr;
		constexpr unsigned int excluded_tree_count = 2;
		hol_term** excluded_trees = (hol_term**) alloca(sizeof(hol_term) * (excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()));
		excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
					(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
					(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
				&HOL_ANY), head_var));
		excluded_trees[1] = hol_term::new_any(hol_term::new_exists(head_variable, &HOL_ANY));
		if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
		if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
		if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr) {
			if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
			free(*head_var); free(head_var);
			return nullptr;
		}
		free(*head_var);

		for (unsigned int i = 0; i < hol_non_head_constants<built_in_predicates>::count(); i++) {
			excluded_trees[excluded_tree_count + i] = hol_non_head_constants<built_in_predicates>::get_terms()[i];
			excluded_trees[excluded_tree_count + i]->reference_count++;
		}

		expected_predicate = hol_term::new_apply(
					hol_term::new_any(nullptr, excluded_trees, excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()), head_var);
		if (expected_predicate == nullptr) {
			for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
				free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
			}
			return nullptr;
		}
		head_var->reference_count++;

	} else if (predicate->type == hol_term_type::UNARY_APPLICATION) {
		expected_predicate = hol_term::new_apply(hol_term::new_apply(&hol_term::constants<Predicate>::value, predicate->binary.left), predicate->binary.right);
		if (expected_predicate == nullptr)
			return nullptr;
		predicate->binary.left->reference_count++;
		predicate->binary.right->reference_count++;
		hol_term::constants<Predicate>::value.reference_count++;
	} else {
		return nullptr;
	}

	hol_term* new_head = apply_predicate<PredicateIndex>(second_head, head_variable, second_predicate_index, &HOL_ANY, expected_predicate);
	free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);

	for (unsigned int i = 0; i < negation_count; i++) {
		hol_term* temp = hol_term::new_not(new_head);
		if (temp == nullptr) {
			free(*new_head); if (new_head->reference_count == 0) free(new_head);
			return nullptr;
		}
		new_head = temp;
	}
	return new_head;
}

template<unsigned int Predicate, int_fast8_t PredicateIndex>
inline bool invert_remove_higher_order_predicate(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	hol_term* second_parent = nullptr;
	hol_term* current = nullptr;
	auto apply = [&second_parent,&current](hol_term* term) {
		second_parent = current;
		current = term;
	};

	head_index first_predicate_index; no_op first_apply;
	auto first_head_finder = make_array_finder(find_head<built_in_predicates>);
	hol_term* first_head = find_head(first, first_predicate_index, first_head_finder, first_apply);
	if (first_head == nullptr)
		return false;

	if ((first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) && first_head->any.included != nullptr)
		first_head = first_head->any.included;

	head_index second_predicate_index;
	hol_term* second_head = find_head(second, second_predicate_index, find_head<built_in_predicates>, apply);
	if (second_head == nullptr)
		return false;

	if (first_head->type == hol_term_type::EXISTS) {
		while (second_head->type == hol_term_type::NOT)
			second_head = second_head->unary.operand;
	}

	hol_term* new_head = apply_array(second_head, second_parent, do_invert_remove_higher_order_predicate<Predicate, PredicateIndex>);
	if (new_head == nullptr)
		return false;

	array<hol_term*> new_heads(4);
	intersect<built_in_predicates>(new_heads, first_head, new_head);
	free(*new_head); if (new_head->reference_count == 0) free(new_head);

	hol_term* first_outer = substitute_head<any_node_position::NONE>(first, first_head, &HOL_ZERO);
	if (first_outer == nullptr) {
		free_all(new_heads);
		return false;
	}
	hol_term* second_outer = substitute_head<any_node_position::NONE>(second, second_head, &HOL_ZERO);
	if (second_outer == nullptr) {
		free(*first_outer); if (first_outer->reference_count == 0) free(first_outer);
		free_all(new_heads); return false;
	}
	array<hol_term*> new_outer(4);
	intersect<built_in_predicates>(new_outer, first_outer, second_outer);
	free(*first_outer); if (first_outer->reference_count == 0) free(first_outer);
	free(*second_outer); if (second_outer->reference_count == 0) free(second_outer);

	array<hol_term*> intersection(max((size_t) 1, new_heads.length * new_outer.length));
	for (hol_term* new_head : new_heads) {
		for (hol_term* outer : new_outer) {
			hol_term* new_inverse = substitute_head<any_node_position::NONE>(outer, &HOL_ZERO, new_head);
			if (new_inverse == nullptr) {
				free_all(intersection); free_all(new_heads); free_all(new_outer);
				return false;
			}
			intersection[intersection.length++] = new_inverse;
		}
	}
	free_all(new_heads); free_all(new_outer);

	inverse = (flagged_logical_form<hol_term>*) malloc(sizeof(flagged_logical_form<hol_term>) * intersection.length);
	if (inverse == nullptr) {
		free_all(intersection);
		return false;
	}
	for (unsigned int i = 0; i < intersection.length; i++) {
		inverse[i].flags = flags;
		inverse[i].root = intersection[i];
	}
	inverse_count = intersection.length;
	return true;
}

inline bool invert_remove_inverse(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	return invert_remove_higher_order_predicate<(unsigned int) built_in_predicates::INVERSE, INT_FAST8_MAX>(inverse, inverse_count, flags, first, second);
}

inline bool invert_remove_greatest(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	return invert_remove_higher_order_predicate<(unsigned int) built_in_predicates::GREATEST, INT_FAST8_MAX>(inverse, inverse_count, flags, first, second);
}

template<int_fast8_t ConjunctIndex>
inline bool invert_remove_constant(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second,
		hol_term* constant)
{
	return invert_apply_head(inverse, inverse_count, flags, first, second,
		find_head<built_in_predicates>, find_head<built_in_predicates>, no_op(),
		[constant](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array)
	{
		hol_term* old_second_head = second_head;
		if ((second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT) && second_head->any.included != nullptr)
			second_head = second_head->any.included;

		unsigned int first_min_negations = 0;
		unsigned int second_negations = 0;
		while (first_head->type == hol_term_type::NOT) {
			first_head = first_head->unary.operand;
			first_min_negations++;
		} while (second_head->type == hol_term_type::NOT) {
			second_head = second_head->unary.operand;
			second_negations++;
		}

		unsigned int expected_first_negations = second_negations;
		if (first_min_negations > expected_first_negations)
			return false;

		if (second_head->type == hol_term_type::EXISTS) {
			hol_term* second_head_operand = second_head->quantifier.operand;

			hol_term** second_head_operands = nullptr;
			unsigned int second_head_length;
			if (second_head_operand->type == hol_term_type::AND) {
				second_head_operands = second_head_operand->array.operands;
				second_head_length = second_head_operand->array.length;
			} else if (second_head_operand->type != hol_term_type::ANY && second_head_operand->type != hol_term_type::ANY_RIGHT && second_head_operand->type != hol_term_type::ANY_ARRAY) {
				second_head_operands = &second_head_operand;
				second_head_length = 1;
			}

			hol_term* conjunction;
			if (!new_hol_term(conjunction))
				return false;
			conjunction->type = hol_term_type::AND;
			conjunction->reference_count = 1;
			conjunction->array.length = second_head_length + 1;
			conjunction->array.operands = (hol_term**) malloc(sizeof(hol_term*) * (second_head_length + 1));
			if (conjunction->array.operands == nullptr) {
				free(conjunction);
				return false;
			}
			int conjunct_index = ConjunctIndex;
			if (ConjunctIndex < 0) conjunct_index += second_head_length + 1;
			for (unsigned int i = 0; i < conjunction->array.length; i++) {
				if (i == (unsigned int) conjunct_index) {
					conjunction->array.operands[i] = constant;
					constant->reference_count++;
				} else {
					unsigned int second_head_index = (i > (unsigned) conjunct_index) ? (i - 1) : i;
					conjunction->array.operands[i] = second_head_operands[second_head_index];
					conjunction->array.operands[i]->reference_count++;
				}
			}

			dst[dst.length] = hol_term::new_exists(second_head->quantifier.variable, conjunction);
			if (dst[dst.length] == nullptr) {
				free(*conjunction); free(conjunction);
				return false;
			}
			dst.length++;

			for (unsigned int i = 0; i < expected_first_negations; i++) {
				hol_term* temp = hol_term::new_not(dst.last());
				if (temp == nullptr) {
					free_all(dst);
					return false;
				}
				dst.last() = temp;
			}

			if (old_second_head->type == hol_term_type::ANY || old_second_head->type == hol_term_type::ANY_RIGHT) {
				hol_term* conjunct = nullptr;
				if (first_head->type == hol_term_type::EXISTS) {
					hol_term* operand = first_head->quantifier.operand;
					if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
						if (ConjunctIndex < 0 && (uint_fast8_t) (-ConjunctIndex) <= operand->any_array.right.length)
							conjunct = operand->any_array.right.operands[operand->any_array.right.length + ConjunctIndex];
						else if (ConjunctIndex >= 0 && (uint_fast8_t) ConjunctIndex < operand->any_array.left.length)
							conjunct = operand->any_array.left.operands[ConjunctIndex];
					} else if (operand->type == hol_term_type::AND) {
						conjunct = operand->array.operands[(ConjunctIndex < 0) ? (operand->array.length + ConjunctIndex) : ConjunctIndex];
					}
				}

				if (conjunct != nullptr && !can_have_free_variables(*conjunct)) {
					dst_outer[dst_outer.length] = &HOL_ZERO;
				} else {
					dst_outer[dst_outer.length] = hol_term::new_any_right(&HOL_ZERO, old_second_head->any.excluded_trees, old_second_head->any.excluded_tree_count);
					if (dst_outer[dst_outer.length] == nullptr) {
						free_all(dst);
						return false;
					}
					for (unsigned int i = 0; i < old_second_head->any.excluded_tree_count; i++)
						old_second_head->any.excluded_trees[i]->reference_count++;
				}
			} else {
				dst_outer[dst_outer.length] = &HOL_ZERO;
			}
			HOL_ZERO.reference_count++;
			dst_outer.length++;
			return true;
		} else {
			return false;
		}
	});
}

template<int_fast8_t ConjunctIndex, unsigned int ArgConstant, bool MustBeSetValued = false>
inline bool invert_select_arg_without_head_predicative(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	if (second->type != hol_term_type::LAMBDA)
		return false;
	unsigned int lambda_variable = second->quantifier.variable;
	second = second->quantifier.operand;

	auto on_remap_variables = [lambda_variable](hol_term* first_head, hol_term* second_head,
			apply_head_inverter& first_head_inverter, apply_head_inverter& second_head_inverter,
			array_map<const hol_term*, unsigned int>& second_variable_map, unsigned int& max_variable,
			bool first_head_is_array, bool second_head_is_array)
	{
		if ((first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) && first_head->any.included != nullptr
		 && (first_head->any.included->type == hol_term_type::NOT || first_head->any.included->type == hol_term_type::EXISTS))
		{
			first_head = first_head->any.included;
			if (!first_head_inverter.outer.add(first_head))
				return false;
		}
		if ((second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT) && second_head->any.included != nullptr) {
			second_head = second_head->any.included;
			if (!second_head_inverter.outer.add(second_head))
				return false;
		}

		while (first_head->type == hol_term_type::NOT) {
			first_head = first_head->unary.operand;
			if (!first_head_inverter.outer.add(first_head))
				return false;
		}

		hol_term* expected_arg = hol_term::new_equals(hol_term::new_apply(hol_term::new_constant(ArgConstant), &HOL_ANY), &HOL_ANY);
		if (expected_arg == nullptr)
			return false;
		HOL_ANY.reference_count += 2;

		hol_term* expected_head;
		if (ConjunctIndex >= 0) {
			expected_head = hol_term::new_any_quantifier(hol_quantifier_type::EXISTS, hol_term::new_any_array(hol_term_type::AND, &HOL_ANY,
					make_array_view((hol_term**) nullptr, 0), make_appended_array_view(make_repeated_array_view(&HOL_ANY, ConjunctIndex), expected_arg), make_array_view((hol_term**) nullptr, 0)));
			if (expected_head == nullptr) {
				free(*expected_arg); free(expected_arg);
				return false;
			}
			HOL_ANY.reference_count += 1 + ConjunctIndex;
		} else {
			unsigned int index = (unsigned int) (-ConjunctIndex) - 1;
			expected_head = hol_term::new_any_quantifier(hol_quantifier_type::EXISTS, hol_term::new_any_array(hol_term_type::AND, &HOL_ANY,
					make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0), make_prepended_array_view(expected_arg, make_repeated_array_view(&HOL_ANY, index))));
			if (expected_head == nullptr) {
				free(*expected_arg); free(expected_arg);
				return false;
			}
			HOL_ANY.reference_count += 1 + index;
		}

		array<hol_term*> intersection(2);
		unsigned int first_element_variable;
		intersect<built_in_predicates>(intersection, first_head, expected_head);
		bool element_wide_scope = (intersection.length != 0);
		if (intersection.length != 0) {
			free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);

			hol_term* operand;
			if (intersection[0]->type == hol_term_type::ANY_QUANTIFIER) {
				operand = intersection[0]->any_quantifier.operand;
			} else {
				operand = intersection[0]->quantifier.operand;
			}

			hol_term* conjunct;
			if (operand->type == hol_term_type::ANY_ARRAY) {
				if (ConjunctIndex >= 0) {
					conjunct = operand->any_array.left.operands[ConjunctIndex];
				} else {
					conjunct = operand->any_array.right.operands[operand->any_array.right.length + ConjunctIndex];
				}
			} else {
				unsigned int index;
				if (ConjunctIndex >= 0) {
					index = ConjunctIndex;
				} else {
					index = operand->array.length + ConjunctIndex;
				}
				conjunct = operand->array.operands[index];
			}

			if (conjunct->binary.right->type == hol_term_type::ANY || conjunct->binary.right->type == hol_term_type::ANY_RIGHT) {
				/* the "element variable" is not defined in `first_head` so we don't have to worry about variable agreement */
				first_element_variable = 0;
			} else if (conjunct->binary.right->type == hol_term_type::VARIABLE) {
				first_element_variable = conjunct->binary.right->variable;
			} else if (conjunct->binary.right->type == hol_term_type::CONSTANT || conjunct->binary.right->type == hol_term_type::STRING || conjunct->binary.right->type == hol_term_type::NUMBER) {
				/* `first` has no element variable, so we don't need to remap variables */
				first_element_variable = 0;
			} else {
				/* this should be a variable */
				for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
				return false;
			}
			for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }

		} else {
			expected_arg->reference_count++;
			free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);

			/* consider the case where the left conjunct in the head scope is an existential quantification */
			hol_term* expected_conjunct = hol_term::new_any_quantifier(hol_quantifier_type::EXISTS, hol_term::new_any_array(hol_term_type::AND, &HOL_ANY,
					make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0), make_array_view(&expected_arg, 1)));
			if (expected_conjunct == nullptr) {
				free(*expected_arg); free(expected_arg);
				return false;
			}
			HOL_ANY.reference_count++;

			if (ConjunctIndex >= 0) {
				expected_head = hol_term::new_any_quantifier(hol_quantifier_type::EXISTS, hol_term::new_any_array(hol_term_type::AND, &HOL_ANY,
						make_array_view((hol_term**) nullptr, 0), make_appended_array_view(make_repeated_array_view(&HOL_ANY, ConjunctIndex), expected_conjunct), make_array_view((hol_term**) nullptr, 0)));
				if (expected_head == nullptr) {
					free(*expected_conjunct); free(expected_conjunct);
					return false;
				}
				HOL_ANY.reference_count += 1 + ConjunctIndex;
			} else {
				unsigned int index = (unsigned int) (-ConjunctIndex) - 1;
				expected_head = hol_term::new_any_quantifier(hol_quantifier_type::EXISTS, hol_term::new_any_array(hol_term_type::AND, &HOL_ANY,
						make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0), make_prepended_array_view(expected_conjunct, make_repeated_array_view(&HOL_ANY, index))));
				if (expected_head == nullptr) {
					free(*expected_conjunct); free(expected_conjunct);
					return false;
				}
				HOL_ANY.reference_count += 1 + index;
			}

			intersect<built_in_predicates>(intersection, first_head, expected_head);
			free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
			if (intersection.length == 0)
				return false;

			hol_term* operand;
			if (intersection[0]->type == hol_term_type::ANY_QUANTIFIER) {
				operand = intersection[0]->any_quantifier.operand;
			} else {
				operand = intersection[0]->quantifier.operand;
			}

			hol_term* conjunct;
			if (operand->type == hol_term_type::ANY_ARRAY) {
				if (ConjunctIndex >= 0) {
					conjunct = operand->any_array.left.operands[ConjunctIndex];
				} else {
					conjunct = operand->any_array.right.operands[operand->any_array.right.length + ConjunctIndex];
				}
			} else {
				unsigned int index;
				if (ConjunctIndex >= 0) {
					index = ConjunctIndex;
				} else {
					index = operand->array.length + ConjunctIndex;
				}
				conjunct = operand->array.operands[index];
			}

			hol_term* inner_operand;
			if (conjunct->type == hol_term_type::ANY_QUANTIFIER)
				inner_operand = conjunct->any_quantifier.operand;
			else inner_operand = conjunct->quantifier.operand;

			hol_term* inner_conjunct;
			if (inner_operand->type == hol_term_type::ANY_ARRAY)
				inner_conjunct = inner_operand->any_array.right.operands[inner_operand->any_array.right.length - 1];
			else inner_conjunct = inner_operand->array.operands[inner_operand->array.length - 1];

			if (inner_conjunct->binary.right->type == hol_term_type::ANY) {
				/* the "element variable" is not defined in `first_head` so we don't have to worry about variable agreement */
				first_element_variable = 0;
			} else if (inner_conjunct->binary.right->type == hol_term_type::VARIABLE) {
				first_element_variable = inner_conjunct->binary.right->variable;
			} else {
				/* this should be a variable */
				for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
				return false;
			}
			for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
		}

		hol_term* right; hol_term* inner_right;
		hol_term* set_definition = nullptr;
		unsigned int second_element_variable;
		if (second_head->type == hol_term_type::EXISTS) {
			hol_term* operand = second_head->quantifier.operand;

			hol_term* left = nullptr;
			if (operand->type == hol_term_type::ANY_ARRAY && (operand->any_array.oper == hol_term_type::ANY_ARRAY || operand->any_array.oper == hol_term_type::AND)) {
				left = (operand->any_array.left.length == 0 ? operand->any_array.all : operand->any_array.left.operands[0]);
				right = (operand->any_array.right.length == 0 ? operand->any_array.all : operand->any_array.right.operands[operand->any_array.right.length - 1]);
			} else if (operand->type == hol_term_type::AND) {
				left = operand->array.operands[0];
				right = operand->array.operands[operand->array.length - 1];
			} else if (operand->type == hol_term_type::ANY) {
				second_element_variable = 0;
				left = nullptr;
				right = nullptr;
			} else {
				return false;
			}

			if (left != nullptr) {
				if (left->type == hol_term_type::EQUALS) {
					set_definition = left->binary.right;
				} else if (left->type == hol_term_type::BINARY_APPLICATION) {
					set_definition = left->ternary.third;
				} else if (left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT) {
					set_definition = left->any.included;
				} else {
					set_definition = nullptr;
				}
			}

			/* make sure the set definition is not empty in `second` */
			if (set_definition != nullptr && set_definition->type == hol_term_type::LAMBDA) {
				if (set_definition->quantifier.operand->type == hol_term_type::TRUE)
					return false;
			}

			if (right != nullptr) {
				if (!second_head_inverter.outer.add(right))
					return false;
				while (right->type == hol_term_type::NOT) {
					right = right->unary.operand;
					if (!second_head_inverter.outer.add(right))
						return false;
				}
				if ((right->type == hol_term_type::ANY || right->type == hol_term_type::ANY_RIGHT) && right->any.included != nullptr) {
					right = right->any.included;
					if (!second_head_inverter.outer.add(right))
						return false;
				}
				while (right->type == hol_term_type::NOT) {
					right = right->unary.operand;
					if (!second_head_inverter.outer.add(right))
						return false;
				}
				if (right->type == hol_term_type::UNARY_APPLICATION && right->binary.left->type == hol_term_type::CONSTANT && right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
					right = right->binary.right;
					if (!second_head_inverter.outer.add(right))
						return false;
				}
				if ((right->type == hol_term_type::ANY || right->type == hol_term_type::ANY_RIGHT) && right->any.included != nullptr) {
					right = right->any.included;
					if (!second_head_inverter.outer.add(right))
						return false;
				}

				if (right->type == hol_term_type::FOR_ALL) {
					second_element_variable = right->quantifier.variable;
					inner_right = right->quantifier.operand->binary.right;
					if (!second_head_inverter.outer.add(inner_right))
						return false;
				} else if (right->type == hol_term_type::EXISTS) {
					second_element_variable = right->quantifier.variable;
					inner_right = right->quantifier.operand->array.operands[right->quantifier.operand->array.length - 1];
					if (!second_head_inverter.outer.add(inner_right))
						return false;
				} else if (right->type == hol_term_type::UNARY_APPLICATION && right->binary.left->type == hol_term_type::VARIABLE
						&& right->binary.left->variable == lambda_variable && right->binary.right->type == hol_term_type::VARIABLE)
				{
					second_element_variable = right->binary.right->variable;
					inner_right = nullptr;

					if (second_head_inverter.outer[0]->type == hol_term_type::LAMBDA)
						second_variable_map.remove(second_head_inverter.outer[0]);

					/* make sure the set variables match */
					if (first_element_variable != 0) {
						unsigned int first_set_variable = 0;
						for (hol_term* term : first_head_inverter.outer) {
							hol_term* second_right;
							if (term->type == hol_term_type::AND) {
								second_right = term->array.operands[term->array.length - 2];
							} else if (term->type == hol_term_type::ANY_ARRAY && term->any_array.oper == hol_term_type::AND && term->any_array.right.length >= 2) {
								second_right = term->any_array.right.operands[term->any_array.right.length - 2];
							} else {
								continue;
							}

							if (second_right->type == hol_term_type::UNARY_APPLICATION && second_right->binary.left->type == hol_term_type::VARIABLE
							 && second_right->binary.right->type == hol_term_type::VARIABLE && second_right->binary.right->variable == first_element_variable)
							{
								first_set_variable = second_right->binary.left->variable;
								break;
							}
						}

						if (first_set_variable != 0) {
							if (!second_variable_map.ensure_capacity(second_variable_map.size + 1))
								return false;
							unsigned int index = second_variable_map.index_of(second_head);
							if (index == second_variable_map.size && first_set_variable != second_head->quantifier.variable) {
								second_variable_map.keys[index] = second_head;
								second_variable_map.values[index] = first_set_variable;
								second_variable_map.size++;
							} else if (first_set_variable == second_head->quantifier.variable) {
								second_variable_map.remove_at(index);
							} else {
								second_variable_map.values[index] = first_set_variable;
							}
						}
					}
				} else {
					return false;
				}
			}
		} else if (second_head->type == hol_term_type::UNARY_APPLICATION && second_head->binary.left->type == hol_term_type::VARIABLE
				&& second_head->binary.left->variable == lambda_variable && second_head->binary.right->type == hol_term_type::VARIABLE)
		{
			right = second_head;
			inner_right = second_head;
			second_element_variable = second_head->binary.right->variable;
			if (!second_head_inverter.outer.add(right))
				return false;
		} else if (second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT
				|| (second_head->type == hol_term_type::ANY_QUANTIFIER && has_intersection(hol_quantifier_type::EXISTS, second_head->any_quantifier.quantifier))) {
			second_element_variable = 0;
		} else {
			return false;
		}

		/* `first_element_variable` could be a set variable (i.e. set-valued) */
		bool is_set_valued = MustBeSetValued;
		for (hol_term* scope : first_head_inverter.outer) {
			if (scope->type == hol_term_type::EXISTS && scope->quantifier.variable == first_element_variable) {
				hol_term* operand = scope->quantifier.operand;
				hol_term* left = nullptr;
				if (operand->type == hol_term_type::AND) {
					left = operand->array.operands[0];
				} else if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND && operand->any_array.left.length != 0) {
					left = operand->any_array.left.operands[0];
				}

				if (left != nullptr) {
					if (left->type == hol_term_type::EQUALS && left->binary.left->type == hol_term_type::VARIABLE
					 && left->binary.left->variable == first_element_variable && left->binary.right->type == hol_term_type::LAMBDA)
					{
						is_set_valued = true;
					} else if (left->type == hol_term_type::BINARY_APPLICATION && left->ternary.second->type == hol_term_type::VARIABLE
							&& left->ternary.second->variable == first_element_variable && left->ternary.third->type == hol_term_type::LAMBDA)
					{
						is_set_valued = true;
					}
				}
				break;
			}
		}

		if (is_set_valued) {
			unsigned int first_set_variable = first_element_variable;
			unsigned int second_set_variable;
			if (second_head->type == hol_term_type::EXISTS) {
				second_set_variable = second_head->quantifier.variable;
			} else if (second_head->type == hol_term_type::UNARY_APPLICATION && second_head->binary.left->type == hol_term_type::VARIABLE
					&& second_head->binary.left->variable == lambda_variable && second_head->binary.right->type == hol_term_type::VARIABLE)
			{
				second_set_variable = 0;
			} else if (second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT
					|| (second_head->type == hol_term_type::ANY_QUANTIFIER && has_intersection(hol_quantifier_type::EXISTS, second_head->any_quantifier.quantifier))) {
				second_set_variable = 0;
			} else {
				return false;
			}

			if (first_set_variable != 0 && second_set_variable != 0) {
				array_map<unsigned int, variable_set> free_variable_map(4);
				free_variable_map.keys[0] = second_set_variable;
				free_variable_map.values[0].type = variable_set_type::SINGLETON;
				free_variable_map.values[0].variable = first_set_variable;
				free_variable_map.size = 1;

				if (right == nullptr)
					return false;

				if (!remap_scopes(free_variable_map, first_head_inverter, second_head_inverter, second_variable_map, max_variable, first_head_is_array, second_head_is_array)) {
					for (auto entry : second_variable_map) free(entry.value);
					return false;
				}
			}
			return true;
		}

		if (first_element_variable != 0 && second_element_variable != 0) {
			if (!element_wide_scope) {
				for (unsigned int i = 0; i < second_variable_map.size; i++) {
					if (second_variable_map.keys[i]->quantifier.variable == second_element_variable) {
						second_variable_map.values[i] = first_element_variable;
						if (first_element_variable == second_element_variable)
							second_variable_map.remove_at(i);
						break;
					}
				}
				return true;
			}

			if (right == nullptr)
				return false;

			array_map<unsigned int, variable_set> free_variable_map(4);
			free_variable_map.keys[0] = second_element_variable;
			free_variable_map.values[0].type = variable_set_type::SINGLETON;
			free_variable_map.values[0].variable = first_element_variable;
			free_variable_map.size = 1;

			if (!remap_scopes(free_variable_map, first_head_inverter, second_head_inverter, second_variable_map, max_variable, first_head_is_array, second_head_is_array)) {
				/* try removing the set */
				for (auto entry : second_variable_map) free(entry.value);

				for (unsigned int i = 0; i < second_variable_map.size; i++) {
					if (second_variable_map.keys[i]->quantifier.variable == second_element_variable) {
						second_variable_map.values[i] = first_element_variable;
						if (first_element_variable == second_element_variable)
							second_variable_map.remove_at(i);
						break;
					}
				}

				hol_term* second_set_definition;
				if (set_definition == nullptr || set_definition->type != hol_term_type::LAMBDA) {
					return true;
				} else {
					second_set_definition = set_definition->quantifier.operand;
				}

				/* find the relativization of the set in `first` */
				hol_term* first_scope = nullptr;
				for (unsigned int i = first_head_inverter.outer.length - 1; i > 0; i--) {
					first_scope = first_head_inverter.outer[i - 1];
					if ((first_scope->type == hol_term_type::FOR_ALL || first_scope->type == hol_term_type::EXISTS || first_scope->type == hol_term_type::LAMBDA) && first_scope->quantifier.variable == first_element_variable)
						break;
				}

				hol_term* first_set_definition;
				if (first_scope->type == hol_term_type::FOR_ALL && first_scope->quantifier.operand->type == hol_term_type::IF_THEN) {
					first_set_definition = first_scope->quantifier.operand->binary.left;
					first_set_definition->reference_count++;
				} else if (first_scope->type == hol_term_type::EXISTS && first_scope->quantifier.operand->type == hol_term_type::AND) {
					if (first_scope->quantifier.operand->array.length > 2) {
						first_set_definition = hol_term::new_and(make_array_view(first_scope->quantifier.operand->array.operands, first_scope->quantifier.operand->array.length - 1));
						if (first_set_definition == nullptr) return false;
						for (unsigned int i = 0; i < first_set_definition->array.length; i++)
							first_set_definition->array.operands[i]->reference_count++;
					} else {
						first_set_definition = first_scope->quantifier.operand->array.operands[0];
						first_set_definition->reference_count++;
					}
				} else {
					return true;
				}

				array<pair<hol_term*, variable_map>> intersection(2);
				intersect<built_in_predicates, true, true>(intersection, first_set_definition, second_set_definition);
				if (intersection.length == 0) {
					free(*first_set_definition); if (first_set_definition->reference_count == 0) free(first_set_definition);
					return false;
				} else if (intersection.length != 1) {
					fprintf(stderr, "invert_select_arg_without_head_predicative ERROR: Intersection is not unique.\n");
					free(*first_set_definition); if (first_set_definition->reference_count == 0) free(first_set_definition);
					free_all(intersection); return false;
				}

				const variable_map& var_map = intersection[0].value;
				for (const auto& entry : var_map.scope_map) {
					const variable_set& set = entry.value;
					unsigned int src_variable = entry.key.src->quantifier.variable;
					unsigned int target_var;
					if (!get_target_variable(src_variable, target_var, set, max_variable)
					 || !second_variable_map.ensure_capacity(second_variable_map.size + 1))
					{
						free(*first_set_definition); if (first_set_definition->reference_count == 0) free(first_set_definition);
						free_all(intersection); return false;
					}

					unsigned int index = second_variable_map.index_of(entry.key.src);
					if (index < second_variable_map.size) {
						second_variable_map.values[index] = target_var;
						if (src_variable == target_var)
							second_variable_map.remove_at(index);
					} else if (src_variable != target_var) {
						second_variable_map.keys[second_variable_map.size] = entry.key.src;
						second_variable_map.values[second_variable_map.size] = target_var;
						second_variable_map.size++;
					}
				} for (const auto& entry : var_map.free_variables) {
					const variable_set& set = entry.value;
					unsigned int src_variable = entry.key;
					if (src_variable == second_element_variable)
						continue;
					if (!free_variable_map.ensure_capacity(free_variable_map.size + 1)) {
						free(*first_set_definition); if (first_set_definition->reference_count == 0) free(first_set_definition);
						free_all(intersection); return false;
					}
					unsigned int index = free_variable_map.index_of(src_variable);
					if (index < free_variable_map.size) {
						variable_set& new_set = *((variable_set*) alloca(sizeof(variable_map)));
						if (!intersect(new_set, set, free_variable_map.values[index])) {
							free(*first_set_definition); if (first_set_definition->reference_count == 0) free(first_set_definition);
							free_all(intersection); return false;
						}
						swap(free_variable_map.values[index], new_set);
						free(new_set);
					} else {
						free_variable_map.keys[free_variable_map.size] = src_variable;
						if (!init(free_variable_map.values[free_variable_map.size], set)) {
							free(*first_set_definition); if (first_set_definition->reference_count == 0) free(first_set_definition);
							free_all(intersection); return false;
						}
						free_variable_map.size++;
					}
				}
				free(*first_set_definition); if (first_set_definition->reference_count == 0) free(first_set_definition);
				free_all(intersection);

				if (!remap_scopes(free_variable_map, first_head_inverter, second_head_inverter, second_variable_map, max_variable, first_head_is_array, second_head_is_array)) {
					for (auto entry : second_variable_map) free(entry.value);
					return false;
				}
			}
		}
		return true;
	};

	return invert_apply_head(inverse, inverse_count, flags, first, second,
		find_head<built_in_predicates, false, true>, predicative_head_finder<built_in_predicates>(lambda_variable), on_remap_variables,
		[lambda_variable](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term*& first_head, hol_term* second_head, apply_head_inverter& first_inverter, apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array)
		{
			if ((first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) && first_head->any.included != nullptr)
				first_head = first_head->any.included;
			if ((second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT) && second_head->any.included != nullptr)
				second_head = second_head->any.included;

			hol_term* new_first_head = first_head;
			while (new_first_head->type == hol_term_type::NOT)
				new_first_head = new_first_head->unary.operand;

			if (!is_array) {
				/* make sure there is no ANY_ARRAY in `second` with no right
				   nodes, since the forward application of the function would
				   fail otherwise */
				for (hol_term* outer : second_inverter.outer)
					if (outer->type == hol_term_type::ANY_ARRAY && outer->any_array.right.length == 0) return false;
			}

			unsigned int predicate_variable;
			if (new_first_head->type == hol_term_type::ANY || new_first_head->type == hol_term_type::ANY_RIGHT) {
				predicate_variable = max_variable + 1;
			} else {
#if !defined(NDEBUG)
				if (new_first_head->type != hol_term_type::EXISTS)
					fprintf(stderr, "invert_select_arg_without_head_predicative WARNING: Expected `first_head` to be an existential quantification.\n");
#endif
				predicate_variable = new_first_head->quantifier.variable;
			}

			if (second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT
			 || (second_head->type == hol_term_type::UNARY_APPLICATION && second_head->binary.left->type == hol_term_type::VARIABLE
			  && second_head->binary.left->variable == lambda_variable && second_head->binary.right->type == hol_term_type::VARIABLE))
			{
				if (!dst.ensure_capacity(dst.length + 2) || !dst_outer.ensure_capacity(dst_outer.length + 2))
					return false;

				hol_term* head_var = hol_term::new_variable(predicate_variable);
				if (head_var == nullptr) return false;
				constexpr bool IS_ARG2 = (ArgConstant == (unsigned int) built_in_predicates::ARG2 || ArgConstant == (unsigned int) built_in_predicates::ARG2_OF);
				constexpr bool IS_ARG3 = (ArgConstant == (unsigned int) built_in_predicates::ARG3 || ArgConstant == (unsigned int) built_in_predicates::ARG3_OF);
				constexpr unsigned int excluded_tree_count = (IS_ARG2 || IS_ARG3) ? 3 : 2;
				hol_term** excluded_trees = (hol_term**) alloca(sizeof(hol_term) * (excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()));
				excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
							(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
							(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
						&HOL_ANY), head_var));
				excluded_trees[1] = hol_term::new_any(hol_term::new_exists(predicate_variable, &HOL_ANY));
				if (IS_ARG2) excluded_trees[2] = &HOL_EXIST;
				if (IS_ARG3) excluded_trees[2] = hol_term::new_any_constant((unsigned int) built_in_predicates::EXIST, (unsigned int) built_in_predicates::SAME, (unsigned int) built_in_predicates::NAME);
				if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
				if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
				if (IS_ARG2 && excluded_trees[2] != nullptr) HOL_EXIST.reference_count++;
				if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr || (IS_ARG3 && excluded_trees[2] == nullptr)) {
					if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
					if (excluded_trees[1] != nullptr) { free(*excluded_trees[1]); free(excluded_trees[1]); }
					free(*head_var); free(head_var);
					return false;
				}
				free(*head_var);

				for (unsigned int i = 0; i < hol_non_head_constants<built_in_predicates>::count(); i++) {
					excluded_trees[excluded_tree_count + i] = hol_non_head_constants<built_in_predicates>::get_terms()[i];
					excluded_trees[excluded_tree_count + i]->reference_count++;
				}

				hol_term* expected_predicate = hol_term::new_apply(
							hol_term::new_any(nullptr, excluded_trees, excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()), head_var);
				if (expected_predicate == nullptr) {
					for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
						free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
					}
					return false;
				}
				head_var->reference_count++;
				for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++)
					excluded_trees[i]->reference_count++;

				if (new_first_head->type == hol_term_type::EXISTS) {
					hol_term* operand = new_first_head->quantifier.operand;
					hol_term* first_predicate = nullptr;
					if (operand->type == hol_term_type::AND) {
						if (first_predicate_index.position == head_position::LEFT)
							first_predicate = operand->array.operands[first_predicate_index.index];
					} else if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
						if (first_predicate_index.position == head_position::LEFT)
							first_predicate = operand->any_array.left.operands[first_predicate_index.index];
						else if (first_predicate_index.position == head_position::RIGHT)
							first_predicate = operand->any_array.right.operands[operand->any_array.right.length - first_predicate_index.index - 1];
						else if (first_predicate_index.position == head_position::ANY)
							first_predicate = operand->any_array.any.operands[first_predicate_index.index];
					} else if (first_predicate_index.position == head_position::LEFT && first_predicate_index.index == 0) {
						first_predicate = operand;
					}

					if (first_predicate != nullptr && first_predicate->type == hol_term_type::UNARY_APPLICATION
					 && first_predicate->binary.right->type == hol_term_type::VARIABLE && first_predicate->binary.right->variable == predicate_variable)
					{
						array<hol_term*> new_predicates(2);
						intersect<built_in_predicates>(new_predicates, expected_predicate, first_predicate);
						free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
						if (new_predicates.length == 0) {
							for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
								free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
							}
							return false;
						} else if (new_predicates.length != 1) {
							fprintf(stderr, "invert_select_arg_without_head_predicative WARNING: Intersection of predicates is not unique.\n");
							for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
								free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
							}
							free_all(new_predicates); return false;
						}
						expected_predicate = new_predicates[0];
					}
				}

				hol_term* arg;
				if (second_head->type == hol_term_type::UNARY_APPLICATION && second_head->binary.left->type == hol_term_type::VARIABLE
			  	 && second_head->binary.left->variable == lambda_variable && second_head->binary.right->type == hol_term_type::VARIABLE)
				{
					arg = hol_term::new_equals(hol_term::new_apply(hol_term::new_constant(ArgConstant), head_var), second_head->binary.right);
					if (arg == nullptr) {
						for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
							free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
						}
						free(*expected_predicate); free(expected_predicate);
						return false;
					}
					second_head->binary.right->reference_count++;
					head_var->reference_count++;
				} else {
					arg = hol_term::new_equals(hol_term::new_apply(hol_term::new_constant(ArgConstant), head_var),
							hol_term::new_any(nullptr, excluded_trees, (IS_ARG2 || IS_ARG3) ? (excluded_tree_count - 1) : excluded_tree_count));
					if (arg == nullptr) {
						for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
							free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
						}
						free(*expected_predicate); free(expected_predicate);
						return false;
					}
					head_var->reference_count++;
					for (unsigned int i = 0; i < ((IS_ARG2 || IS_ARG3) ? (excluded_tree_count - 1) : excluded_tree_count); i++)
						excluded_trees[i]->reference_count++;
				}

				hol_term* conjunct = hol_term::new_any(nullptr, excluded_trees, (IS_ARG2 || IS_ARG3) ? (excluded_tree_count - 1) : excluded_tree_count);
				if (conjunct == nullptr) {
					for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
						free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
					}
					free(*expected_predicate); free(expected_predicate);
					free(*arg); free(arg); return false;
				}
				for (unsigned int i = 0; i < ((IS_ARG2 || IS_ARG3) ? (excluded_tree_count - 1) : excluded_tree_count); i++)
					excluded_trees[i]->reference_count++;
				for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
					free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
				}

				if (ConjunctIndex >= 0) {
					dst[dst.length] = hol_term::new_exists(predicate_variable, hol_term::new_any_array(hol_term_type::AND, conjunct,
							make_array_view(&expected_predicate, 1), make_appended_array_view(make_repeated_array_view(conjunct, ConjunctIndex), arg), make_array_view((hol_term**) nullptr, 0)));
					if (dst[dst.length] == nullptr) {
						free(*expected_predicate); free(expected_predicate);
						free(*arg); free(arg); free(*conjunct); free(conjunct);
						return false;
					}
					conjunct->reference_count += ConjunctIndex;
				} else if (ConjunctIndex < 0) {
					unsigned int index = (unsigned int) (-ConjunctIndex) - 1;
					dst[dst.length] = hol_term::new_exists(predicate_variable, hol_term::new_any_array(hol_term_type::AND, conjunct,
							make_array_view(&expected_predicate, 1), make_array_view((hol_term**) nullptr, 0), make_prepended_array_view(arg, make_repeated_array_view(conjunct, index))));
					if (dst[dst.length] == nullptr) {
						free(*expected_predicate); free(expected_predicate);
						free(*arg); free(arg); free(*conjunct); free(conjunct);
						return false;
					}
					conjunct->reference_count += index;
				} else {
					fprintf(stderr, "invert_select_arg_without_head_predicative ERROR: Unsupported value of `ConjunctIndex`.\n");
					return false;
				}
				dst.length++;
				dst_outer[dst_outer.length++] = &HOL_ZERO;
				HOL_ZERO.reference_count++;
				return true;
			} else if (second_head->type == hol_term_type::EXISTS) {
				unsigned int set_variable = second_head->quantifier.variable;
				hol_term* operand = second_head->quantifier.operand;

				hol_term* left = nullptr;
				hol_term* right = nullptr;
				hol_term* second_right = nullptr;
				hol_term* set_definition = nullptr;
				bool can_keep_set_variable = true;
				bool can_remove_set_variable = (MustBeSetValued ? false : true);
				bool must_be_simple_set_def = false;
				if (operand->type == hol_term_type::ANY_ARRAY && (operand->any_array.oper == hol_term_type::ANY_ARRAY || operand->any_array.oper == hol_term_type::AND)) {
					left = (operand->any_array.left.length == 0 ? operand->any_array.all : operand->any_array.left.operands[0]);
					right = (operand->any_array.right.length == 0 ? operand->any_array.all : operand->any_array.right.operands[operand->any_array.right.length - 1]);
					if (operand->any_array.right.length >= 2)
						second_right = operand->any_array.right.operands[operand->any_array.right.length - 2];
					if (left->type == hol_term_type::EQUALS && left->binary.left->type == hol_term_type::VARIABLE && left->binary.left->variable == set_variable && left->binary.right->type == hol_term_type::LAMBDA) {
						must_be_simple_set_def = (MustBeSetValued ? false : true);
						set_definition = left->binary.right;
					} else if (left->type == hol_term_type::BINARY_APPLICATION && left->ternary.second->type == hol_term_type::VARIABLE && left->ternary.second->variable == set_variable && left->ternary.third->type == hol_term_type::LAMBDA) {
						must_be_simple_set_def = false;
						can_remove_set_variable = false;
						set_definition = left->ternary.third;
					}
				} else if (operand->type == hol_term_type::AND) {
					left = operand->array.operands[0];
					right = operand->array.operands[operand->array.length - 1];
					second_right = operand->array.operands[operand->array.length - 2];
					if (left->type == hol_term_type::EQUALS && left->binary.left->type == hol_term_type::VARIABLE && left->binary.left->variable == set_variable && left->binary.right->type == hol_term_type::LAMBDA) {
						must_be_simple_set_def = (MustBeSetValued ? false : true);
						set_definition = left->binary.right;
					} else if (left->type == hol_term_type::BINARY_APPLICATION && left->ternary.second->type == hol_term_type::VARIABLE && left->ternary.second->variable == set_variable && left->ternary.third->type == hol_term_type::LAMBDA) {
						must_be_simple_set_def = false;
						can_remove_set_variable = false;
						set_definition = left->ternary.third;
					}
					if (operand->array.length == 2 && must_be_simple_set_def)
						can_keep_set_variable = false;
					if (operand->array.length > 2)
						can_remove_set_variable = false;
				}

				if (right->type == hol_term_type::ANY) {
					fprintf(stderr, "invert_select_arg_without_head_predicative ERROR: `ANY` type is unsupported for the right conjunct.");
					return false;
				}

				if (!dst.ensure_capacity(dst.length + 2) || !dst_outer.ensure_capacity(dst_outer.length + 2))
					return false;

				hol_term* head_var = hol_term::new_variable(predicate_variable);
				if (head_var == nullptr) return false;
				constexpr unsigned int excluded_tree_count = 2;
				hol_term* excluded_trees[excluded_tree_count];
				excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
							(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
							(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
						&HOL_ANY), head_var));
				excluded_trees[1] = hol_term::new_any(hol_term::new_exists(predicate_variable, &HOL_ANY));
				if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
				if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
				if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr) {
					if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
					free(*head_var); free(head_var);
					return false;
				}
				free(*head_var);

				hol_term* conjunct = hol_term::new_any(nullptr, excluded_trees, excluded_tree_count);
				if (conjunct == nullptr) {
					free(*excluded_trees[0]); free(excluded_trees[0]);
					free(*excluded_trees[1]); free(excluded_trees[1]);
					return false;
				}

				unsigned int negation_count = 0;
				while (right->type == hol_term_type::NOT) {
					right = right->unary.operand;
					negation_count++;
				}

				hol_term* old_right = right;
				if ((right->type == hol_term_type::ANY || right->type == hol_term_type::ANY_RIGHT) && right->any.included != nullptr)
					right = right->any.included;

				while (right->type == hol_term_type::NOT) {
					right = right->unary.operand;
					negation_count++;
				}

				hol_term* element_var;
				unsigned int element_variable;
				bool wide_scope_marker = false;
				bool element_narrow_scope = false;
				bool could_have_wide_scope_marker_before_head = false;
				if (right->type == hol_term_type::UNARY_APPLICATION && right->binary.left->type == hol_term_type::CONSTANT && right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
					right = right->binary.right;
					element_narrow_scope = true;
					wide_scope_marker = true;
				}
				if ((right->type == hol_term_type::ANY || right->type == hol_term_type::ANY_RIGHT) && right->any.included != nullptr)
					right = right->any.included;
				if (right->type == hol_term_type::FOR_ALL) {
					if (right->quantifier.operand->type == hol_term_type::IF_THEN && right->quantifier.operand->binary.right->type == hol_term_type::UNARY_APPLICATION
					 && right->quantifier.operand->binary.right->binary.left->type == hol_term_type::CONSTANT && right->quantifier.operand->binary.right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE)
						wide_scope_marker = true;
					element_variable = right->quantifier.variable;
					element_var = hol_term::new_variable(element_variable);
					if (element_var == nullptr) {
						free(*conjunct); free(conjunct);
						return false;
					}
				} else if (right->type == hol_term_type::EXISTS) {
					if (right->quantifier.operand->type == hol_term_type::AND && right->quantifier.operand->array.operands[right->quantifier.operand->array.length - 1]->type == hol_term_type::UNARY_APPLICATION
					 && right->quantifier.operand->array.operands[right->quantifier.operand->array.length - 1]->binary.left->type == hol_term_type::CONSTANT
					 && right->quantifier.operand->array.operands[right->quantifier.operand->array.length - 1]->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE)
						wide_scope_marker = true;
					if (right->quantifier.operand->type == hol_term_type::ANY_ARRAY && (right->quantifier.operand->any_array.oper == hol_term_type::ANY_ARRAY || right->quantifier.operand->any_array.oper == hol_term_type::AND)
					 && right->quantifier.operand->any_array.right.length > 0 && right->quantifier.operand->any_array.right.operands[right->quantifier.operand->any_array.right.length - 1]->type == hol_term_type::UNARY_APPLICATION
					 && right->quantifier.operand->any_array.right.operands[right->quantifier.operand->any_array.right.length - 1]->binary.left->type == hol_term_type::CONSTANT
					 && right->quantifier.operand->any_array.right.operands[right->quantifier.operand->any_array.right.length - 1]->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE)
						wide_scope_marker = true;
					if (right->quantifier.operand->type == hol_term_type::AND && right->quantifier.operand->array.operands[right->quantifier.operand->array.length - 1]->type == hol_term_type::ANY_RIGHT)
						could_have_wide_scope_marker_before_head = true;
					if (right->quantifier.operand->type == hol_term_type::ANY_ARRAY && (right->quantifier.operand->any_array.oper == hol_term_type::ANY_ARRAY || right->quantifier.operand->any_array.oper == hol_term_type::AND)
					 && right->quantifier.operand->any_array.right.length > 0 && right->quantifier.operand->any_array.right.operands[right->quantifier.operand->any_array.right.length - 1]->type == hol_term_type::ANY_RIGHT)
						could_have_wide_scope_marker_before_head = true;
					element_variable = right->quantifier.variable;
					element_var = hol_term::new_variable(element_variable);
					if (element_var == nullptr) {
						free(*conjunct); free(conjunct);
						return false;
					}
				} else if (right->type == hol_term_type::UNARY_APPLICATION && right->binary.left->type == hol_term_type::VARIABLE
						&& right->binary.left->variable == lambda_variable && right->binary.right->type == hol_term_type::VARIABLE)
				{
					element_var = right->binary.right;
					element_var->reference_count++;
					element_variable = element_var->variable;
					if (old_right->type != hol_term_type::ANY && old_right->type != hol_term_type::ANY_RIGHT && second_right != nullptr
					 && (second_right->type != hol_term_type::UNARY_APPLICATION || second_right->binary.left->type != hol_term_type::VARIABLE
					  || second_right->binary.left->variable != set_variable || second_right->binary.right->type != hol_term_type::VARIABLE
					  || second_right->binary.right->variable != element_variable))
					{
						free(*conjunct); free(conjunct);
						return false;
					}
				} else {
					free(*conjunct); free(conjunct);
					return false;
				}

				bool could_have_wide_scope_marker_before_quantifier = true;
				if (old_right->type == hol_term_type::ANY || old_right->type == hol_term_type::ANY_RIGHT) {
					hol_term* temp_right = old_right;
					for (unsigned int i = 0; could_have_wide_scope_marker_before_quantifier && i < temp_right->any.excluded_tree_count; i++) {
						hol_term* excluded = temp_right->any.excluded_trees[i];
						if ((excluded->type == hol_term_type::ANY || excluded->type == hol_term_type::ANY_RIGHT)
						 && excluded->any.included != nullptr && excluded->any.included->type == hol_term_type::UNARY_APPLICATION
						 && excluded->any.included->binary.left->type == hol_term_type::CONSTANT
						 && excluded->any.included->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE)
						{
							if (*excluded->any.included->binary.right == HOL_ANY) {
								could_have_wide_scope_marker_before_quantifier = false;
							} else if (excluded->any.included->binary.right->type == right->type
									&& excluded->any.included->binary.right->quantifier.variable == right->quantifier.variable
									&& *excluded->any.included->binary.right->quantifier.operand == HOL_ANY)
							{
								could_have_wide_scope_marker_before_quantifier = false;
							}
						}
					}
					temp_right = temp_right->any.included;
					while (temp_right->type == hol_term_type::NOT)
						temp_right = temp_right->unary.operand;
					if (temp_right->type == hol_term_type::ANY || temp_right->type == hol_term_type::ANY_RIGHT) {
						for (unsigned int i = 0; could_have_wide_scope_marker_before_quantifier && i < temp_right->any.excluded_tree_count; i++) {
							hol_term* excluded = temp_right->any.excluded_trees[i];
							if ((excluded->type == hol_term_type::ANY || excluded->type == hol_term_type::ANY_RIGHT)
							 && excluded->any.included != nullptr && excluded->any.included->type == hol_term_type::UNARY_APPLICATION
							 && excluded->any.included->binary.left->type == hol_term_type::CONSTANT
							 && excluded->any.included->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE)
							{
								if (*excluded->any.included->binary.right == HOL_ANY) {
									could_have_wide_scope_marker_before_quantifier = false;
								} else if (excluded->any.included->binary.right->type == right->type
										&& excluded->any.included->binary.right->quantifier.variable == right->quantifier.variable
										&& *excluded->any.included->binary.right->quantifier.operand == HOL_ANY)
								{
									could_have_wide_scope_marker_before_quantifier = false;
								}
							}
						}
					}
				}

				constexpr bool IS_ARG2 = (ArgConstant == (unsigned int) built_in_predicates::ARG2 || ArgConstant == (unsigned int) built_in_predicates::ARG2_OF);
				constexpr bool IS_ARG3 = (ArgConstant == (unsigned int) built_in_predicates::ARG3 || ArgConstant == (unsigned int) built_in_predicates::ARG3_OF);
				constexpr unsigned int excluded_predicate_tree_count = (IS_ARG2 || IS_ARG3) ? 1 : 0;
				hol_term** excluded_predicate_trees = (hol_term**) alloca(sizeof(hol_term) * (excluded_predicate_tree_count + hol_non_head_constants<built_in_predicates>::count()));
				if (IS_ARG2) excluded_predicate_trees[0] = &HOL_EXIST;
				if (IS_ARG3) excluded_predicate_trees[0] = hol_term::new_any_constant((unsigned int) built_in_predicates::EXIST, (unsigned int) built_in_predicates::SAME, (unsigned int) built_in_predicates::NAME);
				if (IS_ARG2 && excluded_predicate_trees[0] != nullptr) HOL_EXIST.reference_count++;
				if (IS_ARG2 && excluded_predicate_trees[0] == nullptr) {
					free(*conjunct); free(conjunct);
					free(*element_var); if (element_var->reference_count == 0) free(element_var);
					return false;
				}
				for (unsigned int i = 0; i < hol_non_head_constants<built_in_predicates>::count(); i++) {
					excluded_predicate_trees[excluded_predicate_tree_count + i] = hol_non_head_constants<built_in_predicates>::get_terms()[i];
					excluded_predicate_trees[excluded_predicate_tree_count + i]->reference_count++;
				}

				hol_term* expected_predicate = hol_term::new_apply(
						hol_term::new_any(nullptr, excluded_predicate_trees, excluded_predicate_tree_count + hol_non_head_constants<built_in_predicates>::count()),
						hol_term::new_variable(predicate_variable));
				if (expected_predicate == nullptr) {
					for (unsigned int i = 0; i < excluded_predicate_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
						free(*excluded_predicate_trees[i]); if (excluded_predicate_trees[i]->reference_count == 0) free(excluded_predicate_trees[i]);
					}
					free(*conjunct); free(conjunct);
					free(*element_var); if (element_var->reference_count == 0) free(element_var);
					return false;
				}

				if (new_first_head->type == hol_term_type::EXISTS) {
					hol_term* operand = new_first_head->quantifier.operand;
					hol_term* first_predicate = nullptr;
					if (operand->type == hol_term_type::AND) {
						if (first_predicate_index.position == head_position::LEFT)
							first_predicate = operand->array.operands[first_predicate_index.index];
					} else if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
						if (first_predicate_index.position == head_position::LEFT)
							first_predicate = operand->any_array.left.operands[first_predicate_index.index];
						else if (first_predicate_index.position == head_position::RIGHT)
							first_predicate = operand->any_array.right.operands[operand->any_array.right.length - first_predicate_index.index - 1];
						else if (first_predicate_index.position == head_position::ANY)
							first_predicate = operand->any_array.any.operands[first_predicate_index.index];
					} else if (first_predicate_index.position == head_position::LEFT && first_predicate_index.index == 0) {
						first_predicate = operand;
					}

					if (first_predicate != nullptr && first_predicate->type == hol_term_type::UNARY_APPLICATION
					 && first_predicate->binary.right->type == hol_term_type::VARIABLE && first_predicate->binary.right->variable == predicate_variable)
					{
						array<hol_term*> new_predicates(2);
						intersect<built_in_predicates>(new_predicates, expected_predicate, first_predicate);
						free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
						if (new_predicates.length == 0) {
							free(*conjunct); free(conjunct);
							free(*element_var); if (element_var->reference_count == 0) free(element_var);
							return false;
						} else if (new_predicates.length != 1) {
							fprintf(stderr, "invert_select_arg_without_head_predicative WARNING: Intersection of predicates is not unique.\n");
							free(*conjunct); free(conjunct);
							free(*element_var); if (element_var->reference_count == 0) free(element_var);
							free_all(new_predicates); return false;
						}
						expected_predicate = new_predicates[0];
					}
				}

				if (set_definition != nullptr) {
					/* make sure the resulting expression will be syntactically type-correct */
					unsigned int old_first_length = first_inverter.outer.length;
					unsigned int old_second_length = second_inverter.outer.length;
					if ((first_inverter.outer.last() != new_first_head && !first_inverter.outer.add(new_first_head))
					 || (second_inverter.outer.last() != set_definition && !second_inverter.outer.add(set_definition))) {
						free(*conjunct); free(conjunct);
						free(*element_var); if (element_var->reference_count == 0) free(element_var);
						free(*expected_predicate); free(expected_predicate);
						return false;
					}
					array<hol_type<syntactic_type>> dummy(1);
					hol_type<syntactic_type> predicate_type = (new_first_head->type == hol_term_type::EXISTS ? get_type(new_first_head->quantifier.variable, first_inverter.outer) : base_types<syntactic_type>::INDIVIDUAL);
					hol_type<syntactic_type> arg_type = get_type(set_definition->quantifier.variable, second_inverter.outer);
					if (!expect_type<true>(get_expected_type<(built_in_predicates) ArgConstant>(arg_type), predicate_type, dummy)) {
						free(*conjunct); free(conjunct);
						free(*element_var); if (element_var->reference_count == 0) free(element_var);
						free(*expected_predicate); free(expected_predicate);
						return false;
					}
					first_inverter.outer.length = old_first_length;
					second_inverter.outer.length = old_second_length;
				}

				if (must_be_simple_set_def && can_remove_set_variable
				 && set_definition->quantifier.operand->type == hol_term_type::EQUALS
				 && set_definition->quantifier.operand->binary.left->type == hol_term_type::VARIABLE
				 && set_definition->quantifier.operand->binary.left->variable == set_definition->quantifier.variable
				 && (set_definition->quantifier.operand->binary.right->type == hol_term_type::CONSTANT
				  || set_definition->quantifier.operand->binary.right->type == hol_term_type::ANY_CONSTANT
				  || set_definition->quantifier.operand->binary.right->type == hol_term_type::ANY_CONSTANT_EXCEPT
				  || set_definition->quantifier.operand->binary.right->type == hol_term_type::STRING
				  || set_definition->quantifier.operand->binary.right->type == hol_term_type::NUMBER
				  || set_definition->quantifier.operand->binary.right->type == hol_term_type::ANY)
				 && right->type != hol_term_type::FOR_ALL && right->type != hol_term_type::AND)
				{
					/* the set contains a single constant */
					hol_term* constant = set_definition->quantifier.operand->binary.right;
					hol_term* arg_term = hol_term::new_equals(hol_term::new_apply(hol_term::new_constant(ArgConstant), head_var), constant);
					if (arg_term == nullptr) {
						free(*conjunct); free(conjunct);
						free(*element_var); if (element_var->reference_count == 0) free(element_var);
						free(*expected_predicate); free(expected_predicate);
						return false;
					}
					head_var->reference_count++;
					constant->reference_count++;

					array<hol_term*> arg_terms(2);
					intersect<built_in_predicates>(arg_terms, arg_term, conjunct);
					free(*arg_term); if (arg_term->reference_count == 0) free(arg_term);

					if (!dst.ensure_capacity(dst.length + arg_terms.length) || !dst_outer.ensure_capacity(dst_outer.length + arg_terms.length)) {
						for (hol_term* term : arg_terms) { free(*term); if (term->reference_count == 0) free(term); }
						free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
						free(*element_var); if (element_var->reference_count == 0) free(element_var);
						free(*expected_predicate); free(expected_predicate);
						return false;
					}
					for (hol_term* arg_term : arg_terms) {
						if (ConjunctIndex >= 0) {
							dst[dst.length] = hol_term::new_exists(predicate_variable, hol_term::new_any_array(hol_term_type::AND, conjunct,
									make_array_view(&expected_predicate, 1), make_appended_array_view(make_repeated_array_view(conjunct, ConjunctIndex), arg_term), make_array_view((hol_term**) nullptr, 0)));
							conjunct->reference_count += 1 + ConjunctIndex;
						} else if (ConjunctIndex < 0) {
							unsigned int index = (unsigned int) (-ConjunctIndex) - 1;
							dst[dst.length] = hol_term::new_exists(predicate_variable, hol_term::new_any_array(hol_term_type::AND, conjunct,
									make_array_view(&expected_predicate, 1), make_array_view((hol_term**) nullptr, 0), make_prepended_array_view(arg_term, make_repeated_array_view(conjunct, index))));
							conjunct->reference_count += 1 + index;
						} else {
							fprintf(stderr, "invert_select_arg_without_head_predicative ERROR: Unsupported value of `ConjunctIndex`.\n");
							for (hol_term* term : arg_terms) { free(*term); if (term->reference_count == 0) free(term); }
							free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
							free(*element_var); if (element_var->reference_count == 0) free(element_var);
							free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
							return false;
						}
						if (dst[dst.length] == nullptr) {
							for (hol_term* term : arg_terms) { free(*term); if (term->reference_count == 0) free(term); }
							free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
							free(*element_var); if (element_var->reference_count == 0) free(element_var);
							free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
							return false;
						}
						expected_predicate->reference_count++;
						arg_term->reference_count++;
						dst.length++;

						for (unsigned int i = 0; i < negation_count; i++) {
							hol_term* temp = hol_term::new_not(dst.last());
							if (temp == nullptr) {
								for (hol_term* term : arg_terms) { free(*term); if (term->reference_count == 0) free(term); }
								free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
								free(*element_var); if (element_var->reference_count == 0) free(element_var);
								free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
								return false;
							}
							dst.last() = temp;
						}

						if (wide_scope_marker) {
							hol_term* excluded_wide_scope = hol_term::new_any_right(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ANY));
							if (excluded_wide_scope == nullptr) {
								for (hol_term* term : arg_terms) { free(*term); if (term->reference_count == 0) free(term); }
								free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
								free(*element_var); if (element_var->reference_count == 0) free(element_var);
								free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
								return false;
							}
							hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
							HOL_ANY.reference_count++;

							dst_outer[dst_outer.length] = hol_term::new_any_right(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, hol_term::new_any_right(&HOL_ZERO, &excluded_wide_scope, 1)));
							if (dst_outer[dst_outer.length] == nullptr) {
								for (hol_term* term : arg_terms) { free(*term); if (term->reference_count == 0) free(term); }
								free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
								free(*element_var); if (element_var->reference_count == 0) free(element_var);
								free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
								return false;
							}
							hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
							HOL_ZERO.reference_count++;
							dst_outer.length++;
						} else {
							dst_outer[dst_outer.length++] = &HOL_ZERO;
							HOL_ZERO.reference_count++;
						}
					}
					for (hol_term* term : arg_terms) { free(*term); if (term->reference_count == 0) free(term); }
					if (set_definition->quantifier.operand->binary.right->type != hol_term_type::ANY) {
						free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
						free(*element_var); if (element_var->reference_count == 0) free(element_var);
						free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
						return true;
					}
				}

				hol_term* set_var = hol_term::new_variable(set_variable);
				if (set_var == nullptr) {
					free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
					free(*element_var); if (element_var->reference_count == 0) free(element_var);
					free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
					return false;
				}

				hol_term* arg_term = hol_term::new_equals(hol_term::new_apply(hol_term::new_constant(ArgConstant), head_var), element_var);
				if (arg_term == nullptr) {
					free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
					free(*element_var); if (element_var->reference_count == 0) free(element_var);
					free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
					free(*set_var); free(set_var);
					return false;
				}
				head_var->reference_count++;

				/* make sure if there is a WIDE_SCOPE, it doesn't appear right before the set definition */
				hol_term* immediate_outer = nullptr;
				if (is_array && second_inverter.outer.length >= 2)
					immediate_outer = second_inverter.outer[second_inverter.outer.length - 2];
				else if (!is_array)
					immediate_outer = second_inverter.outer[second_inverter.outer.length - 1];
				bool has_immediate_outer_wide_scope = (!wide_scope_marker
						&& immediate_outer != nullptr && immediate_outer->type == hol_term_type::UNARY_APPLICATION
						&& immediate_outer->binary.left->type == hol_term_type::CONSTANT
						&& immediate_outer->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE);
				if (can_remove_set_variable && !has_immediate_outer_wide_scope && !(!could_have_wide_scope_marker_before_quantifier && wide_scope_marker && element_narrow_scope)) {
					hol_term* excluded_quantifiers[3];
					excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(element_variable, &HOL_ANY));
					excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(element_variable, &HOL_ANY));
					excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(element_variable, &HOL_ANY));
					if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
					if (excluded_quantifiers[1] != nullptr) HOL_ANY.reference_count++;
					if (excluded_quantifiers[2] != nullptr) HOL_ANY.reference_count++;
					if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr) {
						if (excluded_quantifiers[0] != nullptr) { free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]); }
						if (excluded_quantifiers[1] != nullptr) { free(*excluded_quantifiers[1]); free(excluded_quantifiers[1]); }
						free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
						free(*arg_term); free(arg_term); free(*set_var); free(set_var);
						free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
						return false;
					}

					hol_term* expected_left = hol_term::new_equals(set_var, hol_term::new_lambda(element_variable, hol_term::new_any(nullptr, excluded_quantifiers, array_length(excluded_quantifiers))));
					if (expected_left == nullptr) {
						for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
						free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
						free(*arg_term); free(arg_term); free(*set_var); free(set_var);
						free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
						return false;
					}
					set_var->reference_count++;

					array<hol_term*> left_intersections(4);
					intersect<built_in_predicates>(left_intersections, expected_left, left);
					free(*expected_left); free(expected_left);

					if (!dst.ensure_capacity(dst.length + left_intersections.length + 1) || !dst_outer.ensure_capacity(dst_outer.length + left_intersections.length + 1)) {
						for (hol_term* term : left_intersections) { free(*term); if (term->reference_count == 0) free(term); }
						free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
						free(*arg_term); free(arg_term);
						free(*set_var); if (set_var->reference_count == 0) free(set_var);
						free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
						return false;
					}
					for (hol_term* left_intersection : left_intersections) {
						hol_term* set_definition;
						if (left_intersection->type == hol_term_type::EQUALS)
							set_definition = left_intersection->binary.right->quantifier.operand;
						else set_definition = left_intersection->ternary.third->quantifier.operand;

						if (right->type == hol_term_type::FOR_ALL || right->type == hol_term_type::EXISTS) {
							/* this case was originally only for FOR_ALL, since we always moved universal quantifiers
							   outside the head scope, and we would keep existential quantifiers inside the head scope
							   if possible; but now we move both quantifiers outside the head scope */
							hol_term* excluded_quantifiers[4];
							unsigned int excluded_quantifier_count = 3;
							excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(element_variable, &HOL_ANY));
							excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(element_variable, &HOL_ANY));
							excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(element_variable, &HOL_ANY));
							if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
							if (excluded_quantifiers[1] != nullptr) HOL_ANY.reference_count++;
							if (excluded_quantifiers[2] != nullptr) HOL_ANY.reference_count++;
							if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr) {
								if (excluded_quantifiers[0] != nullptr) { free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]); }
								if (excluded_quantifiers[1] != nullptr) { free(*excluded_quantifiers[1]); free(excluded_quantifiers[1]); }
								for (hol_term* term : left_intersections) { free(*term); if (term->reference_count == 0) free(term); }
								free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
								free(*arg_term); if (arg_term->reference_count == 0) free(arg_term);
								free(*set_var); if (set_var->reference_count == 0) free(set_var);
								free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
								return false;
							}

							if (ConjunctIndex >= 0) {
								dst[dst.length] = hol_term::new_exists(predicate_variable, hol_term::new_any_array(hol_term_type::AND, conjunct,
										make_array_view(&expected_predicate, 1), make_appended_array_view(make_repeated_array_view(conjunct, ConjunctIndex), arg_term), make_array_view((hol_term**) nullptr, 0)));
								if (dst[dst.length] == nullptr) {
									for (hol_term* term : left_intersections) { free(*term); if (term->reference_count == 0) free(term); }
									free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
									free(*arg_term); if (arg_term->reference_count == 0) free(arg_term);
									free(*set_var); if (set_var->reference_count == 0) free(set_var);
									for (unsigned int i = 0; i < excluded_quantifier_count; i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
									free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
									return false;
								}
								arg_term->reference_count++;
								conjunct->reference_count += 1 + ConjunctIndex;
								expected_predicate->reference_count++;
							} else if (ConjunctIndex < 0) {
								unsigned int index = (unsigned int) (-ConjunctIndex) - 1;
								dst[dst.length] = hol_term::new_exists(predicate_variable, hol_term::new_any_array(hol_term_type::AND, conjunct,
										make_array_view(&expected_predicate, 1), make_array_view((hol_term**) nullptr, 0), make_prepended_array_view(arg_term, make_repeated_array_view(conjunct, index))));
								if (dst[dst.length] == nullptr) {
									for (hol_term* term : left_intersections) { free(*term); if (term->reference_count == 0) free(term); }
									free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
									free(*arg_term); if (arg_term->reference_count == 0) free(arg_term);
									free(*set_var); if (set_var->reference_count == 0) free(set_var);
									for (unsigned int i = 0; i < excluded_quantifier_count; i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
									free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
									return false;
								}
								arg_term->reference_count++;
								conjunct->reference_count += 1 + index;
								expected_predicate->reference_count++;
							}
							dst.length++;

							if (is_array) {
								hol_term* quantified_term;
								if (right->type == hol_term_type::FOR_ALL) {
									quantified_term = hol_term::new_for_all(element_variable, hol_term::new_if_then(set_definition, hol_term::new_any_right(&HOL_ZERO, excluded_quantifiers, excluded_quantifier_count)));
									if (quantified_term == nullptr) {
										for (hol_term* term : left_intersections) { free(*term); if (term->reference_count == 0) free(term); }
										free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
										free(*arg_term); if (arg_term->reference_count == 0) free(arg_term);
										free(*set_var); if (set_var->reference_count == 0) free(set_var);
										for (unsigned int i = 0; i < excluded_quantifier_count; i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
										free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
										free_all(dst); free_all(dst_outer); return false;
									}
									set_definition->reference_count++;
									HOL_ZERO.reference_count++;
								} else if (set_definition->type == hol_term_type::AND) {
									if (wide_scope_marker && !element_narrow_scope) {
										quantified_term = hol_term::new_exists(element_variable, hol_term::new_and(make_appended_array_view(
												make_array_view(set_definition->array.operands, set_definition->array.length),
												hol_term::new_any_right(
													hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ZERO),
												excluded_quantifiers, excluded_quantifier_count))));
									} else {
										quantified_term = hol_term::new_exists(element_variable, hol_term::new_and(make_appended_array_view(
												make_array_view(set_definition->array.operands, set_definition->array.length),
												hol_term::new_any_right(&HOL_ZERO, excluded_quantifiers, excluded_quantifier_count))));
									}
									if (quantified_term == nullptr) {
										for (hol_term* term : left_intersections) { free(*term); if (term->reference_count == 0) free(term); }
										free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
										free(*arg_term); if (arg_term->reference_count == 0) free(arg_term);
										free(*set_var); if (set_var->reference_count == 0) free(set_var);
										for (unsigned int i = 0; i < excluded_quantifier_count; i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
										free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
										free_all(dst); free_all(dst_outer); return false;
									}
									for (unsigned int i = 0; i < set_definition->array.length; i++)
										set_definition->array.operands[i]->reference_count++;
									if (wide_scope_marker && !element_narrow_scope)
										hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
									HOL_ZERO.reference_count++;
								} else {
									if (wide_scope_marker && !element_narrow_scope) {
										quantified_term = hol_term::new_exists(element_variable, hol_term::new_and(set_definition, hol_term::new_any_right(
												hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ZERO), excluded_quantifiers, excluded_quantifier_count)));
									} else {
										if (!could_have_wide_scope_marker_before_head) {
											excluded_quantifiers[excluded_quantifier_count] = hol_term::new_any_right(hol_term::new_apply(
													&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ANY));
											if (excluded_quantifiers[excluded_quantifier_count] == nullptr) {
												for (hol_term* term : left_intersections) { free(*term); if (term->reference_count == 0) free(term); }
												free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
												free(*arg_term); if (arg_term->reference_count == 0) free(arg_term);
												free(*set_var); if (set_var->reference_count == 0) free(set_var);
												for (unsigned int i = 0; i < excluded_quantifier_count; i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
												free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
												free_all(dst); free_all(dst_outer); return false;
											}
											excluded_quantifier_count++;
											hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
											HOL_ANY.reference_count++;
										}
										quantified_term = hol_term::new_exists(element_variable, hol_term::new_and(set_definition, hol_term::new_any_right(&HOL_ZERO, excluded_quantifiers, excluded_quantifier_count)));
									}
									if (quantified_term == nullptr) {
										for (hol_term* term : left_intersections) { free(*term); if (term->reference_count == 0) free(term); }
										free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
										free(*arg_term); if (arg_term->reference_count == 0) free(arg_term);
										free(*set_var); if (set_var->reference_count == 0) free(set_var);
										for (unsigned int i = 0; i < excluded_quantifier_count; i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
										free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
										free_all(dst); free_all(dst_outer); return false;
									}
									set_definition->reference_count++;
									if (wide_scope_marker && !element_narrow_scope)
										hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
									HOL_ZERO.reference_count++;
								}

								for (unsigned int i = 0; i < negation_count; i++) {
									hol_term* temp = hol_term::new_not(quantified_term);
									if (temp == nullptr) {
										for (hol_term* term : left_intersections) { free(*term); if (term->reference_count == 0) free(term); }
										free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
										free(*arg_term); if (arg_term->reference_count == 0) free(arg_term);
										free(*set_var); if (set_var->reference_count == 0) free(set_var);
										free(*quantified_term); free(quantified_term);
										free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
										free_all(dst); free_all(dst_outer); return false;
									}
									quantified_term = temp;
								}

								if ((could_have_wide_scope_marker_before_quantifier && right->type == hol_term_type::FOR_ALL) || (wide_scope_marker && element_narrow_scope)) {
									dst_outer[dst_outer.length] = hol_term::new_apply(
											&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, quantified_term);
									if (dst_outer[dst_outer.length] == nullptr) {
										for (hol_term* term : left_intersections) { free(*term); if (term->reference_count == 0) free(term); }
										free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
										free(*arg_term); if (arg_term->reference_count == 0) free(arg_term);
										free(*set_var); if (set_var->reference_count == 0) free(set_var);
										free(*quantified_term); free(quantified_term);
										free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
										free_all(dst); free_all(dst_outer); return false;
									}
									hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
								} else {
									dst_outer[dst_outer.length] = quantified_term;
								}
								dst_outer.length++;
							} else {
								hol_term* quantified_term;
								if (right->type == hol_term_type::FOR_ALL) {
									quantified_term = hol_term::new_for_all(element_variable, hol_term::new_if_then(set_definition, hol_term::new_any_right(&HOL_ZERO, excluded_quantifiers, excluded_quantifier_count)));
									if (quantified_term == nullptr) {
										for (hol_term* term : left_intersections) { free(*term); if (term->reference_count == 0) free(term); }
										free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
										free(*arg_term); if (arg_term->reference_count == 0) free(arg_term);
										free(*set_var); if (set_var->reference_count == 0) free(set_var);
										for (unsigned int i = 0; i < excluded_quantifier_count; i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
										free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
										free_all(dst); free_all(dst_outer); return false;
									}
									set_definition->reference_count++;
									HOL_ZERO.reference_count++;
								} else if (set_definition->type == hol_term_type::AND) {
									if (wide_scope_marker && !element_narrow_scope) {
										quantified_term = hol_term::new_exists(element_variable, hol_term::new_and(make_appended_array_view(
												make_array_view(set_definition->array.operands, set_definition->array.length),
												hol_term::new_any_right(
													hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ZERO),
												excluded_quantifiers, excluded_quantifier_count))));
									} else {
										quantified_term = hol_term::new_exists(element_variable, hol_term::new_and(make_appended_array_view(
												make_array_view(set_definition->array.operands, set_definition->array.length),
												hol_term::new_any_right(&HOL_ZERO, excluded_quantifiers, excluded_quantifier_count))));
									}
									if (quantified_term == nullptr) {
										for (hol_term* term : left_intersections) { free(*term); if (term->reference_count == 0) free(term); }
										free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
										free(*arg_term); if (arg_term->reference_count == 0) free(arg_term);
										free(*set_var); if (set_var->reference_count == 0) free(set_var);
										for (unsigned int i = 0; i < excluded_quantifier_count; i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
										free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
										free_all(dst); free_all(dst_outer); return false;
									}
									for (unsigned int i = 0; i < set_definition->array.length; i++)
										set_definition->array.operands[i]->reference_count++;
									if (wide_scope_marker && !element_narrow_scope)
										hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
									HOL_ZERO.reference_count++;
								} else {
									if (wide_scope_marker && !element_narrow_scope) {
										quantified_term = hol_term::new_exists(element_variable, hol_term::new_and(set_definition, hol_term::new_any_right(
												hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ZERO), excluded_quantifiers, excluded_quantifier_count)));
									} else {
										quantified_term = hol_term::new_exists(element_variable, hol_term::new_and(set_definition, hol_term::new_any_right(&HOL_ZERO, excluded_quantifiers, excluded_quantifier_count)));
									}
									if (quantified_term == nullptr) {
										for (hol_term* term : left_intersections) { free(*term); if (term->reference_count == 0) free(term); }
										free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
										free(*arg_term); if (arg_term->reference_count == 0) free(arg_term);
										free(*set_var); if (set_var->reference_count == 0) free(set_var);
										for (unsigned int i = 0; i < excluded_quantifier_count; i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
										free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
										free_all(dst); free_all(dst_outer); return false;
									}
									set_definition->reference_count++;
									if (wide_scope_marker && !element_narrow_scope)
										hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
									HOL_ZERO.reference_count++;
								}

								for (unsigned int i = 0; i < negation_count; i++) {
									hol_term* temp = hol_term::new_not(quantified_term);
									if (temp == nullptr) {
										for (hol_term* term : left_intersections) { free(*term); if (term->reference_count == 0) free(term); }
										free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
										free(*arg_term); if (arg_term->reference_count == 0) free(arg_term);
										free(*set_var); if (set_var->reference_count == 0) free(set_var);
										free(*quantified_term); free(quantified_term);
										free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
										free_all(dst); free_all(dst_outer); return false;
									}
									quantified_term = temp;
								}

								if ((could_have_wide_scope_marker_before_quantifier && right->type == hol_term_type::FOR_ALL) || (wide_scope_marker && element_narrow_scope)) {
									hol_term* excluded_wide_scope = hol_term::new_any_right(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ANY));
									if (excluded_wide_scope == nullptr) {
										for (hol_term* term : left_intersections) { free(*term); if (term->reference_count == 0) free(term); }
										free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
										free(*arg_term); if (arg_term->reference_count == 0) free(arg_term);
										free(*set_var); if (set_var->reference_count == 0) free(set_var);
										free(*quantified_term); free(quantified_term);
										free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
										free_all(dst); free_all(dst_outer); return false;
									}
									hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
									HOL_ANY.reference_count++;

									dst_outer[dst_outer.length] = hol_term::new_any_right_only(hol_term::new_apply(
											&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value,
											hol_term::new_any_right_only(quantified_term, &excluded_wide_scope, 1)));
									if (dst_outer[dst_outer.length] == nullptr) {
										for (hol_term* term : left_intersections) { free(*term); if (term->reference_count == 0) free(term); }
										free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
										free(*arg_term); if (arg_term->reference_count == 0) free(arg_term);
										free(*set_var); if (set_var->reference_count == 0) free(set_var);
										free(*excluded_wide_scope); free(excluded_wide_scope);
										free(*quantified_term); free(quantified_term);
										free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
										free_all(dst); free_all(dst_outer); return false;
									}
									hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
								} else {
									dst_outer[dst_outer.length] = quantified_term;
								}
								dst_outer.length++;
							}
							could_have_wide_scope = could_have_wide_scope_marker_before_quantifier;
						} else {
							for (hol_term* term : left_intersections) { free(*term); if (term->reference_count == 0) free(term); }
							free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
							free(*arg_term); if (arg_term->reference_count == 0) free(arg_term);
							free(*set_var); if (set_var->reference_count == 0) free(set_var);
							free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
							return false;
						}
					}
					for (hol_term* term : left_intersections) { free(*term); if (term->reference_count == 0) free(term); }
				}

				if (!MustBeSetValued && can_keep_set_variable && (right->type == hol_term_type::EXISTS || right->type == hol_term_type::FOR_ALL || right->type == hol_term_type::UNARY_APPLICATION))
				{
					hol_term* new_second_head;
					if (ConjunctIndex >= 0) {
						new_second_head = hol_term::new_exists(predicate_variable, hol_term::new_any_array(hol_term_type::AND, conjunct,
								make_array_view(&expected_predicate, 1), make_appended_array_view(make_repeated_array_view(conjunct, ConjunctIndex), arg_term), make_array_view((hol_term**) nullptr, 0)));
						if (new_second_head == nullptr) {
							free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
							free(*arg_term); if (arg_term->reference_count == 0) free(arg_term);
							free(*set_var); if (set_var->reference_count == 0) free(set_var);
							free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
							return false;
						}
						arg_term->reference_count++;
						conjunct->reference_count += 1 + ConjunctIndex;
						expected_predicate->reference_count++;
					} else if (ConjunctIndex < 0) {
						unsigned int index = (unsigned int) (-ConjunctIndex) - 1;
						new_second_head = hol_term::new_exists(predicate_variable, hol_term::new_any_array(hol_term_type::AND, conjunct,
								make_array_view(&expected_predicate, 1), make_array_view((hol_term**) nullptr, 0), make_prepended_array_view(arg_term, make_repeated_array_view(conjunct, index))));
						if (new_second_head == nullptr) {
							free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
							free(*arg_term); if (arg_term->reference_count == 0) free(arg_term);
							free(*set_var); if (set_var->reference_count == 0) free(set_var);
							free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
							return false;
						}
						arg_term->reference_count++;
						conjunct->reference_count += 1 + index;
						expected_predicate->reference_count++;
					}

					array<hol_term*> new_heads(2);
					intersect<built_in_predicates>(new_heads, new_second_head, new_first_head);
					free(*new_second_head); if (new_second_head->reference_count == 0) free(new_second_head);
					if (!dst.ensure_capacity(dst.length + new_heads.length) || !dst_outer.ensure_capacity(dst_outer.length + new_heads.length)) {
						free_all(new_heads);
						free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
						free(*arg_term); if (arg_term->reference_count == 0) free(arg_term);
						free(*set_var); if (set_var->reference_count == 0) free(set_var);
						free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
						return false;
					}
					for (unsigned int i = 0; i < new_heads.length; i++) {
						hol_term* new_head = new_heads[i];
						if (wide_scope_marker && element_narrow_scope && right->type != hol_term_type::FOR_ALL) {
							hol_term* temp = hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, hol_term::new_any_right_only(new_head));
							if (temp == nullptr) {
								free_all(new_heads);
								free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
								free(*arg_term); if (arg_term->reference_count == 0) free(arg_term);
								free(*set_var); if (set_var->reference_count == 0) free(set_var);
								free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
								return false;
							}
							hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
							new_head = temp;
							new_heads[i] = temp;
						}
						dst[dst.length++] = new_head;
						new_head->reference_count++;

						hol_term* excluded_quantifiers[6];
						constexpr unsigned int excluded_quantifier_count = array_length(excluded_quantifiers);
						excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(set_variable, &HOL_ANY));
						excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(set_variable, &HOL_ANY));
						excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(set_variable, &HOL_ANY));
						excluded_quantifiers[3] = hol_term::new_any(hol_term::new_exists(element_variable, &HOL_ANY));
						excluded_quantifiers[4] = hol_term::new_any(hol_term::new_for_all(element_variable, &HOL_ANY));
						excluded_quantifiers[5] = hol_term::new_any(hol_term::new_lambda(element_variable, &HOL_ANY));
						for (unsigned int i = 0; i < excluded_quantifier_count; i++)
							if (excluded_quantifiers[i] != nullptr) HOL_ANY.reference_count++;
						if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr
						 || excluded_quantifiers[3] == nullptr || excluded_quantifiers[4] == nullptr || excluded_quantifiers[5] == nullptr) {
							for (unsigned int i = 0; i < excluded_quantifier_count; i++)
								if (excluded_quantifiers[i] != nullptr) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
							free_all(new_heads);
							free(*arg_term); if (arg_term->reference_count == 0) free(arg_term);
							free(*set_var); if (set_var->reference_count == 0) free(set_var);
							free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
							free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
							return false;
						}

						hol_term* new_right_conjunct;
						if (right->type == hol_term_type::EXISTS) {
							new_right_conjunct = hol_term::new_any_right_only(hol_term::new_exists(element_variable, hol_term::new_and(hol_term::new_apply(set_var, element_var), hol_term::new_any_right_only(&HOL_ZERO, excluded_quantifiers + 3, excluded_quantifier_count - 3))), excluded_quantifiers, 3);
							if (new_right_conjunct == nullptr) {
								free_all(new_heads);
								free(*arg_term); if (arg_term->reference_count == 0) free(arg_term);
								free(*set_var); if (set_var->reference_count == 0) free(set_var);
								free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
								for (unsigned int i = 0; i < excluded_quantifier_count; i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
								free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
								return false;
							}
							HOL_ZERO.reference_count++;
							element_var->reference_count++;
							set_var->reference_count++;
						} else if (right->type == hol_term_type::UNARY_APPLICATION) {
							new_right_conjunct = hol_term::new_any_right_only(&HOL_ZERO, excluded_quantifiers, excluded_quantifier_count);
							if (new_right_conjunct == nullptr) {
								free_all(new_heads);
								free(*arg_term); if (arg_term->reference_count == 0) free(arg_term);
								free(*set_var); if (set_var->reference_count == 0) free(set_var);
								free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
								for (unsigned int i = 0; i < excluded_quantifier_count; i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
								free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
								return false;
							}
							HOL_ZERO.reference_count++;
						} else {
							if (wide_scope_marker) {
								new_right_conjunct = hol_term::new_any_right_only(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, hol_term::new_for_all(element_variable,
										hol_term::new_if_then(hol_term::new_apply(set_var, element_var), hol_term::new_any_right_only(&HOL_ZERO, excluded_quantifiers + 3, excluded_quantifier_count - 3)))), excluded_quantifiers, 3);
							} else {
								new_right_conjunct = hol_term::new_any_right_only(hol_term::new_for_all(element_variable,
										hol_term::new_if_then(hol_term::new_apply(set_var, element_var), hol_term::new_any_right_only(&HOL_ZERO, excluded_quantifiers + 3, excluded_quantifier_count - 3))), excluded_quantifiers, 3);
							}
							if (new_right_conjunct == nullptr) {
								free_all(new_heads);
								free(*arg_term); if (arg_term->reference_count == 0) free(arg_term);
								free(*set_var); if (set_var->reference_count == 0) free(set_var);
								free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
								for (unsigned int i = 0; i < excluded_quantifier_count; i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
								free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
								return false;
							}
							if (wide_scope_marker)
								hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
							HOL_ZERO.reference_count++;
							element_var->reference_count++;
							set_var->reference_count++;
						}

						dst_outer[dst_outer.length] = substitute_head<any_node_position::NONE>(second_head, old_right, new_right_conjunct);
						free(*new_right_conjunct); if (new_right_conjunct->reference_count == 0) free(new_right_conjunct);
						if (dst_outer[dst_outer.length] == nullptr) {
							free(*arg_term); if (arg_term->reference_count == 0) free(arg_term);
							free(*set_var); if (set_var->reference_count == 0) free(set_var);
							free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
							free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
							return false;
						}
						dst_outer.length++;
						could_have_wide_scope = could_have_wide_scope_marker_before_quantifier;
					}
					free_all(new_heads);
				}
				free(*arg_term); if (arg_term->reference_count == 0) free(arg_term);

				/* also consider the case where the argument is a set variable (i.e. set-valued) */
				if (right->type == hol_term_type::FOR_ALL && !wide_scope_marker)
				{
					hol_term* set_valued_arg_term = hol_term::new_equals(hol_term::new_apply(hol_term::new_constant(ArgConstant), head_var), set_var);
					if (set_valued_arg_term == nullptr) {
						free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
						free(*set_var); if (set_var->reference_count == 0) free(set_var);
						free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
						return false;
					}
					head_var->reference_count++;
					set_var->reference_count++;

					hol_term* new_second_head;
					if (ConjunctIndex >= 0) {
						new_second_head = hol_term::new_exists(predicate_variable, hol_term::new_any_array(hol_term_type::AND, conjunct,
								make_array_view(&expected_predicate, 1), make_appended_array_view(make_repeated_array_view(conjunct, ConjunctIndex), set_valued_arg_term), make_array_view((hol_term**) nullptr, 0)));
						if (new_second_head == nullptr) {
							free(*set_valued_arg_term); free(set_valued_arg_term);
							free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
							free(*set_var); if (set_var->reference_count == 0) free(set_var);
							free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
							return false;
						}
						conjunct->reference_count += 1 + ConjunctIndex;
						expected_predicate->reference_count++;
					} else if (ConjunctIndex < 0) {
						unsigned int index = (unsigned int) (-ConjunctIndex) - 1;
						new_second_head = hol_term::new_exists(predicate_variable, hol_term::new_any_array(hol_term_type::AND, conjunct,
								make_array_view(&expected_predicate, 1), make_array_view((hol_term**) nullptr, 0), make_prepended_array_view(set_valued_arg_term, make_repeated_array_view(conjunct, index))));
						if (new_second_head == nullptr) {
							free(*set_valued_arg_term); free(set_valued_arg_term);
							free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
							free(*set_var); if (set_var->reference_count == 0) free(set_var);
							free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
							return false;
						}
						conjunct->reference_count += 1 + index;
						expected_predicate->reference_count++;
					}

					array<hol_term*> new_heads(2);
					intersect<built_in_predicates>(new_heads, new_second_head, new_first_head);
					free(*new_second_head); if (new_second_head->reference_count == 0) free(new_second_head);
					if (!dst.ensure_capacity(dst.length + new_heads.length) || !dst_outer.ensure_capacity(dst_outer.length + new_heads.length)) {
						free_all(new_heads);
						free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
						free(*set_var); if (set_var->reference_count == 0) free(set_var);
						free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
						return false;
					}

					hol_term* excluded_quantifier = hol_term::new_any(hol_term::new_exists(set_variable, &HOL_ANY));
					if (excluded_quantifier == nullptr) {
						free_all(new_heads);
						free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
						free(*set_var); if (set_var->reference_count == 0) free(set_var);
						free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
						return false;
					}
					HOL_ANY.reference_count++;

					hol_term* new_right_conjunct = hol_term::new_any_right_only(&HOL_ZERO, &excluded_quantifier, 1);
					if (new_right_conjunct == nullptr) {
						free_all(new_heads);
						free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
						free(*set_var); if (set_var->reference_count == 0) free(set_var);
						free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
						free(*excluded_quantifier); free(excluded_quantifier);
						return false;
					}
					HOL_ZERO.reference_count++;

					for (unsigned int i = 0; i < new_heads.length; i++) {
						dst[dst.length++] = new_heads[i];
						new_heads[i]->reference_count++;

						if ((old_right->type == hol_term_type::ANY || old_right->type == hol_term_type::ANY_RIGHT) && !can_have_free_variables(*new_heads[i]))
							dst_outer[dst_outer.length] = substitute_head<any_node_position::NONE>(second_head, old_right, new_right_conjunct);
						else dst_outer[dst_outer.length] = substitute_head<any_node_position::NONE>(second_head, right, new_right_conjunct);
						if (dst_outer[dst_outer.length] == nullptr) {
							free(*arg_term); if (arg_term->reference_count == 0) free(arg_term);
							free(*set_var); if (set_var->reference_count == 0) free(set_var);
							free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
							free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
							free(*new_right_conjunct); if (new_right_conjunct->reference_count == 0) free(new_right_conjunct);
							return false;
						}
						dst_outer.length++;
					}
					free(*new_right_conjunct); if (new_right_conjunct->reference_count == 0) free(new_right_conjunct);
					free_all(new_heads);
				}
				free(*set_var); if (set_var->reference_count == 0) free(set_var);
				free(*conjunct); if (conjunct->reference_count == 0) free(conjunct);
				free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);

				return (dst.length > 0);
			} else {
				return false;
			}
		});
}

template<unsigned int ArgConstant, bool InvertArg, bool OuterScope>
inline bool invert_select_singleton_arg_in_set_without_head_predicative(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	if (second->type != hol_term_type::LAMBDA)
		return false;
	unsigned int lambda_variable = second->quantifier.variable;

	bool found_outer_scope = false;
	bool can_invert_outer_scope = false;
	predicative_head_finder<built_in_predicates> predicative_finder(lambda_variable);
	auto find_head = [&predicative_finder,&found_outer_scope](hol_term* src, hol_term*& head, head_index& predicate_index)
	{
		predicative_finder(src, head, predicate_index);
		if (head != nullptr)
			return;

		if (src->type != hol_term_type::EXISTS)
			return;
		hol_term* right;
		hol_term* operand = src->quantifier.operand;
		if (operand->type == hol_term_type::AND) {
			right = operand->array.operands[operand->array.length - 1];
		} else if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND && operand->any_array.right.length != 0) {
			right = operand->any_array.right.operands[operand->any_array.right.length - 1];
		} else {
			return;
		}

		predicative_finder(right, head, predicate_index);
		if (head == nullptr) {
			head = nullptr;
			return;
		}
		found_outer_scope = true;
		head = src;
		return;
	};

	auto on_remap_variables = [lambda_variable,&found_outer_scope,&can_invert_outer_scope](hol_term* first_head, hol_term* second_head,
			apply_head_inverter& first_head_inverter, apply_head_inverter& second_head_inverter,
			array_map<const hol_term*, unsigned int>& second_variable_map, unsigned int max_variable,
			bool first_head_is_array, bool second_head_is_array)
	{
		/* make sure the initial lambda variables are correctly mapped */
		if (first_head_inverter.outer[0]->type == hol_term_type::LAMBDA && second_head_inverter.outer[0]->type == hol_term_type::LAMBDA) {
			if (!second_variable_map.ensure_capacity(second_variable_map.size + 1)) {
				for (auto entry : second_variable_map) free(entry.value);
				return false;
			}

			unsigned int first_lambda_variable = first_head_inverter.outer[0]->quantifier.variable;
			hol_term* second_lambda = second_head_inverter.outer[0];
			unsigned int index = second_variable_map.index_of(second_lambda);
			if (index < second_variable_map.size && first_lambda_variable == second_variable_map.values[index]) {
				/* `second_variable_map` should map `var` to itself */
				second_variable_map.remove_at(index);
			} else {
				/* `second_variable_map` should map `var` to `target_var` */
				second_variable_map.values[index] = first_lambda_variable;
				if (index == second_variable_map.size) {
					second_variable_map.keys[index] = second_lambda;
					second_variable_map.size++;
				}
			}
		}

		if ((first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) && first_head->any.included != nullptr
		 && (first_head->any.included->type == hol_term_type::EXISTS || first_head->any.included->type == hol_term_type::NOT))
			first_head = first_head->any.included;
		if ((second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT) && second_head->any.included != nullptr) {
			second_head = second_head->any.included;
			if (!second_head_inverter.outer.add(second_head))
				return false;
		}

		if (first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) {
			can_invert_outer_scope = (OuterScope ? found_outer_scope : false);
			return true;
		}

		unsigned int first_element_variable;
		if (first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) {
			if (first_head->any.included != nullptr && first_head->any.included->type == hol_term_type::UNARY_APPLICATION
				&& first_head->any.included->binary.left->type == hol_term_type::VARIABLE
				&& first_head->any.included->binary.left->variable == lambda_variable
				&& first_head->any.included->binary.right->type == hol_term_type::VARIABLE)
			{
				first_element_variable = first_head->any.included->binary.right->variable;
			} else {
				first_element_variable = 0;
			}
		} else {
#if !defined(NDEBUG)
			if (first_head->type != hol_term_type::EXISTS)
				fprintf(stderr, "invert_select_singleton_arg_in_set_without_head_predicative WARNING: Expected an existential quantification.\n");
#endif
			hol_term* operand = first_head->quantifier.operand;

			hol_term* right = nullptr;
			hol_term* first_left = nullptr;
			if (operand->type == hol_term_type::ANY || operand->type == hol_term_type::ANY_RIGHT) {
				first_element_variable = 0;
			} else if (operand->type == hol_term_type::AND && operand->array.length != 0) {
				first_left = operand->array.operands[0];
				right = operand->array.operands[operand->array.length - 1];
			} else if (operand->type == hol_term_type::ANY_ARRAY) {
				if (operand->any_array.left.length != 0)
					first_left = operand->any_array.left.operands[0];
				else first_left = operand->any_array.all;
				if (operand->any_array.right.length != 0)
					right = operand->any_array.right.operands[operand->any_array.right.length - 1];
				else right = operand->any_array.all;
			} else {
				return false;
			}

			hol_term* set_definition = nullptr;
			if (first_left != nullptr) {
				if (first_left->type == hol_term_type::ANY || first_left->type == hol_term_type::ANY_RIGHT) {
					if (first_left->any.included != nullptr)
						set_definition = first_left->any.included;
				} else if (first_left->type == hol_term_type::EQUALS) {
					set_definition = first_left->binary.right;
				} else {
					return false;
				}
			}

			if (set_definition != nullptr) {
				if (set_definition->type == hol_term_type::ANY || set_definition->type == hol_term_type::ANY_RIGHT) {
					first_element_variable = 0;
				} else if (set_definition->type == hol_term_type::LAMBDA) {
					first_element_variable = set_definition->quantifier.variable;
				} else {
					return false;
				}
			} else {
				first_element_variable = 0;
			}

			if (first_element_variable == 0 && right != nullptr) {
				/* try to get the element variable from the right conjunct, since we couldn't get it from the left conjunct */
				if ((right->type == hol_term_type::ANY || right->type == hol_term_type::ANY_RIGHT) && right->any.included != nullptr)
					right = right->any.included;
				if (right->type == hol_term_type::UNARY_APPLICATION && right->binary.left->type == hol_term_type::CONSTANT && right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE)
					right = right->binary.right;
				if (right->type == hol_term_type::ANY || right->type == hol_term_type::ANY_RIGHT) {
					first_element_variable = ++max_variable;
				} else if (right->type == hol_term_type::EXISTS) {
					first_element_variable = right->quantifier.variable;
				} else {
					return false;
				}
			}
		}

		hol_term* first_left = nullptr;
		hol_term* first_operand = first_head->quantifier.operand;
		if (first_operand->type == hol_term_type::AND) {
			first_left = first_operand->array.operands[0];
		} else if (first_operand->type == hol_term_type::ANY_ARRAY && first_operand->any_array.oper == hol_term_type::AND) {
			if (first_operand->any_array.left.length == 0)
				first_left = first_operand->any_array.all;
			else first_left = first_operand->any_array.left.operands[0];
		} else if (first_operand->type == hol_term_type::ANY || first_operand->type == hol_term_type::ANY_RIGHT) {
			can_invert_outer_scope = (OuterScope ? found_outer_scope : false);
			return true;
		}

		hol_term* first_set_definition = nullptr;
		if (first_left->type == hol_term_type::EQUALS && first_left->binary.right->type == hol_term_type::LAMBDA) {
			first_set_definition = first_left->binary.right->quantifier.operand;
		} else if (first_left->type == hol_term_type::BINARY_APPLICATION && first_left->ternary.third->type == hol_term_type::LAMBDA) {
			first_set_definition = first_left->ternary.third->quantifier.operand;
		} else if (first_left->type == hol_term_type::ANY_RIGHT && first_left->any.included != nullptr && first_left->any.included->type == hol_term_type::LAMBDA) {
			first_set_definition = first_left->any.included->quantifier.operand;
		} else if (first_left->type == hol_term_type::ANY || first_left->type == hol_term_type::ANY_RIGHT) {
			can_invert_outer_scope = (OuterScope ? found_outer_scope : false);
			return true;
		} else {
			return false;
		}

		hol_term* first_inner_right = nullptr;
		hol_term* innermost_operand = nullptr;
		if (first_set_definition->type == hol_term_type::EXISTS) {
			innermost_operand = first_set_definition->quantifier.operand;
			if (innermost_operand->type == hol_term_type::AND) {
				first_inner_right = innermost_operand->array.operands[innermost_operand->array.length - 1];
			} else if (innermost_operand->type == hol_term_type::ANY_ARRAY && innermost_operand->any_array.oper == hol_term_type::AND) {
				if (innermost_operand->any_array.right.length == 0)
					first_inner_right = innermost_operand->any_array.all;
				else first_inner_right = innermost_operand->any_array.right.operands[innermost_operand->any_array.right.length - 1];
			} else {
				return false;
			}
		} else if (first_set_definition->type == hol_term_type::ANY_RIGHT && first_set_definition->any.included != nullptr && first_set_definition->any.included->type == hol_term_type::EXISTS) {
			can_invert_outer_scope = (OuterScope ? found_outer_scope : false);
			first_inner_right = first_set_definition->any.included;
			innermost_operand = first_set_definition->any.included->quantifier.operand;
		} else if (first_set_definition->type == hol_term_type::ANY || first_set_definition->type == hol_term_type::ANY_RIGHT) {
			can_invert_outer_scope = (OuterScope ? found_outer_scope : false);
			return true;
		}

		if (first_inner_right->type == hol_term_type::EXISTS)
			innermost_operand = first_inner_right->quantifier.operand;

		hol_term* old_second_head = second_head;
		hol_term* second_operand = second_head->quantifier.operand;
		if (found_outer_scope) {
			if (second_operand->type == hol_term_type::AND) {
				second_head = second_operand->array.operands[second_operand->array.length - 1];
				if (!second_head_inverter.outer.add(second_head))
					return false;
			} else if (second_operand->type == hol_term_type::ANY_ARRAY && second_operand->any_array.oper == hol_term_type::AND && second_operand->any_array.right.length != 0) {
				second_head = second_operand->any_array.right.operands[second_operand->any_array.right.length - 1];
				if (!second_head_inverter.outer.add(second_head))
					return false;
			}
			if (second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT) {
				second_head = second_head->any.included;
				if (!second_head_inverter.outer.add(second_head))
					return false;
			}
		}

#if !defined(NDEBUG)
		if (second_head->type != hol_term_type::EXISTS)
			fprintf(stderr, "invert_select_singleton_arg_in_set_without_head_predicative WARNING: Expected an existential quantification.\n");
#endif
		second_operand = second_head->quantifier.operand;

		hol_term* second_left = nullptr;
		if (second_operand->type == hol_term_type::AND && second_operand->array.length == 2) {
			second_left = second_operand->array.operands[0];
		} else {
			fprintf(stderr, "invert_select_singleton_arg_in_set_without_head_predicative ERROR: Expected a binary conjunction.\n");
			return false;
		}

		hol_term* second_lambda = nullptr;
		hol_term* second_set_definition = nullptr;
		unsigned int second_element_variable;
		if (second_left->type == hol_term_type::EQUALS && second_left->binary.right->type == hol_term_type::LAMBDA) {
			second_lambda = second_left->binary.right;
			second_element_variable = second_left->binary.right->quantifier.variable;
			second_set_definition = second_left->binary.right->quantifier.operand;
		} else {
			fprintf(stderr, "invert_select_singleton_arg_in_set_without_head_predicative ERROR: Expected a set definition term with equality and a lambda expression.\n");
			return false;
		}

		hol_term* first_element_var = hol_term::new_variable(first_element_variable);
		if (first_element_var == nullptr)
			return false;

		hol_term* new_second_set_definition;
		if (second_set_definition->type == hol_term_type::AND) {
			new_second_set_definition = hol_term::new_and(make_appended_array_view(make_array_view(second_set_definition->array.operands, second_set_definition->array.length),
						InvertArg
							? hol_term::new_equals(hol_term::new_apply(hol_term::new_constant(ArgConstant), first_element_var), hol_term::new_variable(second_element_variable))
							: hol_term::new_equals(hol_term::new_apply(hol_term::new_constant(ArgConstant), hol_term::new_variable(second_element_variable)), first_element_var)
					));
			if (new_second_set_definition == nullptr) {
				free(*first_element_var); free(first_element_var);
				return false;
			}
			for (unsigned int i = 0; i < second_set_definition->array.length; i++)
				second_set_definition->array.operands[i]->reference_count++;
		} else if (second_set_definition->type == hol_term_type::ANY_ARRAY && second_set_definition->any_array.oper == hol_term_type::AND) {
			new_second_set_definition = hol_term::new_any_array(hol_term_type::AND, second_set_definition->any_array.all,
					make_array_view(second_set_definition->any_array.any.operands, second_set_definition->any_array.any.length),
					make_array_view(second_set_definition->any_array.left.operands, second_set_definition->any_array.left.length),
					make_appended_array_view(make_array_view(second_set_definition->any_array.right.operands, second_set_definition->any_array.right.length),
							InvertArg
								? hol_term::new_equals(hol_term::new_apply(hol_term::new_constant(ArgConstant), first_element_var), hol_term::new_variable(second_element_variable))
								: hol_term::new_equals(hol_term::new_apply(hol_term::new_constant(ArgConstant), hol_term::new_variable(second_element_variable)), first_element_var)
						));
			if (new_second_set_definition == nullptr) {
				free(*first_element_var); free(first_element_var);
				return false;
			}
			second_set_definition->any_array.all->reference_count++;
			for (unsigned int i = 0; i < second_set_definition->any_array.any.length; i++)
				second_set_definition->any_array.any.operands[i]->reference_count++;
			for (unsigned int i = 0; i < second_set_definition->any_array.left.length; i++)
				second_set_definition->any_array.left.operands[i]->reference_count++;
			for (unsigned int i = 0; i < second_set_definition->any_array.right.length; i++)
				second_set_definition->any_array.right.operands[i]->reference_count++;
		} else {
			new_second_set_definition = hol_term::new_and(second_set_definition,
						InvertArg
							? hol_term::new_equals(hol_term::new_apply(hol_term::new_constant(ArgConstant), first_element_var), hol_term::new_variable(second_element_variable))
							: hol_term::new_equals(hol_term::new_apply(hol_term::new_constant(ArgConstant), hol_term::new_variable(second_element_variable)), first_element_var)
					);
			if (new_second_set_definition == nullptr) {
				free(*first_element_var); free(first_element_var);
				return false;
			}
			second_set_definition->reference_count++;
		}

		array<pair<hol_term*, variable_map>> intersection(2);
		intersect<built_in_predicates, true, true>(intersection, innermost_operand, new_second_set_definition);
		free(*new_second_set_definition); if (new_second_set_definition->reference_count == 0) free(new_second_set_definition);
		if (intersection.length == 0) {
			return false;
		} else if (intersection.length != 1) {
			fprintf(stderr, "invert_select_singleton_arg_in_set_without_head_predicative ERROR: Intersection modulo variable relabeling is not unique.\n");
			free_all(intersection); return false;
		}

		/* make sure the variables in `second_head` map to the correct variables in `first_head` */
		const variable_map& var_map = intersection[0].value;
		for (const auto& entry : var_map.scope_map) {
			const variable_set& set = entry.value;
			unsigned int src_variable = entry.key.src->quantifier.variable;
			unsigned int target_var;
			if (!get_target_variable(src_variable, target_var, set, max_variable)
			 || !second_variable_map.ensure_capacity(second_variable_map.size + 1))
			{
				free_all(intersection);
				return false;
			}

			unsigned int index = second_variable_map.index_of(entry.key.src);
			if (index < second_variable_map.size) {
				second_variable_map.values[index] = target_var;
				if (src_variable == target_var)
					second_variable_map.remove_at(index);
			} else if (src_variable != target_var) {
				second_variable_map.keys[second_variable_map.size] = entry.key.src;
				second_variable_map.values[second_variable_map.size] = target_var;
				second_variable_map.size++;
			}
		}

		array_map<unsigned int, variable_set> free_variable_map(8);
		for (const auto& entry : var_map.free_variables) {
			const variable_set& set = entry.value;
			if (set.type == variable_set_type::SINGLETON && first_set_definition->type == hol_term_type::EXISTS && set.variable == first_set_definition->quantifier.variable) {
				/* find the quantifier in `second` that declares the variable `entry.key` */
				unsigned int i;
				for (i = 0; i < second_head_inverter.outer.length; i++)
					if (second_head_inverter.outer[i]->type == hol_term_type::EXISTS && second_head_inverter.outer[i]->quantifier.variable == entry.key) break;
				if (i == second_head_inverter.outer.length) continue;
				if (!second_variable_map.put(second_head_inverter.outer[i], set.variable)) {
					free_all(intersection);
					return false;
				}
				continue;
			} else if (set.type == variable_set_type::SINGLETON && entry.key == second_lambda->quantifier.variable) {
				if (!second_variable_map.put(second_lambda, set.variable)) {
					free_all(intersection);
					return false;
				}
				continue;
			} else if (set.type == variable_set_type::SINGLETON && set.variable == first_element_variable) {
				continue;
			}

			unsigned int src_variable = entry.key;
			if (!free_variable_map.ensure_capacity(free_variable_map.size + 1)) {
				free(*first_set_definition); if (first_set_definition->reference_count == 0) free(first_set_definition);
				free_all(intersection); return false;
			}
			unsigned int index = free_variable_map.index_of(src_variable);
			if (index < free_variable_map.size) {
				variable_set& new_set = *((variable_set*) alloca(sizeof(variable_map)));
				if (!intersect(new_set, set, free_variable_map.values[index])) {
					free(*first_set_definition); if (first_set_definition->reference_count == 0) free(first_set_definition);
					free_all(intersection); return false;
				}
				swap(free_variable_map.values[index], new_set);
				free(new_set);
			} else {
				free_variable_map.keys[free_variable_map.size] = src_variable;
				if (!init(free_variable_map.values[free_variable_map.size], set)) {
					free(*first_set_definition); if (first_set_definition->reference_count == 0) free(first_set_definition);
					free_all(intersection); return false;
				}
				free_variable_map.size++;
			}
		}
		free_all(intersection);

		if (OuterScope && found_outer_scope && first_set_definition->type == hol_term_type::EXISTS) {
			hol_term* new_outer_left;
			hol_term* old_second_operand = old_second_head->quantifier.operand;
			if (old_second_operand->type == hol_term_type::AND) {
				if (old_second_operand->array.length == 2) {
					new_outer_left = old_second_operand->array.operands[0];
					new_outer_left->reference_count++;
				} else {
					new_outer_left = hol_term::new_and(make_array_view(old_second_operand->array.operands, old_second_operand->array.length - 1));
					if (new_outer_left == nullptr) {
						for (auto entry : second_variable_map) free(entry.value);
						return false;
					}
					for (unsigned int i = 0; i < new_outer_left->array.length; i++)
						new_outer_left->array.operands[i]->reference_count++;
				}
			} else if (old_second_operand->type == hol_term_type::ANY_ARRAY && old_second_operand->any_array.oper == hol_term_type::AND && old_second_operand->any_array.right.length != 0) {
				new_outer_left = hol_term::new_any_array(hol_term_type::AND, old_second_operand->any_array.all,
						make_array_view(old_second_operand->any_array.any.operands, old_second_operand->any_array.any.length),
						make_array_view(old_second_operand->any_array.left.operands, old_second_operand->any_array.left.length),
						make_array_view(old_second_operand->any_array.right.operands, old_second_operand->any_array.right.length - 1));
				if (new_outer_left == nullptr) {
					for (auto entry : second_variable_map) free(entry.value);
					return false;
				}
				new_outer_left->any_array.all->reference_count++;
				for (unsigned int i = 0; i < new_outer_left->any_array.left.length; i++)
					new_outer_left->any_array.left.operands[i]->reference_count++;
				for (unsigned int i = 0; i < new_outer_left->any_array.right.length; i++)
					new_outer_left->any_array.right.operands[i]->reference_count++;
				for (unsigned int i = 0; i < new_outer_left->any_array.any.length; i++)
					new_outer_left->any_array.any.operands[i]->reference_count++;
			} else {
				new_outer_left = nullptr;
			}

			if (new_outer_left != nullptr) {
				hol_term* new_set_definition_operand;
				hol_term* first_set_definition_operand = first_set_definition->quantifier.operand;
				if (first_set_definition_operand->type == hol_term_type::AND) {
					if (first_set_definition_operand->array.length == 2) {
						new_set_definition_operand = first_set_definition_operand->array.operands[0];
						new_set_definition_operand->reference_count++;
					} else {
						new_set_definition_operand = hol_term::new_and(make_array_view(first_set_definition_operand->array.operands, first_set_definition_operand->array.length - 1));
						if (new_set_definition_operand == nullptr) {
							for (auto entry : second_variable_map) free(entry.value);
							free(*new_outer_left); if (new_outer_left->reference_count == 0) free(new_outer_left);
							return false;
						}
						for (unsigned int i = 0; i < new_set_definition_operand->array.length; i++)
							new_set_definition_operand->array.operands[i]->reference_count++;
					}
				} else if (first_set_definition_operand->type == hol_term_type::ANY_ARRAY && first_set_definition_operand->any_array.oper == hol_term_type::AND && first_set_definition_operand->any_array.right.length != 0) {
					new_set_definition_operand = hol_term::new_any_array(hol_term_type::AND, first_set_definition_operand->any_array.all,
							make_array_view(first_set_definition_operand->any_array.any.operands, first_set_definition_operand->any_array.any.length),
							make_array_view(first_set_definition_operand->any_array.left.operands, first_set_definition_operand->any_array.left.length),
							make_array_view(first_set_definition_operand->any_array.right.operands, first_set_definition_operand->any_array.right.length - 1));
					if (new_set_definition_operand == nullptr) {
						for (auto entry : second_variable_map) free(entry.value);
						free(*new_outer_left); if (new_outer_left->reference_count == 0) free(new_outer_left);
						return false;
					}
					new_set_definition_operand->any_array.all->reference_count++;
					for (unsigned int i = 0; i < new_set_definition_operand->any_array.left.length; i++)
						new_set_definition_operand->any_array.left.operands[i]->reference_count++;
					for (unsigned int i = 0; i < new_set_definition_operand->any_array.right.length; i++)
						new_set_definition_operand->any_array.right.operands[i]->reference_count++;
					for (unsigned int i = 0; i < new_set_definition_operand->any_array.any.length; i++)
						new_set_definition_operand->any_array.any.operands[i]->reference_count++;
				} else {
					new_set_definition_operand = nullptr;
				}

				if (new_set_definition_operand != nullptr) {
					intersection.clear();
					intersect<built_in_predicates, true, true>(intersection, new_set_definition_operand, new_outer_left);
					free(*new_set_definition_operand); if (new_set_definition_operand->reference_count == 0) free(new_set_definition_operand);
					free(*new_outer_left); if (new_outer_left->reference_count == 0) free(new_outer_left);
					if (intersection.length > 1) {
						fprintf(stderr, "invert_select_singleton_arg_in_set_without_head_predicative ERROR: Intersection modulo variable relabeling is not unique.\n");
						for (auto entry : second_variable_map) free(entry.value);
						free_all(intersection); return false;
					}

					if (intersection.length != 0) {
						/* make sure the variables in `second_head` map to the correct variables in `first_head` */
						const variable_map& var_map = intersection[0].value;
						for (const auto& entry : var_map.scope_map) {
							const variable_set& set = entry.value;
							unsigned int src_variable = entry.key.src->quantifier.variable;
							unsigned int target_var;
							if (!get_target_variable(src_variable, target_var, set, max_variable)
							 || !second_variable_map.ensure_capacity(second_variable_map.size + 1))
							{
								for (auto entry : second_variable_map) free(entry.value);
								free_all(intersection); return false;
							}

							unsigned int index = second_variable_map.index_of(entry.key.src);
							if (index < second_variable_map.size) {
								second_variable_map.values[index] = target_var;
								if (src_variable == target_var)
									second_variable_map.remove_at(index);
							} else if (src_variable != target_var) {
								second_variable_map.keys[second_variable_map.size] = entry.key.src;
								second_variable_map.values[second_variable_map.size] = target_var;
								second_variable_map.size++;
							}
						}

						for (const auto& entry : var_map.free_variables) {
							const variable_set& set = entry.value;
							if (set.type == variable_set_type::SINGLETON && first_set_definition->type == hol_term_type::EXISTS && set.variable == first_set_definition->quantifier.variable) {
								/* find the quantifier in `second` that declares the variable `entry.key` */
								unsigned int i;
								for (i = 0; i < second_head_inverter.outer.length; i++)
									if (second_head_inverter.outer[i]->type == hol_term_type::EXISTS && second_head_inverter.outer[i]->quantifier.variable == entry.key) break;
								if (!second_variable_map.put(second_head_inverter.outer[i], set.variable)) {
									free_all(intersection);
									return false;
								}
								continue;
							} else if (set.type == variable_set_type::SINGLETON && entry.key == second_lambda->quantifier.variable) {
								if (!second_variable_map.put(second_lambda, set.variable)) {
									free_all(intersection);
									return false;
								}
								continue;
							}

							unsigned int src_variable = entry.key;
							if (src_variable == second_element_variable)
								continue;
							if (!free_variable_map.ensure_capacity(free_variable_map.size + 1)) {
								for (auto entry : second_variable_map) free(entry.value);
								free_all(intersection); return false;
							}
							unsigned int index = free_variable_map.index_of(src_variable);
							if (index < free_variable_map.size) {
								variable_set& new_set = *((variable_set*) alloca(sizeof(variable_map)));
								if (!intersect(new_set, set, free_variable_map.values[index])) {
									for (auto entry : second_variable_map) free(entry.value);
									free_all(intersection); return false;
								}
								swap(free_variable_map.values[index], new_set);
								free(new_set);
							} else {
								free_variable_map.keys[free_variable_map.size] = src_variable;
								if (!init(free_variable_map.values[free_variable_map.size], set)) {
									for (auto entry : second_variable_map) free(entry.value);
									free_all(intersection); return false;
								}
								free_variable_map.size++;
							}
						}
						free_all(intersection);
						can_invert_outer_scope = true;
					}
				} else {
					free(*new_outer_left); if (new_outer_left->reference_count == 0) free(new_outer_left);
				}
			}
		}

		if (!remap_scopes(free_variable_map, first_head_inverter, second_head_inverter, second_variable_map, max_variable, first_head_is_array, second_head_is_array)) {
			for (auto entry : second_variable_map) free(entry.value);
			return false;
		}
		return true;
	};

	return invert_apply_head(inverse, inverse_count, flags, first, second,
		predicative_head_finder<built_in_predicates>(lambda_variable), find_head, on_remap_variables,
		[lambda_variable,&found_outer_scope,&can_invert_outer_scope](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, const apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array)
		{
			hol_term* old_first_head = first_head;
			if ((first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) && first_head->any.included != nullptr
			 && (first_head->any.included->type == hol_term_type::EXISTS || first_head->any.included->type == hol_term_type::NOT))
				first_head = first_head->any.included;
			hol_term* old_second_head = second_head;
			if ((second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT) && second_head->any.included != nullptr)
				second_head = second_head->any.included;

			if (first_head->type == hol_term_type::NOT)
				first_head = first_head->unary.operand;

			unsigned int first_set_variable, first_element_variable;
			hol_term* first_left = nullptr;
			hol_term* first_set_operand = nullptr;
			if (first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) {
				if (first_head->any.included != nullptr && first_head->any.included->type == hol_term_type::UNARY_APPLICATION
				 && first_head->any.included->binary.left->type == hol_term_type::VARIABLE
				 && first_head->any.included->binary.left->variable == lambda_variable
				 && first_head->any.included->binary.right->type == hol_term_type::VARIABLE)
				{
					first_element_variable = first_head->any.included->binary.right->variable;
				} else {
					first_element_variable = 0;
				}
				first_set_variable = 0;
			} else {
#if !defined(NDEBUG)
				if (first_head->type != hol_term_type::EXISTS)
					fprintf(stderr, "invert_select_singleton_arg_in_set_without_head_predicative WARNING: Expected an existential quantification.\n");
#endif
				first_set_variable = first_head->quantifier.variable;
				hol_term* operand = first_head->quantifier.operand;

				hol_term* right = nullptr;
				if (operand->type == hol_term_type::ANY || operand->type == hol_term_type::ANY_RIGHT) {
					first_element_variable = 0;
				} else if (operand->type == hol_term_type::AND && operand->array.length != 0) {
					first_left = operand->array.operands[0];
					right = operand->array.operands[operand->array.length - 1];
				} else if (operand->type == hol_term_type::ANY_ARRAY) {
					if (operand->any_array.left.length != 0)
						first_left = operand->any_array.left.operands[0];
					else first_left = operand->any_array.all;
					if (operand->any_array.right.length != 0)
						right = operand->any_array.right.operands[operand->any_array.right.length - 1];
					else right = operand->any_array.all;
				} else {
					return false;
				}

				hol_term* set_definition = nullptr;
				if (first_left != nullptr) {
					if (first_left->type == hol_term_type::ANY || first_left->type == hol_term_type::ANY_RIGHT) {
						if (first_left->any.included != nullptr)
							set_definition = first_left->any.included;
					} else if (first_left->type == hol_term_type::EQUALS) {
						set_definition = first_left->binary.right;
					} else {
						return false;
					}
				}

				if (set_definition != nullptr) {
					if (set_definition->type == hol_term_type::ANY || set_definition->type == hol_term_type::ANY_RIGHT) {
						first_element_variable = 0;
					} else if (set_definition->type == hol_term_type::LAMBDA) {
						first_element_variable = set_definition->quantifier.variable;
						first_set_operand = set_definition->quantifier.operand;
					} else {
						return false;
					}
				} else {
					first_element_variable = 0;
				}

				if (first_element_variable == 0 && right != nullptr) {
					/* try to get the element variable from the right conjunct, since we couldn't get it from the left conjunct */
					if ((right->type == hol_term_type::ANY || right->type == hol_term_type::ANY_RIGHT) && right->any.included != nullptr)
						right = right->any.included;
					if (right->type == hol_term_type::UNARY_APPLICATION && right->binary.left->type == hol_term_type::CONSTANT && right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE)
						right = right->binary.right;
					if (right->type == hol_term_type::ANY || right->type == hol_term_type::ANY_RIGHT) {
						first_element_variable = ++max_variable;
					} else if (right->type == hol_term_type::EXISTS) {
						first_element_variable = right->quantifier.variable;
					} else {
						return false;
					}
				}
			}

			hol_term* outer_scope = second_head;
			hol_term* old_inner_second_head = old_second_head;
			if (found_outer_scope) {
				hol_term* second_operand = second_head->quantifier.operand;
				if (second_operand->type == hol_term_type::AND) {
					second_head = second_operand->array.operands[second_operand->array.length - 1];
				} else if (second_operand->type == hol_term_type::ANY_ARRAY && second_operand->any_array.oper == hol_term_type::AND && second_operand->any_array.right.length != 0) {
					second_head = second_operand->any_array.right.operands[second_operand->any_array.right.length - 1];
				}
				old_inner_second_head = second_head;
				if (second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT)
					second_head = second_head->any.included;
			}

#if !defined(NDEBUG)
			if (second_head->type != hol_term_type::EXISTS)
				fprintf(stderr, "invert_select_singleton_arg_in_set_without_head_predicative WARNING: Expected an existential quantification.\n");
#endif
			unsigned int second_set_variable = second_head->quantifier.variable;
			hol_term* operand = second_head->quantifier.operand;

			hol_term* second_left = nullptr;
			if (operand->type == hol_term_type::AND && operand->array.length == 2) {
				second_left = operand->array.operands[0];
			} else {
				fprintf(stderr, "invert_select_singleton_arg_in_set_without_head_predicative ERROR: Expected a binary conjunction.\n");
				return false;
			}

			hol_term* set_definition = nullptr;
			unsigned int second_element_variable;
			if (second_left->type == hol_term_type::EQUALS && second_left->binary.right->type == hol_term_type::LAMBDA) {
				second_element_variable = second_left->binary.right->quantifier.variable;
				set_definition = second_left->binary.right->quantifier.operand;
			} else {
				fprintf(stderr, "invert_select_singleton_arg_in_set_without_head_predicative ERROR: Expected a set definition term with equality and a lambda expression.\n");
				return false;
			}

			if (first_set_variable == 0)
				first_set_variable = second_set_variable;
			if (first_element_variable == 0)
				first_element_variable = ++max_variable;

			hol_term* first_element_var = hol_term::new_variable(first_element_variable);
			if (first_element_var == nullptr)
				return false;

			hol_term* new_operand;
			if (set_definition->type == hol_term_type::AND) {
				new_operand = hol_term::new_and(make_appended_array_view(make_array_view(set_definition->array.operands, set_definition->array.length),
							InvertArg
								? hol_term::new_equals(hol_term::new_apply(hol_term::new_constant(ArgConstant), first_element_var), hol_term::new_variable(second_element_variable))
								: hol_term::new_equals(hol_term::new_apply(hol_term::new_constant(ArgConstant), hol_term::new_variable(second_element_variable)), first_element_var)
						));
				if (new_operand == nullptr) {
					free(*first_element_var); free(first_element_var);
					return false;
				}
				first_element_var->reference_count++;
				for (unsigned int i = 0; i < set_definition->array.length; i++)
					set_definition->array.operands[i]->reference_count++;
			} else if (set_definition->type == hol_term_type::ANY_ARRAY && set_definition->any_array.oper == hol_term_type::AND) {
				new_operand = hol_term::new_any_array(hol_term_type::AND, &HOL_ANY /* this scope is no longer a "root scope" after adding the right conjunct */,
						make_array_view(set_definition->any_array.any.operands, set_definition->any_array.any.length),
						make_array_view(set_definition->any_array.left.operands, set_definition->any_array.left.length),
						make_appended_array_view(make_array_view(set_definition->any_array.right.operands, set_definition->any_array.right.length),
								InvertArg
									? hol_term::new_equals(hol_term::new_apply(hol_term::new_constant(ArgConstant), first_element_var), hol_term::new_variable(second_element_variable))
									: hol_term::new_equals(hol_term::new_apply(hol_term::new_constant(ArgConstant), hol_term::new_variable(second_element_variable)), first_element_var)
							));
				if (new_operand == nullptr) {
					free(*first_element_var); free(first_element_var);
					return false;
				}
				HOL_ANY.reference_count++;
				first_element_var->reference_count++;
				for (unsigned int i = 0; i < set_definition->any_array.any.length; i++)
					set_definition->any_array.any.operands[i]->reference_count++;
				for (unsigned int i = 0; i < set_definition->any_array.left.length; i++)
					set_definition->any_array.left.operands[i]->reference_count++;
				for (unsigned int i = 0; i < set_definition->any_array.right.length; i++)
					set_definition->any_array.right.operands[i]->reference_count++;
			} else {
				new_operand = hol_term::new_and(set_definition,
							InvertArg
								? hol_term::new_equals(hol_term::new_apply(hol_term::new_constant(ArgConstant), first_element_var), hol_term::new_variable(second_element_variable))
								: hol_term::new_equals(hol_term::new_apply(hol_term::new_constant(ArgConstant), hol_term::new_variable(second_element_variable)), first_element_var)
						);
				if (new_operand == nullptr) {
					free(*first_element_var); free(first_element_var);
					return false;
				}
				first_element_var->reference_count++;
				set_definition->reference_count++;
			}

			hol_term* first_set_var = hol_term::new_variable(first_set_variable);
			if (first_set_var == nullptr) {
				free(*new_operand); free(new_operand);
				free(*first_element_var); free(first_element_var);
				return false;
			}

			hol_term* new_set_operand;
			bool new_operand_has_free_variables = true;
			if (!can_invert_outer_scope) {
				if (first_set_operand != nullptr && first_set_operand->type == hol_term_type::ANY_RIGHT)
					first_set_operand = first_set_operand->any.included;
				if (first_set_operand != nullptr && first_set_operand->type == hol_term_type::EXISTS) {
					hol_term* first_inner_operand = first_set_operand->quantifier.operand;
					array<hol_term*> new_inner_operands(2);
					intersect<built_in_predicates>(new_inner_operands, first_inner_operand, new_operand);
					free(*new_operand); if (new_operand->reference_count == 0) free(new_operand);
					if (new_inner_operands.length == 0) {
						free(*first_set_var); free(first_set_var);
						free(*first_element_var); free(first_element_var);
						return false;
					} else if (new_inner_operands.length != 1) {
						fprintf(stderr, "select_singleton_arg_in_set_without_head_predicative ERROR: Intersection is not unique.\n");
						free_all(new_inner_operands);
						free(*first_set_var); free(first_set_var);
						free(*first_element_var); free(first_element_var);
						return false;
					}
					new_operand = new_inner_operands[0];
					new_operand_has_free_variables = can_have_free_variables(*new_operand);
				}

				if (new_operand_has_free_variables && (old_second_head->type == hol_term_type::ANY || old_second_head->type == hol_term_type::ANY_RIGHT)) {
					hol_term* excluded_quantifiers[3];
					excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(first_element_variable, &HOL_ANY));
					excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(first_element_variable, &HOL_ANY));
					excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(first_element_variable, &HOL_ANY));
					if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
					if (excluded_quantifiers[1] != nullptr) HOL_ANY.reference_count++;
					if (excluded_quantifiers[2] != nullptr) HOL_ANY.reference_count++;
					if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr) {
						if (excluded_quantifiers[0] != nullptr) { free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]); }
						if (excluded_quantifiers[1] != nullptr) { free(*excluded_quantifiers[1]); free(excluded_quantifiers[1]); }
						free(*new_operand); free(new_operand);
						free(*first_set_var); free(first_set_var);
						free(*first_element_var); free(first_element_var);
						return false;
					}

					new_set_operand = hol_term::new_any_right(hol_term::new_exists(second_element_variable, new_operand), excluded_quantifiers, array_length(excluded_quantifiers));
					if (new_set_operand == nullptr) {
						for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
						free(*new_operand); free(new_operand);
						free(*first_set_var); free(first_set_var);
						free(*first_element_var); free(first_element_var);
						return false;
					}
				} else {
					new_set_operand = hol_term::new_exists(second_element_variable, new_operand);
					if (new_set_operand == nullptr) {
						free(*new_operand); free(new_operand);
						free(*first_set_var); free(first_set_var);
						free(*first_element_var); free(first_element_var);
						return false;
					}
				}
			} else {
				hol_term* outer_scope_operand = outer_scope->quantifier.operand;
				if (outer_scope_operand->type == hol_term_type::AND) {
					new_set_operand = hol_term::new_and(make_appended_array_view(make_array_view(outer_scope_operand->array.operands, outer_scope_operand->array.length - 1),
							hol_term::new_exists(second_element_variable, new_operand)));
					if (new_set_operand == nullptr) {
						free(*new_operand); free(new_operand);
						free(*first_set_var); free(first_set_var);
						free(*first_element_var); free(first_element_var);
						return false;
					}
					for (unsigned int i = 0; i + 1 < new_set_operand->array.length; i++)
						new_set_operand->array.operands[i]->reference_count++;
				} else if (outer_scope_operand->type == hol_term_type::ANY_ARRAY && outer_scope_operand->any_array.oper == hol_term_type::AND) {
					new_set_operand = hol_term::new_any_array(hol_term_type::AND, outer_scope_operand->any_array.all,
							make_array_view(outer_scope_operand->any_array.any.operands, outer_scope_operand->any_array.any.length),
							make_array_view(outer_scope_operand->any_array.left.operands, outer_scope_operand->any_array.left.length),
							make_appended_array_view(make_array_view(outer_scope_operand->any_array.right.operands, max(1u, outer_scope_operand->any_array.right.length) - 1),
								hol_term::new_exists(second_element_variable, new_operand)));
					if (new_set_operand == nullptr) {
						free(*new_operand); free(new_operand);
						free(*first_set_var); free(first_set_var);
						free(*first_element_var); free(first_element_var);
						return false;
					}
					new_set_operand->any_array.all->reference_count++;
					for (unsigned int i = 0; i < new_set_operand->any_array.any.length; i++)
						new_set_operand->any_array.any.operands[i]->reference_count++;
					for (unsigned int i = 0; i < new_set_operand->any_array.left.length; i++)
						new_set_operand->any_array.left.operands[i]->reference_count++;
					for (unsigned int i = 0; i + 1 < new_set_operand->any_array.right.length; i++)
						new_set_operand->any_array.right.operands[i]->reference_count++;
				} else {
					free(*new_operand); free(new_operand);
					free(*first_set_var); free(first_set_var);
					free(*first_element_var); free(first_element_var);
					return false;
				}
			}

			hol_term* new_set_definition;
			if (can_invert_outer_scope)
				new_set_definition = hol_term::new_equals(first_set_var, hol_term::new_lambda(first_element_variable, hol_term::new_exists(outer_scope->quantifier.variable, new_set_operand)));
			else new_set_definition = hol_term::new_equals(first_set_var, hol_term::new_lambda(first_element_variable, new_set_operand));
			if (new_set_definition == nullptr) {
				free(*new_set_operand); free(new_set_operand);
				free(*first_element_var); free(first_element_var);
				free(*first_set_var); free(first_set_var);
				return false;
			}
			first_set_var->reference_count++;

			dst[dst.length] = hol_term::new_exists(first_set_variable, hol_term::new_and(new_set_definition,
					hol_term::new_exists(first_element_variable, hol_term::new_and(
						hol_term::new_apply(first_set_var, first_element_var), hol_term::new_apply(hol_term::new_variable(lambda_variable), first_element_var)))));
			if (dst[dst.length] == nullptr) {
				free(*new_set_definition); free(new_set_definition);
				free(*first_set_var); free(first_set_var);
				free(*first_element_var); free(first_element_var);
				return false;
			}
			first_element_var->reference_count += 2 - 1;
			dst.length++;

			hol_term* new_outer = &HOL_ZERO;
			HOL_ZERO.reference_count++;

			if (found_outer_scope && !can_invert_outer_scope) {
				if (new_operand_has_free_variables && (old_inner_second_head->type == hol_term_type::ANY || old_inner_second_head->type == hol_term_type::ANY_RIGHT)) {
					hol_term* excluded_quantifiers[3];
					excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(outer_scope->quantifier.variable, &HOL_ANY));
					excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(outer_scope->quantifier.variable, &HOL_ANY));
					excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(outer_scope->quantifier.variable, &HOL_ANY));
					if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
					if (excluded_quantifiers[1] != nullptr) HOL_ANY.reference_count++;
					if (excluded_quantifiers[2] != nullptr) HOL_ANY.reference_count++;
					if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr) {
						if (excluded_quantifiers[0] != nullptr) { free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]); }
						if (excluded_quantifiers[1] != nullptr) { free(*excluded_quantifiers[1]); free(excluded_quantifiers[1]); }
						HOL_ZERO.reference_count--;
						return false;
					}

					hol_term* temp = hol_term::new_any_right(new_outer, excluded_quantifiers, array_length(excluded_quantifiers));
					if (temp == nullptr) {
						for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
						HOL_ZERO.reference_count--;
						return false;
					}
					new_outer = temp;
				}

				hol_term* temp;
				hol_term* outer_scope_operand = outer_scope->quantifier.operand;
				if (outer_scope_operand->type == hol_term_type::AND) {
					temp = hol_term::new_exists(outer_scope->quantifier.variable,
						hol_term::new_and(make_appended_array_view(make_array_view(outer_scope_operand->array.operands, outer_scope_operand->array.length - 1), new_outer)));
					if (temp == nullptr) {
						HOL_ZERO.reference_count--;
						return false;
					}
					hol_term* new_operand = temp->quantifier.operand;
					for (unsigned int i = 0; i + 1 < new_operand->array.length; i++)
						new_operand->array.operands[i]->reference_count++;
				} else if (outer_scope_operand->type == hol_term_type::ANY_ARRAY && outer_scope_operand->any_array.oper == hol_term_type::AND) {
					temp = hol_term::new_exists(outer_scope->quantifier.variable, hol_term::new_any_array(hol_term_type::AND, outer_scope_operand->any_array.all,
							make_array_view(outer_scope_operand->any_array.any.operands, outer_scope_operand->any_array.any.length),
							make_array_view(outer_scope_operand->any_array.left.operands, outer_scope_operand->any_array.left.length),
							make_appended_array_view(make_array_view(outer_scope_operand->any_array.right.operands, max(1u, outer_scope_operand->any_array.right.length) - 1), new_outer)));
					if (temp == nullptr) {
						HOL_ZERO.reference_count--;
						return false;
					}
					hol_term* new_operand = temp->quantifier.operand;
					new_operand->any_array.all->reference_count++;
					for (unsigned int i = 0; i < new_operand->any_array.any.length; i++)
						new_operand->any_array.any.operands[i]->reference_count++;
					for (unsigned int i = 0; i < new_operand->any_array.left.length; i++)
						new_operand->any_array.left.operands[i]->reference_count++;
					for (unsigned int i = 0; i + 1 < new_operand->any_array.right.length; i++)
						new_operand->any_array.right.operands[i]->reference_count++;
				} else {
					HOL_ZERO.reference_count--;
					return false;
				}
				new_outer = temp;
			}

			if ((old_first_head->type == hol_term_type::ANY || old_first_head->type == hol_term_type::ANY_RIGHT)
			 && (old_second_head->type == hol_term_type::ANY || old_second_head->type == hol_term_type::ANY_RIGHT))
			{
				dst_outer[dst_outer.length] = hol_term::new_any_right(new_outer, old_second_head->any.excluded_trees, old_second_head->any.excluded_tree_count);
				if (dst_outer[dst_outer.length] == nullptr) {
					free(*new_outer); if (new_outer->reference_count == 0) free(new_outer);
					return false;
				}
				for (unsigned int i = 0; i < old_second_head->any.excluded_tree_count; i++)
					old_second_head->any.excluded_trees[i]->reference_count++;
				dst_outer.length++;
			} else {
				dst_outer[dst_outer.length++] = new_outer;
			}
			return true;
		});
}

template<unsigned int ArgConstant, bool InvertArg>
hol_term* invert_select_arg_without_head_process_operand(hol_term* operand, unsigned int new_head_variable, unsigned int& operand_variable)
{
	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	hol_term* dst;
	bool result = apply_head<true>(operand, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker, find_head<built_in_predicates>,
			[new_head_variable,&operand_variable](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
					head = head->any.included;
				unsigned int negation_count = 0;
				while (head->type == hol_term_type::NOT) {
					head = head->unary.operand;
					negation_count++;
				}
				if (head->type != hol_term_type::EXISTS) {
					fprintf(stderr, "invert_select_arg_without_head_process_operand ERROR: Expected head of `operand` to be an existentially-quantified expression.\n");
					return (hol_term*) nullptr;
				}

				operand_variable = head->quantifier.variable;
				hol_term* operand_var = hol_term::new_variable(operand_variable);
				if (operand_var == nullptr)
					return (hol_term*) nullptr;

				hol_term* new_inner_right;
				if (InvertArg) {
					new_inner_right = hol_term::new_equals(
							hol_term::new_apply(hol_term::new_constant(ArgConstant), hol_term::new_variable(new_head_variable)),
							operand_var);
				} else {
					new_inner_right = hol_term::new_equals(
							hol_term::new_apply(hol_term::new_constant(ArgConstant), operand_var),
							hol_term::new_variable(new_head_variable));
				}
				if (new_inner_right == nullptr) {
					free(*operand_var); free(operand_var);
					return (hol_term*) nullptr;
				}

				hol_term* excluded_conjuncts[2];
				excluded_conjuncts[0] = hol_term::new_any(hol_term::new_equals(
							hol_term::new_apply(hol_term::new_constant(InvertArg ? ArgConstant : (unsigned int) invert_arg<(built_in_predicates) ArgConstant>::value), &HOL_ANY), operand_var));
				excluded_conjuncts[1] = hol_term::new_any(hol_term::new_equals(
							hol_term::new_apply(hol_term::new_constant(InvertArg ? (unsigned int) invert_arg<(built_in_predicates) ArgConstant>::value : ArgConstant), operand_var), &HOL_ANY));
				if (excluded_conjuncts[0] != nullptr) { operand_var->reference_count++; HOL_ANY.reference_count++; }
				if (excluded_conjuncts[1] != nullptr) { operand_var->reference_count++; HOL_ANY.reference_count++; }
				if (excluded_conjuncts[0] == nullptr || excluded_conjuncts[1] == nullptr) {
					if (excluded_conjuncts[0] != nullptr) { free(*excluded_conjuncts[0]); free(excluded_conjuncts[0]); }
					free(*new_inner_right); free(new_inner_right); return (hol_term*) nullptr;
				}

				hol_term* excluded = hol_term::new_any(nullptr, excluded_conjuncts, array_length(excluded_conjuncts));
				if (excluded == nullptr) {
					for (unsigned int i = 0; i < array_length(excluded_conjuncts); i++) { free(*excluded_conjuncts[i]); free(excluded_conjuncts[i]); }
					free(*new_inner_right); free(new_inner_right); return (hol_term*) nullptr;
				}

				array<hol_term*> inner_operands(2);
				intersect<built_in_predicates>(inner_operands, head->quantifier.operand, excluded);
				free(*excluded); if (excluded->reference_count == 0) free(excluded);
				if (inner_operands.length == 0) {
					free(*new_inner_right); free(new_inner_right);
					return (hol_term*) nullptr;
				} else if (inner_operands.length != 1) {
					fprintf(stderr, "invert_select_arg_without_head_process_operand ERROR: Intersection is not unique.\n");
					free(*new_inner_right); free(new_inner_right);
					free_all(inner_operands); return (hol_term*) nullptr;
				}
				hol_term* inner_operand = inner_operands[0];

				hol_term* new_conjunct;
				if (inner_operand->type == hol_term_type::ANY_ARRAY && inner_operand->any_array.oper == hol_term_type::AND) {
					new_conjunct = hol_term::new_exists(operand_variable, hol_term::new_any_array(hol_term_type::AND, inner_operand->any_array.all,
							make_array_view(inner_operand->any_array.any.operands, inner_operand->any_array.any.length),
							make_array_view(inner_operand->any_array.left.operands, inner_operand->any_array.left.length),
							make_appended_array_view(make_array_view(inner_operand->any_array.right.operands, inner_operand->any_array.right.length), new_inner_right)));
					if (new_conjunct == nullptr) {
						free(*new_inner_right); free(new_inner_right);
						free_all(inner_operands); return (hol_term*) nullptr;
					}
					inner_operand->any_array.all->reference_count++;
					for (unsigned int i = 0; i < inner_operand->any_array.any.length; i++)
						inner_operand->any_array.any.operands[i]->reference_count++;
					for (unsigned int i = 0; i < inner_operand->any_array.left.length; i++)
						inner_operand->any_array.left.operands[i]->reference_count++;
					for (unsigned int i = 0; i < inner_operand->any_array.right.length; i++)
						inner_operand->any_array.right.operands[i]->reference_count++;
				} else if (inner_operand->type == hol_term_type::AND) {
					new_conjunct = hol_term::new_exists(operand_variable, hol_term::new_and(
							make_appended_array_view(make_array_view(inner_operand->array.operands, inner_operand->array.length), new_inner_right)));
					if (new_conjunct == nullptr) {
						free(*new_inner_right); free(new_inner_right);
						free_all(inner_operands); return (hol_term*) nullptr;
					}
					for (unsigned int i = 0; i < inner_operand->array.length; i++)
						inner_operand->array.operands[i]->reference_count++;
				} else {
					new_conjunct = hol_term::new_exists(operand_variable, hol_term::new_and(inner_operand, new_inner_right));
					if (new_conjunct == nullptr) {
						free(*new_inner_right); free(new_inner_right);
						free_all(inner_operands); return (hol_term*) nullptr;
					}
					inner_operand->reference_count++;
				}
				free_all(inner_operands);

				for (unsigned int i = 0; i < negation_count; i++) {
					hol_term* temp = hol_term::new_not(new_conjunct);
					if (temp == nullptr) {
						free(*new_conjunct); free(new_conjunct);
						return (hol_term*) nullptr;
					}
					new_conjunct = temp;
				}
				return new_conjunct;
			}, no_op());

	if (!result)
		return nullptr;
	return dst;
}

template<int_fast8_t ConjunctIndex, unsigned int ArgConstant, bool InvertArg>
inline bool invert_select_arg_without_head(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	auto on_remap_variables = [](hol_term* first_head, hol_term* second_head,
			apply_head_inverter& first_head_inverter, apply_head_inverter& second_head_inverter,
			array_map<const hol_term*, unsigned int>& second_variable_map, unsigned int max_variable,
			bool first_head_is_array, bool second_head_is_array)
	{
		if ((first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) && first_head->any.included != nullptr)
			first_head = first_head->any.included;
		if ((second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT) && second_head->any.included != nullptr)
			second_head = second_head->any.included;

		hol_term* first_operand;
		unsigned int head_variable;
		if (first_head->type == hol_term_type::EXISTS) {
			first_operand = first_head->quantifier.operand;
			head_variable = first_head->quantifier.variable;
		} else {
			return true;
		}

		/* make sure that `head_variable` is remapped in second */
		if (first_head->type == hol_term_type::EXISTS) {
			/* TODO: we don't have to recompute `second_scopes` since the caller computes it */
			array<hol_term*> second_scopes(8);
			if (!get_scopes(*second_head, second_scopes))
				return false;
			bool has_variable = false;
			for (const hol_term* scope : second_scopes) {
				if (scope->type != hol_term_type::FOR_ALL && scope->type != hol_term_type::EXISTS && scope->type != hol_term_type::LAMBDA)
					continue;
				if (scope->quantifier.variable != first_head->quantifier.variable)
					continue;

				if (!has_variable) {
					++max_variable;
					has_variable = true;
				}
				if (!second_variable_map.put(scope, max_variable))
					return false;
			}
		}

		hol_term* first_conjunct;
		if (first_operand->type == hol_term_type::AND) {
			unsigned int index = (ConjunctIndex < 0) ? (first_operand->array.length + ConjunctIndex) : ConjunctIndex;
			first_conjunct = first_operand->array.operands[index];
		} else if (first_operand->type == hol_term_type::ANY_ARRAY && first_operand->any_array.oper == hol_term_type::AND) {
			if (ConjunctIndex < 0) {
				if (first_operand->any_array.right.length < -ConjunctIndex)
					first_conjunct = first_operand->any_array.all;
				else first_conjunct = first_operand->any_array.right.operands[first_operand->any_array.right.length + ConjunctIndex];
			} else {
				if (ConjunctIndex < first_operand->any_array.left.length)
					first_conjunct = first_operand->any_array.left.operands[ConjunctIndex];
				else first_conjunct = first_operand->any_array.all;
			}
		} else {
			return true;
		}

		hol_term* new_conjunct;
		unsigned int new_operand_variable = 0;
		if (second_head->type == hol_term_type::ANY_ARRAY) {
			unsigned int operand_variable = 0;
			hol_term* all = invert_select_arg_without_head_process_operand<ArgConstant, InvertArg>(second_head->any_array.all, head_variable, operand_variable);
			if (all == nullptr) return false;
			if (operand_variable == first_head->quantifier.variable) {
				if (new_operand_variable == 0)
					new_operand_variable = ++max_variable;
				second_variable_map.put(second_head->any_array.all, new_operand_variable);
			}

			array<hol_term*> left(second_head->array.length);
			for (unsigned int i = 0; i < second_head->array.length; i++) {
				operand_variable = 0;
				left[i] = invert_select_arg_without_head_process_operand<ArgConstant, InvertArg>(second_head->any_array.left.operands[i], head_variable, operand_variable);
				if (left[i] == nullptr) {
					free(*all); if (all->reference_count == 0) free(all);
					free_all(left); return false;
				}
				left.length++;
				if (operand_variable == first_head->quantifier.variable) {
					if (new_operand_variable == 0)
						new_operand_variable = ++max_variable;
					second_variable_map.put(second_head->any_array.left.operands[i], new_operand_variable);
				}
			}

			array<hol_term*> right(second_head->array.length);
			for (unsigned int i = 0; i < second_head->array.length; i++) {
				operand_variable = 0;
				right[i] = invert_select_arg_without_head_process_operand<ArgConstant, InvertArg>(second_head->any_array.right.operands[i], head_variable, operand_variable);
				if (right[i] == nullptr) {
					free(*all); if (all->reference_count == 0) free(all);
					free_all(left); free_all(right); return false;
				}
				right.length++;
				if (operand_variable == first_head->quantifier.variable) {
					if (new_operand_variable == 0)
						new_operand_variable = ++max_variable;
					second_variable_map.put(second_head->any_array.right.operands[i], new_operand_variable);
				}
			}

			array<hol_term*> any(second_head->array.length);
			for (unsigned int i = 0; i < second_head->array.length; i++) {
				operand_variable = 0;
				any[i] = invert_select_arg_without_head_process_operand<ArgConstant, InvertArg>(second_head->any_array.any.operands[i], head_variable, operand_variable);
				if (any[i] == nullptr) {
					free(*all); if (all->reference_count == 0) free(all);
					free_all(left); free_all(right); free_all(any); return false;
				}
				any.length++;
				if (operand_variable == first_head->quantifier.variable) {
					if (new_operand_variable == 0)
						new_operand_variable = ++max_variable;
					second_variable_map.put(second_head->any_array.any.operands[i], new_operand_variable);
				}
			}

			new_conjunct = hol_term::new_any_array(second_head->any_array.oper, all,
					make_array_view(any.data, any.length), make_array_view(left.data, left.length), make_array_view(right.data, right.length));
			if (new_conjunct == nullptr) {
				free(*all); if (all->reference_count == 0) free(all);
				free_all(left); free_all(right); free_all(any); return false;
			}

		} else if (second_head->type == hol_term_type::AND || second_head->type == hol_term_type::OR) {
			array<hol_term*> new_operands(second_head->array.length);
			for (unsigned int i = 0; i < second_head->array.length; i++) {
				unsigned int operand_variable = 0;
				new_operands[i] = invert_select_arg_without_head_process_operand<ArgConstant, InvertArg>(second_head->array.operands[i], head_variable, operand_variable);
				if (new_operands[i] == nullptr) {
					free_all(new_operands);
					return false;
				}
				new_operands.length++;
				if (operand_variable == first_head->quantifier.variable) {
					if (new_operand_variable == 0)
						new_operand_variable = ++max_variable;
					second_variable_map.put(second_head->array.operands[i], new_operand_variable);
				}
			}

			if (second_head->type == hol_term_type::AND)
				new_conjunct = hol_term::new_and(make_array_view(new_operands.data, new_operands.length));
			else new_conjunct = hol_term::new_or(make_array_view(new_operands.data, new_operands.length));
			if (new_conjunct == nullptr) {
				free_all(new_operands);
				return false;
			}

		} else {
			unsigned int operand_variable = 0;
			new_conjunct = invert_select_arg_without_head_process_operand<ArgConstant, InvertArg>(second_head, head_variable, operand_variable);
			if (new_conjunct == nullptr) return false;
			if (operand_variable == first_head->quantifier.variable) {
				if (new_operand_variable == 0)
					new_operand_variable = ++max_variable;
				second_variable_map.put(second_head, new_operand_variable);
			}
		}

		array<pair<hol_term*, variable_map>> intersection(2);
		intersect<built_in_predicates, true, true>(intersection, first_conjunct, new_conjunct);
		free(*new_conjunct); if (new_conjunct->reference_count == 0) free(new_conjunct);
		if (intersection.length == 0) {
			return false;
		} else if (intersection.length != 1) {
			fprintf(stderr, "invert_select_arg_without_head ERROR: Intersection modulo variable relabeling is not unique.\n");
			free_all(intersection); return false;
		}

		/* make sure the variables in `second_head` map to the correct variables in `first_head` */
		const variable_map& var_map = intersection[0].value;
		for (const auto& entry : var_map.scope_map) {
			if (!second_variable_map.contains(entry.key.src))
				continue;

			unsigned int target_var = 0;
			if (!get_target_variable(entry.key.src->quantifier.variable, target_var, entry.value, max_variable)) {
				free_all(intersection);
				return false;
			}

			if (!second_variable_map.ensure_capacity(second_variable_map.size + 1)) {
				free_all(intersection);
				return false;
			}
			unsigned int index = second_variable_map.index_of(entry.key.src);
			if (target_var == second_variable_map.values[index]) {
				/* `second_variable_map` should map `var` to itself */
				second_variable_map.remove_at(index);
			} else {
				/* `second_variable_map` should map `var` to `target_var` */
				second_variable_map.values[index] = target_var;
				if (index == second_variable_map.size) {
					second_variable_map.keys[index] = entry.key.src;
					second_variable_map.size++;
				}
			}
		}

		array_map<unsigned int, variable_set> free_variable_map(8);
		for (const auto& entry : var_map.free_variables) {
			const variable_set& set = entry.value;
			if (entry.key == head_variable)
				continue;

			unsigned int src_variable = entry.key;
			if (!free_variable_map.ensure_capacity(free_variable_map.size + 1)) {
				free_all(intersection);
				return false;
			}
			unsigned int index = free_variable_map.index_of(src_variable);
			if (index < free_variable_map.size) {
				variable_set& new_set = *((variable_set*) alloca(sizeof(variable_map)));
				if (!intersect(new_set, set, free_variable_map.values[index])) {
					free_all(intersection);
					return false;
				}
				swap(free_variable_map.values[index], new_set);
				free(new_set);
			} else {
				free_variable_map.keys[free_variable_map.size] = src_variable;
				if (!init(free_variable_map.values[free_variable_map.size], set)) {
					free_all(intersection);
					return false;
				}
				free_variable_map.size++;
			}
		}
		free_all(intersection);

		if (!remap_scopes(free_variable_map, first_head_inverter, second_head_inverter, second_variable_map, max_variable, first_head_is_array, second_head_is_array)) {
			for (auto entry : second_variable_map) free(entry.value);
			return false;
		}
		return true;
	};

	return invert_apply_head(inverse, inverse_count, flags, first, second,
		find_head<built_in_predicates>, make_array_finder(find_head_or_universal<built_in_predicates>), on_remap_variables,
		[](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, const apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array) {
			if ((first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) && first_head->any.included != nullptr)
				first_head = first_head->any.included;
			if ((second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT) && second_head->any.included != nullptr)
				second_head = second_head->any.included;

			unsigned int new_head_variable;
			if (first_head->type == hol_term_type::EXISTS) {
				new_head_variable = first_head->quantifier.variable;
			} else {
				new_head_variable = ++max_variable;
			}

			hol_term* new_conjunct;
			unsigned int operand_variable;
			if (second_head->type == hol_term_type::ANY_ARRAY) {
				hol_term* all = invert_select_arg_without_head_process_operand<ArgConstant, InvertArg>(second_head->any_array.all, new_head_variable, operand_variable);
				if (all == nullptr) return false;

				array<hol_term*> left(second_head->array.length);
				for (unsigned int i = 0; i < second_head->array.length; i++) {
					left[i] = invert_select_arg_without_head_process_operand<ArgConstant, InvertArg>(second_head->any_array.left.operands[i], new_head_variable, operand_variable);
					if (left[i] == nullptr) {
						free(*all); if (all->reference_count == 0) free(all);
						free_all(left); return false;
					}
					left.length++;
				}

				array<hol_term*> right(second_head->array.length);
				for (unsigned int i = 0; i < second_head->array.length; i++) {
					right[i] = invert_select_arg_without_head_process_operand<ArgConstant, InvertArg>(second_head->any_array.right.operands[i], new_head_variable, operand_variable);
					if (right[i] == nullptr) {
						free(*all); if (all->reference_count == 0) free(all);
						free_all(left); free_all(right); return false;
					}
					right.length++;
				}

				array<hol_term*> any(second_head->array.length);
				for (unsigned int i = 0; i < second_head->array.length; i++) {
					any[i] = invert_select_arg_without_head_process_operand<ArgConstant, InvertArg>(second_head->any_array.any.operands[i], new_head_variable, operand_variable);
					if (any[i] == nullptr) {
						free(*all); if (all->reference_count == 0) free(all);
						free_all(left); free_all(right); free_all(any); return false;
					}
					any.length++;
				}

				new_conjunct = hol_term::new_any_array(second_head->any_array.oper, all,
						make_array_view(any.data, any.length), make_array_view(left.data, left.length), make_array_view(right.data, right.length));
				if (new_conjunct == nullptr) {
					free(*all); if (all->reference_count == 0) free(all);
					free_all(left); free_all(right); free_all(any); return false;
				}

			} else if (second_head->type == hol_term_type::AND || second_head->type == hol_term_type::OR) {
				array<hol_term*> new_operands(second_head->array.length);
				for (unsigned int i = 0; i < second_head->array.length; i++) {
					new_operands[i] = invert_select_arg_without_head_process_operand<ArgConstant, InvertArg>(second_head->array.operands[i], new_head_variable, operand_variable);
					if (new_operands[i] == nullptr) {
						free_all(new_operands);
						return false;
					}
					new_operands.length++;
				}

				if (second_head->type == hol_term_type::AND)
					new_conjunct = hol_term::new_and(make_array_view(new_operands.data, new_operands.length));
				else new_conjunct = hol_term::new_or(make_array_view(new_operands.data, new_operands.length));
				if (new_conjunct == nullptr) {
					free_all(new_operands);
					return false;
				}

			} else {
				new_conjunct = invert_select_arg_without_head_process_operand<ArgConstant, InvertArg>(second_head, new_head_variable, operand_variable);
				if (new_conjunct == nullptr) return false;
			}

			hol_term* new_head;
			if (ConjunctIndex >= 0) {
				new_head = hol_term::new_exists(new_head_variable, hol_term::new_any_array(hol_term_type::AND, &HOL_ANY,
						make_array_view((hol_term**) nullptr, 0), make_appended_array_view(make_repeated_array_view(&HOL_ANY, (unsigned int) ConjunctIndex), new_conjunct),
						make_array_view((hol_term**) nullptr, 0)));
				if (new_head == nullptr) {
					free(*new_conjunct); free(new_conjunct);
					return false;
				}
				HOL_ANY.reference_count += ConjunctIndex + 1;
			} else {
				unsigned int index = -(ConjunctIndex + 1);
				new_head = hol_term::new_exists(new_head_variable, hol_term::new_any_array(hol_term_type::AND, &HOL_ANY,
						make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0),
						make_prepended_array_view(new_conjunct, make_repeated_array_view(&HOL_ANY, (unsigned int) index))));
				if (new_head == nullptr) {
					free(*new_conjunct); free(new_conjunct);
					return false;
				}
				HOL_ANY.reference_count += index + 1;
			}

			dst[dst.length++] = new_head;
			dst_outer[dst_outer.length++] = &HOL_ZERO;
			HOL_ZERO.reference_count++;
			return true;
		});
}

template<size_t N, typename InputConstantType, typename OutputConstantType>
inline bool invert_apply_tense_predicate(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second,
		const InputConstantType (&input_tense_predicates)[N],
		const OutputConstantType (&output_tense_predicates)[N])
{
	auto on_remap_variables = [](hol_term* first_head, hol_term* second_head,
			apply_head_inverter& first_head_inverter, apply_head_inverter& second_head_inverter,
			array_map<const hol_term*, unsigned int>& second_variable_map, unsigned int max_variable,
			bool first_head_is_array, bool second_head_is_array)
	{
		if ((first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) && first_head->any.included != nullptr)
			first_head = first_head->any.included;
		if ((second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT) && second_head->any.included != nullptr)
			second_head = second_head->any.included;

		while (first_head->type == hol_term_type::NOT)
			first_head = first_head->unary.operand;
		while (second_head->type == hol_term_type::NOT)
			second_head = second_head->unary.operand;

		if (first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT
		 || second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT)
		{
			return true;
		} else {
#if !defined(NDEBUG)
			if (first_head->type != hol_term_type::EXISTS || second_head->type != hol_term_type::EXISTS)
				fprintf(stderr, "invert_apply_tense_predicate WARNING: Expected an existential quantification.\n");
#endif
		}

		array<hol_term*> first_conjuncts(8);
		array<hol_term*> second_conjuncts(8);
		head_index first_predicate_index, second_predicate_index;
		hol_term* first_operand = first_head->quantifier.operand;
		hol_term* second_operand = second_head->quantifier.operand;
		unsigned int second_head_variable = second_head->quantifier.variable;
		find_predicate<built_in_predicates>(first_head->quantifier.variable, first_operand, first_predicate_index);
		find_predicate<built_in_predicates>(second_head_variable, second_operand, second_predicate_index);
		if (first_operand->type == hol_term_type::AND) {
			if (first_operand->array.length < 2 || first_predicate_index.position != head_position::LEFT || first_predicate_index.index == first_operand->array.length - 1)
				return false;
			if (first_operand->array.length == 2)
				return true;
			if (second_operand->type == hol_term_type::AND) {
				if (first_operand->array.length != second_operand->array.length
				 || !first_conjuncts.ensure_capacity(first_operand->array.length - 1)
				 || !second_conjuncts.ensure_capacity(first_operand->array.length - 1))
				{
					return false;
				}
				for (unsigned int i = 0; i < first_operand->array.length; i++) {
					if (i == first_predicate_index.index + 1) continue;
					first_conjuncts[first_conjuncts.length++] = first_operand->array.operands[i];
					second_conjuncts[second_conjuncts.length++] = second_operand->array.operands[i];
				}
			} else {
				return false;
			}
		} else if (first_operand->type == hol_term_type::ANY_ARRAY) {
			if (second_operand->type == hol_term_type::AND) {
				if (second_operand->array.length < 2 || second_predicate_index.position != head_position::LEFT || second_predicate_index.index == second_operand->array.length - 1
				 || !first_conjuncts.ensure_capacity(first_operand->any_array.left.length + first_operand->any_array.right.length + first_operand->any_array.any.length)
				 || !second_conjuncts.ensure_capacity(first_operand->any_array.left.length + first_operand->any_array.right.length + first_operand->any_array.any.length))
				{
					return false;
				}
				for (unsigned int i = 0; i < first_operand->any_array.left.length; i++) {
					if (i == second_predicate_index.index + 1) continue;
					first_conjuncts[first_conjuncts.length++] = first_operand->any_array.left.operands[i];
					second_conjuncts[second_conjuncts.length++] = second_operand->array.operands[i];
				} for (unsigned int i = 0; i < first_operand->any_array.right.length; i++) {
					if (second_operand->array.length - i + 1 == second_predicate_index.index + 1) continue;
					first_conjuncts[first_conjuncts.length++] = first_operand->any_array.right.operands[first_operand->any_array.right.length - i - 1];
					second_conjuncts[second_conjuncts.length++] = second_operand->array.operands[second_operand->array.length - i + 1];
				}
				if (second_predicate_index.position == head_position::ANY) {
					if (second_predicate_index.index < first_predicate_index.index
					 || first_operand->any_array.any.length - 1 - first_predicate_index.index + second_predicate_index.index >= second_operand->array.length)
					{
						return false;
					}
					for (unsigned int i = 0; i < first_operand->any_array.any.length; i++) {
						if (i - first_predicate_index.index + second_predicate_index.index == second_predicate_index.index + 1) continue;
						first_conjuncts[first_conjuncts.length++] = first_operand->any_array.any.operands[i];
						second_conjuncts[second_conjuncts.length++] = second_operand->array.operands[i - first_predicate_index.index + second_predicate_index.index];
					}
				}
			} else if (second_operand->type == hol_term_type::ANY_ARRAY) {
				if (!first_conjuncts.ensure_capacity(first_operand->any_array.left.length + first_operand->any_array.right.length + first_operand->any_array.any.length)
				 || !second_conjuncts.ensure_capacity(first_operand->any_array.left.length + first_operand->any_array.right.length + first_operand->any_array.any.length))
				{
					return false;
				}
				for (unsigned int i = 0; i < first_operand->any_array.left.length; i++) {
					if (second_predicate_index.position == head_position::LEFT && i == second_predicate_index.index + 1) continue;
					first_conjuncts[first_conjuncts.length++] = first_operand->any_array.left.operands[i];
					second_conjuncts[second_conjuncts.length++] = second_operand->any_array.left.operands[i];
				} for (unsigned int i = 0; i < first_operand->any_array.right.length; i++) {
					if (second_predicate_index.position == head_position::RIGHT && second_operand->any_array.right.length - i - 1 == second_predicate_index.index - 1) continue;
					first_conjuncts[first_conjuncts.length++] = first_operand->any_array.right.operands[first_operand->any_array.right.length - i - 1];
					second_conjuncts[second_conjuncts.length++] = second_operand->any_array.right.operands[second_operand->any_array.right.length - i - 1];
				}
				if (first_predicate_index.position == head_position::ANY && second_predicate_index.position == head_position::ANY) {
					if (second_predicate_index.index < first_predicate_index.index
					 || first_operand->any_array.any.length - 1 - first_predicate_index.index + second_predicate_index.index >= second_operand->any_array.any.length)
					{
						return false;
					}
					for (unsigned int i = 0; i < first_operand->any_array.any.length; i++) {
						if (i - first_predicate_index.index + second_predicate_index.index == second_predicate_index.index + 1) continue;
						first_conjuncts[first_conjuncts.length++] = first_operand->any_array.any.operands[i];
						second_conjuncts[second_conjuncts.length++] = second_operand->any_array.any.operands[i - first_predicate_index.index + second_predicate_index.index];
					}
				} else if (first_predicate_index.position != head_position::ANY && first_predicate_index.position != head_position::NONE) {
					return false;
				}
			} else {
				return false;
			}
		} else {
			return false;
		}

		for (unsigned int i = 0; i < first_conjuncts.length; i++) {
			if (second_conjuncts[i]->type == hol_term_type::UNARY_APPLICATION) {
				if (second_conjuncts[i]->binary.right->type == hol_term_type::VARIABLE) {
					if (second_conjuncts[i]->binary.left->type == hol_term_type::ANY || second_conjuncts[i]->binary.left->type == hol_term_type::ANY_RIGHT) {
						if (first_conjuncts[i]->type == hol_term_type::UNARY_APPLICATION)
							first_conjuncts[i] = first_conjuncts[i]->binary.right;
						second_conjuncts[i] = second_conjuncts[i]->binary.right;
					}
				} else if (second_conjuncts[i]->binary.right->type == hol_term_type::ANY || second_conjuncts[i]->binary.right->type == hol_term_type::ANY_RIGHT) {
					first_conjuncts.remove(i);
					second_conjuncts.remove(i--);
				}
			} else if (second_conjuncts[i]->type == hol_term_type::ANY || second_conjuncts[i]->type == hol_term_type::ANY_RIGHT) {
				first_conjuncts.remove(i);
				second_conjuncts.remove(i--);
			}
		}

		if (first_conjuncts.length == 0)
			return true;

		hol_term* new_first_conjunction;
		hol_term* new_second_conjunction;
		if (first_conjuncts.length == 1) {
			new_first_conjunction = first_conjuncts[0];
		} else {
			new_first_conjunction = hol_term::new_and(make_array_view(first_conjuncts.data, first_conjuncts.length));
		}
		if (new_first_conjunction == nullptr)
			return false;
		for (hol_term* conjunct : first_conjuncts)
			conjunct->reference_count++;

		if (second_conjuncts.length == 1) {
			new_second_conjunction = second_conjuncts[0];
		} else {
			new_second_conjunction = hol_term::new_and(make_array_view(second_conjuncts.data, second_conjuncts.length));
		}
		if (new_second_conjunction == nullptr) {
			free(*new_first_conjunction); free(new_first_conjunction);
			return false;
		}
		for (hol_term* conjunct : second_conjuncts)
			conjunct->reference_count++;

		array<pair<hol_term*, variable_map>> intersection(2);
		intersect<built_in_predicates, true, true>(intersection, new_first_conjunction, new_second_conjunction);
		free(*new_first_conjunction); if (new_first_conjunction->reference_count == 0) free(new_first_conjunction);
		free(*new_second_conjunction); if (new_second_conjunction->reference_count == 0) free(new_second_conjunction);
		if (intersection.length == 0) {
			return false;
		} else if (intersection.length != 1) {
			fprintf(stderr, "invert_apply_tense_predicate ERROR: Intersection modulo variable relabeling is not unique.\n");
			free_all(intersection); return false;
		}

		/* make sure the variables in `second_head` map to the correct variables in `first_head` */
		const variable_map& var_map = intersection[0].value;
		for (const auto& entry : var_map.scope_map) {
			if (!second_variable_map.contains(entry.key.src))
				continue;

			unsigned int target_var = 0;
			if (!get_target_variable(entry.key.src->quantifier.variable, target_var, entry.value, max_variable)) {
				free_all(intersection);
				return false;
			}

			if (!second_variable_map.ensure_capacity(second_variable_map.size + 1)) {
				free_all(intersection);
				return false;
			}
			unsigned int index = second_variable_map.index_of(entry.key.src);
			if (target_var == second_variable_map.values[index]) {
				/* `second_variable_map` should map `var` to itself */
				second_variable_map.remove_at(index);
			} else {
				/* `second_variable_map` should map `var` to `target_var` */
				second_variable_map.values[index] = target_var;
				if (index == second_variable_map.size) {
					second_variable_map.keys[index] = entry.key.src;
					second_variable_map.size++;
				}
			}
		}

		array_map<unsigned int, variable_set> free_variable_map(8);
		for (const auto& entry : var_map.free_variables) {
			const variable_set& set = entry.value;
			if (entry.key == second_head_variable)
				continue;

			unsigned int src_variable = entry.key;
			if (!free_variable_map.ensure_capacity(free_variable_map.size + 1)) {
				free_all(intersection);
				return false;
			}
			unsigned int index = free_variable_map.index_of(src_variable);
			if (index < free_variable_map.size) {
				variable_set& new_set = *((variable_set*) alloca(sizeof(variable_map)));
				if (!intersect(new_set, set, free_variable_map.values[index])) {
					free_all(intersection);
					return false;
				}
				swap(free_variable_map.values[index], new_set);
				free(new_set);
			} else {
				free_variable_map.keys[free_variable_map.size] = src_variable;
				if (!init(free_variable_map.values[free_variable_map.size], set)) {
					free_all(intersection);
					return false;
				}
				free_variable_map.size++;
			}
		}
		free_all(intersection);

		if (!remap_scopes(free_variable_map, first_head_inverter, second_head_inverter, second_variable_map, max_variable, first_head_is_array, second_head_is_array)) {
			for (auto entry : second_variable_map) free(entry.value);
			return false;
		}
		return true;
	};

	return invert_apply_head(inverse, inverse_count, flags, first, second,
		find_head<built_in_predicates>, find_head<built_in_predicates>, on_remap_variables,
		[input_tense_predicates,output_tense_predicates](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, const apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array)
		{
			unsigned int negation_count = 0;
			while (second_head->type == hol_term_type::NOT) {
				second_head = second_head->unary.operand;
				negation_count++;
			}

			unsigned int predicate_variable;
			if (second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT) {
				predicate_variable = max_variable + 1;
			} else {
#if !defined(NDEBUG)
				if (second_head->type != hol_term_type::EXISTS)
					fprintf(stderr, "invert_apply_tense_predicate WARNING: Expected `second_head` to be an existential quantification.\n");
#endif
				predicate_variable = second_head->quantifier.variable;
			}

			if (!map_tense_predicate<false>(dst, second_head, predicate_variable, second_predicate_index, output_tense_predicates, input_tense_predicates))
				return false;
			for (unsigned int i = 0; i < dst.length; i++) {
				for (unsigned int j = 0; j < negation_count; j++) {
					hol_term* temp = hol_term::new_not(dst[i]);
					if (temp == nullptr) {
						free_all(dst);
						return false;
					}
					dst[i] = temp;
				}
			}
			if (!dst_outer.ensure_capacity(dst.length)) {
				free_all(dst);
				return false;
			}
			for (unsigned int i = 0; i < dst.length; i++)
				dst_outer[i] = &HOL_ZERO;
			dst_outer.length = dst.length;
			HOL_ZERO.reference_count += dst.length;
			return (dst.length > 0);
		});
}

inline bool invert_remove_perfect(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	return invert_apply_head(inverse, inverse_count, flags, first, second,
		find_head<built_in_predicates>, find_head<built_in_predicates>, no_op(),
		[](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, const apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array)
		{
			unsigned int predicate_variable;
			if (second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT) {
				predicate_variable = max_variable + 1;
			} else {
#if !defined(NDEBUG)
				if (second_head->type != hol_term_type::EXISTS)
					fprintf(stderr, "invert_remove_perfect WARNING: Expected `second_head` to be an existential quantification.\n");
#endif
				predicate_variable = second_head->quantifier.variable;
			}

			if (!map_tense_predicate<false>(dst, second_head, predicate_variable, second_predicate_index, NON_PERFECT_PREDICATES, PERFECT_PREDICATES))
				return false;
			if (!dst_outer.ensure_capacity(dst.length)) {
				free_all(dst);
				return false;
			}
			for (unsigned int i = 0; i < dst.length; i++)
				dst_outer[i] = &HOL_ZERO;
			dst_outer.length = dst.length;
			HOL_ZERO.reference_count += dst.length;
			return (dst.length > 0);
		});
}

inline bool invert_remove_not(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	return invert_apply_head(inverse, inverse_count, flags, first, second,
		find_head<built_in_predicates>, find_head<built_in_predicates>, no_op(),
		[](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, const apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array)
		{
			if (!dst.ensure_capacity(dst.length + 1))
				return false;

			dst[dst.length] = hol_term::new_not(second_head);
			if (dst[dst.length] == nullptr)
				return false;
			second_head->reference_count++;
			dst.length++;
			dst_outer[dst_outer.length++] = &HOL_ZERO;
			HOL_ZERO.reference_count++;
			return true;
		});
}

inline bool invert_require_predicative_universal(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	if (second->type != hol_term_type::LAMBDA)
		return false;
	unsigned int lambda_variable = second->quantifier.variable;

	head_index second_predicate_index; no_op apply;
	auto head_finder = predicative_head_finder<built_in_predicates>(lambda_variable);
	hol_term* second_head = find_head(second, second_predicate_index, head_finder, apply);
	if (second_head == nullptr)
		return false;

	if ((second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT) && second_head->any.included != nullptr)
		second_head = second_head->any.included;

#if !defined(NDEBUG)
	if (second_head->type != hol_term_type::EXISTS) {
		fprintf(stderr, "invert_require_predicative_universal ERROR: Expected the head of `second` to be an existentially-quantified expression.\n");
		return false;
	}
#endif

	hol_term* right;
	unsigned int set_variable = second_head->quantifier.variable;
	hol_term* operand = second_head->quantifier.operand;
	if (operand->type == hol_term_type::ANY_ARRAY) {
#if !defined(NDEBUG)
		if (operand->any_array.right.length == 0) {
			fprintf(stderr, "invert_require_predicative_universal ERROR: Expected the head of `second` to be an existentially-quantified conjunction with a known right conjunct.\n");
			return false;
		}
#endif
		right = operand->any_array.right.operands[operand->any_array.right.length - 1];
	} else {
#if !defined(NDEBUG)
		if (operand->type != hol_term_type::AND) {
			fprintf(stderr, "invert_require_predicative_universal ERROR: Expected the head of `second` to be an existentially-quantified conjunction.\n");
			return false;
		}
#endif
		right = operand->array.operands[operand->array.length - 1];
	}

	/* get the element variable */
	hol_term* current = right;
	while (current->type != hol_term_type::FOR_ALL) {
		if (current->type == hol_term_type::ANY || current->type == hol_term_type::ANY_RIGHT) {
#if !defined(NDEBUG)
			if (current->any.included == nullptr) {
				fprintf(stderr, "invert_require_predicative_universal ERROR: Unable to find universal quantifier in right conjunct.\n");
				return false;
			}
#endif
			current = current->any.included;
		} else if (current->type == hol_term_type::NOT) {
			current = current->unary.operand;
		} else if (current->type == hol_term_type::UNARY_APPLICATION) {
			current = current->binary.right;
		} else {
			fprintf(stderr, "invert_require_predicative_universal ERROR: Found unexpected expression in right conjunct.\n");
			return false;
		}
	}
	unsigned int element_variable = current->quantifier.variable;

	constexpr unsigned int excluded_quantifier_count = 8;
	hol_term* excluded_quantifiers[excluded_quantifier_count];
	excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(set_variable, &HOL_ANY));
	excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(set_variable, &HOL_ANY));
	excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(set_variable, &HOL_ANY));
	excluded_quantifiers[3] = hol_term::new_any_right(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, hol_term::new_for_all(element_variable, &HOL_ANY)));
	excluded_quantifiers[4] = hol_term::new_any(hol_term::new_exists(element_variable, &HOL_ANY));
	excluded_quantifiers[5] = hol_term::new_any(hol_term::new_for_all(element_variable, &HOL_ANY));
	excluded_quantifiers[6] = hol_term::new_any(hol_term::new_lambda(element_variable, &HOL_ANY));
	excluded_quantifiers[7] = hol_term::new_any_right(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ANY));
	if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
	if (excluded_quantifiers[1] != nullptr) HOL_ANY.reference_count++;
	if (excluded_quantifiers[2] != nullptr) HOL_ANY.reference_count++;
	if (excluded_quantifiers[3] != nullptr) {
		hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
		HOL_ANY.reference_count++;
	}
	if (excluded_quantifiers[4] != nullptr) HOL_ANY.reference_count++;
	if (excluded_quantifiers[5] != nullptr) HOL_ANY.reference_count++;
	if (excluded_quantifiers[6] != nullptr) HOL_ANY.reference_count++;
	if (excluded_quantifiers[7] != nullptr) {
		hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
		HOL_ANY.reference_count++;
	}
	if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr
	 || excluded_quantifiers[3] == nullptr || excluded_quantifiers[4] == nullptr || excluded_quantifiers[5] == nullptr
	 || excluded_quantifiers[6] == nullptr || excluded_quantifiers[7] == nullptr)
	{
		for (unsigned int i = 0; i + 1 < excluded_quantifier_count; i++) {
			if (excluded_quantifiers[i] != nullptr) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
		}
		return false;
	}

	hol_term* expected_right = hol_term::new_any_right(hol_term::new_for_all(element_variable, hol_term::new_any(nullptr, excluded_quantifiers + 3 + 1, 3)), excluded_quantifiers, 3 + 1);
	if (expected_right == nullptr) {
		for (unsigned int i = 0; i < excluded_quantifier_count; i++) {
			free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
		}
		return false;
	}
	for (unsigned int i = 0; i < 3; i++)
		excluded_quantifiers[i]->reference_count++;
	for (unsigned int i = 3 + 1; i < 3 + 1 + 3; i++)
		excluded_quantifiers[i]->reference_count++;

	array<hol_term*> intersection(2);
	intersect<built_in_predicates>(intersection, right, expected_right);
	free(*expected_right); if (expected_right->reference_count == 0) free(expected_right);

	expected_right = hol_term::new_any_right(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value,
			hol_term::new_for_all(element_variable, hol_term::new_any(nullptr, excluded_quantifiers + 3 + 1, 3 + 1))), excluded_quantifiers, 3);
	if (expected_right == nullptr) {
		for (unsigned int i = 0; i < excluded_quantifier_count; i++) {
			if (i == 3) continue;
			free(*excluded_quantifiers[i]); if (excluded_quantifiers[i]->reference_count == 0) free(excluded_quantifiers[i]);
		}
		return false;
	}
	hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;

	intersect<built_in_predicates>(intersection, right, expected_right);
	free(*expected_right); if (expected_right->reference_count == 0) free(expected_right);
	if (intersection.length == 0)
		return false;

	inverse = (flagged_logical_form<hol_term>*) malloc(sizeof(flagged_logical_form<hol_term>) * intersection.length);
	inverse_count = 0;
	for (hol_term* new_right : intersection) {
		hol_term* new_term = substitute_head<any_node_position::NONE>(second, right, new_right);
		if (new_term == nullptr) {
			free_all(intersection);
			for (unsigned int i = 0; i < inverse_count; i++) free(inverse[i]);
			free(inverse); return false;
		}
		
		inverse[inverse_count].flags = flags;
		inverse[inverse_count].root = new_term;
		inverse_count++;
	}
	free_all(intersection);
	return true;
}

inline bool invert_replace_predicative_lambda_with_existential(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	if (second->type != hol_term_type::LAMBDA)
		return false;
	unsigned int lambda_variable = second->quantifier.variable;
	second = second->quantifier.operand;

	unsigned int element_variable = 0;
	if (first->type == hol_term_type::LAMBDA && first->quantifier.operand->type == hol_term_type::LAMBDA) {
		element_variable = first->quantifier.operand->quantifier.variable;
		first = first->quantifier.operand->quantifier.operand;
	} else if (first->type == hol_term_type::LAMBDA) {
		first = first->quantifier.operand;
	}

	auto on_remap_variables = [&element_variable, lambda_variable](hol_term* first_head, hol_term* second_head,
			apply_head_inverter& first_head_inverter, apply_head_inverter& second_head_inverter,
			array_map<const hol_term*, unsigned int>& second_variable_map, unsigned int& max_variable,
			bool first_head_is_array, bool second_head_is_array)
	{
		if ((first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) && first_head->any.included != nullptr)
			first_head = first_head->any.included;
		if ((second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT) && second_head->any.included != nullptr)
			second_head = second_head->any.included;

		if (first_head->type == hol_term_type::NOT)
			first_head = first_head->unary.operand;

		if (first_head->type == hol_term_type::UNARY_APPLICATION && first_head->binary.left->type == hol_term_type::VARIABLE
		 && first_head->binary.left->variable == lambda_variable && first_head->binary.right->type == hol_term_type::VARIABLE)
		{
			element_variable = first_head->binary.right->variable;
		} else if (first_head->type == hol_term_type::EXISTS) {
			hol_term* last = nullptr;
			hol_term* operand = first_head->quantifier.operand;
			if (operand->type == hol_term_type::ANY_ARRAY) {
				last = operand->any_array.right.operands[operand->any_array.right.length - 1];
			} else if (operand->type == hol_term_type::AND) {
				last = operand->array.operands[operand->array.length - 1];
			} else {
				last = operand;
			}

			if (last->type == hol_term_type::ANY_RIGHT && last->any.included != nullptr) {
				last = last->any.included;
			} if (last->type == hol_term_type::UNARY_APPLICATION && last->binary.left->type == hol_term_type::CONSTANT && last->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
				last = last->binary.right;
			}

			while (last->type == hol_term_type::NOT)
				last = operand->unary.operand;

			if (last->type == hol_term_type::UNARY_APPLICATION && last->binary.left->type == hol_term_type::VARIABLE
				&& last->binary.left->variable == lambda_variable && last->binary.right->type == hol_term_type::VARIABLE)
			{
				if (element_variable == 0)
					element_variable = last->binary.right->variable;
			} else if (last->type != hol_term_type::ANY_RIGHT) {
				return false;
			}
		}

		hol_term* left = nullptr;
		hol_term* second_operand = second_head->quantifier.operand;
		if (second_operand->type == hol_term_type::AND) {
			left = second_operand->array.operands[0];
		} else if (second_operand->type == hol_term_type::ANY_ARRAY && second_operand->any_array.oper == hol_term_type::AND) {
			if (second_operand->any_array.left.length != 0)
				left = second_operand->any_array.left.operands[0];
		}

		hol_term* set_definition = nullptr;
		if (left != nullptr) {
			if (left->type == hol_term_type::EQUALS && left->binary.right->type == hol_term_type::LAMBDA) {
				set_definition = left->binary.right;
			} else if (left->type == hol_term_type::BINARY_APPLICATION && left->ternary.third->type == hol_term_type::LAMBDA) {
				set_definition = left->ternary.third;
			} else if ((left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT) && left->any.included != nullptr && left->any.included->type == hol_term_type::LAMBDA) {
				set_definition = left->any.included;
			}
		}

		if (set_definition != nullptr && set_definition->quantifier.variable == element_variable)
			return second_variable_map.put(set_definition, ++max_variable);
		else return true;
	};

	bool result = invert_apply_head(inverse, inverse_count, flags, first, second,
		predicative_head_finder<built_in_predicates>(lambda_variable), predicative_head_finder<built_in_predicates>(lambda_variable), on_remap_variables,
		[&element_variable,lambda_variable](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, const apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array)
		{
			if ((first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) && first_head->any.included != nullptr)
				first_head = first_head->any.included;
			if ((second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT) && second_head->any.included != nullptr)
				second_head = second_head->any.included;

#if !defined(NDEBUG)
			if (second_head->type != hol_term_type::EXISTS) {
				fprintf(stderr, "invert_replace_predicative_lambda_with_existential ERROR: Expected existential quantification of set.\n");
				return false;
			}
#endif

			hol_term* right;
			hol_term* operand = second_head->quantifier.operand;
			unsigned int set_variable = second_head->quantifier.variable;
			if (operand->type == hol_term_type::AND) {
				right = operand->array.operands[operand->array.length - 1];
			} else {
				right = operand->any_array.right.operands[operand->any_array.right.length - 1];
			}

			if (right->type == hol_term_type::UNARY_APPLICATION && right->binary.left->type == hol_term_type::CONSTANT
			 && right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE)
				return false;

			hol_term* old_right = right;
			if (right->type == hol_term_type::ANY_RIGHT)
				right = right->any.included;

			if (element_variable == 0)
				element_variable = ++max_variable;
			hol_term* element_var = hol_term::new_variable(element_variable);
			if (element_var == nullptr)
				return false;

			hol_term* set_apply_term = hol_term::new_apply(hol_term::new_variable(set_variable), element_var);
			if (set_apply_term == nullptr) {
				free(*element_var); free(element_var);
				return false;
			}

			hol_term* lambda_apply_term = hol_term::new_apply(hol_term::new_variable(lambda_variable), element_var);
			if (lambda_apply_term == nullptr) {
				free(*set_apply_term); free(set_apply_term);
				return false;
			}
			element_var->reference_count++;

			if (old_right->type == hol_term_type::ANY_RIGHT) {
				hol_term* temp = hol_term::new_any_right(lambda_apply_term, old_right->any.excluded_trees, old_right->any.excluded_tree_count);
				if (temp == nullptr) {
					free(*set_apply_term); free(set_apply_term);
					free(*lambda_apply_term); free(lambda_apply_term);
					return false;
				}
				for (unsigned int i = 0; i < old_right->any.excluded_tree_count; i++)
					old_right->any.excluded_trees[i]->reference_count++;
				lambda_apply_term = temp;
			}

			hol_term* new_operand;
			if (operand->type == hol_term_type::AND) {
				new_operand = hol_term::new_and(make_appended_array_view(make_appended_array_view(make_array_view(operand->array.operands, operand->array.length - 1), set_apply_term), lambda_apply_term));
				if (new_operand == nullptr) {
					free(*set_apply_term); free(set_apply_term);
					free(*lambda_apply_term); free(lambda_apply_term);
					return false;
				}
				for (unsigned int i = 0; i < operand->array.length - 1; i++)
					operand->array.operands[i]->reference_count++;
			} else {
				new_operand = hol_term::new_any_array(hol_term_type::AND, operand->any_array.all,
						make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
						make_array_view(operand->any_array.left.operands, operand->any_array.left.length),
						make_appended_array_view(make_appended_array_view(make_array_view(operand->any_array.right.operands, max(1u, operand->any_array.right.length) - 1), set_apply_term), lambda_apply_term));
				if (new_operand == nullptr) {
					free(*set_apply_term); free(set_apply_term);
					free(*lambda_apply_term); free(lambda_apply_term);
					return false;
				}
				operand->any_array.all->reference_count++;
				for (unsigned int i = 0; i < operand->any_array.any.length; i++)
					operand->any_array.any.operands[i]->reference_count++;
				for (unsigned int i = 0; i < operand->any_array.left.length; i++)
					operand->any_array.left.operands[i]->reference_count++;
				for (unsigned int i = 0; i + 1 < operand->any_array.right.length; i++)
					operand->any_array.right.operands[i]->reference_count++;
			}

			dst[dst.length] = hol_term::new_exists(set_variable, new_operand);
			if (dst[dst.length] == nullptr) {
				free(*new_operand); free(new_operand);
				return false;
			}
			dst.length++;
			dst_outer[dst_outer.length++] = &HOL_ZERO;
			HOL_ZERO.reference_count++;
			return true;
		});
	if (!result) return false;
	for (unsigned int i = 0; i < inverse_count; i++) {
		hol_term* new_inverse = hol_term::new_lambda(lambda_variable, hol_term::new_lambda(element_variable, inverse[i].root));
		if (new_inverse == nullptr) {
			for (unsigned int j = 0; j < inverse_count; j++) free(inverse[j]);
			free(inverse); return false;
		}
		inverse[i].root = new_inverse;
	}
	return true;
}

template<hol_term_type SrcQuantifierType, hol_term_type DstQuantifierType>
inline bool invert_replace_predicative_quantifier(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	hol_term* new_second;
	if (!replace_predicative_quantifier<DstQuantifierType, SrcQuantifierType>(second, new_second))
		return false;

	array<hol_term*> inverted_logical_forms(2);
	intersect<built_in_predicates>(inverted_logical_forms, first, new_second);
	free(*new_second); if (new_second->reference_count == 0) free(new_second);
	if (inverted_logical_forms.length == 0)
		return false;

	inverse = (flagged_logical_form<hol_term>*) malloc(sizeof(flagged_logical_form<hol_term>) * inverted_logical_forms.length);
	for (unsigned int i = 0; i < inverted_logical_forms.length; i++) {
		inverse[i].flags = flags;
		inverse[i].root = inverted_logical_forms[i];
	}
	inverse_count = inverted_logical_forms.length;
	return true;
}

inline bool invert_remove_predicative_not(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	if (second->type != hol_term_type::LAMBDA)
		return false;
	unsigned int lambda_variable = second->quantifier.variable;
	second = second->quantifier.operand;

	return invert_apply_head(inverse, inverse_count, flags, first, second,
		predicative_head_finder<built_in_predicates>(lambda_variable), predicative_head_finder<built_in_predicates>(lambda_variable), no_op(),
		[](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, const apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array)
		{
			if ((first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) && first_head->any.included != nullptr)
				first_head = first_head->any.included;
			if ((second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT) && second_head->any.included != nullptr)
				second_head = second_head->any.included;

#if !defined(NDEBUG)
			if (second_head->type != hol_term_type::EXISTS) {
				fprintf(stderr, "invert_remove_predicative_not ERROR: Expected existential quantification of set.\n");
				return false;
			}
#endif

			hol_term* last;
			hol_term* operand = second_head->quantifier.operand;
			if (operand->type == hol_term_type::ANY_ARRAY) {
				if (operand->any_array.right.length == 0)
					return false;
				last = operand->any_array.right.operands[operand->any_array.right.length - 1];
			} else if (operand->type == hol_term_type::AND) {
				last = operand->array.operands[operand->array.length - 1];
			} else {
				last = operand;
			}

			if (last->type == hol_term_type::ANY_RIGHT && last->any.included != nullptr) {
				last = last->any.included;
			} else if (last->type == hol_term_type::UNARY_APPLICATION && last->binary.left->type == hol_term_type::CONSTANT && last->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
				last = last->binary.right;
			}

			if (last->type == hol_term_type::NOT) {
				/* try adding the negation here */
				hol_term* negated = hol_term::new_not(last);
				if (negated == nullptr) return false;
				last->reference_count++;
				hol_term* new_head = substitute_head<any_node_position::NONE>(second_head, last, negated);
				free(*negated); if (negated->reference_count == 0) free(negated);
				if (new_head == nullptr)
					return false;
				dst[dst.length++] = new_head;
				dst_outer[dst_outer.length++] = &HOL_ZERO;
				HOL_ZERO.reference_count++;
				return true;
			}

			if (last->type == hol_term_type::UNARY_APPLICATION)
				return true;

			/* try adding the negation here */
			hol_term* negated = hol_term::new_not(last);
			if (negated == nullptr) return false;
			last->reference_count++;
			hol_term* new_head = substitute_head<any_node_position::NONE>(second_head, last, negated);
			free(*negated); if (negated->reference_count == 0) free(negated);
			if (new_head == nullptr)
				return false;
			dst[dst.length++] = new_head;
			dst_outer[dst_outer.length++] = &HOL_ZERO;
			HOL_ZERO.reference_count++;
			return true;
		});
}

inline bool invert_predicate_only(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	/* we expect the head of `first` to be at the root */
	hol_term* head; head_index predicate_index;
	find_head<built_in_predicates>(first, head, predicate_index);
	if (head == nullptr) return false;

	return invert_apply_head(inverse, inverse_count, flags, first, second,
		find_head<built_in_predicates>, find_root, no_op(),
		[](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, const apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array) {
			array<hol_term*> new_heads(4);
			if (first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) {
				unsigned int predicate_variable = max_variable + 1;
				new_heads[new_heads.length] = hol_term::new_exists(predicate_variable, hol_term::new_apply(second_head, hol_term::new_variable(predicate_variable)));
				if (new_heads[new_heads.length] == nullptr)
					return false;
				second_head->reference_count++;
				new_heads.length++;

			} else if (first_head->type == hol_term_type::EXISTS && (first_head->quantifier.operand->type == hol_term_type::AND || first_head->quantifier.operand->type == hol_term_type::ANY_ARRAY)) {
				hol_term* new_head = hol_term::new_exists(first_head->quantifier.variable, hol_term::new_apply(second_head, hol_term::new_variable(first_head->quantifier.variable)));
				if (new_head == nullptr) return false;
				second_head->reference_count++;
				intersect<built_in_predicates>(new_heads, first_head, new_head);
				free(*new_head); if (new_head->reference_count == 0) free(new_head);

			} else {
				fprintf(stderr, "invert_predicate_only ERROR: Expected `first_head` to be an existentially quantified conjunction.\n");
				return false;
			}

			if (!dst.ensure_capacity(dst.length + new_heads.length) || !dst_outer.ensure_capacity(dst_outer.length + new_heads.length)) {
				for (hol_term* term : new_heads) { free(*term); if (term->reference_count == 0) free(term); }
				return false;
			}

			hol_term* any_wide_scope = hol_term::new_any_right(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ANY));
			if (any_wide_scope == nullptr) {
				return false;
			}
			hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
			HOL_ANY.reference_count++;

			hol_term* duplicate_wide_scopes = hol_term::new_any_right(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, any_wide_scope));
			if (duplicate_wide_scopes == nullptr) {
				for (hol_term* term : new_heads) { free(*term); if (term->reference_count == 0) free(term); }
				free(*any_wide_scope); free(any_wide_scope);
				return false;
			}
			hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;

			hol_term* excluded_universal = hol_term::new_any_right(hol_term::new_any_quantifier(hol_quantifier_type::FOR_ALL, any_wide_scope));
			if (excluded_universal == nullptr) {
				for (hol_term* term : new_heads) { free(*term); if (term->reference_count == 0) free(term); }
				free(*duplicate_wide_scopes); free(duplicate_wide_scopes);
				return false;
			}
			any_wide_scope->reference_count++;

			for (hol_term* new_head : new_heads) {
				dst[dst.length++] = new_head;
				new_head->reference_count++;

				hol_term* excluded_trees[2];
				excluded_trees[0] = excluded_universal;
				excluded_trees[1] = duplicate_wide_scopes;
				dst_outer[dst_outer.length] = hol_term::new_any_right(&HOL_ZERO, excluded_trees, array_length(excluded_trees));
				if (dst_outer[dst_outer.length] == nullptr) {
					for (hol_term* term : new_heads) { free(*term); if (term->reference_count == 0) free(term); }
					free(*excluded_universal); if (excluded_universal->reference_count == 0) free(excluded_universal);
					free(*duplicate_wide_scopes); if (duplicate_wide_scopes->reference_count == 0) free(duplicate_wide_scopes);
					return false;
				}
				excluded_universal->reference_count++;
				duplicate_wide_scopes->reference_count++;
				HOL_ZERO.reference_count++;
				dst_outer.length++;
			}
			for (hol_term* term : new_heads) { free(*term); if (term->reference_count == 0) free(term); }
			free(*excluded_universal); if (excluded_universal->reference_count == 0) free(excluded_universal);
			free(*duplicate_wide_scopes); if (duplicate_wide_scopes->reference_count == 0) free(duplicate_wide_scopes);
			return (dst.length > 0);
		});
}

inline bool invert_predicate(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	/* we expect the head of `first` to be at the root */
	hol_term* head; head_index predicate_index;
	find_head<built_in_predicates>(first, head, predicate_index);
	if (head == nullptr) return false;

	return invert_apply_head(inverse, inverse_count, flags, first, second,
		find_head<built_in_predicates>, find_root, no_op(),
		[](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, const apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array) {
			array<hol_term*> new_heads(4);
			if (first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) {
				unsigned int predicate_variable = max_variable + 1;
				hol_term* head_var = hol_term::new_variable(predicate_variable);
				if (head_var == nullptr) return false;
				constexpr unsigned int excluded_tree_count = 2;
				hol_term* excluded_trees[excluded_tree_count];
				excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
							(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
							(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
						&HOL_ANY), head_var));
				excluded_trees[1] = hol_term::new_any(hol_term::new_exists(predicate_variable, &HOL_ANY));
				if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
				if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
				if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr) {
					if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
					free(*head_var); free(head_var);
					return false;
				}
				free(*head_var);

				hol_term* head_conjunct = hol_term::new_any(nullptr, excluded_trees, excluded_tree_count);
				if (head_conjunct == nullptr) {
					free(*excluded_trees[0]); free(excluded_trees[0]);
					free(*excluded_trees[1]); free(excluded_trees[1]);
					return false;
				}

				hol_term* predicate = hol_term::new_apply(second_head, head_var);
				if (predicate == nullptr) {
					free(*head_conjunct); free(head_conjunct);
					return false;
				}
				second_head->reference_count++;
				head_var->reference_count++;

				array<hol_term*> new_predicates(2);
				intersect<built_in_predicates>(new_predicates, predicate, head_conjunct);
				free(*predicate); if (predicate->reference_count == 0) free(predicate);
				if (!new_heads.ensure_capacity(new_heads.length + new_predicates.length)) {
					free_all(new_predicates);
					free(*head_conjunct); free(head_conjunct);
					return false;
				}
				for (hol_term* new_predicate : new_predicates) {
					new_heads[new_heads.length] = hol_term::new_exists(predicate_variable, hol_term::new_any_array(hol_term_type::AND, head_conjunct,
							make_array_view(&new_predicate, 1), make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0)));
					if (new_heads[new_heads.length] == nullptr) {
						free_all(new_heads); free_all(new_predicates);
						free(*head_conjunct); free(head_conjunct);
						return false;
					}
					head_conjunct->reference_count++;
					new_predicate->reference_count++;
					new_heads.length++;
				}
				free_all(new_predicates);
				free(*head_conjunct); if (head_conjunct->reference_count == 0) free(head_conjunct);

			} else if (first_head->type == hol_term_type::EXISTS && first_head->quantifier.operand->type == hol_term_type::AND) {
				hol_term* first_head_operand = first_head->quantifier.operand;

				unsigned int first_index = 0;
				if (first_predicate_index.position == head_position::LEFT)
					first_index = first_predicate_index.index;
				else if (first_predicate_index.position == head_position::RIGHT)
					first_index = first_head_operand->array.length - first_predicate_index.index - 1;
				hol_term* first_predicate = first_head_operand->array.operands[first_index];
				array<hol_term*> new_predicates(8);
				hol_term* new_predicate = hol_term::new_apply(second_head, hol_term::new_variable(first_head->quantifier.variable));
				if (new_predicate == nullptr) return false;
				second_head->reference_count++;
				intersect<built_in_predicates>(new_predicates, first_predicate, new_predicate);
				free(*new_predicate); if (new_predicate->reference_count == 0) free(new_predicate);

#if !defined(NDEBUG)
				if (new_predicates.length == 0)
					fprintf(stderr, "invert_predicate WARNING: `new_predicates` is empty.\n");
#endif

				if (!new_heads.ensure_capacity(new_heads.length + new_predicates.length)) {
					for (hol_term* term : new_predicates) { free(*term); if (term->reference_count == 0) free(term); }
					return false;
				}
				for (hol_term* new_predicate : new_predicates) {
					hol_term* conjunction;
					if (!new_hol_term(conjunction)) {
						for (hol_term* term : new_predicates) { free(*term); if (term->reference_count == 0) free(term); }
						return false;
					}
					conjunction->type = hol_term_type::AND;
					conjunction->reference_count = 1;
					conjunction->array.length = first_head_operand->array.length;
					conjunction->array.operands = (hol_term**) malloc(sizeof(hol_term*) * first_head_operand->array.length);
					if (conjunction->array.operands == nullptr) {
						for (hol_term* term : new_predicates) { free(*term); if (term->reference_count == 0) free(term); }
						free(conjunction); return false;
					}
					for (unsigned int i = 0; i < conjunction->array.length; i++) {
						if (i == first_index) {
							conjunction->array.operands[i] = new_predicate;
						} else {
							conjunction->array.operands[i] = first_head_operand->array.operands[i];
						}
						conjunction->array.operands[i]->reference_count++;
					}

					new_heads[new_heads.length] = hol_term::new_exists(first_head->quantifier.variable, conjunction);
					if (new_heads[new_heads.length] == nullptr) {
						for (hol_term* term : new_predicates) { free(*term); if (term->reference_count == 0) free(term); }
						free(*conjunction); free(conjunction);
						return false;
					}
					new_heads.length++;
				}
				for (hol_term* term : new_predicates) { free(*term); if (term->reference_count == 0) free(term); }

			} else if (first_head->type == hol_term_type::EXISTS && first_head->quantifier.operand->type == hol_term_type::ANY_ARRAY) {
				hol_term* first_head_operand = first_head->quantifier.operand;

				hol_term* first_predicate = nullptr;
				if (first_predicate_index.position == head_position::LEFT)
					first_predicate = first_head_operand->any_array.left.operands[first_predicate_index.index];
				else if (first_predicate_index.position == head_position::RIGHT)
					first_predicate = first_head_operand->any_array.right.operands[first_head_operand->any_array.right.length - first_predicate_index.index - 1];
				else if (first_predicate_index.position == head_position::ANY)
					first_predicate = first_head_operand->any_array.any.operands[first_predicate_index.index];

				array<hol_term*> new_predicates(8);
				hol_term* new_predicate = hol_term::new_apply(second_head, hol_term::new_variable(first_head->quantifier.variable));
				if (new_predicate == nullptr) return false;
				second_head->reference_count++;
				intersect<built_in_predicates>(new_predicates, first_predicate, new_predicate);
				free(*new_predicate); if (new_predicate->reference_count == 0) free(new_predicate);

#if !defined(NDEBUG)
				if (new_predicates.length == 0)
					fprintf(stderr, "invert_predicate WARNING: `new_predicates` is empty.\n");
#endif

				if (!new_heads.ensure_capacity(new_heads.length + new_predicates.length)) {
					for (hol_term* term : new_predicates) { free(*term); if (term->reference_count == 0) free(term); }
					return false;
				}
				for (hol_term* new_predicate : new_predicates) {
					hol_term* conjunction;
					if (!new_hol_term(conjunction)) {
						for (hol_term* term : new_predicates) { free(*term); if (term->reference_count == 0) free(term); }
						return false;
					}
					conjunction->type = hol_term_type::ANY_ARRAY;
					conjunction->reference_count = 1;
					conjunction->any_array.oper = hol_term_type::AND;
					conjunction->any_array.all = first_head_operand->any_array.all;
					conjunction->any_array.all->reference_count++;
					conjunction->any_array.left.length = 0;
					conjunction->any_array.left.operands = nullptr;
					conjunction->any_array.right.length = 0;
					conjunction->any_array.right.operands = nullptr;
					conjunction->any_array.any.length = 0;
					conjunction->any_array.any.operands = nullptr;

					conjunction->any_array.left.length = first_head_operand->any_array.left.length;
					if (conjunction->any_array.left.length == 0) {
						conjunction->any_array.left.operands = nullptr;
					} else {
						conjunction->any_array.left.operands = (hol_term**) malloc(sizeof(hol_term*) * conjunction->any_array.left.length);
						if (conjunction->any_array.left.operands == nullptr) {
							for (hol_term* term : new_predicates) { free(*term); if (term->reference_count == 0) free(term); }
							free(*conjunction); free(conjunction);
							return false;
						}
						for (unsigned int i = 0; i < conjunction->any_array.left.length; i++) {
							if (first_predicate_index.position == head_position::LEFT && first_predicate_index.index == i) {
								conjunction->any_array.left.operands[i] = new_predicate;
							} else {
								conjunction->any_array.left.operands[i] = first_head_operand->any_array.left.operands[i];
							}
							conjunction->any_array.left.operands[i]->reference_count++;
						}
					}
					conjunction->any_array.right.length = first_head_operand->any_array.right.length;
					if (conjunction->any_array.right.length == 0) {
						conjunction->any_array.right.operands = nullptr;
					} else {
						conjunction->any_array.right.operands = (hol_term**) malloc(sizeof(hol_term*) * conjunction->any_array.right.length);
						if (conjunction->any_array.right.operands == nullptr) {
							for (hol_term* term : new_predicates) { free(*term); if (term->reference_count == 0) free(term); }
							free(*conjunction); free(conjunction);
							return false;
						}
						for (unsigned int i = 0; i < conjunction->any_array.right.length; i++) {
							if (first_predicate_index.position == head_position::RIGHT && first_predicate_index.index == conjunction->any_array.right.length - i - 1) {
								conjunction->any_array.right.operands[i] = new_predicate;
							} else {
								conjunction->any_array.right.operands[i] = first_head_operand->any_array.right.operands[i];
							}
							conjunction->any_array.right.operands[i]->reference_count++;
						}
					}
					conjunction->any_array.any.length = first_head_operand->any_array.any.length;
					if (conjunction->any_array.any.length == 0) {
						conjunction->any_array.any.operands = nullptr;
					} else {
						conjunction->any_array.any.operands = (hol_term**) malloc(sizeof(hol_term*) * conjunction->any_array.any.length);
						if (conjunction->any_array.any.operands == nullptr) {
							for (hol_term* term : new_predicates) { free(*term); if (term->reference_count == 0) free(term); }
							free(*conjunction); free(conjunction);
							return false;
						}
						for (unsigned int i = 0; i < conjunction->any_array.any.length; i++) {
							if (first_predicate_index.position == head_position::ANY && first_predicate_index.index == i) {
								conjunction->any_array.any.operands[i] = new_predicate;
							} else {
								conjunction->any_array.any.operands[i] = first_head_operand->any_array.any.operands[i];
							}
							conjunction->any_array.any.operands[i]->reference_count++;
						}
					}

					new_heads[new_heads.length] = hol_term::new_exists(first_head->quantifier.variable, conjunction);
					if (new_heads[new_heads.length] == nullptr) {
						for (hol_term* term : new_predicates) { free(*term); if (term->reference_count == 0) free(term); }
						free(*conjunction); free(conjunction);
						return false;
					}
					new_heads.length++;
				}
				for (hol_term* term : new_predicates) { free(*term); if (term->reference_count == 0) free(term); }
			} else {
				fprintf(stderr, "invert_predicate ERROR: Expected `first_head` to be an existentially quantified conjunction.\n");
				return false;
			}

			if (!dst.ensure_capacity(dst.length + new_heads.length) || !dst_outer.ensure_capacity(dst_outer.length + new_heads.length)) {
				for (hol_term* term : new_heads) { free(*term); if (term->reference_count == 0) free(term); }
				return false;
			}

			hol_term* any_wide_scope = hol_term::new_any_right(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ANY));
			if (any_wide_scope == nullptr) {
				return false;
			}
			hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
			HOL_ANY.reference_count++;

			hol_term* duplicate_wide_scopes = hol_term::new_any_right(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, any_wide_scope));
			if (duplicate_wide_scopes == nullptr) {
				for (hol_term* term : new_heads) { free(*term); if (term->reference_count == 0) free(term); }
				free(*any_wide_scope); free(any_wide_scope);
				return false;
			}
			hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;

			hol_term* excluded_universal = hol_term::new_any_right(hol_term::new_any_quantifier(hol_quantifier_type::FOR_ALL, any_wide_scope));
			if (excluded_universal == nullptr) {
				for (hol_term* term : new_heads) { free(*term); if (term->reference_count == 0) free(term); }
				free(*duplicate_wide_scopes); free(duplicate_wide_scopes);
				return false;
			}
			any_wide_scope->reference_count++;

			for (hol_term* new_head : new_heads) {
				dst[dst.length++] = new_head;
				new_head->reference_count++;

				hol_term* excluded_trees[2];
				excluded_trees[0] = excluded_universal;
				excluded_trees[1] = duplicate_wide_scopes;
				dst_outer[dst_outer.length] = hol_term::new_any_right(&HOL_ZERO, excluded_trees, array_length(excluded_trees));
				if (dst_outer[dst_outer.length] == nullptr) {
					for (hol_term* term : new_heads) { free(*term); if (term->reference_count == 0) free(term); }
					free(*excluded_universal); if (excluded_universal->reference_count == 0) free(excluded_universal);
					free(*duplicate_wide_scopes); if (duplicate_wide_scopes->reference_count == 0) free(duplicate_wide_scopes);
					return false;
				}
				excluded_universal->reference_count++;
				duplicate_wide_scopes->reference_count++;
				HOL_ZERO.reference_count++;
				dst_outer.length++;
			}
			for (hol_term* term : new_heads) { free(*term); if (term->reference_count == 0) free(term); }
			free(*excluded_universal); if (excluded_universal->reference_count == 0) free(excluded_universal);
			free(*duplicate_wide_scopes); if (duplicate_wide_scopes->reference_count == 0) free(duplicate_wide_scopes);
			return (dst.length > 0);
		});
}

inline bool invert_predicate_and_tense(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	array<hol_term*> inverted_logical_forms(4);
	intersect<built_in_predicates>(inverted_logical_forms, first, second);

	hol_term* wide_scope_second = hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, second);
	if (wide_scope_second == nullptr) {
		free_all(inverted_logical_forms);
		return false;
	}
	hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
	second->reference_count++;

	intersect<built_in_predicates>(inverted_logical_forms, first, wide_scope_second);
	free(*wide_scope_second); if (wide_scope_second->reference_count == 0) free(wide_scope_second);

	inverse = (flagged_logical_form<hol_term>*) malloc(sizeof(flagged_logical_form<hol_term>) * inverted_logical_forms.length);
	for (unsigned int i = 0; i < inverted_logical_forms.length; i++) {
		inverse[i].flags = flags;
		inverse[i].root = inverted_logical_forms[i];
	}
	inverse_count = inverted_logical_forms.length;
	return true;
}

inline bool invert_select_predicate_in_set(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	unsigned int lambda_variable = 0;
	if (first->type == hol_term_type::LAMBDA) {
		lambda_variable = first->quantifier.variable;
		first = first->quantifier.operand;
	} else if (first->type == hol_term_type::ANY) {
		unsigned int max_variable = 0;
		max_bound_variable(*first, max_variable);
		lambda_variable = ++max_variable;
	} else {
		return false;
	}
	if (!invert_apply_head(inverse, inverse_count, flags, first, second,
		predicative_head_finder<built_in_predicates>(lambda_variable), find_root, no_op(),
		[lambda_variable](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, const apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array) {
			array<hol_term*> new_heads(2);
			select_predicate_in_set<false, false, false, false, false>(new_heads, first_head, second_head, max_variable, lambda_variable);
			if (new_heads.length == 0)
				return false;

			for (hol_term* new_head : new_heads) {
				if (!dst.ensure_capacity(dst.length + 2) || !dst_outer.ensure_capacity(dst_outer.length + 2)) {
					for (hol_term* term : new_heads) { free(*term); if (term->reference_count == 0) free(term); }
					return false;
				}

				hol_term* right = new_head->quantifier.operand->array.operands[new_head->quantifier.operand->array.length - 1];
				if (right->type == hol_term_type::UNARY_APPLICATION && right->binary.left->type == hol_term_type::CONSTANT && right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;
					continue;
				}

				hol_term* operand;
				if (right->type == hol_term_type::ANY_QUANTIFIER) {
					operand = right->any_quantifier.operand;
				} else if (right->type == hol_term_type::FOR_ALL || right->type == hol_term_type::EXISTS) {
					operand = right->quantifier.operand;
				} else {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;
					continue;
				}

				hol_term* inner_right;
				if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.right.length != 0) {
					inner_right = operand->any_array.right.operands[operand->any_array.right.length - 1];
				} else if (operand->type == hol_term_type::AND) {
					inner_right = operand->array.operands[operand->array.length - 1];
				} else if (operand->type == hol_term_type::IF_THEN) {
					inner_right = operand->binary.right;
				} else {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;
					continue;
				}

				if (inner_right->type == hol_term_type::UNARY_APPLICATION && inner_right->binary.left->type == hol_term_type::CONSTANT && inner_right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;
					continue;
				} else {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;

					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length] = hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ZERO);
					if (dst_outer[dst_outer.length] == nullptr) {
						free_all(new_heads);
						return false;
					}
					hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
					HOL_ZERO.reference_count++;
					dst_outer.length++;
				}
			}
			for (hol_term* term : new_heads) { free(*term); if (term->reference_count == 0) free(term); }
			return true;
		})) return false;
	for (unsigned int i = 0; i < inverse_count; i++) {
		hol_term* new_inverse = hol_term::new_lambda(lambda_variable, inverse[i].root);
		if (new_inverse == nullptr) {
			for (unsigned int j = 0; j < inverse_count; j++) free(inverse[j]);
			free(inverse); return false;
		}
		inverse[i].root = new_inverse;
	}
	return true;
}

inline bool invert_select_constant_in_set(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	unsigned int lambda_variable = 0;
	if (first->type == hol_term_type::LAMBDA) {
		lambda_variable = first->quantifier.variable;
		first = first->quantifier.operand;
	} else if (first->type == hol_term_type::ANY) {
		unsigned int max_variable = 0;
		max_bound_variable(*first, max_variable);
		lambda_variable = ++max_variable;
	} else {
		return false;
	}
	if (!invert_apply_head(inverse, inverse_count, flags, first, second,
		predicative_head_finder<built_in_predicates>(lambda_variable), find_root, no_op(),
		[lambda_variable](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, const apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array) {
			array<hol_term*> new_heads(2);
			select_predicate_in_set<false, false, true, true, false>(new_heads, first_head, second_head, max_variable, lambda_variable);
			if (new_heads.length == 0)
				return false;

			for (hol_term* new_head : new_heads) {
				if (!dst.ensure_capacity(dst.length + 2) || !dst_outer.ensure_capacity(dst_outer.length + 2)) {
					for (hol_term* term : new_heads) { free(*term); if (term->reference_count == 0) free(term); }
					return false;
				}

				hol_term* right = new_head->quantifier.operand->array.operands[new_head->quantifier.operand->array.length - 1];
				if (right->type == hol_term_type::UNARY_APPLICATION && right->binary.left->type == hol_term_type::CONSTANT && right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;
					continue;
				}

				hol_term* operand;
				if (right->type == hol_term_type::ANY_QUANTIFIER) {
					operand = right->any_quantifier.operand;
				} else if (right->type == hol_term_type::FOR_ALL || right->type == hol_term_type::EXISTS) {
					operand = right->quantifier.operand;
				} else {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;
					continue;
				}

				hol_term* inner_right;
				if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.right.length != 0) {
					inner_right = operand->any_array.right.operands[operand->any_array.right.length - 1];
				} else if (operand->type == hol_term_type::AND) {
					inner_right = operand->array.operands[operand->array.length - 1];
				} else if (operand->type == hol_term_type::IF_THEN) {
					inner_right = operand->binary.right;
				} else {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;
					continue;
				}

				if (inner_right->type == hol_term_type::UNARY_APPLICATION && inner_right->binary.left->type == hol_term_type::CONSTANT && inner_right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;
					continue;
				} else {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;

					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length] = hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ZERO);
					if (dst_outer[dst_outer.length] == nullptr) {
						free_all(new_heads);
						return false;
					}
					hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
					HOL_ZERO.reference_count++;
					dst_outer.length++;
				}
			}
			for (hol_term* term : new_heads) { free(*term); if (term->reference_count == 0) free(term); }
			return true;
		})) return false;
	for (unsigned int i = 0; i < inverse_count; i++) {
		hol_term* new_inverse = hol_term::new_lambda(lambda_variable, inverse[i].root);
		if (new_inverse == nullptr) {
			for (unsigned int j = 0; j < inverse_count; j++) free(inverse[j]);
			free(inverse); return false;
		}
		inverse[i].root = new_inverse;
	}
	return true;
}

inline bool invert_select_string_in_set(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	unsigned int lambda_variable = 0;
	if (first->type == hol_term_type::LAMBDA) {
		lambda_variable = first->quantifier.variable;
		first = first->quantifier.operand;
	} else if (first->type == hol_term_type::ANY) {
		unsigned int max_variable = 0;
		max_bound_variable(*first, max_variable);
		lambda_variable = ++max_variable;
	} else {
		return false;
	}
	if (!invert_apply_head(inverse, inverse_count, flags, first, second,
		predicative_head_finder<built_in_predicates>(lambda_variable), find_root, no_op(),
		[lambda_variable](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, const apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array) {
			if (second_head->type != hol_term_type::STRING)
				return false;

			array<hol_term*> new_heads(2);
			select_predicate_in_set<false, false, true, true, false>(new_heads, first_head, second_head, max_variable, lambda_variable);
			if (new_heads.length == 0)
				return false;

			for (hol_term* new_head : new_heads) {
				if (!dst.ensure_capacity(dst.length + 2) || !dst_outer.ensure_capacity(dst_outer.length + 2)) {
					for (hol_term* term : new_heads) { free(*term); if (term->reference_count == 0) free(term); }
					return false;
				}

				hol_term* right = new_head->quantifier.operand->array.operands[new_head->quantifier.operand->array.length - 1];
				if (right->type == hol_term_type::UNARY_APPLICATION && right->binary.left->type == hol_term_type::CONSTANT && right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;
					continue;
				}

				hol_term* operand;
				if (right->type == hol_term_type::ANY_QUANTIFIER) {
					operand = right->any_quantifier.operand;
				} else if (right->type == hol_term_type::FOR_ALL || right->type == hol_term_type::EXISTS) {
					operand = right->quantifier.operand;
				} else {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;
					continue;
				}

				hol_term* inner_right;
				if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.right.length != 0) {
					inner_right = operand->any_array.right.operands[operand->any_array.right.length - 1];
				} else if (operand->type == hol_term_type::AND) {
					inner_right = operand->array.operands[operand->array.length - 1];
				} else if (operand->type == hol_term_type::IF_THEN) {
					inner_right = operand->binary.right;
				} else {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;
					continue;
				}

				if (inner_right->type == hol_term_type::UNARY_APPLICATION && inner_right->binary.left->type == hol_term_type::CONSTANT && inner_right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;
					continue;
				} else {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;

					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length] = hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ZERO);
					if (dst_outer[dst_outer.length] == nullptr) {
						free_all(new_heads);
						return false;
					}
					hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
					HOL_ZERO.reference_count++;
					dst_outer.length++;
				}
			}
			for (hol_term* term : new_heads) { free(*term); if (term->reference_count == 0) free(term); }
			return true;
		})) return false;
	for (unsigned int i = 0; i < inverse_count; i++) {
		hol_term* new_inverse = hol_term::new_lambda(lambda_variable, inverse[i].root);
		if (new_inverse == nullptr) {
			for (unsigned int j = 0; j < inverse_count; j++) free(inverse[j]);
			free(inverse); return false;
		}
		inverse[i].root = new_inverse;
	}
	return true;
}

inline bool invert_select_name_in_set(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	unsigned int lambda_variable = 0;
	if (first->type == hol_term_type::LAMBDA) {
		lambda_variable = first->quantifier.variable;
		first = first->quantifier.operand;
	} else if (first->type == hol_term_type::ANY) {
		unsigned int max_variable = 0;
		max_bound_variable(*first, max_variable);
		lambda_variable = ++max_variable;
	} else {
		return false;
	}
	if (!invert_apply_head(inverse, inverse_count, flags, first, second,
		predicative_head_finder<built_in_predicates>(lambda_variable), find_root, no_op(),
		[lambda_variable](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, const apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array) {
			array<hol_term*> new_heads(2);
			select_scope_arg_in_set<false, false, false, false, false>(new_heads, first_head, &HOL_NAME, second_head, max_variable, lambda_variable);
			if (new_heads.length == 0)
				return false;

			for (hol_term* new_head : new_heads) {
				if (!dst.ensure_capacity(dst.length + 2) || !dst_outer.ensure_capacity(dst_outer.length + 2)) {
					for (hol_term* term : new_heads) { free(*term); if (term->reference_count == 0) free(term); }
					return false;
				}

				hol_term* right = new_head->quantifier.operand->array.operands[new_head->quantifier.operand->array.length - 1];
				if (right->type == hol_term_type::UNARY_APPLICATION && right->binary.left->type == hol_term_type::CONSTANT && right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;
					continue;
				}

				hol_term* operand;
				if (right->type == hol_term_type::ANY_QUANTIFIER) {
					operand = right->any_quantifier.operand;
				} else if (right->type == hol_term_type::FOR_ALL || right->type == hol_term_type::EXISTS) {
					operand = right->quantifier.operand;
				} else {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;
					continue;
				}

				hol_term* inner_right;
				if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.right.length != 0) {
					inner_right = operand->any_array.right.operands[operand->any_array.right.length - 1];
				} else if (operand->type == hol_term_type::AND) {
					inner_right = operand->array.operands[operand->array.length - 1];
				} else if (operand->type == hol_term_type::IF_THEN) {
					inner_right = operand->binary.right;
				} else {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;
					continue;
				}

				if (inner_right->type == hol_term_type::UNARY_APPLICATION && inner_right->binary.left->type == hol_term_type::CONSTANT && inner_right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;
					continue;
				} else {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;

					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length] = hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ZERO);
					if (dst_outer[dst_outer.length] == nullptr) {
						free_all(new_heads);
						return false;
					}
					hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
					HOL_ZERO.reference_count++;
					dst_outer.length++;
				}
			}
			for (hol_term* term : new_heads) { free(*term); if (term->reference_count == 0) free(term); }
			return true;
		})) return false;
	for (unsigned int i = 0; i < inverse_count; i++) {
		hol_term* new_inverse = hol_term::new_lambda(lambda_variable, inverse[i].root);
		if (new_inverse == nullptr) {
			for (unsigned int j = 0; j < inverse_count; j++) free(inverse[j]);
			free(inverse); return false;
		}
		inverse[i].root = new_inverse;
	}
	return true;
}

inline bool invert_select_number_in_set(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	unsigned int lambda_variable = 0;
	if (first->type == hol_term_type::LAMBDA) {
		lambda_variable = first->quantifier.variable;
		first = first->quantifier.operand;
	} else if (first->type == hol_term_type::ANY) {
		unsigned int max_variable = 0;
		max_bound_variable(*first, max_variable);
		lambda_variable = ++max_variable;
	} else {
		return false;
	}
	if (!invert_apply_head(inverse, inverse_count, flags, first, second,
		predicative_head_finder<built_in_predicates>(lambda_variable), find_root, no_op(),
		[lambda_variable](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, const apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array) {
			if (second_head->type != hol_term_type::NUMBER)
				return false;

			array<hol_term*> new_heads(2);
			select_predicate_in_set<false, false, true, true, false>(new_heads, first_head, second_head, max_variable, lambda_variable);
			if (new_heads.length == 0)
				return false;

			for (hol_term* new_head : new_heads) {
				if (!dst.ensure_capacity(dst.length + 2) || !dst_outer.ensure_capacity(dst_outer.length + 2)) {
					for (hol_term* term : new_heads) { free(*term); if (term->reference_count == 0) free(term); }
					return false;
				}

				hol_term* right = new_head->quantifier.operand->array.operands[new_head->quantifier.operand->array.length - 1];
				if (right->type == hol_term_type::UNARY_APPLICATION && right->binary.left->type == hol_term_type::CONSTANT && right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;
					continue;
				}

				hol_term* operand;
				if (right->type == hol_term_type::ANY_QUANTIFIER) {
					operand = right->any_quantifier.operand;
				} else if (right->type == hol_term_type::FOR_ALL || right->type == hol_term_type::EXISTS) {
					operand = right->quantifier.operand;
				} else {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;
					continue;
				}

				hol_term* inner_right;
				if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.right.length != 0) {
					inner_right = operand->any_array.right.operands[operand->any_array.right.length - 1];
				} else if (operand->type == hol_term_type::AND) {
					inner_right = operand->array.operands[operand->array.length - 1];
				} else if (operand->type == hol_term_type::IF_THEN) {
					inner_right = operand->binary.right;
				} else {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;
					continue;
				}

				if (inner_right->type == hol_term_type::UNARY_APPLICATION && inner_right->binary.left->type == hol_term_type::CONSTANT && inner_right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;
					continue;
				} else {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;

					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length] = hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ZERO);
					if (dst_outer[dst_outer.length] == nullptr) {
						free_all(new_heads);
						return false;
					}
					hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
					HOL_ZERO.reference_count++;
					dst_outer.length++;
				}
			}
			for (hol_term* term : new_heads) { free(*term); if (term->reference_count == 0) free(term); }
			return true;
		})) return false;
	for (unsigned int i = 0; i < inverse_count; i++) {
		hol_term* new_inverse = hol_term::new_lambda(lambda_variable, inverse[i].root);
		if (new_inverse == nullptr) {
			for (unsigned int j = 0; j < inverse_count; j++) free(inverse[j]);
			free(inverse); return false;
		}
		inverse[i].root = new_inverse;
	}
	return true;
}

inline bool invert_mark_wide_scope(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	bool found_universal_quantifier = false;
	auto second_apply = [&found_universal_quantifier](hol_term* term) {
		found_universal_quantifier |= (term->type == hol_term_type::FOR_ALL || (term->type == hol_term_type::ANY_QUANTIFIER && term->any_quantifier.quantifier == hol_quantifier_type::FOR_ALL));
	};

	head_index second_predicate_index;
	auto head_finder = make_head_or_unary_application_finder<(unsigned int) built_in_predicates::WIDE_SCOPE>(find_head<built_in_predicates>);
	hol_term* second_head = find_head(second, second_predicate_index, head_finder, second_apply);
	if (second_head == nullptr || found_universal_quantifier)
		return false;

	while (second_head->type == hol_term_type::NOT)
		second_head = second_head->unary.operand;

	hol_term* new_head;
	if (second_head->type == hol_term_type::UNARY_APPLICATION && second_head->binary.left->type == hol_term_type::CONSTANT && second_head->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
		if (second_head->binary.right->type != hol_term_type::FOR_ALL)
			return false;
		new_head = second_head->binary.right;
		second_head->binary.right->reference_count++;
	} else if (second_head->type == hol_term_type::EXISTS) {
		new_head = second_head;
		second_head->reference_count++;
	} else {
		return false;
	}

	hol_term* new_term = substitute_head<any_node_position::NONE>(second, second_head, new_head);
	free(*new_head); if (new_head->reference_count == 0) free(new_head);
	if (new_term == nullptr)
		return false;

	inverse = (flagged_logical_form<hol_term>*) malloc(sizeof(flagged_logical_form<hol_term>) * 1);
	if (inverse == nullptr) {
		fprintf(stderr, "invert_mark_wide_scope ERROR: Out of memory.\n");
		return false;
	}
	inverse[0].flags = flags;
	inverse[0].root = new_term;
	inverse_count = 1;
	return true;
}

template<bool WideScope>
inline bool invert_require_narrow_or_wide_scope(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	unsigned int max_variable = 0;
	unsigned int lambda_variable = 0;
	if (first->type == hol_term_type::LAMBDA) {
		lambda_variable = first->quantifier.variable;
	} else if (first->type == hol_term_type::ANY) {
		max_bound_variable(*first, max_variable);
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	head_index predicate_index; no_op apply;
	predicative_head_finder<built_in_predicates> try_find_head(lambda_variable);
	hol_term* second_head = find_head(second, predicate_index, try_find_head, apply);
	if (second_head == nullptr)
		return false;

	if ((second_head->type == hol_term_type::ANY || second_head->type == hol_term_type::ANY_RIGHT) && second_head->any.included != nullptr)
		second_head = second_head->any.included;

#if !defined(NDEBUG)
	if (second_head->type != hol_term_type::EXISTS)
		fprintf(stderr, "invert_require_narrow_or_wide_scope WARNING: Expected `second_head` to be an existential quantification.\n");
#endif

	hol_term* operand = second_head->quantifier.operand;

	hol_term* last;
	if (operand->type == hol_term_type::ANY_ARRAY) {
		if (operand->any_array.right.length == 0) {
			fprintf(stderr, "invert_require_narrow_or_wide_scope ERROR: Expected an existentially quantified conjunction with a right-most operand.\n");
			return (hol_term*) nullptr;
		}
		last = operand->any_array.right.operands[operand->any_array.right.length - 1];
	} else if (operand->type == hol_term_type::AND) {
		last = operand->array.operands[operand->array.length - 1];
	} else {
		last = operand;
	}

	bool could_have_negation = false;
	unsigned int negation_count = 0;
	if ((last->type == hol_term_type::ANY || last->type == hol_term_type::ANY_RIGHT) && last->any.included != nullptr) {
		last = last->any.included;
		could_have_negation = true;
	} if (last->type == hol_term_type::UNARY_APPLICATION && last->binary.left->type == hol_term_type::CONSTANT && last->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
		last = last->binary.right;
		if (WideScope) {
			return intersect(inverse, inverse_count, flags, first, second);
		} else {
			return false;
		}
	}

	while (last->type == hol_term_type::NOT) {
		last = operand->unary.operand;
		negation_count++;
	}

	array<hol_term*> inverted_logical_forms(8);
	hol_term* expected_second;
	if (WideScope) {
		hol_term* any_wide_scope = hol_term::new_any_right(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ANY));
		if (any_wide_scope == nullptr)
			return false;
		hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
		HOL_ANY.reference_count++;

		hol_term* duplicate_wide_scopes = hol_term::new_any_right(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, any_wide_scope));
		if (duplicate_wide_scopes == nullptr) {
			free(*any_wide_scope); free(any_wide_scope);
			return false;
		}
		hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;

		hol_term* excluded_universal = hol_term::new_any_right(hol_term::new_any_quantifier(hol_quantifier_type::FOR_ALL, any_wide_scope));
		if (excluded_universal == nullptr) {
			free(*duplicate_wide_scopes); free(duplicate_wide_scopes);
			return false;
		}
		any_wide_scope->reference_count++;

		hol_term* expected_last;
		if ((last->type == hol_term_type::ANY || last->type == hol_term_type::ANY_RIGHT) && last->any.included != nullptr
		 && last->any.included->type == hol_term_type::UNARY_APPLICATION && last->any.included->binary.left->type == hol_term_type::VARIABLE
		 && last->any.included->binary.left->variable == lambda_variable)
		{
			expected_last = last;
			last->reference_count++;
			could_have_negation = true;
		} else {
			hol_term* inner_last;
			if (last->type == hol_term_type::AND && last->array.length == 2) {
				inner_last = last->array.operands[1];
			} else if (last->type == hol_term_type::FOR_ALL && last->quantifier.operand->type == hol_term_type::IF_THEN) {
				inner_last = last->quantifier.operand->binary.right;
			} else if (last->type == hol_term_type::EXISTS && last->quantifier.operand->type == hol_term_type::AND && last->quantifier.operand->array.length == 2) {
				inner_last = last->quantifier.operand->array.operands[1];
			} else if (last->type == hol_term_type::ANY_QUANTIFIER && last->any_quantifier.operand->type == hol_term_type::IF_THEN) {
				inner_last = last->quantifier.operand->binary.right;
			} else if (last->type == hol_term_type::ANY_QUANTIFIER && last->any_quantifier.operand->type == hol_term_type::AND && last->quantifier.operand->array.length == 2) {
				inner_last = last->quantifier.operand->array.operands[1];
			} else {
				free(*excluded_universal); free(excluded_universal);
				free(*duplicate_wide_scopes); free(duplicate_wide_scopes);
				return false;
			}

			if ((inner_last->type == hol_term_type::ANY || inner_last->type == hol_term_type::ANY_RIGHT) && inner_last->any.included != nullptr) {
				expected_last = substitute_head<any_node_position::NONE>(last, inner_last, inner_last->any.included);
			} else {
				expected_last = last;
				last->reference_count++;
			}
		}

		if (could_have_negation) {
			hol_term* temp = hol_term::new_any_right(expected_last);
			if (temp == nullptr) {
				free(*excluded_universal); free(excluded_universal);
				free(*duplicate_wide_scopes); free(duplicate_wide_scopes);
				free(*expected_last); if (expected_last->reference_count == 0) free(expected_last);
				return false;
			}
			expected_last = temp;
		} for (unsigned int i = 0; i < negation_count; i++) {
			hol_term* temp = hol_term::new_not(expected_last);
			if (temp == nullptr) {
				free(*excluded_universal); free(excluded_universal);
				free(*duplicate_wide_scopes); free(duplicate_wide_scopes);
				free(*expected_last); if (expected_last->reference_count == 0) free(expected_last);
				return false;
			}
			expected_last = temp;
		}

		hol_term* excluded_trees[2];
		excluded_trees[0] = excluded_universal;
		excluded_trees[1] = duplicate_wide_scopes;
		expected_second = hol_term::new_any_right(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, expected_last), excluded_trees, 2);
		if (expected_second == nullptr) {
			free(*excluded_trees[0]); free(excluded_trees[0]);
			free(*excluded_trees[1]); free(excluded_trees[1]);
			free(*expected_last); if (expected_last->reference_count == 0) free(expected_last);
			return false;
		}
		hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
	} else {
		hol_term* wide_scope = hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ANY);
		if (wide_scope == nullptr) return false;
		hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
		HOL_ANY.reference_count++;
		expected_second = hol_term::new_any_right(nullptr, &wide_scope, 1);
		if (expected_second == nullptr) {
			free(*wide_scope); free(wide_scope);
			return false;
		}
	}

	array<hol_term*> intersection(4);
	intersect<built_in_predicates>(intersection, second, expected_second);
	free(*expected_second); if (expected_second->reference_count == 0) free(expected_second);

	for (hol_term* new_second : intersection)
		intersect<built_in_predicates>(inverted_logical_forms, first, new_second);
	free_all(intersection);

	if (inverted_logical_forms.length == 0)
		return false;

	inverse = (flagged_logical_form<hol_term>*) malloc(sizeof(flagged_logical_form<hol_term>) * inverted_logical_forms.length);
	for (unsigned int i = 0; i < inverted_logical_forms.length; i++) {
		inverse[i].flags = flags;
		inverse[i].root = inverted_logical_forms[i];
	}
	inverse_count = inverted_logical_forms.length;
	return true;
}

inline bool invert_remove_wide_scope(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	hol_term* excluding_term = nullptr;
	unsigned int excluded_tree_index;
	auto second_apply = [&excluding_term,&excluded_tree_index](hol_term* term) {
		if (term->type == hol_term_type::ANY || term->type == hol_term_type::ANY_RIGHT) {
			for (unsigned int i = 0; i < term->any.excluded_tree_count; i++) {
				hol_term* excluded = term->any.excluded_trees[i];
				if ((excluded->type == hol_term_type::ANY || excluded->type == hol_term_type::ANY_RIGHT) && excluded->any.included != nullptr && excluded->any.included->type == hol_term_type::UNARY_APPLICATION
				 && excluded->any.included->binary.left->type == hol_term_type::CONSTANT && excluded->any.included->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE
				 && (excluded->any.included->binary.right->type == hol_term_type::ANY || excluded->any.included->binary.right->type == hol_term_type::ANY_RIGHT)
				 && excluded->any.included->binary.right->any.included == nullptr)
				{
					excluding_term = term;
					excluded_tree_index = i;
					break;
				}
			}
		}
	};

	head_index predicate_index; no_op first_apply;
	auto find_array_head = make_array_finder(find_head<built_in_predicates>);
	hol_term* first_head = find_head(first, predicate_index, find_array_head, first_apply);
	if (first_head == nullptr)
		return false;
	hol_term* second_head = find_head(second, predicate_index, find_array_head, second_apply);
	if (second_head == nullptr)
		return false;

	hol_term* new_second;
	if (excluding_term != nullptr) {
		hol_term** new_excluded_trees;
		if (excluding_term->any.excluded_tree_count == 1) {
			new_excluded_trees = nullptr;
		} else {
			new_excluded_trees = (hol_term**) malloc(sizeof(hol_term*) * (excluding_term->any.excluded_tree_count - 1));
			if (new_excluded_trees == nullptr) {
				fprintf(stderr, "invert_remove_wide_scope ERROR: Out of memory.\n");
				return false;
			}
			unsigned int index = 0;
			for (unsigned int i = 0; i < excluding_term->any.excluded_tree_count; i++)
				if (i != excluded_tree_index) new_excluded_trees[index++] = excluding_term->any.excluded_trees[i];
		}

		hol_term* new_term;
		if (!new_hol_term(new_term)) {
			free(new_excluded_trees);
			return false;
		}
		new_term->type = excluding_term->type;
		new_term->reference_count = 1;
		new_term->any.included = excluding_term->any.included;
		new_term->any.included->reference_count++;
		new_term->any.excluded_trees = new_excluded_trees;
		new_term->any.excluded_tree_count = excluding_term->any.excluded_tree_count - 1;
		for (unsigned int i = 0; i < new_term->any.excluded_tree_count; i++)
			new_excluded_trees[i]->reference_count++;

		new_second = substitute_head<any_node_position::NONE>(second, excluding_term, new_term);
		free(*new_term); if (new_term->reference_count == 0) free(new_term);
		if (new_second == nullptr) {
			free(*new_term); free(new_term);
			return false;
		}
	} else {
		new_second = second;
		second->reference_count++;
	}

	if (second_head->type == hol_term_type::ANY_RIGHT && second_head->any.included != nullptr)
		second_head = second_head->any.included;

	hol_term* second_outer = substitute_head<any_node_position::LEFT>(new_second, second_head, &HOL_ZERO, true);
	free(*new_second); if (new_second->reference_count == 0) free(new_second);
	if (second_outer == nullptr)
		return false;

	hol_term* any_wide_scope = hol_term::new_any_right(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ANY));
	if (any_wide_scope == nullptr) {
		free(*second_outer); if (second_outer->reference_count == 0) free(second_outer);
		return false;
	}
	hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
	HOL_ANY.reference_count++;

	hol_term* duplicate_wide_scopes = hol_term::new_any_right(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, any_wide_scope));
	if (duplicate_wide_scopes == nullptr) {
		free(*second_outer); if (second_outer->reference_count == 0) free(second_outer);
		free(*any_wide_scope); free(any_wide_scope);
		return false;
	}
	hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;

	hol_term* excluded_universal = hol_term::new_any_right(hol_term::new_any_quantifier(hol_quantifier_type::FOR_ALL, any_wide_scope));
	if (excluded_universal == nullptr) {
		free(*second_outer); if (second_outer->reference_count == 0) free(second_outer);
		free(*duplicate_wide_scopes); free(duplicate_wide_scopes);
		return false;
	}
	any_wide_scope->reference_count++;

	hol_term* excluded_trees[2];
	excluded_trees[0] = excluded_universal;
	excluded_trees[1] = duplicate_wide_scopes;
	hol_term* wide_scope = hol_term::new_any_right(hol_term::new_apply(
				&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value,
				hol_term::new_any_right(&HOL_ZERO)),
			excluded_trees, 2);
	if (wide_scope == nullptr) {
		free(*second_outer); if (second_outer->reference_count == 0) free(second_outer);
		free(*duplicate_wide_scopes); if (duplicate_wide_scopes->reference_count == 0) free(duplicate_wide_scopes);
		free(*excluded_universal); if (excluded_universal->reference_count == 0) free(excluded_universal);
		return false;
	}
	hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
	HOL_ZERO.reference_count++;

	array<hol_term*> intersection(4);
	intersect<built_in_predicates>(intersection, second_outer, wide_scope);
	free(*wide_scope); if (wide_scope->reference_count == 0) free(wide_scope);

	/* also consider the possibility that there is no universal quantifier */
	hol_term* any_right_universal = hol_term::new_any_right(hol_term::new_any_quantifier(hol_quantifier_type::FOR_ALL, &HOL_ANY));
	if (any_right_universal == nullptr) {
		free(*second_outer); if (second_outer->reference_count == 0) free(second_outer);
		free_all(intersection); return false;
	}
	HOL_ANY.reference_count++;

	hol_term* no_wide_scope = hol_term::new_any_right(&HOL_ZERO, &any_right_universal, 1);
	if (no_wide_scope == nullptr) {
		free(*second_outer); if (second_outer->reference_count == 0) free(second_outer);
		free(*any_right_universal); if (any_right_universal->reference_count == 0) free(any_right_universal);
		free_all(intersection); return false;
	}
	HOL_ZERO.reference_count++;

	intersect<built_in_predicates>(intersection, second_outer, no_wide_scope);
	free(*second_outer); if (second_outer->reference_count == 0) free(second_outer);
	free(*no_wide_scope); if (no_wide_scope->reference_count == 0) free(no_wide_scope);
	if (intersection.length == 0)
		return false;

	hol_term* first_outer = substitute_head<any_node_position::NONE>(first, first_head, &HOL_ZERO);
	if (first_outer == nullptr) {
		free_all(intersection);
		return false;
	}

	if (first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) {
		hol_term* new_first_outer = hol_term::new_any_right(first_outer, first_head->any.excluded_trees, first_head->any.excluded_tree_count);
		if (new_first_outer == nullptr) {
			free(*first_outer); if (first_outer->reference_count == 0) free(first_outer);
			free_all(intersection); return false;
		}
		for (unsigned int i = 0; i < first_head->any.excluded_tree_count; i++)
			first_head->any.excluded_trees[i]->reference_count++;
		first_outer = new_first_outer;
	}

	array<hol_term*> inverted_logical_forms(intersection.length);
	for (hol_term* term : intersection) {
		hol_term* new_outer = remove_any_nodes(term, find_zero);
		if (new_outer == nullptr) {
			free(*first_outer); if (first_outer->reference_count == 0) free(first_outer);
			free_all(inverted_logical_forms); free_all(intersection);
			return false;
		}

		array<hol_term*> new_intersection(4);
		intersect<built_in_predicates>(new_intersection, first_outer, new_outer);
		free(*new_outer); if (new_outer->reference_count == 0) free(new_outer);
		if (!inverted_logical_forms.ensure_capacity(inverted_logical_forms.length + new_intersection.length)) {
			free(*first_outer); if (first_outer->reference_count == 0) free(first_outer);
			free_all(inverted_logical_forms); free_all(new_intersection); free_all(intersection);
			return false;
		}
		for (hol_term* merged_outer : new_intersection) {
			hol_term* new_term = substitute_head<any_node_position::NONE>(merged_outer, &HOL_ZERO, second_head);
			if (new_term == nullptr) {
				free(*first_outer); if (first_outer->reference_count == 0) free(first_outer);
				free_all(inverted_logical_forms); free_all(new_intersection); free_all(intersection);
				return false;
			}
			inverted_logical_forms[inverted_logical_forms.length++] = new_term;
		}
		free_all(new_intersection);
	}
	free(*first_outer); if (first_outer->reference_count == 0) free(first_outer);
	free_all(intersection);

	inverse = (flagged_logical_form<hol_term>*) malloc(sizeof(flagged_logical_form<hol_term>) * inverted_logical_forms.length);
	for (unsigned int i = 0; i < inverted_logical_forms.length; i++) {
		inverse[i].flags = flags;
		inverse[i].root = inverted_logical_forms[i];
	}
	inverse_count = inverted_logical_forms.length;
	return true;
}

inline bool invert_require_string_or_number_in_set(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	unsigned int lambda_variable = 0;
	if (first->type == hol_term_type::LAMBDA) {
		lambda_variable = first->quantifier.variable;
		first = first->quantifier.operand;
	} else if (first->type == hol_term_type::ANY) {
		unsigned int max_variable = 0;
		max_bound_variable(*first, max_variable);
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	if (second->type == hol_term_type::LAMBDA)
		second = second->quantifier.operand;

	if (!invert_apply_head(inverse, inverse_count, flags, first, second,
		predicative_head_finder<built_in_predicates>(lambda_variable), predicative_head_finder<built_in_predicates>(lambda_variable), no_op(),
		[lambda_variable](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, const apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array) {
			array<hol_term*> new_heads(2);
			select_predicate_in_set<false, false, true, true, false>(new_heads, second_head, &HOL_ANY, max_variable, lambda_variable);
			if (new_heads.length == 0)
				return false;

			if (!dst.ensure_capacity(dst.length + 2 * new_heads.length) || !dst_outer.ensure_capacity(dst_outer.length + 2 * new_heads.length)) {
				free_all(new_heads);
				return false;
			}
			for (hol_term* new_head : new_heads) {
				hol_term* left = new_head->quantifier.operand->array.operands[0];
				hol_term* set_definition = left->binary.right->quantifier.operand;
				if (set_definition->binary.right->type != hol_term_type::STRING && set_definition->binary.right->type != hol_term_type::NUMBER)
					continue;

				hol_term* right = new_head->quantifier.operand->array.operands[new_head->quantifier.operand->array.length - 1];
				if (right->type == hol_term_type::UNARY_APPLICATION && right->binary.left->type == hol_term_type::CONSTANT && right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;
					continue;
				}

				hol_term* operand;
				if (right->type == hol_term_type::ANY_QUANTIFIER) {
					operand = right->any_quantifier.operand;
				} else if (right->type == hol_term_type::FOR_ALL || right->type == hol_term_type::EXISTS) {
					operand = right->quantifier.operand;
				} else {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;
					continue;
				}

				hol_term* inner_right;
				if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.right.length != 0) {
					inner_right = operand->any_array.right.operands[operand->any_array.right.length - 1];
				} else if (operand->type == hol_term_type::AND) {
					inner_right = operand->array.operands[operand->array.length - 1];
				} else if (operand->type == hol_term_type::IF_THEN) {
					inner_right = operand->binary.right;
				} else {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;
					continue;
				}

				if (inner_right->type == hol_term_type::UNARY_APPLICATION && inner_right->binary.left->type == hol_term_type::CONSTANT && inner_right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;
					continue;
				} else {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;

					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length] = hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ZERO);
					if (dst_outer[dst_outer.length] == nullptr) {
						free_all(new_heads);
						return false;
					}
					hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
					HOL_ZERO.reference_count++;
					dst_outer.length++;
				}
			}
			for (hol_term* term : new_heads) { free(*term); if (term->reference_count == 0) free(term); }
			return true;
		})) return false;
	for (unsigned int i = 0; i < inverse_count; i++) {
		hol_term* new_inverse = hol_term::new_lambda(lambda_variable, inverse[i].root);
		if (new_inverse == nullptr) {
			for (unsigned int j = 0; j < inverse_count; j++) free(inverse[j]);
			free(inverse); return false;
		}
		inverse[i].root = new_inverse;
	}
	return true;
}

inline bool invert_require_no_string_or_number_or_name_in_set(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	unsigned int lambda_variable = 0;
	if (first->type == hol_term_type::LAMBDA) {
		lambda_variable = first->quantifier.variable;
		first = first->quantifier.operand;
	} else if (first->type == hol_term_type::ANY) {
		unsigned int max_variable = 0;
		max_bound_variable(*first, max_variable);
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	if (second->type == hol_term_type::LAMBDA)
		second = second->quantifier.operand;

	if (!invert_apply_head(inverse, inverse_count, flags, first, second,
		predicative_head_finder<built_in_predicates>(lambda_variable), predicative_head_finder<built_in_predicates>(lambda_variable), no_op(),
		[lambda_variable](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, const apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array) {
			array<hol_term*> new_heads(2);
			select_predicate_in_set<false, false, true, true, false>(new_heads, second_head, &HOL_ANY, max_variable, lambda_variable);
			if (new_heads.length == 0)
				return false;

			if (!dst.ensure_capacity(dst.length + 2 * new_heads.length) || !dst_outer.ensure_capacity(dst_outer.length + 2 * new_heads.length)) {
				free_all(new_heads);
				return false;
			}
			for (hol_term* new_head : new_heads) {
				hol_term* left = new_head->quantifier.operand->array.operands[0];
				hol_term* set_definition = left->binary.right->quantifier.operand;
				if (set_definition->binary.right->type != hol_term_type::STRING && set_definition->binary.right->type != hol_term_type::NUMBER)
					continue;

				hol_term* right = new_head->quantifier.operand->array.operands[new_head->quantifier.operand->array.length - 1];
				if (right->type == hol_term_type::UNARY_APPLICATION && right->binary.left->type == hol_term_type::CONSTANT && right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;
					continue;
				}

				hol_term* operand;
				if (right->type == hol_term_type::ANY_QUANTIFIER) {
					operand = right->any_quantifier.operand;
				} else if (right->type == hol_term_type::FOR_ALL || right->type == hol_term_type::EXISTS) {
					operand = right->quantifier.operand;
				} else {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;
					continue;
				}

				hol_term* inner_right;
				if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.right.length != 0) {
					inner_right = operand->any_array.right.operands[operand->any_array.right.length - 1];
				} else if (operand->type == hol_term_type::AND) {
					inner_right = operand->array.operands[operand->array.length - 1];
				} else if (operand->type == hol_term_type::IF_THEN) {
					inner_right = operand->binary.right;
				} else {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;
					continue;
				}

				if (inner_right->type == hol_term_type::UNARY_APPLICATION && inner_right->binary.left->type == hol_term_type::CONSTANT && inner_right->binary.left->constant == (unsigned int) built_in_predicates::WIDE_SCOPE) {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;
					continue;
				} else {
					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length++] = &HOL_ZERO;
					HOL_ZERO.reference_count++;

					dst[dst.length++] = new_head;
					new_head->reference_count++;
					dst_outer[dst_outer.length] = hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ZERO);
					if (dst_outer[dst_outer.length] == nullptr) {
						free_all(new_heads);
						return false;
					}
					hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
					HOL_ZERO.reference_count++;
					dst_outer.length++;
				}
			}
			for (hol_term* term : new_heads) { free(*term); if (term->reference_count == 0) free(term); }
			return true;
		})) return false;
	for (unsigned int i = 0; i < inverse_count; i++) {
		hol_term* new_inverse = hol_term::new_lambda(lambda_variable, inverse[i].root);
		if (new_inverse == nullptr) {
			for (unsigned int j = 0; j < inverse_count; j++) free(inverse[j]);
			free(inverse); return false;
		}
		inverse[i].root = new_inverse;
	}
	return true;
}

inline bool invert_size(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	unsigned int head_variable;
	if (first->type == hol_term_type::EXISTS) {
		head_variable = first->quantifier.variable;
	} else if ((first->type == hol_term_type::ANY || first->type == hol_term_type::ANY_RIGHT) && first->any.included != nullptr && first->any.included->type == hol_term_type::EXISTS) {
		first = first->any.included;
		head_variable = first->quantifier.variable;
	} else {
		head_variable = 1;
	}

	if (second->type == hol_term_type::NUMBER) {
		if (second->number.decimal != 0) {
			return false;
		} else if (second->number.integer == 1 && second->number.decimal == 0) {
			if (!intersect(flags.index_number, grammatical_num::SINGULAR, flags.index_number))
				return false;
		} else {
			if (!intersect(flags.index_number, grammatical_num::PLURAL, flags.index_number))
				return false;
		}
	}

	hol_term* expected_head = hol_term::new_exists(head_variable, hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::SIZE>::value, hol_term::new_variable(head_variable)), second));
	if (expected_head == nullptr)
		return false;
	hol_term::constants<(unsigned int) built_in_predicates::SIZE>::value.reference_count++;
	second->reference_count++;

	array<hol_term*> inverted_logical_forms(2);
	intersect<built_in_predicates>(inverted_logical_forms, first, expected_head);
	free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
	if (inverted_logical_forms.length == 0)
		return false;

	inverse = (flagged_logical_form<hol_term>*) malloc(sizeof(flagged_logical_form<hol_term>) * inverted_logical_forms.length);
	for (unsigned int i = 0; i < inverted_logical_forms.length; i++) {
		inverse[i].flags = flags;
		inverse[i].root = inverted_logical_forms[i];
	}
	inverse_count = inverted_logical_forms.length;
	return true;
}

template<unsigned int Arg, int_fast8_t ArgIndex>
inline bool invert_arg_function(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	unsigned int head_variable;
	if (first->type == hol_term_type::EXISTS) {
		head_variable = first->quantifier.variable;
	} else if ((first->type == hol_term_type::ANY || first->type == hol_term_type::ANY_RIGHT) && first->any.included != nullptr && first->any.included->type == hol_term_type::EXISTS) {
		first = first->any.included;
		head_variable = first->quantifier.variable;
	} else {
		head_variable = 1;
	}

	if (second->type == hol_term_type::NUMBER) {
		if (second->number.integer == 1 && second->number.decimal == 0) {
			if (!intersect(flags.index_number, grammatical_num::SINGULAR, flags.index_number))
				return false;
		} else {
			if (!intersect(flags.index_number, grammatical_num::PLURAL, flags.index_number))
				return false;
		}
	}

	hol_term* head_var = hol_term::new_variable(head_variable);
	if (head_var == nullptr) return false;
	constexpr unsigned int excluded_tree_count = 2;
	hol_term* excluded_trees[excluded_tree_count];
	excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
				(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
				(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
			&HOL_ANY), head_var));
	excluded_trees[1] = hol_term::new_any(hol_term::new_exists(head_variable, &HOL_ANY));
	if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
	if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
	if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr) {
		if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
		free(*head_var); free(head_var);
		return false;
	}

	hol_term* conjunct = hol_term::new_any(nullptr, excluded_trees, excluded_tree_count);
	if (conjunct == nullptr) {
		for (unsigned int i = 0; i < excluded_tree_count; i++) { free(*excluded_trees[i]); free(excluded_trees[i]); }
		free(*head_var); free(head_var);
		return false;
	}

	hol_term* expected_arg = hol_term::new_equals(hol_term::new_apply(&hol_term::constants<Arg>::value, head_var), second);
	if (expected_arg == nullptr) {
		free(*head_var); free(head_var);
		free(*conjunct); free(conjunct);
		return false;
	}
	hol_term::constants<Arg>::value.reference_count++;
	second->reference_count++;

	hol_term* expected_head;
	if (ArgIndex >= 0) {
		expected_head = hol_term::new_exists(head_variable, hol_term::new_any_array(
				hol_term_type::AND, conjunct, make_array_view((hol_term**) nullptr, 0),
				make_appended_array_view(make_repeated_array_view(conjunct, ArgIndex), expected_arg),
				make_array_view((hol_term**) nullptr, 0)));
		if (expected_head == nullptr) {
			free(*expected_arg); free(expected_arg);
			free(*conjunct); free(conjunct);
			free(*head_var); free(head_var);
			return false;
		}
		conjunct->reference_count += ArgIndex + 1 - 1;
	} else {
		unsigned int index = (unsigned int) (-ArgIndex) - 1;
		expected_head = hol_term::new_exists(head_variable, hol_term::new_any_array(hol_term_type::AND, conjunct,
				make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0),
				make_prepended_array_view(expected_arg, make_repeated_array_view(conjunct, index))));
		if (expected_head == nullptr) {
			free(*expected_arg); free(expected_arg);
			free(*conjunct); free(conjunct);
			free(*head_var); free(head_var);
			return false;
		}
		conjunct->reference_count += index;
	}

	array<hol_term*> inverted_logical_forms(2);
	intersect<built_in_predicates>(inverted_logical_forms, first, expected_head);
	free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
	if (inverted_logical_forms.length == 0)
		return false;

	inverse = (flagged_logical_form<hol_term>*) malloc(sizeof(flagged_logical_form<hol_term>) * inverted_logical_forms.length);
	for (unsigned int i = 0; i < inverted_logical_forms.length; i++) {
		inverse[i].flags = flags;
		inverse[i].root = inverted_logical_forms[i];
	}
	inverse_count = inverted_logical_forms.length;
	return true;
}

inline bool invert_set_size(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	unsigned int lambda_variable = 0;
	if (first->type == hol_term_type::LAMBDA) {
		lambda_variable = first->quantifier.variable;
		first = first->quantifier.operand;
	} else if (first->type == hol_term_type::ANY) {
		unsigned int max_variable = 0;
		max_bound_variable(*first, max_variable);
		lambda_variable = ++max_variable;
	} else {
		return false;
	}
	bool result = invert_apply_head(inverse, inverse_count, flags, first, second,
		predicative_head_finder<built_in_predicates>(lambda_variable), find_root, no_op(),
		[lambda_variable](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, const apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array) {
			if ((first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) && first_head->any.included != nullptr)
				first_head = first_head->any.included;

			hol_term* left = nullptr;
			unsigned int set_variable, set_definition_variable, element_variable = 0;
			if (first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) {
				set_variable = ++max_variable;
				element_variable = ++max_variable;
				set_definition_variable = element_variable;
			} else {
#if !defined(NDEBUG)
				if (first_head->type != hol_term_type::EXISTS) {
					fprintf(stderr, "invert_set_size ERROR: Expected existential quantification of set.\n");
					return false;
				}
#endif
				set_variable = first_head->quantifier.variable;
				hol_term* operand = first_head->quantifier.operand;

				if (operand->type == hol_term_type::ANY || operand->type == hol_term_type::ANY_RIGHT) {
					set_definition_variable = 0;
				} else if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
					if (operand->any_array.left.length == 0) {
						left = operand->any_array.all;
					} else {
						left = operand->any_array.left.operands[0];
					}
				} else if (operand->type == hol_term_type::AND) {
					left = operand->array.operands[0];
				} else {
					return false;
				}

				hol_term* set_definition = nullptr;
				if (left != nullptr) {
					if (left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT) {
						set_definition_variable = 0;
					} else if (left->type == hol_term_type::EQUALS) {
						set_definition = left->binary.right;
					} else if (left->type == hol_term_type::BINARY_APPLICATION) {
						set_definition = left->ternary.third;
					} else {
						return false;
					}
				}

				if (set_definition != nullptr) {
					if (set_definition->type == hol_term_type::ANY || set_definition->type == hol_term_type::ANY_RIGHT) {
						set_definition_variable = 0;
					} else if (set_definition->type == hol_term_type::ANY_QUANTIFIER && has_intersection(set_definition->any_quantifier.quantifier, hol_quantifier_type::LAMBDA)) {
						set_definition_variable = 0;
					} else if (set_definition->type == hol_term_type::LAMBDA) {
						set_definition_variable = set_definition->quantifier.variable;
					} else {
						return false;
					}
				}

				hol_term* right = nullptr;
				if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
					if (operand->any_array.right.length == 0) {
						right = operand->any_array.all;
					} else {
						right = operand->any_array.right.operands[operand->any_array.right.length - 1];
					}
				} else if (operand->type == hol_term_type::AND) {
					right = operand->array.operands[operand->array.length - 1];
				} else {
					element_variable = set_definition_variable;
				}

				if (right != nullptr) {
					if ((right->type == hol_term_type::ANY || right->type == hol_term_type::ANY_RIGHT) && right->any.included != nullptr)
						right = right->any.included;
					if (right->type == hol_term_type::NOT)
						right = right->unary.operand;

					hol_term* lambda_application = nullptr;
					if (right->type == hol_term_type::FOR_ALL && right->quantifier.operand->type == hol_term_type::IF_THEN) {
						lambda_application = right->quantifier.operand->binary.right;
					} else if (right->type == hol_term_type::EXISTS && right->quantifier.operand->type == hol_term_type::AND && right->quantifier.operand->array.length == 2) {
						lambda_application = right->quantifier.operand->array.operands[1];
					} else if (right->type == hol_term_type::AND && right->array.length == 2) {
						lambda_application = right->array.operands[1];
					} else {
						lambda_application = right;
					}

					if ((lambda_application->type == hol_term_type::ANY || lambda_application->type == hol_term_type::ANY_RIGHT) && lambda_application->any.included != nullptr)
						lambda_application = lambda_application->any.included;

					if (lambda_application->type == hol_term_type::UNARY_APPLICATION
						&& lambda_application->binary.left->type == hol_term_type::VARIABLE
						&& lambda_application->binary.left->variable == lambda_variable
						&& lambda_application->binary.right->type == hol_term_type::VARIABLE)
					{
						element_variable = lambda_application->binary.right->variable;
					} else {
						return false;
					}
				}
			}

			if (set_definition_variable == 0) {
				if (element_variable == 0)
					element_variable = ++max_variable;
				set_definition_variable = element_variable;
			}

			hol_term* set_var = hol_term::new_variable(set_variable);
			if (set_var == nullptr)
				return false;

			hol_term* excluded_quantifiers[3];
			excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(set_variable, &HOL_ANY));
			excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(set_variable, &HOL_ANY));
			excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(set_variable, &HOL_ANY));
			if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
			if (excluded_quantifiers[1] != nullptr) HOL_ANY.reference_count++;
			if (excluded_quantifiers[2] != nullptr) HOL_ANY.reference_count++;
			if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr) {
				if (excluded_quantifiers[0] != nullptr) { free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]); }
				if (excluded_quantifiers[1] != nullptr) { free(*excluded_quantifiers[1]); free(excluded_quantifiers[1]); }
				free(*set_var); free(set_var);
				return false;
			}

#if !defined(NDEBUG)
			if (second_head->type != hol_term_type::NUMBER) {
				fprintf(stderr, "invert_set_size ERROR: Expected number.\n");
				free(*set_var); free(set_var); return false;
			}
#endif

			hol_term* element_var = hol_term::new_variable(element_variable);
			if (element_var == nullptr) {
				free(*set_var); free(set_var);
				return false;
			}

			hol_term* expected_quantifier;
			if (second_head->number.integer == 1 && second_head->number.decimal == 0) {
				expected_quantifier = hol_term::new_any_right(hol_term::new_exists(element_variable, hol_term::new_and(
							hol_term::new_apply(set_var, element_var),
							hol_term::new_apply(hol_term::new_variable(lambda_variable), element_var)
						)), excluded_quantifiers, array_length(excluded_quantifiers));
			} else {
				expected_quantifier = hol_term::new_any_right(hol_term::new_for_all(element_variable, hol_term::new_if_then(
							hol_term::new_apply(set_var, element_var),
							hol_term::new_apply(hol_term::new_variable(lambda_variable), element_var)
						)), excluded_quantifiers, array_length(excluded_quantifiers));
			}
			if (expected_quantifier == nullptr) {
				for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
				free(*set_var); free(set_var);
				free(*element_var); free(element_var);
				return false;
			}
			element_var->reference_count += 2 - 1;

			array<hol_term*> expected_lefts(2);
			if (left == nullptr || left->type == hol_term_type::EQUALS || left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT) {
				expected_lefts[expected_lefts.length] = hol_term::new_equals(set_var, hol_term::new_lambda(set_definition_variable, hol_term::new_true()));
				if (expected_lefts[expected_lefts.length] == nullptr) {
					free(*expected_quantifier); free(expected_quantifier);
					return false;
				}
				set_var->reference_count++;
				expected_lefts.length++;
			} if (left == nullptr || left->type == hol_term_type::BINARY_APPLICATION || left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT) {
				expected_lefts[expected_lefts.length] = hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::SUBSET>::value, set_var, hol_term::new_lambda(set_definition_variable, hol_term::new_true()));
				if (expected_lefts[expected_lefts.length] == nullptr) {
					free(*expected_quantifier); free(expected_quantifier);
					return false;
				}
				hol_term::constants<(unsigned int) built_in_predicates::SUBSET>::value.reference_count++;
				set_var->reference_count++;
				expected_lefts.length++;
			}

			if (!dst.ensure_capacity(dst.length + expected_lefts.length) || !dst_outer.ensure_capacity(dst_outer.length + expected_lefts.length)) {
				free_all(expected_lefts);
				free(*expected_quantifier); free(expected_quantifier);
				return false;
			}
			for (hol_term* expected_left : expected_lefts) {
				dst[dst.length] = hol_term::new_exists(set_variable, hol_term::new_and(
						expected_left,
						hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::SIZE>::value, set_var), second_head),
						expected_quantifier));
				if (dst[dst.length] == nullptr) {
					free_all(dst); free_all(expected_lefts);
					free(*expected_quantifier); free(expected_quantifier);
					return false;
				}
				expected_left->reference_count++;
				set_var->reference_count++;
				expected_quantifier->reference_count++;
				hol_term::constants<(unsigned int) built_in_predicates::SIZE>::value.reference_count++;
				second_head->reference_count++;
				dst.length++;

				dst_outer[dst_outer.length++] = &HOL_ZERO;
				HOL_ZERO.reference_count++;
			}
			free_all(expected_lefts);
			free(*expected_quantifier); if (expected_quantifier->reference_count == 0) free(expected_quantifier);
			return true;
		});
	if (!result) return false;
	for (unsigned int i = 0; i < inverse_count; i++) {
		hol_term* new_inverse = hol_term::new_lambda(lambda_variable, inverse[i].root);
		if (new_inverse == nullptr) {
			for (unsigned int j = 0; j < inverse_count; j++) free(inverse[j]);
			free(inverse); return false;
		}
		inverse[i].root = new_inverse;
	}
	return true;
}

inline bool invert_require_lambda(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	unsigned int lambda_variable = second->quantifier.variable;
	hol_term* expected_operand = hol_term::new_any(hol_term::new_variable(lambda_variable));
	if (expected_operand == nullptr) return false;

	array<hol_term*> intersection(2);
	intersect<built_in_predicates>(intersection, second->quantifier.operand, expected_operand);
	free(*expected_operand); if (expected_operand->reference_count == 0) free(expected_operand);
	if (intersection.length == 0)
		return false;
	for (unsigned int i = 0; i < intersection.length; i++) {
		hol_term* temp = hol_term::new_lambda(lambda_variable, intersection[i]);
		if (temp == nullptr) {
			free_all(intersection);
			return false;
		}
		intersection[i] = temp;
	}

	inverse = (flagged_logical_form<hol_term>*) malloc(sizeof(flagged_logical_form<hol_term>) * intersection.length);
	if (inverse == nullptr) {
		free_all(intersection);
		return false;
	}
	for (unsigned int i = 0; i < intersection.length; i++) {
		inverse[i].flags = flags;
		inverse[i].root = intersection[i];
	}
	inverse_count = intersection.length;
	return true;
}

template<typename FindHeadFunction>
inline bool invert_factor(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second,
		FindHeadFunction find_head_function)
{
	head_index first_predicate_index, second_predicate_index; no_op apply;
	auto find_array_head = make_array_finder(find_head_function);
	hol_term* first_head = find_head(first, first_predicate_index, find_array_head, apply);
	hol_term* second_head = find_head(second, second_predicate_index, find_head_function, apply);
	if (first_head == nullptr || second_head == nullptr)
		return false;

	if (first_head->type != hol_term_type::ANY && first_head->type != hol_term_type::ANY_RIGHT
	 && first_head->type != hol_term_type::ANY_ARRAY && first_head->type != hol_term_type::AND
	 && first_head->type != hol_term_type::OR)
	{
		return intersect(inverse, inverse_count, flags, first, second);
	}

	hol_term* new_second_head = hol_term::new_any_array(hol_term_type::ANY_ARRAY, second_head,
			make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0));
	if (new_second_head == nullptr)
		return false;
	second_head->reference_count++;

	array<hol_term*> new_heads(4);
	intersect<built_in_predicates>(new_heads, first_head, new_second_head);
	free(*new_second_head); if (new_second_head->reference_count == 0) free(new_second_head);
	if (new_heads.length == 0)
		return false;

	array<hol_term*> intersection(new_heads.length);
	for (hol_term* new_head : new_heads) {
		intersection[intersection.length] = substitute_head<any_node_position::NONE>(second, second_head, new_head);
		if (intersection[intersection.length] == nullptr) {
			free_all(new_heads); free_all(intersection);
			return false;
		}
		intersection.length++;
	}
	free_all(new_heads);

	inverse = (flagged_logical_form<hol_term>*) malloc(sizeof(flagged_logical_form<hol_term>) * intersection.length);
	if (inverse == nullptr) {
		free_all(intersection);
		return false;
	}
	for (unsigned int i = 0; i < intersection.length; i++) {
		inverse[i].flags = flags;
		inverse[i].root = intersection[i];
	}
	inverse_count = intersection.length;
	return true;
}

inline bool invert_factor(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	return invert_factor(inverse, inverse_count, flags, first, second, find_head<built_in_predicates>);
}

inline bool invert_factor_predicative(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	unsigned int max_variable = 0;
	max_bound_variable(*second, max_variable);

	unsigned int first_lambda_variable = 0;
	if (first->type == hol_term_type::LAMBDA) {
		first_lambda_variable = first->quantifier.variable;
		first = first->quantifier.operand;
	} else {
		return false;
	}

	unsigned int second_lambda_variable = 0;
	if (second->type == hol_term_type::LAMBDA) {
		second_lambda_variable = second->quantifier.variable;
		second = second->quantifier.operand;
	} else {
		return false;
	}

	bool result = invert_factor(inverse, inverse_count, flags, first, second, predicative_head_finder<built_in_predicates>(second_lambda_variable));
	if (!result) return false;
	for (unsigned int i = 0; i < inverse_count; i++) {
		hol_term* new_inverse = hol_term::new_lambda(first_lambda_variable, inverse[i].root);
		if (new_inverse == nullptr) {
			for (unsigned int j = 0; j < inverse_count; j++) free(inverse[j]);
			free(inverse); return false;
		}
		inverse[i].root = new_inverse;
	}
	return true;
}

template<int_fast8_t ConjunctIndex>
inline bool invert_select_conjunct_without_head(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	return invert_apply_head(inverse, inverse_count, flags, first, second,
		find_head<built_in_predicates>, find_head<built_in_predicates>, no_op(),
		[](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, const apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array) {
#if !defined(NDEBUG)
			if (second_head->type != hol_term_type::EXISTS)
				fprintf(stderr, "invert_select_conjunct_without_head WARNING: Expected an extential quantification.\n");
#endif

			hol_term* operand = second_head->quantifier.operand;
			unsigned int head_variable = second_head->quantifier.variable;

			hol_term* excluded_quantifiers[3];
			excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(head_variable, &HOL_ANY));
			excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(head_variable, &HOL_ANY));
			excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(head_variable, &HOL_ANY));
			if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
			if (excluded_quantifiers[1] != nullptr) HOL_ANY.reference_count++;
			if (excluded_quantifiers[2] != nullptr) HOL_ANY.reference_count++;
			if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr) {
				if (excluded_quantifiers[0] != nullptr) { free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]); }
				if (excluded_quantifiers[1] != nullptr) { free(*excluded_quantifiers[1]); free(excluded_quantifiers[1]); }
				return (hol_term*) nullptr;
			}

			hol_term* expected_conjunct = hol_term::new_any(nullptr, excluded_quantifiers, array_length(excluded_quantifiers));
			if (expected_conjunct == nullptr) {
				for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
				return (hol_term*) nullptr;
			}

			hol_term* new_head;
			if (ConjunctIndex >= 0) {
				new_head = hol_term::new_any_array(hol_term_type::AND, expected_conjunct, make_array_view((hol_term**) nullptr, 0),
						make_appended_array_view(make_repeated_array_view(conjunct, ConjunctIndex), operand), make_array_view((hol_term**) nullptr, 0));
				if (new_head == nullptr) {
					free(*expected_conjunct); free(expected_conjunct);
					return false;
				}
				operand->reference_count++;
				expected_conjunct->reference_count += ConjunctIndex;
			} else {
				unsigned int index = (unsigned int) (-ConjunctIndex) - 1;
				new_head = hol_term::new_any_array(hol_term_type::AND, expected_conjunct, make_array_view((hol_term**) nullptr, 0),
						make_array_view((hol_term**) nullptr, 0), make_prepended_array_view(operand, make_repeated_array_view(expected_conjunct, index)));
				if (new_head == nullptr) {
					free(*expected_conjunct); free(expected_conjunct);
					return false;
				}
				operand->reference_count++;
				expected_conjunct->reference_count += index;
			}

			dst[dst.length++] = new_head;
			dst_outer[dst_outer.length++] = &HOL_ZERO;
			HOL_ZERO.reference_count++;
			return true;
		});
}

template<int_fast8_t ConjunctIndex, uint_fast8_t ConjunctCount>
inline bool invert_select_conjuncts_without_head(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	static_assert(ConjunctCount != 0, "invert_select_conjuncts_without_head ERROR: `ConjunctCount` must be non-zero.");

	return invert_apply_head(inverse, inverse_count, flags, first, second,
		find_head<built_in_predicates>, find_head<built_in_predicates>, no_op(),
		[](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, const apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array) {
			hol_term* old_first_head = first_head;
			if ((first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) && first_head->any.included != nullptr)
				first_head = first_head->any.included;
#if !defined(NDEBUG)
			if (second_head->type != hol_term_type::EXISTS || (ConjunctCount > 1 && (second_head->quantifier.operand->type != hol_term_type::AND || second_head->quantifier.operand->array.length != ConjunctCount))) {
				fprintf(stderr, "invert_select_conjuncts_without_head ERROR: Expected an existentially-quantified conjunction of length %u.\n", ConjunctCount);
				return false;
			}
#endif

			unsigned int negation_count = 0;
			while (first_head->type == hol_term_type::NOT) {
				first_head = first_head->unary.operand;
				negation_count++;
			}

			hol_term* head_var = hol_term::new_variable(second_head->quantifier.variable);
			if (head_var == nullptr) return false;
			constexpr unsigned int excluded_tree_count = 2;
			hol_term* excluded_trees[excluded_tree_count];
			excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
						(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
						(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
					&HOL_ANY), head_var));
			excluded_trees[1] = hol_term::new_any(hol_term::new_exists(second_head->quantifier.variable, &HOL_ANY));
			if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
			if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
			if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr) {
				if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
				free(*head_var); free(head_var);
				return false;
			}
			free(*head_var);

			hol_term* expected_conjunct = hol_term::new_any(nullptr, excluded_trees, excluded_tree_count);
			if (expected_conjunct == nullptr) {
				free(*excluded_trees[0]); free(excluded_trees[0]);
				free(*excluded_trees[1]); free(excluded_trees[1]);
				return false;
			}

			hol_term* new_head;
			if (ConjunctIndex >= 0) {
				if (ConjunctCount == 1) {
					new_head = hol_term::new_exists(second_head->quantifier.variable, hol_term::new_any_array(
							hol_term_type::AND, expected_conjunct, make_array_view((hol_term**) nullptr, 0),
							make_appended_array_view(make_repeated_array_view(expected_conjunct, ConjunctIndex), second_head->quantifier.operand),
							make_array_view((hol_term**) nullptr, 0)));
				} else {
					new_head = hol_term::new_exists(second_head->quantifier.variable, hol_term::new_any_array(
							hol_term_type::AND, expected_conjunct, make_array_view((hol_term**) nullptr, 0),
							make_concat_array_view(make_repeated_array_view(expected_conjunct, ConjunctIndex), make_array_view(second_head->quantifier.operand->array.operands, second_head->quantifier.operand->array.length)),
							make_array_view((hol_term**) nullptr, 0)));
				}
				if (new_head == nullptr) {
					free(*expected_conjunct); free(expected_conjunct);
					return false;
				}
				expected_conjunct->reference_count += ConjunctIndex;
			} else {
				unsigned int index = (unsigned int) (-ConjunctIndex) - ConjunctCount;
				if (ConjunctCount == 1) {
					new_head = hol_term::new_exists(second_head->quantifier.variable, hol_term::new_any_array(
							hol_term_type::AND, expected_conjunct, make_array_view((hol_term**) nullptr, 0),
							make_array_view((hol_term**) nullptr, 0),
							make_prepended_array_view(second_head->quantifier.operand, make_repeated_array_view(expected_conjunct, index))));
				} else {
					new_head = hol_term::new_exists(second_head->quantifier.variable, hol_term::new_any_array(
							hol_term_type::AND, expected_conjunct, make_array_view((hol_term**) nullptr, 0),
							make_array_view((hol_term**) nullptr, 0),
							make_concat_array_view(make_array_view(second_head->quantifier.operand->array.operands, second_head->quantifier.operand->array.length), make_repeated_array_view(expected_conjunct, index))));
				}
				if (new_head == nullptr) {
					free(*expected_conjunct); free(expected_conjunct);
					return false;
				}
				expected_conjunct->reference_count += index;
			}
			if (ConjunctCount == 1) {
				second_head->quantifier.operand->reference_count++;
			} else {
				for (unsigned int i = 0; i < second_head->quantifier.operand->array.length; i++)
					second_head->quantifier.operand->array.operands[i]->reference_count++;
			}
			for (unsigned int i = 0; i < negation_count; i++) {
				hol_term* temp = hol_term::new_not(new_head);
				if (temp == nullptr) {
					free(*new_head); free(new_head);
					return false;
				}
				new_head = temp;
			}
			dst[dst.length++] = new_head;

			bool can_have_free_variable_references = false;
			if (first_head->type != hol_term_type::EXISTS || first_head->quantifier.operand->type == hol_term_type::ANY_ARRAY) {
				can_have_free_variable_references = true;
			} else {
				hol_term* operand = first_head->quantifier.operand;
				if (operand->type == hol_term_type::AND) {
					unsigned int index = (ConjunctIndex >= 0 ? ConjunctIndex : operand->array.length + ConjunctIndex);
					for (unsigned int i = 0; !can_have_free_variable_references && i < operand->array.length; i++) {
						if (i >= index && i < index + ConjunctCount) continue;
						if (can_have_free_variables(*operand->array.operands[i]))
							can_have_free_variable_references = true;
					}
				}

				if (ConjunctCount == 1) {
					if (can_have_free_variables(*second_head->quantifier.operand))
						can_have_free_variable_references = true;
				} else {
					for (unsigned int i = 0; !can_have_free_variable_references && i < second_head->quantifier.operand->array.length; i++)
						if (can_have_free_variables(*second_head->quantifier.operand->array.operands[i]))
							can_have_free_variable_references = true;
				}
			}

			if (old_first_head->type == hol_term_type::ANY || old_first_head->type == hol_term_type::ANY_RIGHT) {
				array<hol_term*> excluded(old_first_head->any.excluded_tree_count + 1);
				for (unsigned int i = 0; i < old_first_head->any.excluded_tree_count; i++) {
					excluded[excluded.length] = old_first_head->any.excluded_trees[i];
					excluded[excluded.length++]->reference_count++;
				}
				if (can_have_free_variable_references) {
					excluded[excluded.length] = hol_term::new_any_right(hol_term::new_apply(
							&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ANY));
					if (excluded[excluded.length] == nullptr) {
						free_all(excluded);
						return false;
					}
					hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
					HOL_ANY.reference_count++;
					excluded.length++;
				}
				hol_term* temp = hol_term::new_any_right(dst.last(), excluded.data, excluded.length);
				if (temp == nullptr) {
					free_all(excluded);
					return false;
				}
				dst.last() = temp;
			}

			if (can_have_free_variable_references && old_first_head->type != hol_term_type::ANY && old_first_head->type != hol_term_type::ANY_RIGHT) {
				/* exclude wide scope markers in front of the head */
				hol_term* excluded_tree = hol_term::new_any_right(hol_term::new_apply(
						&hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value, &HOL_ANY));
				if (excluded_tree == nullptr)
					return false;
				hol_term::constants<(unsigned int) built_in_predicates::WIDE_SCOPE>::value.reference_count++;
				HOL_ANY.reference_count++;

				dst_outer[dst_outer.length] = hol_term::new_any_right(&HOL_ZERO, &excluded_tree, 1);
				if (dst_outer[dst_outer.length] == nullptr) {
					free(*excluded_tree); free(excluded_tree);
					return false;
				}
			} else {
				dst_outer[dst_outer.length] = &HOL_ZERO;
			}
			dst_outer.length++;
			HOL_ZERO.reference_count++;
			return true;
		});
}

template<int_fast8_t PredicateIndex>
inline hol_term* do_invert_set_predicate_empty(hol_term* second_head)
{
	unsigned int head_variable;
	if (second_head->type == hol_term_type::EXISTS) {
		head_variable = second_head->quantifier.variable;
	} else {
		unsigned int max_variable = 0;
		max_bound_variable(*second_head, max_variable);
		head_variable = ++max_variable;
	}

	hol_term* head_var = hol_term::new_variable(head_variable);
	if (head_var == nullptr) return (hol_term*) nullptr;
	constexpr unsigned int excluded_tree_count = 2;
	hol_term** excluded_trees = (hol_term**) alloca(sizeof(hol_term) * (excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()));
	excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
				(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
				(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
			&HOL_ANY), head_var));
	excluded_trees[1] = hol_term::new_any(hol_term::new_exists(head_variable, &HOL_ANY));
	if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
	if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
	if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr) {
		if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
		free(*head_var); free(head_var);
		return nullptr;
	}
	free(*head_var);

	for (unsigned int i = 0; i < hol_non_head_constants<built_in_predicates>::count(); i++) {
		excluded_trees[excluded_tree_count + i] = hol_non_head_constants<built_in_predicates>::get_terms()[i];
		excluded_trees[excluded_tree_count + i]->reference_count++;
	}

	hol_term* expected_predicate = hol_term::new_apply(
				hol_term::new_any(nullptr, excluded_trees, excluded_tree_count + hol_non_head_constants<built_in_predicates>::count()), head_var);
	if (expected_predicate == nullptr) {
		for (unsigned int i = 0; i < excluded_tree_count + hol_non_head_constants<built_in_predicates>::count(); i++) {
			free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
		}
		return nullptr;
	}
	head_var->reference_count++;

	hol_term* empty_predicate = hol_term::new_apply(&HOL_EMPTY, head_var);
	if (empty_predicate == nullptr) {
		free(*expected_predicate); free(expected_predicate);
		return nullptr;
	}
	HOL_EMPTY.reference_count++;
	head_var->reference_count++;

	head_index second_predicate_index;
	if (second_head->type == hol_term_type::EXISTS)
		find_predicate<built_in_predicates>(head_variable, second_head->quantifier.operand, second_predicate_index);
	hol_term* new_head = apply_predicate<PredicateIndex>(second_head, head_variable, second_predicate_index, empty_predicate, expected_predicate);
	free(*empty_predicate); if (empty_predicate->reference_count == 0) free(empty_predicate);
	free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
	return new_head;
}

template<int_fast8_t PredicateIndex>
inline bool invert_set_predicate_empty(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	hol_term* second_parent = nullptr;
	hol_term* current = nullptr;
	auto apply = [&second_parent,&current](hol_term* term) {
		second_parent = current;
		current = term;
	};

	head_index first_predicate_index; no_op first_apply;
	auto first_head_finder = make_array_finder(find_head<built_in_predicates>);
	hol_term* first_head = find_head(first, first_predicate_index, first_head_finder, first_apply);
	if (first_head == nullptr)
		return false;

	if ((first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) && first_head->any.included != nullptr)
		first_head = first_head->any.included;

	head_index second_predicate_index;
	hol_term* second_head = find_head(second, second_predicate_index, find_head<built_in_predicates>, apply);
	if (second_head == nullptr)
		return false;

	hol_term* new_head = apply_array(second_head, second_parent, do_invert_set_predicate_empty<PredicateIndex>);
	if (new_head == nullptr)
		return false;

	array<hol_term*> new_heads(4);
	intersect<built_in_predicates>(new_heads, first_head, new_head);
	free(*new_head); if (new_head->reference_count == 0) free(new_head);

	hol_term* first_outer = substitute_head<any_node_position::NONE>(first, first_head, &HOL_ZERO);
	if (first_outer == nullptr) {
		free_all(new_heads);
		return false;
	}
	hol_term* second_outer = substitute_head<any_node_position::NONE>(second, second_head, &HOL_ZERO);
	if (second_outer == nullptr) {
		free(*first_outer); if (first_outer->reference_count == 0) free(first_outer);
		free_all(new_heads); return false;
	}
	array<hol_term*> new_outer(4);
	intersect<built_in_predicates>(new_outer, first_outer, second_outer);
	free(*first_outer); if (first_outer->reference_count == 0) free(first_outer);
	free(*second_outer); if (second_outer->reference_count == 0) free(second_outer);

	array<hol_term*> intersection(max((size_t) 1, new_heads.length * new_outer.length));
	for (hol_term* new_head : new_heads) {
		for (hol_term* outer : new_outer) {
			hol_term* new_inverse = substitute_head<any_node_position::NONE>(outer, &HOL_ZERO, new_head);
			if (new_inverse == nullptr) {
				free_all(intersection); free_all(new_heads); free_all(new_outer);
				return false;
			}
			intersection[intersection.length++] = new_inverse;
		}
	}
	free_all(new_heads); free_all(new_outer);

	inverse = (flagged_logical_form<hol_term>*) malloc(sizeof(flagged_logical_form<hol_term>) * intersection.length);
	if (inverse == nullptr) {
		free_all(intersection);
		return false;
	}
	for (unsigned int i = 0; i < intersection.length; i++) {
		inverse[i].flags = flags;
		inverse[i].root = intersection[i];
	}
	inverse_count = intersection.length;
	return true;
}

template<int_fast8_t ConjunctIndex, typename FindHeadFunction>
inline bool invert_select_operand(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second,
		FindHeadFunction find_head_function)
{
	auto on_remap_variables = [](hol_term* first_head, hol_term* second_head,
			apply_head_inverter& first_head_inverter, apply_head_inverter& second_head_inverter,
			array_map<const hol_term*, unsigned int>& second_variable_map, unsigned int& max_variable,
			bool first_head_is_array, bool second_head_is_array)
	{
		if (is_ambiguous(*second_head))
			return true;

		hol_term* first_operand;
		if (first_head->type == hol_term_type::ANY_ARRAY) {
			if (ConjunctIndex >= 0 && ConjunctIndex < first_head->any_array.left.length) {
				first_operand = first_head->any_array.left.operands[ConjunctIndex];
			} else if (ConjunctIndex < 0 && first_head->any_array.right.length >= -ConjunctIndex) {
				first_operand = first_head->any_array.right.operands[first_head->any_array.right.length + ConjunctIndex];
			} else {
				return true;
			}
		} else if (first_head->type == hol_term_type::AND || first_head->type == hol_term_type::OR) {
			if (ConjunctIndex >= 0) {
				first_operand = first_head->array.operands[ConjunctIndex];
			} else {
				first_operand = first_head->array.operands[first_head->array.length + ConjunctIndex];
			}
		} else if (first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) {
			return true;
		} else {
			return false;
		}

		array<pair<hol_term*, variable_map>> intersection(2);
		intersect<built_in_predicates, true, true>(intersection, first_operand, second_head);
		if (intersection.length == 0) {
			return false;
		} else if (intersection.length != 1) {
			fprintf(stderr, "invert_select_operand ERROR: Intersection modulo variable relabeling is not unique.\n");
			free_all(intersection); return false;
		}

		/* make sure the variables in `second_head` map to the correct variables in `first_head` */
		const variable_map& var_map = intersection[0].value;
		for (const auto& entry : var_map.scope_map) {
			if (!second_variable_map.contains(entry.key.src))
				continue;

			unsigned int target_var = 0;
			if (!get_target_variable(entry.key.src->quantifier.variable, target_var, entry.value, max_variable)) {
				free_all(intersection);
				return false;
			}

			if (!second_variable_map.ensure_capacity(second_variable_map.size + 1)) {
				free_all(intersection);
				return false;
			}
			unsigned int index = second_variable_map.index_of(entry.key.src);
			if (target_var == second_variable_map.values[index]) {
				/* `second_variable_map` should map `var` to itself */
				second_variable_map.remove_at(index);
			} else {
				/* `second_variable_map` should map `var` to `target_var` */
				second_variable_map.values[index] = target_var;
				if (index == second_variable_map.size) {
					second_variable_map.keys[index] = entry.key.src;
					second_variable_map.size++;
				}
			}
		}

		array_map<unsigned int, variable_set> free_variable_map(8);
		for (const auto& entry : var_map.free_variables) {
			const variable_set& set = entry.value;

			unsigned int src_variable = entry.key;
			if (!free_variable_map.ensure_capacity(free_variable_map.size + 1)) {
				free_all(intersection);
				return false;
			}
			unsigned int index = free_variable_map.index_of(src_variable);
			if (index < free_variable_map.size) {
				variable_set& new_set = *((variable_set*) alloca(sizeof(variable_map)));
				if (!intersect(new_set, set, free_variable_map.values[index])) {
					free_all(intersection);
					return false;
				}
				swap(free_variable_map.values[index], new_set);
				free(new_set);
			} else {
				free_variable_map.keys[free_variable_map.size] = src_variable;
				if (!init(free_variable_map.values[free_variable_map.size], set)) {
					free_all(intersection);
					return false;
				}
				free_variable_map.size++;
			}
		}
		free_all(intersection);

		if (!remap_scopes(free_variable_map, first_head_inverter, second_head_inverter, second_variable_map, max_variable, first_head_is_array, second_head_is_array)) {
			for (auto entry : second_variable_map) free(entry.value);
			return false;
		}
		return true;
	};

	return invert_apply_head(inverse, inverse_count, flags, first, second,
		make_array_finder(find_head_function), find_head_function, on_remap_variables,
		[](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, const apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array) {
			hol_term* new_head;
			if (ConjunctIndex == 0) {
				new_head = hol_term::new_any_array(hol_term_type::ANY_ARRAY, &HOL_ANY, make_array_view((hol_term**) nullptr, 0),
						make_appended_array_view(make_array_view(&second_head, 1), &HOL_ANY), make_array_view((hol_term**) nullptr, 0));
				if (new_head == nullptr)
					return false;
				HOL_ANY.reference_count += 2;
			} else if (ConjunctIndex > 0) {
				new_head = hol_term::new_any_array(hol_term_type::ANY_ARRAY, &HOL_ANY, make_array_view((hol_term**) nullptr, 0),
						make_appended_array_view(make_repeated_array_view(&HOL_ANY, ConjunctIndex), second_head), make_array_view((hol_term**) nullptr, 0));
				if (new_head == nullptr)
					return false;
				HOL_ANY.reference_count += 1 + ConjunctIndex;
			} else {
				unsigned int index = (unsigned int) (-ConjunctIndex) - 1;
				new_head = hol_term::new_any_array(hol_term_type::ANY_ARRAY, &HOL_ANY, make_array_view((hol_term**) nullptr, 0),
						make_repeated_array_view(&HOL_ANY, 2), make_prepended_array_view(second_head, make_repeated_array_view(&HOL_ANY, index)));
				if (new_head == nullptr)
					return false;
				HOL_ANY.reference_count += 3 + index;
			}
			second_head->reference_count++;
			dst[dst.length++] = new_head;
			dst_outer[dst_outer.length++] = &HOL_ZERO;
			HOL_ZERO.reference_count++;
			return true;
		});
}

template<int_fast8_t ConjunctIndex, typename FindHeadFunction>
inline bool invert_remove_operand(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second,
		FindHeadFunction find_head_function)
{
	return invert_apply_head(inverse, inverse_count, flags, first, second,
		make_array_finder(find_head_function), find_head_function, no_op(),
		[](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, const apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array)
		{
			hol_term* hol_any_ptr = &HOL_ANY;
			if (second_head->type == hol_term_type::ANY_ARRAY) {
				hol_term* new_head;
				if (ConjunctIndex >= 0) {
					if (ConjunctIndex >= second_head->any_array.left.length) {
						new_head = second_head;
						new_head->reference_count++;
					} else {
						new_head = hol_term::new_any_array(second_head->any_array.oper, second_head->any_array.all,
								make_array_view(second_head->any_array.any.operands, second_head->any_array.any.length),
								make_included_array_view(second_head->any_array.left.operands, second_head->any_array.left.length, hol_any_ptr, ConjunctIndex),
								make_array_view(second_head->any_array.right.operands, second_head->any_array.right.length));
						if (new_head == nullptr)
							return false;
						HOL_ANY.reference_count++;
						second_head->any_array.all->reference_count++;
						for (unsigned int i = 0; i < second_head->any_array.any.length; i++)
							second_head->any_array.any.operands[i]->reference_count++;
						for (unsigned int i = 0; i < second_head->any_array.left.length; i++)
							second_head->any_array.left.operands[i]->reference_count++;
						for (unsigned int i = 0; i < second_head->any_array.right.length; i++)
							second_head->any_array.right.operands[i]->reference_count++;
					}
				} else {
					if (-ConjunctIndex > second_head->any_array.right.length) {
						new_head = second_head;
						new_head->reference_count++;
					} else {
						unsigned int index = second_head->any_array.right.length + ConjunctIndex;
						new_head = hol_term::new_any_array(second_head->any_array.oper, second_head->any_array.all,
								make_array_view(second_head->any_array.any.operands, second_head->any_array.any.length),
								make_array_view(second_head->any_array.left.operands, second_head->any_array.left.length),
								make_included_array_view(second_head->any_array.right.operands, second_head->any_array.right.length, hol_any_ptr, index));
						if (new_head == nullptr)
							return false;
						HOL_ANY.reference_count++;
						second_head->any_array.all->reference_count++;
						for (unsigned int i = 0; i < second_head->any_array.any.length; i++)
							second_head->any_array.any.operands[i]->reference_count++;
						for (unsigned int i = 0; i < second_head->any_array.left.length; i++)
							second_head->any_array.left.operands[i]->reference_count++;
						for (unsigned int i = 0; i < second_head->any_array.right.length; i++)
							second_head->any_array.right.operands[i]->reference_count++;
					}
				}
				dst[dst.length++] = new_head;
				dst_outer[dst_outer.length++] = &HOL_ZERO;
				HOL_ZERO.reference_count++;
			} else if (second_head->type == hol_term_type::AND) {
				unsigned int index = (ConjunctIndex >= 0) ? ConjunctIndex : (second_head->array.length + ConjunctIndex);
				hol_term* new_head = hol_term::new_and(make_included_array_view(second_head->array.operands, second_head->array.length, hol_any_ptr, index));
				if (new_head == nullptr)
					return false;
				for (unsigned int i = 0; i < new_head->array.length; i++)
					new_head->array.operands[i]->reference_count++;
				dst[dst.length++] = new_head;
				dst_outer[dst_outer.length++] = &HOL_ZERO;
				HOL_ZERO.reference_count++;
			} else if (second_head->type == hol_term_type::OR) {
				unsigned int index = (ConjunctIndex >= 0) ? ConjunctIndex : (second_head->array.length + ConjunctIndex);
				hol_term* new_head = hol_term::new_or(make_included_array_view(second_head->array.operands, second_head->array.length, hol_any_ptr, index));
				if (new_head == nullptr)
					return false;
				for (unsigned int i = 0; i < new_head->array.length; i++)
					new_head->array.operands[i]->reference_count++;
				dst[dst.length++] = new_head;
				dst_outer[dst_outer.length++] = &HOL_ZERO;
				HOL_ZERO.reference_count++;
			} else {
				if (ConjunctIndex < -2 || ConjunctIndex > 1) return false;
				unsigned int index = (ConjunctIndex >= 0) ? ConjunctIndex : (2 + ConjunctIndex);
				hol_term* new_head = (index == 0) ? hol_term::new_and(hol_any_ptr, second_head) : hol_term::new_and(second_head, hol_any_ptr);
				if (new_head == nullptr)
					return false;
				HOL_ANY.reference_count++;
				second_head->reference_count++;
				dst[dst.length++] = new_head;
				dst_outer[dst_outer.length++] = &HOL_ZERO;
				HOL_ZERO.reference_count++;

				new_head = (index == 0) ? hol_term::new_or(hol_any_ptr, second_head) : hol_term::new_or(second_head, hol_any_ptr);
				if (new_head == nullptr)
					return false;
				HOL_ANY.reference_count++;
				second_head->reference_count++;
				dst[dst.length++] = new_head;
				dst_outer[dst_outer.length++] = &HOL_ZERO;
				HOL_ZERO.reference_count++;
			}
			return true;
		});
}

inline bool invert_apply_to_predicative_set_function(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second,
		unsigned int src_predicate,
		unsigned int dst_predicate)
{
	unsigned int max_variable = 0;
	max_bound_variable(*second, max_variable);

	unsigned int lambda_variable = 0;
	if (second->type == hol_term_type::LAMBDA) {
		lambda_variable = second->quantifier.variable;
		second = second->quantifier.operand;
	} else if (second->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	return invert_apply_head(inverse, inverse_count, flags, first, second,
		predicative_head_finder<built_in_predicates>(lambda_variable), predicative_head_finder<built_in_predicates>(lambda_variable), no_op(),
		[src_predicate,dst_predicate](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, const apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array)
		{
			if (!apply_to_predicative_set_function(second_head, dst, max_variable, dst_predicate, src_predicate))
				return false;
			if (!dst_outer.ensure_capacity(dst.length)) {
				free_all(dst);
				return false;
			}
			for (unsigned int i = 0; i < dst.length; i++)
				dst_outer[dst_outer.length++] = &HOL_ZERO;
			HOL_ZERO.reference_count += dst.length;
			return true;
		});
}

inline bool invert_select_lambda(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	array<pair<hol_term*, head_index>> second_scopes(8);
	auto second_apply = [&second_scopes](hol_term* term) {
		if (term->type == hol_term_type::AND || term->type == hol_term_type::OR || term->type == hol_term_type::IFF) {
			return second_scopes.add({term, {head_position::LEFT, term->array.length - 1}});
		} else if (term->type == hol_term_type::ANY_ARRAY) {
			if (term->any_array.right.length == 0)
				return second_scopes.add({term, {head_position::NONE, 0}});
			else return second_scopes.add({term, {head_position::RIGHT, term->any_array.right.length - 1}});
		} else {
			return second_scopes.add({term, {head_position::LEFT, 0}});
		}
	};

	unsigned int max_variable = 0;
	max_bound_variable(*first, max_variable);

	unsigned int lambda_variable = 0;
	if (first->type == hol_term_type::LAMBDA) {
		lambda_variable = first->quantifier.variable;
	} else if (first->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	bool found_arg = false;
	array<pair<hol_term*, head_index>> first_scopes(8);
	if (!find_lambda(first, lambda_variable, first_scopes, found_arg))
		return false;

	head_index second_predicate_index;
	hol_term* second_head = find_head(second, second_predicate_index, find_head<built_in_predicates>, second_apply);
	if (second_head == nullptr)
		return false;

#if !defined(NDEBUG)
	if (second_head->type != hol_term_type::EXISTS || second_head->quantifier.operand->type != hol_term_type::AND || second_head->quantifier.operand->array.length != 2)
		fprintf(stderr, "invert_select_lambda WARNING: Expected an existentially-quantified conjunction of length 2.\n");
#endif

	if (found_arg) {
		/* construct the new head */
		unsigned int head_variable = first_scopes[first_scopes.length - 3].key->quantifier.variable;
		hol_term* operand = first_scopes[first_scopes.length - 2].key;
		hol_term* arg_term = first_scopes[first_scopes.length - 1].key;
		head_index arg_index = first_scopes[first_scopes.length - 2].value;

		head_index predicate_index;
		hol_term* predicate = find_predicate<built_in_predicates>(head_variable, operand, predicate_index);
		if (predicate_index.position == head_position::NONE)
			return false;

		array<hol_term*> new_predicates(4);
		if (predicate == nullptr) {
			new_predicates[0] = second_head->quantifier.operand->array.operands[0];
			new_predicates[0]->reference_count++;
			new_predicates.length = 1;
		} else {
			intersect<built_in_predicates>(new_predicates, second_head->quantifier.operand->array.operands[0], predicate);
			if (new_predicates.length == 0)
				return false;
		}

		array<hol_term*> new_args(4);
		intersect<built_in_predicates>(new_args, second_head->quantifier.operand->array.operands[1], arg_term);
		if (new_args.length == 0) {
			free_all(new_predicates);
			return false;
		}

		array<hol_term*> new_heads(new_predicates.length * new_args.length);
		for (hol_term* new_predicate : new_predicates) {
			for (hol_term* new_arg : new_args) {
				hol_term* new_operand;
				if (operand->type == hol_term_type::AND) {
					new_operand = hol_term::new_and(make_replaced_array_view(make_replaced_array_view(make_array_view(operand->array.operands, operand->array.length), new_predicate, predicate_index.index), new_arg, arg_index.index));
					if (new_operand == nullptr) {
						free_all(new_predicates); free_all(new_args);
						free_all(new_heads); return false;
					}
					for (unsigned int i = 0; i < new_operand->array.length; i++)
						new_operand->array.operands[i]->reference_count++;
				} else {
					hol_term** new_left = (hol_term**) malloc(max((size_t) 1, sizeof(hol_term*) * operand->any_array.left.length));
					if (new_left == nullptr) {
						free_all(new_predicates); free_all(new_args);
						free_all(new_heads); return false;
					}
					hol_term** new_right = (hol_term**) malloc(max((size_t) 1, sizeof(hol_term*) * operand->any_array.right.length));
					if (new_right == nullptr) {
						free(new_left);
						free_all(new_predicates); free_all(new_args);
						free_all(new_heads); return false;
					}
					hol_term** new_any = (hol_term**) malloc(max((size_t) 1, sizeof(hol_term*) * operand->any_array.any.length));
					if (new_any == nullptr) {
						free(new_left); free(new_right);
						free_all(new_predicates); free_all(new_args);
						free_all(new_heads); return false;
					}

					for (unsigned int i = 0; i < operand->any_array.left.length; i++) {
						if (predicate_index.position == head_position::LEFT && predicate_index.index == i)
							operand->any_array.left.operands[i] = new_predicate;
						else if (arg_index.position == head_position::LEFT && arg_index.index == i)
							operand->any_array.left.operands[i] = new_arg;
						else operand->any_array.left.operands[i] = operand->any_array.left.operands[i];
					} for (unsigned int i = 0; i < operand->any_array.right.length; i++) {
						if (predicate_index.position == head_position::RIGHT && predicate_index.index == operand->any_array.right.length - i - 1)
							operand->any_array.right.operands[i] = new_predicate;
						else if (arg_index.position == head_position::RIGHT && arg_index.index == operand->any_array.right.length - i - 1)
							operand->any_array.right.operands[i] = new_arg;
						else operand->any_array.right.operands[i] = operand->any_array.right.operands[i];
					} for (unsigned int i = 0; i < operand->any_array.any.length; i++) {
						if (predicate_index.position == head_position::ANY && predicate_index.index == i)
							operand->any_array.any.operands[i] = new_predicate;
						else if (arg_index.position == head_position::ANY && arg_index.index == i)
							operand->any_array.any.operands[i] = new_arg;
						else operand->any_array.any.operands[i] = operand->any_array.any.operands[i];
					}
					new_operand = hol_term::new_any_array(operand->any_array.oper, operand->any_array.all,
							make_array_view(new_any, operand->any_array.any.length),
							make_array_view(new_left, operand->any_array.left.length),
							make_array_view(new_right, operand->any_array.right.length));
					free(new_left); free(new_right); free(new_any);
					if (new_operand == nullptr) {
						free_all(new_predicates); free_all(new_args);
						free_all(new_heads); return false;
					}
					new_operand->any_array.all->reference_count++;
					for (unsigned int i = 0; i < new_operand->any_array.any.length; i++)
						new_operand->any_array.any.operands[i]->reference_count++;
					for (unsigned int i = 0; i < new_operand->any_array.left.length; i++)
						new_operand->any_array.left.operands[i]->reference_count++;
					for (unsigned int i = 0; i < new_operand->any_array.right.length; i++)
						new_operand->any_array.right.operands[i]->reference_count++;
				}

				new_heads[new_heads.length] = hol_term::new_exists(head_variable, new_operand);
				if (new_heads[new_heads.length]) {
					free(*new_operand); free(new_operand);
					free_all(new_predicates); free_all(new_args);
					free_all(new_heads); return false;
				}
				new_heads.length++;
			}
		}
		free_all(new_predicates); free_all(new_args);

		first_scopes.length -= 3;
		second_scopes.length -= 1;

		/* compute the boundaries between the moveable portions in `first` and `second` */
		array<unsigned int> first_scope_starts(8), second_scope_starts(8);
		first_scope_starts[0] = 0; second_scope_starts[0] = 0;
		first_scope_starts.length = 1; second_scope_starts.length = 1;
		for (unsigned int i = 1; i < first_scopes.length; i++) {
			if (first_scopes[i - 1].key->type == hol_term_type::AND || first_scopes[i - 1].key->type == hol_term_type::OR
			 || first_scopes[i - 1].key->type == hol_term_type::IFF || first_scopes[i - 1].key->type == hol_term_type::IF_THEN
			 || first_scopes[i - 1].key->type == hol_term_type::FOR_ALL || first_scopes[i - 1].key->type == hol_term_type::EXISTS
			 || first_scopes[i - 1].key->type == hol_term_type::LAMBDA || first_scopes[i - 1].key->type == hol_term_type::UNARY_APPLICATION)
			{
				if (!first_scope_starts.add(i)) { free_all(new_heads); return false; }
			}
		} for (unsigned int i = 1; i < second_scopes.length; i++) {
			if (second_scopes[i - 1].key->type == hol_term_type::AND || second_scopes[i - 1].key->type == hol_term_type::OR
			 || second_scopes[i - 1].key->type == hol_term_type::IFF || second_scopes[i - 1].key->type == hol_term_type::IF_THEN
			 || second_scopes[i - 1].key->type == hol_term_type::FOR_ALL || second_scopes[i - 1].key->type == hol_term_type::EXISTS
			 || second_scopes[i - 1].key->type == hol_term_type::LAMBDA || second_scopes[i - 1].key->type == hol_term_type::UNARY_APPLICATION)
			{
				if (!second_scope_starts.add(i)) { free_all(new_heads); return false; }
			}
		}

		/* compute the "anchors" */
		array<pair<size_t, size_t>> anchors(4);
		unsigned int current_second_index = 0;
		for (unsigned int i = 0; i < first_scope_starts.length; i++) {
			/* check if this scope contains a quantifier */
			// TODO: continue from here
			//unsigned int end = ()
			//for (unsigned int a = first_scope_starts[i]; a < first_scope_starts[i + 1])
			if (first_scopes[i].key->type != hol_term_type::EXISTS && first_scopes[i].key->type != hol_term_type::FOR_ALL && first_scopes[i].key->type != hol_term_type::LAMBDA)
				continue;
			/* check to see if this scope exists in `second` */
			for (unsigned int j = current_second_index; j < second_scopes.length; j++) {
				if (second_scopes[j].key->type != hol_term_type::EXISTS && second_scopes[j].key->type != hol_term_type::FOR_ALL && second_scopes[j].key->type != hol_term_type::LAMBDA)
					continue;
				if (second_scopes[j].key->quantifier.variable != first_scopes[i].key->quantifier.variable)
					continue;
				if (second_scopes[j].key->type != first_scopes[i].key->type) {
					/* we found two different kinds of quantifiers with the same variable */
					free_all(new_heads); return false;
				}

				/* make sure there are no quantifiers in `second` between `current_second_index` and `j` that are also in `first` after `i` */
				for (unsigned int k = i + 1; k < first_scopes.length; k++) {
					if (first_scopes[k].key->type != hol_term_type::EXISTS && first_scopes[k].key->type != hol_term_type::FOR_ALL && first_scopes[k].key->type != hol_term_type::LAMBDA)
						continue;
					for (unsigned int l = current_second_index; l < j; l++) {
						if (second_scopes[l].key->type != hol_term_type::EXISTS && second_scopes[l].key->type != hol_term_type::FOR_ALL && second_scopes[l].key->type != hol_term_type::LAMBDA)
							continue;
						if (first_scopes[k].key->quantifier.variable == second_scopes[l].key->quantifier.variable) {
							/* we found a pair of matching quantifiers in `first` and `second` that are "discontinuous" (i.e. they appear in one order in `first` but reversed in `second`) */
							free_all(new_heads); return false;
						}
					}
				}

				current_second_index = j + 1;
				if (!anchors.add({i, j})) {
					free_all(new_heads);
					return false;
				}
				break;
			}
		}
		if (!anchors.add({first_scopes.length, second_scopes.length})) {
			free_all(new_heads);
			return false;
		}

		/*for (unsigned int i = anchors.length - 1; i > 0; i--) {
			array<hol_term*> temp(8);
			if (!merge_scopes(temp, new_heads,
					first_scopes.data + anchors[i - 1].key, anchors[i].key - anchors[i - 1].key,
					second_scopes.data + anchors[i - 1].value, anchors[i].value - anchors[i - 1].value))
			{
				free_all(new_heads);
				return false;
			}
			free_all(new_heads);
			swap(temp, new_heads);
		}*/

	} else {
		/* we use a special construction here to avoid extending the
		   `ANY_ARRAY` logical form type to support more than one `any` fields;
		   we assume that `invert_remove_lambda` will be called where the
		   output of this function will be `first` */
		
	}
}

inline bool invert_remove_lambda(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
}

template<substitution_setting SubstitutionSetting>
inline bool invert_select_function(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	unsigned int lambda_variable = 0;
	unsigned int max_variable = 0;
	max_bound_variable(*second, max_variable);
	if (SubstitutionSetting == substitution_setting::ARG2) {
		if (second->type == hol_term_type::LAMBDA)
			lambda_variable = second->quantifier.variable;
	}

	auto on_remap_variables = [&lambda_variable](hol_term* first_head, hol_term* second_head,
			apply_head_inverter& first_head_inverter, apply_head_inverter& second_head_inverter,
			array_map<const hol_term*, unsigned int>& second_variable_map, unsigned int& max_variable,
			bool first_head_is_array, bool second_head_is_array)
	{
		/* make sure the initial lambda variables are correctly mapped */
		if (SubstitutionSetting == substitution_setting::ARG2 && first_head_inverter.outer[0]->type == hol_term_type::LAMBDA)
			lambda_variable = first_head_inverter.outer[0]->quantifier.variable;
		if (first_head_inverter.outer[0]->type == hol_term_type::LAMBDA && second_head_inverter.outer[0]->type == hol_term_type::LAMBDA) {
			if (!second_variable_map.ensure_capacity(second_variable_map.size + 1)) {
				for (auto entry : second_variable_map) free(entry.value);
				return false;
			}

			unsigned int first_lambda_variable = first_head_inverter.outer[0]->quantifier.variable;
			hol_term* second_lambda = second_head_inverter.outer[0];
			unsigned int index = second_variable_map.index_of(second_lambda);
			if (index < second_variable_map.size && first_lambda_variable == second_variable_map.values[index]) {
				/* `second_variable_map` should map `var` to itself */
				second_variable_map.remove_at(index);
			} else {
				/* `second_variable_map` should map `var` to `target_var` */
				second_variable_map.values[index] = first_lambda_variable;
				if (index == second_variable_map.size) {
					second_variable_map.keys[index] = second_lambda;
					second_variable_map.size++;
				}
			}
		}

		/* make sure no scopes in `second` collide with the function variables declared in `first` */
		if ((first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) && first_head->any.included != nullptr && first_head->any.included->type == hol_term_type::EXISTS)
			first_head = first_head->any.included;
		if (first_head->type == hol_term_type::EXISTS) {
			hol_term* left;
			hol_term* operand = first_head->quantifier.operand;
			if (operand->type == hol_term_type::AND) {
				left = operand->array.operands[0];
			} else if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
				if (operand->any_array.left.length == 0)
					left = nullptr;
				else left = operand->any_array.left.operands[0];
			} else {
				left = operand;
			}

			if (left != nullptr && left->type == hol_term_type::UNARY_APPLICATION
				&& left->binary.left->type == hol_term_type::UNARY_APPLICATION
				&& left->binary.left->binary.right->type == hol_term_type::VARIABLE)
			{
				unsigned int function_variable = left->binary.left->binary.right->variable;
				hol_term* function_scope = nullptr;
				for (hol_term* scope : first_head_inverter.outer) {
					if (scope->type != hol_term_type::EXISTS && scope->type != hol_term_type::FOR_ALL && scope->type != hol_term_type::LAMBDA)
						continue;
					if (scope->quantifier.variable == function_variable) {
						function_scope = scope;
						break;
					}
				}

				left = nullptr;
				operand = function_scope->quantifier.operand;
				if (operand->type == hol_term_type::AND) {
					left = operand->array.operands[0];
				} else if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
					if (operand->any_array.left.length != 0)
						left = operand->any_array.left.operands[0];
				}

				if (left != nullptr && left->type == hol_term_type::EQUALS
				 && left->binary.right->type == hol_term_type::LAMBDA
				 && left->binary.right->quantifier.operand->type == hol_term_type::LAMBDA)
				{
					unsigned int first_function_variable = left->binary.right->quantifier.variable;
					unsigned int second_function_variable = left->binary.right->quantifier.operand->quantifier.variable;
					unsigned int new_first_function_variable = ++max_variable;
					unsigned int new_second_function_variable = ++max_variable;

					array<hol_term*> second_scopes(8);
					if (!get_scopes(*second_head, second_scopes))
						return false;
					for (const hol_term* scope : second_scopes) {
						if (scope->type != hol_term_type::FOR_ALL && scope->type != hol_term_type::EXISTS && scope->type != hol_term_type::LAMBDA)
							continue;
						if (scope->quantifier.variable == first_function_variable) {
							if (!second_variable_map.ensure_capacity(second_variable_map.size + 1)) {
								for (auto entry : second_variable_map) free(entry.value);
								return false;
							}
							unsigned int index = second_variable_map.index_of(scope);
							second_variable_map.keys[index] = scope;
							second_variable_map.values[index] = new_first_function_variable;
							if (index == second_variable_map.size)
								second_variable_map.size++;
						} else if (scope->quantifier.variable == second_function_variable) {
							if (!second_variable_map.ensure_capacity(second_variable_map.size + 1)) {
								for (auto entry : second_variable_map) free(entry.value);
								return false;
							}
							unsigned int index = second_variable_map.index_of(scope);
							second_variable_map.keys[index] = scope;
							second_variable_map.values[index] = new_second_function_variable;
							if (index == second_variable_map.size)
								second_variable_map.size++;
						}
					}
				}
			}
		}

		if (SubstitutionSetting == substitution_setting::ARG2 && lambda_variable != 0) {
			/* get the arg1 term from `first_head` */
			hol_term* first_set_var = nullptr;
			if ((first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) && first_head->any.included != nullptr && first_head->any.included->type == hol_term_type::EXISTS)
				first_head = first_head->any.included;
			if (first_head->type == hol_term_type::EXISTS) {
				hol_term* second = nullptr;
				hol_term* operand = first_head->quantifier.operand;
				if (operand->type == hol_term_type::AND) {
					second = operand->array.operands[1];
				} else if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
					if (operand->any_array.left.length > 1) {
						second = operand->any_array.left.operands[1];
					} else {
						if (operand->any_array.right.length > 1) {
							second = operand->any_array.right.operands[1];
						} else {
							second = operand->any_array.all;
						}
					}
				}

				if (second != nullptr && second->type == hol_term_type::EQUALS)
					first_set_var = second->binary.right;
			}

			hol_term* arg1_set = nullptr;
			hol_term* current = second_head;
			while (first_set_var != nullptr && current != nullptr) {
				if (current->type == hol_term_type::AND) {
					for (unsigned int i = 0; arg1_set == nullptr && i < current->array.length; i++)
						if (current->array.operands[i]->type == hol_term_type::UNARY_APPLICATION
						 && current->array.operands[i]->binary.right->type == hol_term_type::VARIABLE
						 && current->array.operands[i]->binary.right->variable == lambda_variable)
							arg1_set = current->array.operands[i]->binary.left;
				} else if (current->type == hol_term_type::ANY_ARRAY && current->any_array.oper == hol_term_type::AND) {
					for (unsigned int i = 0; arg1_set == nullptr && i < current->any_array.left.length; i++)
						if (current->any_array.left.operands[i]->type == hol_term_type::UNARY_APPLICATION
						 && current->any_array.left.operands[i]->binary.right->type == hol_term_type::VARIABLE
						 && current->any_array.left.operands[i]->binary.right->variable == lambda_variable)
							arg1_set = current->any_array.left.operands[i]->binary.left;
					for (unsigned int i = 0; arg1_set == nullptr && i < current->any_array.any.length; i++)
						if (current->any_array.any.operands[i]->type == hol_term_type::UNARY_APPLICATION
						 && current->any_array.any.operands[i]->binary.right->type == hol_term_type::VARIABLE
						 && current->any_array.any.operands[i]->binary.right->variable == lambda_variable)
							arg1_set = current->any_array.any.operands[i]->binary.left;
					for (unsigned int i = 0; arg1_set == nullptr && i < current->any_array.right.length; i++)
						if (current->any_array.right.operands[i]->type == hol_term_type::UNARY_APPLICATION
						 && current->any_array.right.operands[i]->binary.right->type == hol_term_type::VARIABLE
						 && current->any_array.right.operands[i]->binary.right->variable == lambda_variable)
							arg1_set = current->any_array.right.operands[i]->binary.left;
				}

				switch (current->type) {
				case hol_term_type::VARIABLE:
				case hol_term_type::VARIABLE_PREIMAGE:
				case hol_term_type::CONSTANT:
				case hol_term_type::PARAMETER:
				case hol_term_type::NUMBER:
				case hol_term_type::STRING:
				case hol_term_type::UINT_LIST:
				case hol_term_type::TRUE:
				case hol_term_type::FALSE:
				case hol_term_type::EQUALS:
				case hol_term_type::BINARY_APPLICATION:
				case hol_term_type::IFF:
				case hol_term_type::ANY_CONSTANT:
				case hol_term_type::ANY_CONSTANT_EXCEPT:
				case hol_term_type::ANY_RIGHT_ONLY:
					current = nullptr;
					break;
				case hol_term_type::NOT:
					current = current->unary.operand;
					break;
				case hol_term_type::AND:
				case hol_term_type::OR:
					current = current->array.operands[current->array.length - 1];
					break;
				case hol_term_type::FOR_ALL:
				case hol_term_type::EXISTS:
				case hol_term_type::LAMBDA:
					current = current->quantifier.operand;
					break;
				case hol_term_type::IF_THEN:
				case hol_term_type::UNARY_APPLICATION:
					current = current->binary.right;
					break;
				case hol_term_type::ANY:
				case hol_term_type::ANY_RIGHT:
					current = current->any.included;
					break;
				case hol_term_type::ANY_ARRAY:
					if (current->any_array.right.length != 0)
						current = current->any_array.right.operands[current->any_array.right.length - 1];
					else current = current->any_array.all;
					break;
				case hol_term_type::ANY_QUANTIFIER:
					current = current->any_quantifier.operand;
					break;
				}

				if (current != nullptr && !second_head_inverter.outer.add(current)) {
					for (auto entry : second_variable_map) free(entry.value);
					return false;
				}
				if (arg1_set != nullptr && (current->type == hol_term_type::FOR_ALL || current->type == hol_term_type::EXISTS || current->type == hol_term_type::LAMBDA))
					break;
			}

			if (first_set_var != nullptr && arg1_set != nullptr) {
				array<pair<hol_term*, variable_map>> intersection(2);
				intersect<built_in_predicates, true, true>(intersection, arg1_set, first_set_var);
				if (intersection.length == 0) {
					return false;
				} else if (intersection.length != 1) {
					fprintf(stderr, "invert_select_function ERROR: Intersection modulo variable relabeling is not unique.\n");
					free_all(intersection); return false;
				}

				const variable_map& var_map = intersection[0].value;
				array_map<unsigned int, variable_set> free_variable_map(8);
				for (const auto& entry : var_map.free_variables) {
					const variable_set& set = entry.value;
					unsigned int src_variable = entry.key;
					if (!free_variable_map.ensure_capacity(free_variable_map.size + 1)) {
						free_all(intersection);
						return false;
					}
					unsigned int index = free_variable_map.index_of(src_variable);
					if (index < free_variable_map.size) {
						variable_set& new_set = *((variable_set*) alloca(sizeof(variable_map)));
						if (!intersect(new_set, set, free_variable_map.values[index])) {
							free_all(intersection);
							return false;
						}
						swap(free_variable_map.values[index], new_set);
						free(new_set);
					} else {
						free_variable_map.keys[free_variable_map.size] = src_variable;
						if (!init(free_variable_map.values[free_variable_map.size], set)) {
							free_all(intersection);
							return false;
						}
						free_variable_map.size++;
					}
				}
				free_all(intersection);

				if (!remap_scopes(free_variable_map, first_head_inverter, second_head_inverter, second_variable_map, max_variable, first_head_is_array, second_head_is_array)) {
					for (auto entry : second_variable_map) free(entry.value);
					return false;
				}
			}
		}
		return true;
	};

	return invert_apply_head(inverse, inverse_count, flags, first, second,
		find_head<built_in_predicates>, find_root, on_remap_variables,
		[&lambda_variable](array<hol_term*>& dst, array<hol_term*>& dst_outer, hol_term* first_head, hol_term* second_head, const apply_head_inverter& first_inverter, const apply_head_inverter& second_inverter, head_index first_predicate_index, head_index second_predicate_index, hol_term*& conjunct, unsigned int& max_variable, bool& any_right_only, bool& could_have_wide_scope, bool is_array)
		{
			/* first try to get these variables from `first` */
			unsigned int function_variable, first_function_variable, second_function_variable, head_variable;
			if ((first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) && first_head->any.included != nullptr && first_head->any.included->type == hol_term_type::EXISTS)
				first_head = first_head->any.included;
			while (first_head->type == hol_term_type::NOT)
				first_head = first_head->unary.operand;
			if (first_head->type == hol_term_type::ANY || first_head->type == hol_term_type::ANY_RIGHT) {
				function_variable = ++max_variable;
				first_function_variable = ++max_variable;
				second_function_variable = ++max_variable;
				head_variable = ++max_variable;
			} else {
#if !defined(NDEBUG)
				if (first_head->type != hol_term_type::EXISTS)
					fprintf(stderr, "invert_select_function ERROR: Expected existentially-quantified conjunction.\n");
#endif
				hol_term* left;
				hol_term* operand = first_head->quantifier.operand;
				head_variable = first_head->quantifier.variable;
				if (operand->type == hol_term_type::AND) {
					left = operand->array.operands[0];
				} else if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
					if (operand->any_array.left.length == 0)
						left = nullptr;
					else left = operand->any_array.left.operands[0];
				} else {
					left = operand;
				}

				if (left != nullptr && left->type == hol_term_type::UNARY_APPLICATION
				 && left->binary.left->type == hol_term_type::UNARY_APPLICATION
				 && left->binary.left->binary.right->type == hol_term_type::VARIABLE)
				{
					function_variable = left->binary.left->binary.right->variable;
					hol_term* function_scope = nullptr;
					for (hol_term* scope : first_inverter.outer) {
						if (scope->type != hol_term_type::EXISTS && scope->type != hol_term_type::FOR_ALL && scope->type != hol_term_type::LAMBDA)
							continue;
						if (scope->quantifier.variable == function_variable) {
							function_scope = scope;
							break;
						}
					}

					left = nullptr;
					operand = function_scope->quantifier.operand;
					if (operand->type == hol_term_type::AND) {
						left = operand->array.operands[0];
					} else if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
						if (operand->any_array.left.length != 0)
							left = operand->any_array.left.operands[0];
					}

					if (left != nullptr && left->type == hol_term_type::EQUALS
					 && left->binary.right->type == hol_term_type::LAMBDA
					 && left->binary.right->quantifier.operand->type == hol_term_type::LAMBDA)
					{
						first_function_variable = left->binary.right->quantifier.variable;
						second_function_variable = left->binary.right->quantifier.operand->quantifier.variable;
					} else {
						first_function_variable = ++max_variable;
						second_function_variable = ++max_variable;
					}
				} else {
					function_variable = ++max_variable;
					first_function_variable = ++max_variable;
					second_function_variable = ++max_variable;
				}
			}

			hol_term* found_conjunct = nullptr;
			bool could_have_conjunct = false;
			array<pair<hol_term*, head_index>> scopes(8);
			if (!find_conjunct(second_head, &hol_term::constants<(unsigned int) built_in_predicates::TRACE>::value, scopes, found_conjunct, could_have_conjunct) || !could_have_conjunct)
				return false;

			hol_term* arg1_set = nullptr;
			hol_term* common_ancestor_scope;
			unsigned int last_common_ancestor_scope;
			if (found_conjunct == nullptr) {
				/* scopes is empty if the precise conjunct is not found */
				hol_term* first_any_right = nullptr;
				hol_term* current = second_head;
				while (current != nullptr) {
					switch (current->type) {
					case hol_term_type::VARIABLE:
					case hol_term_type::VARIABLE_PREIMAGE:
					case hol_term_type::CONSTANT:
					case hol_term_type::PARAMETER:
					case hol_term_type::NUMBER:
					case hol_term_type::STRING:
					case hol_term_type::UINT_LIST:
					case hol_term_type::TRUE:
					case hol_term_type::FALSE:
					case hol_term_type::EQUALS:
					case hol_term_type::BINARY_APPLICATION:
					case hol_term_type::IFF:
					case hol_term_type::ANY_CONSTANT:
					case hol_term_type::ANY_CONSTANT_EXCEPT:
					case hol_term_type::ANY_RIGHT_ONLY:
						current = nullptr;
						break;
					case hol_term_type::NOT:
						current = current->unary.operand;
						break;
					case hol_term_type::AND:
						if (SubstitutionSetting == substitution_setting::ARG2 && lambda_variable != 0) {
							for (unsigned int i = 0; arg1_set == nullptr && i < current->array.length; i++) {
								if (current->array.operands[i]->type == hol_term_type::UNARY_APPLICATION
								 && current->array.operands[i]->binary.right->type == hol_term_type::VARIABLE
								 && current->array.operands[i]->binary.right->variable == lambda_variable)
								{
									arg1_set = current->array.operands[i]->binary.left;
									first_any_right = nullptr;
								}
							}
						}
					case hol_term_type::OR:
						current = current->array.operands[current->array.length - 1];
						break;
					case hol_term_type::FOR_ALL:
					case hol_term_type::EXISTS:
					case hol_term_type::LAMBDA:
						current = current->quantifier.operand;
						break;
					case hol_term_type::IF_THEN:
					case hol_term_type::UNARY_APPLICATION:
						current = current->binary.right;
						break;
					case hol_term_type::ANY_RIGHT:
						if (first_any_right == nullptr)
							first_any_right = current;
					case hol_term_type::ANY:
						current = current->any.included;
						break;
					case hol_term_type::ANY_ARRAY:
						if (SubstitutionSetting == substitution_setting::ARG2 && lambda_variable != 0) {
							for (unsigned int i = 0; arg1_set == nullptr && i < current->any_array.left.length; i++) {
								if (current->any_array.left.operands[i]->type == hol_term_type::UNARY_APPLICATION
								 && current->any_array.left.operands[i]->binary.right->type == hol_term_type::VARIABLE
								 && current->any_array.left.operands[i]->binary.right->variable == lambda_variable)
								{
									arg1_set = current->any_array.left.operands[i]->binary.left;
									first_any_right = nullptr;
								}
							} for (unsigned int i = 0; arg1_set == nullptr && i < current->any_array.any.length; i++) {
								if (current->any_array.any.operands[i]->type == hol_term_type::UNARY_APPLICATION
								 && current->any_array.any.operands[i]->binary.right->type == hol_term_type::VARIABLE
								 && current->any_array.any.operands[i]->binary.right->variable == lambda_variable)
								{
									arg1_set = current->any_array.any.operands[i]->binary.left;
									first_any_right = nullptr;
								}
							} for (unsigned int i = 0; arg1_set == nullptr && i < current->any_array.right.length; i++) {
								if (current->any_array.right.operands[i]->type == hol_term_type::UNARY_APPLICATION
								 && current->any_array.right.operands[i]->binary.right->type == hol_term_type::VARIABLE
								 && current->any_array.right.operands[i]->binary.right->variable == lambda_variable)
								{
									arg1_set = current->any_array.right.operands[i]->binary.left;
									first_any_right = nullptr;
								}
							}
						}
						if (current->any_array.right.length != 0)
							current = current->any_array.right.operands[current->any_array.right.length - 1];
						else current = current->any_array.all;
						break;
					case hol_term_type::ANY_QUANTIFIER:
						current = current->any_quantifier.operand;
						break;
					}
				}
				common_ancestor_scope = first_any_right;
			} else {
				/* find the last node on the right-most path from the root */
				unsigned int last_existential_scope = 0;
				for (unsigned int i = scopes.length; i > 0; i--) {
					if (scopes[i - 1].key->type == hol_term_type::AND || scopes[i - 1].key->type == hol_term_type::OR || scopes[i - 1].key->type == hol_term_type::IFF) {
						if (scopes[i - 1].value.index != scopes[i - 1].key->array.length - 1)
							break;
					} else if (scopes[i - 1].key->type == hol_term_type::ANY_ARRAY) {
						if (scopes[i - 1].value.position != head_position::NONE && !(scopes[i - 1].value.position == head_position::RIGHT && scopes[i - 1].value.index == 0))
							break;
					} else if (scopes[i - 1].key->type == hol_term_type::EXISTS) {
						last_existential_scope = i;
					}
				}
				last_common_ancestor_scope = last_existential_scope;
				if (last_common_ancestor_scope < scopes.length && (scopes[last_common_ancestor_scope].key->type == hol_term_type::ANY || scopes[last_common_ancestor_scope].key->type == hol_term_type::ANY_RIGHT))
					last_common_ancestor_scope++;
				common_ancestor_scope = scopes[last_common_ancestor_scope - 1].key;
			}

			hol_term* new_common_ancestor;
			if (found_conjunct == nullptr) {
				new_common_ancestor = common_ancestor_scope;
				new_common_ancestor->reference_count++;
			} else {
				unsigned int inner_variable;
				if (scopes[0].key->type == hol_term_type::EXISTS) {
					inner_variable = scopes[0].key->quantifier.variable;
				} else if (scopes.length >= 2 && scopes[1].key->type == hol_term_type::EXISTS) {
					inner_variable = scopes[1].key->quantifier.variable;
				} else if (scopes.length == 1) {
					inner_variable = second_head->quantifier.variable;
				} else {
					return false;
				}
				hol_term* new_inner_conjunct = hol_term::new_equals(
						hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value, hol_term::new_variable(inner_variable)),
						hol_term::new_variable(second_function_variable));
				if (new_inner_conjunct == nullptr)
					return false;
				hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value.reference_count++;

				unsigned int old_scope_length = scopes.length;
				scopes.length = last_common_ancestor_scope;
				new_common_ancestor = substitute_scope<false>(common_ancestor_scope, new_inner_conjunct, scopes);
				scopes.length = old_scope_length;
				if (new_common_ancestor == nullptr)
					return false;
			}

			head_index predicate_index; no_op apply;
			hol_term* inner_second_head = find_head(new_common_ancestor, predicate_index, find_head<built_in_predicates>, apply);
			if (inner_second_head == nullptr) {
				free(*new_common_ancestor); if (new_common_ancestor->reference_count == 0) free(new_common_ancestor);
				return false;
			}

			if ((inner_second_head->type == hol_term_type::ANY || inner_second_head->type == hol_term_type::ANY_RIGHT) && inner_second_head->any.included != nullptr)
				inner_second_head = inner_second_head->any.included;
			hol_term* old_inner_second_head = inner_second_head;

			if (SubstitutionSetting == substitution_setting::EMPTY) {
				hol_term* operand = inner_second_head->quantifier.operand;
				if (operand->type == hol_term_type::AND) {
					inner_second_head = operand->array.operands[1];
				} else if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND && operand->any_array.right.length != 0) {
					inner_second_head = operand->any_array.right.operands[operand->any_array.right.length - 1];
				} else if (operand->type == hol_term_type::ANY_RIGHT && operand->any.included != nullptr && operand->any.included->type == hol_term_type::EXISTS) {
					inner_second_head = operand->any.included;
				} else {
					return false;
				}
			}
#if !defined(NDEBUG)
			if (inner_second_head->type != hol_term_type::EXISTS)
				fprintf(stderr, "invert_select_function WARNING: Expected an existentially-quantified expression.\n");
#endif

			hol_term* substituted_term;
			hol_term* new_inner_second_head = nullptr;
			hol_term* second_operand = inner_second_head->quantifier.operand;
			if (SubstitutionSetting == substitution_setting::NONE) {
				hol_term* new_right = hol_term::new_equals(
						hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG1_OF>::value, hol_term::new_variable(first_function_variable)),
						hol_term::new_variable(second_head->quantifier.variable));
				if (new_right == nullptr) {
					free(*new_common_ancestor); if (new_common_ancestor->reference_count == 0) free(new_common_ancestor);
					return false;
				}
				hol_term::constants<(unsigned int) built_in_predicates::ARG1_OF>::value.reference_count++;

				if (second_operand->type == hol_term_type::AND) {
					new_inner_second_head = hol_term::new_exists(inner_second_head->quantifier.variable,
							hol_term::new_and(make_appended_array_view(make_array_view(second_operand->array.operands, second_operand->array.length), new_right)));
					if (new_inner_second_head == nullptr) {
						free(*new_common_ancestor); if (new_common_ancestor->reference_count == 0) free(new_common_ancestor);
						free(*new_right); free(new_right); return false;
					}
					for (unsigned int i = 0; i < second_operand->array.length; i++)
						second_operand->array.operands[i]->reference_count++;
				} else if (second_operand->type == hol_term_type::ANY_ARRAY && second_operand->any_array.oper == hol_term_type::AND) {
					new_inner_second_head = hol_term::new_exists(inner_second_head->quantifier.variable,
							hol_term::new_any_array(hol_term_type::AND, second_operand->any_array.all,
							make_array_view(second_operand->any_array.any.operands, second_operand->any_array.any.length),
							make_array_view(second_operand->any_array.left.operands, second_operand->any_array.left.length),
							make_appended_array_view(make_array_view(second_operand->any_array.right.operands, second_operand->any_array.right.length), new_right)));
					if (new_inner_second_head == nullptr) {
						free(*new_common_ancestor); if (new_common_ancestor->reference_count == 0) free(new_common_ancestor);
						free(*new_right); free(new_right); return false;
					}
					second_operand->any_array.all->reference_count++;
					for (unsigned int i = 0; i < second_operand->any_array.any.length; i++)
						second_operand->any_array.any.operands[i]->reference_count++;
					for (unsigned int i = 0; i < second_operand->any_array.left.length; i++)
						second_operand->any_array.left.operands[i]->reference_count++;
					for (unsigned int i = 0; i < second_operand->any_array.right.length; i++)
						second_operand->any_array.right.operands[i]->reference_count++;
				} else {
					new_inner_second_head = hol_term::new_exists(inner_second_head->quantifier.variable, hol_term::new_and(second_operand, new_right));
					if (new_inner_second_head == nullptr) {
						free(*new_common_ancestor); if (new_common_ancestor->reference_count == 0) free(new_common_ancestor);
						free(*new_right); free(new_right); return false;
					}
					second_operand->reference_count++;
				}
			} else {
				hol_term* arg_term;
				if (second_operand->type == hol_term_type::AND) {
					if (SubstitutionSetting == substitution_setting::ARG2)
						arg_term = second_operand->array.operands[0];
					else arg_term = second_operand->array.operands[second_operand->array.length - 1];
				} else {
					if (SubstitutionSetting == substitution_setting::ARG2)
						arg_term = second_operand->any_array.left.operands[0];
					else arg_term = second_operand->any_array.right.operands[second_operand->any_array.right.length - 1];
				}

				if (arg_term->type == hol_term_type::ANY_RIGHT && arg_term->any.included != nullptr)
					arg_term = arg_term->any.included;

				hol_term* new_arg_term;
				if (arg_term->type == hol_term_type::EQUALS && arg_term->binary.left->type == hol_term_type::UNARY_APPLICATION
				 && arg_term->binary.left->binary.left->type == hol_term_type::CONSTANT)
				{
					if (arg_term->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG1
					 || arg_term->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG2
					 || arg_term->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG3)
					{
						new_arg_term = hol_term::new_equals(arg_term->binary.left,
								hol_term::new_variable(first_function_variable));
						if (new_arg_term == nullptr) {
							free(*new_common_ancestor); if (new_common_ancestor->reference_count == 0) free(new_common_ancestor);
							return false;
						}
						arg_term->binary.left->reference_count++;
						substituted_term = arg_term->binary.right;
					} else if (arg_term->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG1_OF
							|| arg_term->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG2_OF
							|| arg_term->binary.left->binary.left->constant == (unsigned int) built_in_predicates::ARG3_OF)
					{
						new_arg_term = hol_term::new_equals(
								hol_term::new_apply(arg_term->binary.left->binary.left, hol_term::new_variable(first_function_variable)),
								arg_term->binary.right);
						if (new_arg_term == nullptr) {
							free(*new_common_ancestor); if (new_common_ancestor->reference_count == 0) free(new_common_ancestor);
							return false;
						}
						arg_term->binary.left->binary.left->reference_count++;
						arg_term->binary.right->reference_count++;
						substituted_term = arg_term->binary.left->binary.right;
					} else {
						free(*new_common_ancestor); if (new_common_ancestor->reference_count == 0) free(new_common_ancestor);
						return false;
					}
				} else {
					free(*new_common_ancestor); if (new_common_ancestor->reference_count == 0) free(new_common_ancestor);
					return false;
				}

				if (second_operand->type == hol_term_type::AND) {
					if (SubstitutionSetting == substitution_setting::ARG2) {
						new_inner_second_head = hol_term::new_exists(inner_second_head->quantifier.variable,
								hol_term::new_and(make_prepended_array_view(new_arg_term, make_array_view(second_operand->array.operands + 1, second_operand->array.length - 1))));
						if (new_inner_second_head == nullptr) {
							free(*new_common_ancestor); if (new_common_ancestor->reference_count == 0) free(new_common_ancestor);
							free(*new_arg_term); free(new_arg_term); return false;
						}
						for (unsigned int i = 1; i < second_operand->array.length; i++)
							second_operand->array.operands[i]->reference_count++;
					} else {
						new_inner_second_head = hol_term::new_exists(inner_second_head->quantifier.variable,
								hol_term::new_and(make_appended_array_view(make_array_view(second_operand->array.operands, second_operand->array.length - 1), new_arg_term)));
						if (new_inner_second_head == nullptr) {
							free(*new_common_ancestor); if (new_common_ancestor->reference_count == 0) free(new_common_ancestor);
							free(*new_arg_term); free(new_arg_term); return false;
						}
						for (unsigned int i = 0; i < second_operand->array.length - 1; i++)
							second_operand->array.operands[i]->reference_count++;
					}
				} else if (second_operand->type == hol_term_type::ANY_ARRAY && second_operand->any_array.oper == hol_term_type::AND) {
					if (SubstitutionSetting == substitution_setting::ARG2) {
						new_inner_second_head = hol_term::new_exists(inner_second_head->quantifier.variable,
								hol_term::new_any_array(hol_term_type::AND, second_operand->any_array.all,
								make_array_view(second_operand->any_array.any.operands, second_operand->any_array.any.length),
								make_prepended_array_view(new_arg_term, make_array_view(second_operand->any_array.left.operands + 1, second_operand->any_array.left.length - 1)),
								make_array_view(second_operand->any_array.right.operands, second_operand->any_array.right.length)));
						if (new_inner_second_head == nullptr) {
							free(*new_common_ancestor); if (new_common_ancestor->reference_count == 0) free(new_common_ancestor);
							free(*new_arg_term); free(new_arg_term); return false;
						}
						second_operand->any_array.all->reference_count++;
						for (unsigned int i = 0; i < second_operand->any_array.any.length; i++)
							second_operand->any_array.any.operands[i]->reference_count++;
						for (unsigned int i = 1; i < second_operand->any_array.left.length; i++)
							second_operand->any_array.left.operands[i]->reference_count++;
						for (unsigned int i = 0; i < second_operand->any_array.right.length; i++)
							second_operand->any_array.right.operands[i]->reference_count++;
					} else {
						new_inner_second_head = hol_term::new_exists(inner_second_head->quantifier.variable,
								hol_term::new_any_array(hol_term_type::AND, second_operand->any_array.all,
								make_array_view(second_operand->any_array.any.operands, second_operand->any_array.any.length),
								make_array_view(second_operand->any_array.left.operands, second_operand->any_array.left.length),
								make_appended_array_view(make_array_view(second_operand->any_array.right.operands, second_operand->any_array.right.length - 1), new_arg_term)));
						if (new_inner_second_head == nullptr) {
							free(*new_common_ancestor); if (new_common_ancestor->reference_count == 0) free(new_common_ancestor);
							free(*new_arg_term); free(new_arg_term); return false;
						}
						second_operand->any_array.all->reference_count++;
						for (unsigned int i = 0; i < second_operand->any_array.any.length; i++)
							second_operand->any_array.any.operands[i]->reference_count++;
						for (unsigned int i = 0; i < second_operand->any_array.left.length; i++)
							second_operand->any_array.left.operands[i]->reference_count++;
						for (unsigned int i = 0; i < second_operand->any_array.right.length - 1; i++)
							second_operand->any_array.right.operands[i]->reference_count++;
					}
				}
			}

			hol_term* new_function_head = substitute_head<any_node_position::NONE>(new_common_ancestor, old_inner_second_head, new_inner_second_head);
			free(*new_common_ancestor); if (new_common_ancestor->reference_count == 0) free(new_common_ancestor);
			free(*new_inner_second_head); if (new_inner_second_head->reference_count == 0) free(new_inner_second_head);
			if (new_function_head == nullptr)
				return false;

			hol_term* function_var = hol_term::new_variable(function_variable);
			if (function_var == nullptr) {
				free(*new_function_head); if (new_function_head->reference_count == 0) free(new_function_head);
				return false;
			}

			hol_term* head_var = hol_term::new_variable(head_variable);
			if (head_var == nullptr) {
				free(*new_function_head); if (new_function_head->reference_count == 0) free(new_function_head);
				free(*function_var); free(function_var);
				return false;
			}

			hol_term* new_term;
			if (SubstitutionSetting == substitution_setting::ARG2 && lambda_variable != 0) {
				for (unsigned int i = scopes.length; arg1_set == nullptr && i > 0; i--) {
					hol_term* scope = scopes[i - 1].key;
					if (scope->type == hol_term_type::AND) {
						for (unsigned int i = 0; arg1_set == nullptr && i < scope->array.length; i++)
							if (scope->array.operands[i]->type == hol_term_type::UNARY_APPLICATION
							 && scope->array.operands[i]->binary.right->type == hol_term_type::VARIABLE
							 && scope->array.operands[i]->binary.right->variable == lambda_variable)
								arg1_set = scope->array.operands[i]->binary.left;
					} else if (scope->type == hol_term_type::ANY_ARRAY && scope->any_array.oper == hol_term_type::AND) {
						for (unsigned int i = 0; arg1_set == nullptr && i < scope->any_array.left.length; i++)
							if (scope->any_array.left.operands[i]->type == hol_term_type::UNARY_APPLICATION
							 && scope->any_array.left.operands[i]->binary.right->type == hol_term_type::VARIABLE
							 && scope->any_array.left.operands[i]->binary.right->variable == lambda_variable)
								arg1_set = scope->any_array.left.operands[i]->binary.left;
						for (unsigned int i = 0; arg1_set == nullptr && i < scope->any_array.any.length; i++)
							if (scope->any_array.any.operands[i]->type == hol_term_type::UNARY_APPLICATION
							 && scope->any_array.any.operands[i]->binary.right->type == hol_term_type::VARIABLE
							 && scope->any_array.any.operands[i]->binary.right->variable == lambda_variable)
								arg1_set = scope->any_array.any.operands[i]->binary.left;
						for (unsigned int i = 0; arg1_set == nullptr && i < scope->any_array.right.length; i++)
							if (scope->any_array.right.operands[i]->type == hol_term_type::UNARY_APPLICATION
							 && scope->any_array.right.operands[i]->binary.right->type == hol_term_type::VARIABLE
							 && scope->any_array.right.operands[i]->binary.right->variable == lambda_variable)
								arg1_set = scope->any_array.right.operands[i]->binary.left;
					}
				}

				if (arg1_set == nullptr)
					arg1_set = &HOL_ANY;

				new_term = hol_term::new_exists(head_variable, hol_term::new_and(
							hol_term::new_apply(hol_term::new_apply(&HOL_ANY, function_var), head_var),
							hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG1>::value, head_var), arg1_set),
							hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value, head_var), substituted_term)
						));
				if (new_term == nullptr) {
					free(*new_function_head); if (new_function_head->reference_count == 0) free(new_function_head);
					free(*head_var); free(head_var);
					free(*function_var); free(function_var);
					return false;
				}
				function_var->reference_count++;
				head_var->reference_count += 3 - 1;
				arg1_set->reference_count++;
				substituted_term->reference_count++;
				HOL_ANY.reference_count++;
				hol_term::constants<(unsigned int) built_in_predicates::ARG1>::value.reference_count++;
				hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value.reference_count++;
			} else if (SubstitutionSetting == substitution_setting::ARG2) {
				new_term = hol_term::new_exists(head_variable, hol_term::new_and(
							hol_term::new_apply(hol_term::new_apply(&HOL_ANY, function_var), head_var),
							hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value, head_var), substituted_term)
						));
				if (new_term == nullptr) {
					free(*new_function_head); if (new_function_head->reference_count == 0) free(new_function_head);
					free(*head_var); free(head_var);
					free(*function_var); free(function_var);
					return false;
				}
				function_var->reference_count++;
				head_var->reference_count += 2 - 1;
				substituted_term->reference_count++;
				HOL_ANY.reference_count++;
				hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value.reference_count++;
			} else if (SubstitutionSetting == substitution_setting::EMPTY || SubstitutionSetting == substitution_setting::NONE) {
				new_term = hol_term::new_exists(head_variable, hol_term::new_apply(hol_term::new_apply(&HOL_ANY, function_var), head_var));
				if (new_term == nullptr) {
					free(*new_function_head); if (new_function_head->reference_count == 0) free(new_function_head);
					free(*head_var); free(head_var);
					free(*function_var); free(function_var);
					return false;
				}
				function_var->reference_count++;
				HOL_ANY.reference_count += 1;
			}

			dst[dst.length++] = new_term;
			hol_term* new_outer = hol_term::new_exists(function_variable, hol_term::new_and(
						hol_term::new_equals(function_var, hol_term::new_lambda(first_function_variable, hol_term::new_lambda(second_function_variable, new_function_head))), &HOL_ZERO));
			if (new_outer == nullptr) {
				free(*new_function_head); if (new_function_head->reference_count == 0) free(new_function_head);
				free(*function_var); if (function_var->reference_count == 0) free(function_var);
				return false;
			}
			HOL_ZERO.reference_count++;

			dst_outer[dst_outer.length] = substitute_head<any_node_position::LEFT>(second_head, common_ancestor_scope, new_outer);
			free(*new_outer); if (new_outer->reference_count == 0) free(new_outer);
			if (dst_outer[dst_outer.length] == nullptr)
				return false;
			dst_outer.length++;
			return true;
		});
}

inline bool invert_select_antecedent(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	hol_term* new_second = hol_term::new_if_then(second, &HOL_ANY);
	if (new_second == nullptr)
		return false;
	second->reference_count++;
	HOL_ANY.reference_count++;

	array<hol_term*> inverted_logical_forms(2);
	intersect<built_in_predicates>(inverted_logical_forms, first, new_second);
	free(*new_second); if (new_second->reference_count == 0) free(new_second);
	if (inverted_logical_forms.length == 0)
		return false;

	inverse = (flagged_logical_form<hol_term>*) malloc(sizeof(flagged_logical_form<hol_term>) * inverted_logical_forms.length);
	for (unsigned int i = 0; i < inverted_logical_forms.length; i++) {
		inverse[i].flags = flags;
		inverse[i].root = inverted_logical_forms[i];
	}
	inverse_count = inverted_logical_forms.length;
	return true;
}

inline bool invert_select_consequent(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	hol_term* new_second = hol_term::new_if_then(&HOL_ANY, second);
	if (new_second == nullptr)
		return false;
	second->reference_count++;
	HOL_ANY.reference_count++;

	array<hol_term*> inverted_logical_forms(2);
	intersect<built_in_predicates>(inverted_logical_forms, first, new_second);
	free(*new_second); if (new_second->reference_count == 0) free(new_second);
	if (inverted_logical_forms.length == 0)
		return false;

	inverse = (flagged_logical_form<hol_term>*) malloc(sizeof(flagged_logical_form<hol_term>) * inverted_logical_forms.length);
	for (unsigned int i = 0; i < inverted_logical_forms.length; i++) {
		inverse[i].flags = flags;
		inverse[i].root = inverted_logical_forms[i];
	}
	inverse_count = inverted_logical_forms.length;
	return true;
}

inline bool invert_require_capitalized(
		flagged_logical_form<hol_term>*& inverse,
		unsigned int& inverse_count,
		const grammatical_flags& flags,
		hol_term* first, hol_term* second)
{
	hol_term* new_head;
	if (!require_capitalized<false>(second, new_head))
		return false;

	if (!intersect(inverse, inverse_count, flags, first, new_head)) {
		free(*new_head); if (new_head->reference_count == 0) free(new_head);
		return false;
	}
	free(*new_head); if (new_head->reference_count == 0) free(new_head);
	return true;
}

template<typename Formula>
inline bool invert_add_flag(
		flagged_logical_form<Formula>*& inverse,
		unsigned int& inverse_count,
		const flagged_logical_form<Formula>& first,
		const flagged_logical_form<Formula>& second,
		grammatical_flag flag)
{
	grammatical_flags flags;
	if ((second.flags.flags[(uint_fast8_t) flag] != grammatical_flag_value::TRUE && second.flags.flags[(uint_fast8_t) flag] != grammatical_flag_value::ANY)
	 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
	 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
	 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
	 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
	 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
	 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
	 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
	 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
	 || !intersect(flags.mood, first.flags.mood, second.flags.mood)
	 || !intersect(flags.flags[(uint_fast8_t) flag], first.flags.flags[(uint_fast8_t) flag], grammatical_flag_value::FALSE))
		return false;
	flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
	for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++) {
		if ((grammatical_flag) i == flag) continue;
		if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
	}
	return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
		&& intersect(inverse, inverse_count, flags, first.root, second.root);
}

template<typename Formula, typename FindHeadFunction>
inline bool invert_add_flag(
		flagged_logical_form<Formula>*& inverse,
		unsigned int& inverse_count,
		const flagged_logical_form<Formula>& first,
		const flagged_logical_form<Formula>& second,
		grammatical_flag flag,
		FindHeadFunction find_head_function)
{
	grammatical_flags flags;
	if ((second.flags.flags[(uint_fast8_t) flag] != grammatical_flag_value::TRUE && second.flags.flags[(uint_fast8_t) flag] != grammatical_flag_value::ANY)
	 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
	 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
	 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
	 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
	 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
	 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
	 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
	 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
	 || !intersect(flags.mood, first.flags.mood, second.flags.mood)
	 || !intersect(flags.flags[(uint_fast8_t) flag], first.flags.flags[(uint_fast8_t) flag], grammatical_flag_value::FALSE))
		return false;
	flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
	for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++) {
		if ((grammatical_flag) i == flag) continue;
		if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
	}
	return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
		&& intersect_with_head(inverse, inverse_count, flags, first.root, second.root, find_head_function);
}

template<typename Formula>
inline bool invert_try_add_flag(
		flagged_logical_form<Formula>*& inverse,
		unsigned int& inverse_count,
		const flagged_logical_form<Formula>& first,
		const flagged_logical_form<Formula>& second,
		grammatical_flag flag)
{
	grammatical_flags flags;
	if ((second.flags.flags[(uint_fast8_t) flag] != grammatical_flag_value::TRUE && second.flags.flags[(uint_fast8_t) flag] != grammatical_flag_value::ANY)
	 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
	 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
	 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
	 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
	 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
	 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
	 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
	 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
	 || !intersect(flags.mood, first.flags.mood, second.flags.mood))
		return false;
	flags.flags[(uint_fast8_t) flag] = first.flags.flags[(uint_fast8_t) flag];
	flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
	for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++) {
		if ((grammatical_flag) i == flag) continue;
		if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
	}
	return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
		&& intersect(inverse, inverse_count, flags, first.root, second.root);
}

template<typename Formula>
inline bool invert_remove_flag(
		flagged_logical_form<Formula>*& inverse,
		unsigned int& inverse_count,
		const flagged_logical_form<Formula>& first,
		const flagged_logical_form<Formula>& second,
		grammatical_flag flag)
{
	grammatical_flags flags;
	if ((second.flags.flags[(uint_fast8_t) flag] != grammatical_flag_value::FALSE && second.flags.flags[(uint_fast8_t) flag] != grammatical_flag_value::ANY)
	 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
	 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
	 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
	 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
	 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
	 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
	 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
	 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
	 || !intersect(flags.mood, first.flags.mood, second.flags.mood)
	 || !intersect(flags.flags[(uint_fast8_t) flag], first.flags.flags[(uint_fast8_t) flag], grammatical_flag_value::TRUE))
		return false;
	flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
	for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++) {
		if ((grammatical_flag) i == flag) continue;
		if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
	}
	return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
		&& intersect(inverse, inverse_count, flags, first.root, second.root);
}

template<typename Formula, typename FindHeadFunction>
inline bool invert_remove_flag(
		flagged_logical_form<Formula>*& inverse,
		unsigned int& inverse_count,
		const flagged_logical_form<Formula>& first,
		const flagged_logical_form<Formula>& second,
		grammatical_flag flag,
		FindHeadFunction find_head_function)
{
	grammatical_flags flags;
	if ((second.flags.flags[(uint_fast8_t) flag] != grammatical_flag_value::FALSE && second.flags.flags[(uint_fast8_t) flag] != grammatical_flag_value::ANY)
	 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
	 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
	 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
	 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
	 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
	 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
	 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
	 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
	 || !intersect(flags.mood, first.flags.mood, second.flags.mood)
	 || !intersect(flags.flags[(uint_fast8_t) flag], first.flags.flags[(uint_fast8_t) flag], grammatical_flag_value::TRUE))
		return false;
	flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
	for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++) {
		if ((grammatical_flag) i == flag) continue;
		if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
	}
	return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
		&& intersect_with_head(inverse, inverse_count, flags, first.root, second.root, find_head_function);
}

template<typename Formula>
inline bool invert_try_remove_flag(
		flagged_logical_form<Formula>*& inverse,
		unsigned int& inverse_count,
		const flagged_logical_form<Formula>& first,
		const flagged_logical_form<Formula>& second,
		grammatical_flag flag)
{
	grammatical_flags flags;
	if ((second.flags.flags[(uint_fast8_t) flag] != grammatical_flag_value::FALSE && second.flags.flags[(uint_fast8_t) flag] != grammatical_flag_value::ANY)
	 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
	 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
	 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
	 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
	 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
	 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
	 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
	 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
	 || !intersect(flags.mood, first.flags.mood, second.flags.mood))
		return false;
	flags.flags[(uint_fast8_t) flag] = first.flags.flags[(uint_fast8_t) flag];
	flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
	for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++) {
		if ((grammatical_flag) i == flag) continue;
		if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
	}
	return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
		&& intersect(inverse, inverse_count, flags, first.root, second.root);
}

template<typename Formula, typename FindHeadFunction>
inline bool invert_try_remove_flag(
		flagged_logical_form<Formula>*& inverse,
		unsigned int& inverse_count,
		const flagged_logical_form<Formula>& first,
		const flagged_logical_form<Formula>& second,
		grammatical_flag flag,
		FindHeadFunction find_head_function)
{
	grammatical_flags flags;
	if ((second.flags.flags[(uint_fast8_t) flag] != grammatical_flag_value::FALSE && second.flags.flags[(uint_fast8_t) flag] != grammatical_flag_value::ANY)
	 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
	 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
	 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
	 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
	 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
	 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
	 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
	 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
	 || !intersect(flags.mood, first.flags.mood, second.flags.mood))
		return false;
	flags.flags[(uint_fast8_t) flag] = first.flags.flags[(uint_fast8_t) flag];
	flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
	for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++) {
		if ((grammatical_flag) i == flag) continue;
		if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
	}
	return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
		&& intersect_with_head(inverse, inverse_count, flags, first.root, second.root, find_head_function);
}

template<typename Formula>
inline bool invert_require_flag(
		flagged_logical_form<Formula>*& inverse,
		unsigned int& inverse_count,
		const flagged_logical_form<Formula>& first,
		const flagged_logical_form<Formula>& second,
		grammatical_flag flag)
{
	grammatical_flags flags;
	if ((second.flags.flags[(uint_fast8_t) flag] != grammatical_flag_value::TRUE && second.flags.flags[(uint_fast8_t) flag] != grammatical_flag_value::ANY)
	 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
	 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
	 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
	 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
	 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
	 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
	 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
	 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
	 || !intersect(flags.mood, first.flags.mood, second.flags.mood)
	 || !intersect(flags.flags[(uint_fast8_t) flag], first.flags.flags[(uint_fast8_t) flag], grammatical_flag_value::TRUE))
		return false;
	flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
	for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++) {
		if ((grammatical_flag) i == flag) continue;
		if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
	}
	return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
		&& intersect(inverse, inverse_count, flags, first.root, second.root);
}

template<typename Formula, typename FindHeadFunction>
inline bool invert_require_flag(
		flagged_logical_form<Formula>*& inverse,
		unsigned int& inverse_count,
		const flagged_logical_form<Formula>& first,
		const flagged_logical_form<Formula>& second,
		grammatical_flag flag,
		FindHeadFunction find_head_function)
{
	grammatical_flags flags;
	if ((second.flags.flags[(uint_fast8_t) flag] != grammatical_flag_value::TRUE && second.flags.flags[(uint_fast8_t) flag] != grammatical_flag_value::ANY)
	 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
	 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
	 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
	 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
	 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
	 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
	 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
	 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
	 || !intersect(flags.mood, first.flags.mood, second.flags.mood)
	 || !intersect(flags.flags[(uint_fast8_t) flag], first.flags.flags[(uint_fast8_t) flag], grammatical_flag_value::TRUE))
		return false;
	flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
	for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++) {
		if ((grammatical_flag) i == flag) continue;
		if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
	}
	return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
		&& intersect_with_head(inverse, inverse_count, flags, first.root, second.root, find_head_function);
}

template<typename Formula>
inline bool invert_require_no_flag(
		flagged_logical_form<Formula>*& inverse,
		unsigned int& inverse_count,
		const flagged_logical_form<Formula>& first,
		const flagged_logical_form<Formula>& second,
		grammatical_flag flag)
{
	grammatical_flags flags;
	if ((second.flags.flags[(uint_fast8_t) flag] != grammatical_flag_value::FALSE && second.flags.flags[(uint_fast8_t) flag] != grammatical_flag_value::ANY)
	 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
	 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
	 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
	 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
	 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
	 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
	 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
	 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
	 || !intersect(flags.mood, first.flags.mood, second.flags.mood)
	 || !intersect(flags.flags[(uint_fast8_t) flag], first.flags.flags[(uint_fast8_t) flag], grammatical_flag_value::FALSE))
		return false;
	flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
	for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++) {
		if ((grammatical_flag) i == flag) continue;
		if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
	}
	return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
		&& intersect(inverse, inverse_count, flags, first.root, second.root);
}

template<typename Formula, typename FindHeadFunction>
inline bool invert_require_no_flag(
		flagged_logical_form<Formula>*& inverse,
		unsigned int& inverse_count,
		const flagged_logical_form<Formula>& first,
		const flagged_logical_form<Formula>& second,
		grammatical_flag flag,
		FindHeadFunction find_head_function)
{
	grammatical_flags flags;
	if ((second.flags.flags[(uint_fast8_t) flag] != grammatical_flag_value::FALSE && second.flags.flags[(uint_fast8_t) flag] != grammatical_flag_value::ANY)
	 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
	 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
	 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
	 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
	 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
	 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
	 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
	 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
	 || !intersect(flags.mood, first.flags.mood, second.flags.mood)
	 || !intersect(flags.flags[(uint_fast8_t) flag], first.flags.flags[(uint_fast8_t) flag], grammatical_flag_value::FALSE))
		return false;
	flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
	for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++) {
		if ((grammatical_flag) i == flag) continue;
		if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
	}
	return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
		&& intersect_with_head(inverse, inverse_count, flags, first.root, second.root, find_head_function);
}

template<typename Formula>
inline bool invert_add_conjunction(
		flagged_logical_form<Formula>*& inverse,
		unsigned int& inverse_count,
		const flagged_logical_form<Formula>& first,
		const flagged_logical_form<Formula>& second,
		grammatical_conjunction cnj)
{
	grammatical_flags flags;
	if ((second.flags.cnj != cnj && second.flags.cnj != grammatical_conjunction::ANY)
	 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
	 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
	 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
	 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
	 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
	 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
	 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
	 || !intersect(flags.mood, first.flags.mood, second.flags.mood)
	 || !intersect(flags.cnj, first.flags.cnj, grammatical_conjunction::NONE))
		return false;
	flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
	for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
		if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
	return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
		&& intersect(inverse, inverse_count, flags, first.root, second.root);
}

template<typename Formula>
inline bool invert_remove_conjunction(
		flagged_logical_form<Formula>*& inverse,
		unsigned int& inverse_count,
		const flagged_logical_form<Formula>& first,
		const flagged_logical_form<Formula>& second,
		grammatical_conjunction cnj)
{
	grammatical_flags flags;
	if ((second.flags.cnj != grammatical_conjunction::NONE && second.flags.cnj != grammatical_conjunction::ANY)
	 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
	 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
	 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
	 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
	 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
	 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
	 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
	 || !intersect(flags.mood, first.flags.mood, second.flags.mood)
	 || !intersect(flags.cnj, first.flags.cnj, cnj))
		return false;
	flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
	for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
		if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
	return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
		&& intersect(inverse, inverse_count, flags, first.root, second.root);
}

template<typename Formula>
inline bool invert_require_no_conjunction(
		flagged_logical_form<Formula>*& inverse,
		unsigned int& inverse_count,
		const flagged_logical_form<Formula>& first,
		const flagged_logical_form<Formula>& second,
		grammatical_conjunction cnj)
{
	grammatical_flags flags;
	if (second.flags.cnj == cnj
	 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
	 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
	 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
	 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
	 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
	 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
	 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
	 || !intersect(flags.mood, first.flags.mood, second.flags.mood)
	 || !intersect(flags.cnj, first.flags.cnj, grammatical_conjunction::ANY))
		return false;
	flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
	for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
		if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
	return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
		&& intersect(inverse, inverse_count, flags, first.root, second.root);
}

template<typename Formula>
inline bool invert_add_correlator(
		flagged_logical_form<Formula>*& inverse,
		unsigned int& inverse_count,
		const flagged_logical_form<Formula>& first,
		const flagged_logical_form<Formula>& second,
		correlator corr)
{
	grammatical_flags flags;
	if ((second.flags.corr != corr && second.flags.corr != correlator::ANY)
	 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
	 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
	 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
	 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
	 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
	 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
	 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
	 || !intersect(flags.mood, first.flags.mood, second.flags.mood)
	 || !intersect(flags.corr, first.flags.corr, correlator::NONE))
		return false;
	flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
	for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
		if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
	return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
		&& intersect(inverse, inverse_count, flags, first.root, second.root);
}

template<typename Formula>
inline bool invert_remove_correlator(
		flagged_logical_form<Formula>*& inverse,
		unsigned int& inverse_count,
		const flagged_logical_form<Formula>& first,
		const flagged_logical_form<Formula>& second,
		correlator corr)
{
	grammatical_flags flags;
	if ((second.flags.corr != correlator::NONE && second.flags.corr != correlator::ANY)
	 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
	 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
	 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
	 || !intersect(flags.corr, first.flags.corr, corr)
	 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
	 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
	 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
	 || !intersect(flags.mood, first.flags.mood, second.flags.mood)
	 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj))
		return false;
	flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
	for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
		if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
	return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
		&& intersect(inverse, inverse_count, flags, first.root, second.root);
}

template<typename Formula>
inline bool invert_add_correlated_by(
		flagged_logical_form<Formula>*& inverse,
		unsigned int& inverse_count,
		const flagged_logical_form<Formula>& first,
		const flagged_logical_form<Formula>& second,
		correlator correlated_by)
{
	grammatical_flags flags;
	if ((second.flags.correlated_by != correlated_by && second.flags.correlated_by != correlator::ANY)
	 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
	 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
	 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
	 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
	 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
	 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
	 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
	 || !intersect(flags.mood, first.flags.mood, second.flags.mood)
	 || !intersect(flags.correlated_by, first.flags.correlated_by, correlator::NONE))
		return false;
	flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
	for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
		if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
	return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
		&& intersect(inverse, inverse_count, flags, first.root, second.root);
}

template<typename Formula>
inline bool invert_add_coordination(
		flagged_logical_form<Formula>*& inverse,
		unsigned int& inverse_count,
		const flagged_logical_form<Formula>& first,
		const flagged_logical_form<Formula>& second,
		coordination coord)
{
	grammatical_flags flags;
	if ((second.flags.coord != coord && second.flags.coord != coordination::ANY)
	 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
	 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
	 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
	 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
	 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
	 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
	 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
	 || !intersect(flags.mood, first.flags.mood, second.flags.mood)
	 || !intersect(flags.coord, first.flags.coord, coordination::NONE))
		return false;
	flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
	for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
		if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
	return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
		&& intersect(inverse, inverse_count, flags, first.root, second.root);
}

template<typename Formula>
inline bool invert_remove_coordination(
		flagged_logical_form<Formula>*& inverse,
		unsigned int& inverse_count,
		const flagged_logical_form<Formula>& first,
		const flagged_logical_form<Formula>& second,
		coordination coord)
{
	grammatical_flags flags;
	if ((second.flags.coord != coordination::NONE && second.flags.coord != coordination::ANY)
	 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
	 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
	 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
	 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
	 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
	 || !intersect(flags.coord, first.flags.coord, coord)
	 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
	 || !intersect(flags.mood, first.flags.mood, second.flags.mood)
	 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj))
		return false;
	flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
	for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
		if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
	if (!flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf))
		return false;

	inverse = (flagged_logical_form<Formula>*) malloc(sizeof(flagged_logical_form<Formula>) * 1);
	if (inverse == nullptr) {
		fprintf(stderr, "invert_remove_coordination ERROR: Out of memory.\n");
		return false;
	}

	if ((flags.coord == coordination::AND && !require_no_array<hol_term_type::AND, false>(second.root, inverse[0].root, find_root))
	 || (flags.coord == coordination::OR && !require_no_array<hol_term_type::OR, false>(second.root, inverse[0].root, find_root))
	 || (flags.coord == coordination::NOR && !require_no_array<hol_term_type::AND, true>(second.root, inverse[0].root, find_root)))
	{
		free(inverse);
		return false;
	}
	inverse[0].flags = flags;
	inverse_count = 1;
	return true;
}

template<typename Formula>
inline bool invert_apply_auxiliary(
		flagged_logical_form<Formula>*& inverse,
		unsigned int& inverse_count,
		const flagged_logical_form<Formula>& first,
		const flagged_logical_form<Formula>& second,
		const auxiliary_flag expected_aux,
		auxiliary_flag dst_aux)
{
	grammatical_flags flags;
	if (!has_intersection(dst_aux, second.flags.aux)
	 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
	 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
	 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
	 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
	 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
	 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
	 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
	 || !intersect(flags.mood, first.flags.mood, second.flags.mood)
	 || !intersect(flags.aux, expected_aux, first.flags.aux))
		return false;
	flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
	for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
		if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
	if (!second.flags.aux_or_subjunctive_or_inf_or_to_inf && first.flags.aux_or_subjunctive_or_inf_or_to_inf) {
		if (flags.aux == auxiliary_flag::AUX || flags.mood == grammatical_mood::SUBJUNCTIVE || flags.mood == grammatical_mood::BARE_INFINITIVE || flags.mood == grammatical_mood::TO_INFINITIVE)
			flags.aux_or_subjunctive_or_inf_or_to_inf = false;
		else if (has_intersection(flags.aux, auxiliary_flag::AUX))
			flags.aux_or_subjunctive_or_inf_or_to_inf = true;
		else flags.aux_or_subjunctive_or_inf_or_to_inf = false;
	} else if (!flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)) {
		return false;
	}
	return intersect(inverse, inverse_count, flags, first.root, second.root);
}

template<typename Formula, typename FindHeadFunction>
inline bool invert_apply_auxiliary(
		flagged_logical_form<Formula>*& inverse,
		unsigned int& inverse_count,
		const flagged_logical_form<Formula>& first,
		const flagged_logical_form<Formula>& second,
		const auxiliary_flag expected_aux,
		auxiliary_flag dst_aux,
		FindHeadFunction find_head_function)
{
	grammatical_flags flags;
	if (!has_intersection(dst_aux, second.flags.aux)
	 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
	 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
	 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
	 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
	 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
	 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
	 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
	 || !intersect(flags.mood, first.flags.mood, second.flags.mood)
	 || !intersect(flags.aux, expected_aux, first.flags.aux))
		return false;
	flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
	for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
		if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
	if (!second.flags.aux_or_subjunctive_or_inf_or_to_inf && first.flags.aux_or_subjunctive_or_inf_or_to_inf) {
		if (flags.aux == auxiliary_flag::AUX || flags.mood == grammatical_mood::SUBJUNCTIVE || flags.mood == grammatical_mood::BARE_INFINITIVE || flags.mood == grammatical_mood::TO_INFINITIVE)
			flags.aux_or_subjunctive_or_inf_or_to_inf = false;
		else if (has_intersection(flags.aux, auxiliary_flag::AUX))
			flags.aux_or_subjunctive_or_inf_or_to_inf = true;
		else flags.aux_or_subjunctive_or_inf_or_to_inf = false;
	} else if (!flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)) {
		return false;
	}
	return intersect_with_head(inverse, inverse_count, flags, first.root, second.root, find_head_function);
}

template<typename Formula>
inline bool invert_add_mood(
		flagged_logical_form<Formula>*& inverse,
		unsigned int& inverse_count,
		const flagged_logical_form<Formula>& first,
		const flagged_logical_form<Formula>& second,
		grammatical_mood mood)
{
	grammatical_flags flags;
	if (!has_intersection(second.flags.mood, mood)
	 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
	 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
	 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
	 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
	 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
	 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
	 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
	 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
	 || !intersect(flags.mood, first.flags.mood, grammatical_mood::INDICATIVE))
		return false;
	flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
	for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
		if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
	if (!second.flags.aux_or_subjunctive_or_inf_or_to_inf && first.flags.aux_or_subjunctive_or_inf_or_to_inf) {
		if (flags.aux == auxiliary_flag::AUX) {
			flags.aux_or_subjunctive_or_inf_or_to_inf = false;
		} else if (has_intersection(flags.aux, auxiliary_flag::AUX)) {
			flags.aux_or_subjunctive_or_inf_or_to_inf = true;
		} else {
			flags.aux_or_subjunctive_or_inf_or_to_inf = false;
		}
	} else if (!flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)) {
		return false;
	}
	return intersect(inverse, inverse_count, flags, first.root, second.root);
}

template<typename Formula>
inline bool invert_remove_mood(
		flagged_logical_form<Formula>*& inverse,
		unsigned int& inverse_count,
		const flagged_logical_form<Formula>& first,
		const flagged_logical_form<Formula>& second,
		grammatical_mood mood)
{
	grammatical_flags flags;
	if (!has_intersection(second.flags.mood, grammatical_mood::INDICATIVE)
	 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
	 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
	 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
	 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
	 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
	 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
	 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
	 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
	 || !intersect(flags.mood, first.flags.mood, grammatical_mood::ANY))
		return false;
	flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
	for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
		if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
	if (!second.flags.aux_or_subjunctive_or_inf_or_to_inf && first.flags.aux_or_subjunctive_or_inf_or_to_inf) {
		if (flags.aux == auxiliary_flag::AUX) {
			flags.aux_or_subjunctive_or_inf_or_to_inf = false;
		} else if (has_intersection(flags.aux, auxiliary_flag::AUX)
				|| has_intersection(flags.mood, grammatical_mood::SUBJUNCTIVE)
				|| has_intersection(flags.mood, grammatical_mood::BARE_INFINITIVE)
				|| has_intersection(flags.mood, grammatical_mood::TO_INFINITIVE))
		{
			flags.aux_or_subjunctive_or_inf_or_to_inf = true;
		} else {
			flags.aux_or_subjunctive_or_inf_or_to_inf = false;
		}
	} else if (!flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)) {
		return false;
	}
	return intersect(inverse, inverse_count, flags, first.root, second.root);
}

template<typename Formula>
inline bool invert_try_remove_mood(
		flagged_logical_form<Formula>*& inverse,
		unsigned int& inverse_count,
		const flagged_logical_form<Formula>& first,
		const flagged_logical_form<Formula>& second)
{
	grammatical_flags flags;
	if (!has_intersection(second.flags.mood, grammatical_mood::INDICATIVE)
	 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
	 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
	 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
	 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
	 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
	 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
	 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
	 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
	 || !intersect(flags.mood, first.flags.mood, grammatical_mood::ANY))
		return false;
	flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
	for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
		if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
	if (!second.flags.aux_or_subjunctive_or_inf_or_to_inf && first.flags.aux_or_subjunctive_or_inf_or_to_inf) {
		if (flags.aux == auxiliary_flag::AUX) {
			flags.aux_or_subjunctive_or_inf_or_to_inf = false;
		} else if (has_intersection(flags.aux, auxiliary_flag::AUX)
				|| has_intersection(flags.mood, grammatical_mood::SUBJUNCTIVE)
				|| has_intersection(flags.mood, grammatical_mood::BARE_INFINITIVE)
				|| has_intersection(flags.mood, grammatical_mood::TO_INFINITIVE))
		{
			flags.aux_or_subjunctive_or_inf_or_to_inf = true;
		} else {
			flags.aux_or_subjunctive_or_inf_or_to_inf = false;
		}
	} else if (!flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)) {
		return false;
	}
	return intersect(inverse, inverse_count, flags, first.root, second.root);
}

template<typename Formula>
bool init_array(flagged_logical_form<Formula>*& array, unsigned int length)
{
	array = (flagged_logical_form<Formula>*) malloc(sizeof(flagged_logical_form<Formula>) * length);
	if (array == nullptr) {
		fprintf(stderr, "init_array ERROR: Out of memory.\n");
		return false;
	}
	return true;
}

template<typename Formula>
bool invert(
	flagged_logical_form<Formula>*& inverse,
	unsigned int& inverse_count,
	typename flagged_logical_form<Formula>::function function,
	const flagged_logical_form<Formula>& first,
	const flagged_logical_form<Formula>& second)
{
	typedef typename flagged_logical_form<Formula>::function_type function_type;

	uint_fast8_t i;
	grammatical_flags flags;
	switch (function.type) {
	case function_type::EMPTY:
		inverse_count = 1; if (!init_array(inverse, inverse_count)) return false;
		*inverse = first;
		return true;
	case function_type::IDENTITY:
		if (intersect(flags, first.flags, second.flags)) {
			auto head_finder = make_array_finder(find_head<built_in_predicates>);
			return intersect_with_head(inverse, inverse_count, flags, first.root, second.root, head_finder);
		} else {
			return false;
		}
	case function_type::IDENTITY_PREDICATIVE:
		if (intersect(flags, first.flags, second.flags)) {
			unsigned int lambda_variable;
			if (second.root->type == hol_term_type::LAMBDA)
				lambda_variable = second.root->quantifier.variable;
			else return false;
			auto head_finder = predicative_head_finder<built_in_predicates>(lambda_variable);
			return intersect_with_head(inverse, inverse_count, flags, first.root, second.root, head_finder);
		} else {
			return false;
		}
	case function_type::IDENTITY_ROOT:
	case function_type::REQUIRE_LEFT_PREDICATE_EXIST:
	case function_type::REQUIRE_LEFT_GREATEST:
	case function_type::REQUIRE_NO_LEFT_PREDICATE_EXIST:
	case function_type::REQUIRE_RIGHT_PREDICATE_IN_SET:
	case function_type::REQUIRE_NO_PREDICATE_EMPTY:
	case function_type::REQUIRE_AUX_OR_SUBJUNCTIVE_OR_INFINITIVE_OR_TO_INFINITIVE:
	case function_type::REQUIRE_PAST_PARTICIPLE:
	case function_type::REQUIRE_PRESENT_PARTICIPLE:
	case function_type::REQUIRE_PREDICATIVE_EXISTENTIAL:
	case function_type::REQUIRE_CONSTANT_IN_SET:
	case function_type::REQUIRE_NO_CONSTANT_IN_SET:
	case function_type::REQUIRE_NAME_IN_SET:
	case function_type::REQUIRE_MEASURE_IN_SET:
	case function_type::REQUIRE_SINGLETON:
	case function_type::REQUIRE_NO_STRING_OR_NUMBER_OR_NAME_IN_SET:
	case function_type::REQUIRE_LEFT_ARG1:
	case function_type::REQUIRE_NO_LAMBDA:
	case function_type::REQUIRE_PREDICATE_OF_LAMBDA:
	case function_type::REQUIRE_SINGULAR:
	case function_type::REQUIRE_PLURAL:
	case function_type::REQUIRE_SUPERLATIVE:
	case function_type::REQUIRE_NO_SUPERLATIVE:
	case function_type::REQUIRE_REF_IN_SET:
	case function_type::REQUIRE_PLURAL_REF_IN_SET:
	case function_type::REQUIRE_ANIMATE_IN_SET:
		/* the forward application already ensures that `second` satisfies this requirement */
		if (!intersect(flags, first.flags, second.flags)) return false;
		return intersect(inverse, inverse_count, flags, first.root, second.root);
	case function_type::REQUIRE_PAST:
	case function_type::REQUIRE_NO_FUTURE:
	case function_type::REQUIRE_NO_PERFECT:
	case function_type::REQUIRE_NO_PROGRESSIVE:
	case function_type::REQUIRE_NO_EMPTY_REF:
	case function_type::REQUIRE_NO_SUBJUNCTIVE:
	case function_type::REQUIRE_NO_INVERSE:
	case function_type::REQUIRE_LEFT_PREDICATE_SAME:
	case function_type::REQUIRE_NO_PREDICATE_SAME:
	case function_type::REQUIRE_LEFT_PREDICATE_INVERSE:
	case function_type::REQUIRE_LEFT_PREDICATE_INVERSE_HAS:
	case function_type::REQUIRE_CONJUNCTION:
	case function_type::REQUIRE_BINARY_CONJUNCTION:
	case function_type::REQUIRE_DISJUNCTION:
	case function_type::REQUIRE_NEGATIVE_CONJUNCTION:
	case function_type::REQUIRE_HEAD_CONJUNCTION:
	case function_type::REQUIRE_HEAD_BINARY_CONJUNCTION:
	case function_type::REQUIRE_HEAD_DISJUNCTION:
	case function_type::REQUIRE_HEAD_NEGATIVE_CONJUNCTION:
	case function_type::REQUIRE_NO_HEAD_ARRAY:
	case function_type::REQUIRE_TO_INFINITIVE:
	case function_type::REQUIRE_NO_TO_INFINITIVE:
	case function_type::REQUIRE_NO_REQ_AUX:
	case function_type::REQUIRE_NO_REQ_NO_AUX:
	case function_type::REQUIRE_NO_REQ_SUBJECT:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return intersect_with_head(inverse, inverse_count, flags, first.root, second.root, make_array_finder(find_head<built_in_predicates>));
	case function_type::SELECT_RIGHT_CONJUNCT:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_conjunct<-1>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::REMOVE_RIGHT_CONJUNCT:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_remove_conjunct<-1>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_LEFT_CONJUNCT:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_conjunct<0>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_LEFT_CONJUNCT_AND_NEGATION:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_conjunct<0, true>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::REMOVE_LEFT_CONJUNCT:
	case function_type::REMOVE_LEFT_PREDICATE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_remove_conjunct<0>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::REMOVE_LEFT_CONJUNCT_AND_NEGATION:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_remove_conjunct<0, true>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::REMOVE_SECOND_LEFT_CONJUNCT:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_remove_conjunct<1>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_SECOND_LEFT_SET_CONJUNCT:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_set_conjunct<1>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_SECOND_LEFT_SET_CONJUNCT_ROOT:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_set_conjunct<1, true>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::REMOVE_SECOND_LEFT_SET_CONJUNCT:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_remove_set_conjunct<1>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_LEFT_CONJUNCT_IN_SET:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_conjunct_in_set<0>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::REMOVE_LEFT_CONJUNCT_IN_SET:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_remove_conjunct_in_set<0, true>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_SECOND_LEFT_CONJUNCT_IN_SET:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_conjunct_in_set<1>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_RIGHT_CONJUNCT_IN_SET:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_conjunct_in_set<-1>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::REMOVE_RIGHT_CONJUNCT_IN_SET:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_remove_conjunct_in_set<-1, true>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::REMOVE_RIGHT_CONJUNCT_IN_SET_WITHOUT_PREDICATIVE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_remove_conjunct_in_set<-1, false>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_RIGHT_SUBSET_IN_SET:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_subset_in_set<-1>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_ONLY_RIGHT_CONJUNCT_IN_SET_PREDICATIVE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_only_conjunct_in_set_predicative<-1>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::REMOVE_INVERSE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_remove_inverse(inverse, inverse_count, flags, first.root, second.root);
	case function_type::REMOVE_GREATEST:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_remove_greatest(inverse, inverse_count, flags, first.root, second.root);
	case function_type::REMOVE_RIGHT_TRACE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_remove_constant<-1>(inverse, inverse_count, flags, first.root, second.root, &hol_term::constants<(unsigned int) built_in_predicates::TRACE>::value);
	case function_type::SELECT_RIGHT_ARG1_WITHOUT_HEAD:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_arg_without_head<-1, (unsigned int) built_in_predicates::ARG1, false>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_RIGHT_ARG2_WITHOUT_HEAD:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_arg_without_head<-1, (unsigned int) built_in_predicates::ARG2, false>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_RIGHT_ARG3_WITHOUT_HEAD:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_arg_without_head<-1, (unsigned int) built_in_predicates::ARG3, false>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_RIGHT_ARG1_OF_WITHOUT_HEAD:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_arg_without_head<-1, (unsigned int) built_in_predicates::ARG1_OF, true>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_RIGHT_ARG2_OF_WITHOUT_HEAD:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_arg_without_head<-1, (unsigned int) built_in_predicates::ARG2_OF, true>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_RIGHT_ARG3_OF_WITHOUT_HEAD:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_arg_without_head<-1, (unsigned int) built_in_predicates::ARG3_OF, true>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_RIGHT_ARG1_WITHOUT_HEAD_PREDICATIVE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_arg_without_head_predicative<-1, (unsigned int) built_in_predicates::ARG1>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_RIGHT_ARG2_WITHOUT_HEAD_PREDICATIVE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_arg_without_head_predicative<-1, (unsigned int) built_in_predicates::ARG2>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_RIGHT_ARG3_WITHOUT_HEAD_PREDICATIVE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_arg_without_head_predicative<-1, (unsigned int) built_in_predicates::ARG3>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_RIGHT_SET_ARG1_WITHOUT_HEAD_PREDICATIVE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_arg_without_head_predicative<-1, (unsigned int) built_in_predicates::ARG1, true>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_RIGHT_SET_ARG2_WITHOUT_HEAD_PREDICATIVE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_arg_without_head_predicative<-1, (unsigned int) built_in_predicates::ARG2, true>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_RIGHT_SET_ARG3_WITHOUT_HEAD_PREDICATIVE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_arg_without_head_predicative<-1, (unsigned int) built_in_predicates::ARG3, true>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_SINGLETON_ARG1_IN_SET_WITHOUT_HEAD_PREDICATIVE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_singleton_arg_in_set_without_head_predicative<(unsigned int) built_in_predicates::ARG1, false, true>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_SINGLETON_ARG2_IN_SET_WITHOUT_HEAD_PREDICATIVE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_singleton_arg_in_set_without_head_predicative<(unsigned int) built_in_predicates::ARG2, false, true>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_SINGLETON_ARG3_IN_SET_WITHOUT_HEAD_PREDICATIVE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_singleton_arg_in_set_without_head_predicative<(unsigned int) built_in_predicates::ARG3, false, true>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_SINGLETON_ARG1_OF_IN_SET_WITHOUT_HEAD_PREDICATIVE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_singleton_arg_in_set_without_head_predicative<(unsigned int) built_in_predicates::ARG1_OF, true, true>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_SINGLETON_ARG2_OF_IN_SET_WITHOUT_HEAD_PREDICATIVE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_singleton_arg_in_set_without_head_predicative<(unsigned int) built_in_predicates::ARG2_OF, true, true>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_SINGLETON_ARG3_OF_IN_SET_WITHOUT_HEAD_PREDICATIVE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_singleton_arg_in_set_without_head_predicative<(unsigned int) built_in_predicates::ARG3_OF, true, true>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_SINGLETON_ARG1_IN_SET_WITHOUT_HEAD_OUTER_SCOPE_PREDICATIVE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_singleton_arg_in_set_without_head_predicative<(unsigned int) built_in_predicates::ARG1, false, false>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_SINGLETON_ARG2_IN_SET_WITHOUT_HEAD_OUTER_SCOPE_PREDICATIVE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_singleton_arg_in_set_without_head_predicative<(unsigned int) built_in_predicates::ARG2, false, false>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_SINGLETON_ARG3_IN_SET_WITHOUT_HEAD_OUTER_SCOPE_PREDICATIVE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_singleton_arg_in_set_without_head_predicative<(unsigned int) built_in_predicates::ARG3, false, false>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_SINGLETON_ARG1_OF_IN_SET_WITHOUT_HEAD_OUTER_SCOPE_PREDICATIVE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_singleton_arg_in_set_without_head_predicative<(unsigned int) built_in_predicates::ARG1_OF, true, false>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_SINGLETON_ARG2_OF_IN_SET_WITHOUT_HEAD_OUTER_SCOPE_PREDICATIVE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_singleton_arg_in_set_without_head_predicative<(unsigned int) built_in_predicates::ARG2_OF, true, false>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_SINGLETON_ARG3_OF_IN_SET_WITHOUT_HEAD_OUTER_SCOPE_PREDICATIVE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_singleton_arg_in_set_without_head_predicative<(unsigned int) built_in_predicates::ARG3_OF, true, false>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::REMOVE_FUTURE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_apply_tense_predicate(inverse, inverse_count, flags, first.root, second.root, FUTURE_PREDICATES, PRESENT_PREDICATES);
	case function_type::REMOVE_PERFECT:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_apply_tense_predicate(inverse, inverse_count, flags, first.root, second.root, PERFECT_PREDICATES, NON_PERFECT_PREDICATES);
	case function_type::REMOVE_PROGRESSIVE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_apply_tense_predicate(inverse, inverse_count, flags, first.root, second.root, PROGRESSIVE_PREDICATES, NON_PROGRESSIVE_PREDICATES);
	case function_type::REMOVE_PRESENT_PROGRESSIVE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_apply_tense_predicate(inverse, inverse_count, flags, first.root, second.root, PRESENT_PROGRESSIVE_PREDICATE, PRESENT_PREDICATE);
	case function_type::REMOVE_PAST_PROGRESSIVE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_apply_tense_predicate(inverse, inverse_count, flags, first.root, second.root, PAST_PROGRESSIVE_PREDICATE, PAST_PREDICATE);
	case function_type::REMOVE_ASPECT:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_apply_tense_predicate(inverse, inverse_count, flags, first.root, second.root, ONLY_ASPECT_PREDICATES, PAST_OR_PRESENT);
	case function_type::TRY_REMOVE_ASPECT:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_apply_tense_predicate(inverse, inverse_count, flags, first.root, second.root, ASPECT_PREDICATES, PAST_OR_PRESENT);
	case function_type::REMOVE_NOT:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_remove_not(inverse, inverse_count, flags, first.root, second.root);
	case function_type::REQUIRE_PREDICATIVE_UNIVERSAL:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_require_predicative_universal(inverse, inverse_count, flags, first.root, second.root);
	case function_type::REPLACE_PREDICATIVE_LAMBDA_WITH_EXISTENTIAL:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_replace_predicative_lambda_with_existential(inverse, inverse_count, flags, first.root, second.root);
	case function_type::REPLACE_PREDICATIVE_UNIVERSAL_WITH_EXISTENTIAL:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_replace_predicative_quantifier<hol_term_type::FOR_ALL, hol_term_type::EXISTS>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::REMOVE_PREDICATIVE_NOT:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_remove_predicative_not(inverse, inverse_count, flags, first.root, second.root);
	case function_type::PREDICATE_ONLY:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_predicate_only(inverse, inverse_count, flags, first.root, second.root);
	case function_type::PREDICATE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_predicate(inverse, inverse_count, flags, first.root, second.root);
	case function_type::PREDICATE_AND_TENSE:
	case function_type::EMPTY_AND_TENSE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_predicate_and_tense(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_PREDICATE_IN_SET:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_predicate_in_set(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_CONSTANT_IN_SET:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_constant_in_set(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_STRING_IN_SET:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_string_in_set(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_NAME_IN_SET:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_name_in_set(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_NUMBER_IN_SET:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_number_in_set(inverse, inverse_count, flags, first.root, second.root);
	case function_type::MARK_WIDE_SCOPE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_mark_wide_scope(inverse, inverse_count, flags, first.root, second.root);
	case function_type::REQUIRE_WIDE_SCOPE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_require_narrow_or_wide_scope<true>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::REQUIRE_NARROW_SCOPE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_require_narrow_or_wide_scope<false>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::REMOVE_WIDE_SCOPE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_remove_wide_scope(inverse, inverse_count, flags, first.root, second.root);
	case function_type::REQUIRE_STRING_OR_NUMBER_IN_SET:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_require_string_or_number_in_set(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SIZE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_size(inverse, inverse_count, flags, first.root, second.root);
	case function_type::RIGHT_ARG1:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_arg_function<(unsigned int) built_in_predicates::ARG1, -1>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SET_SIZE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_set_size(inverse, inverse_count, flags, first.root, second.root);
	case function_type::REQUIRE_LAMBDA:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_require_lambda(inverse, inverse_count, flags, first.root, second.root);
	case function_type::FACTOR:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_factor(inverse, inverse_count, flags, first.root, second.root);
	case function_type::FACTOR_PREDICATIVE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_factor_predicative(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_LEFT_PREDICATE_AND_TENSE:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_conjuncts_without_head<0, 2>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SET_PREDICATE_EMPTY:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_set_predicate_empty<INT_FAST8_MAX>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SET_LEFT_PREDICATE_EMPTY:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_set_predicate_empty<0>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_LEFT_OPERAND:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_operand<0>(inverse, inverse_count, flags, first.root, second.root, find_root);
	case function_type::REMOVE_LEFT_OPERAND:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_remove_operand<0>(inverse, inverse_count, flags, first.root, second.root, find_root);
	case function_type::SELECT_LEFT_HEAD_OPERAND:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_operand<0>(inverse, inverse_count, flags, first.root, second.root, find_head<built_in_predicates>);
	case function_type::REMOVE_LEFT_HEAD_OPERAND:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_remove_operand<0>(inverse, inverse_count, flags, first.root, second.root, find_head<built_in_predicates>);
	case function_type::REPLACE_PREDICATIVE_SUBSET_WITH_EQUALITY:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_apply_to_predicative_set_function(inverse, inverse_count, flags, first.root, second.root,
				(unsigned int) built_in_predicates::SUBSET, (unsigned int) built_in_predicates::EQUALS);
	case function_type::SELECT_LAMBDA:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_lambda(inverse, inverse_count, flags, first.root, second.root);
	case function_type::REMOVE_LAMBDA:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_remove_lambda(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_FUNCTION_WITH_SUBSTITUTION:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_function<substitution_setting::ARG2>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_FUNCTION_WITH_EMPTY_SUBSTITUTION:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_function<substitution_setting::EMPTY>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_FUNCTION_WITHOUT_SUBSTITUTION:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_function<substitution_setting::NONE>(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_ANTECEDENT:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_antecedent(inverse, inverse_count, flags, first.root, second.root);
	case function_type::SELECT_CONSEQUENT:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_select_consequent(inverse, inverse_count, flags, first.root, second.root);
	case function_type::REQUIRE_ONE_OR_TWO_CONJUNCTS:
		if (!intersect(flags, first.flags, second.flags)) {
			return false;
		} else {
			hol_term* dst;
			if (!require_one_or_two_conjuncts<false>(second.root, dst))
				return false;
			inverse = (flagged_logical_form<hol_term>*) malloc(sizeof(flagged_logical_form<hol_term>));
			if (inverse == nullptr) {
				free(*dst); if (dst->reference_count == 0) free(dst);
				return false;
			}
			inverse[0].root = dst;
			inverse[0].flags = flags;
			inverse_count = 1;
			return true;
		}
	case function_type::REQUIRE_CAPITALIZED:
		if (!intersect(flags, first.flags, second.flags)) return false;
		return invert_require_capitalized(inverse, inverse_count, flags, first.root, second.root);
	case function_type::ADD_SINGULAR:
		if (!has_intersection(second.flags.index_number, grammatical_num::SINGULAR)
		 || !intersect(flags.index_number, first.flags.index_number, grammatical_num::NONE)
		 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
		 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
		 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
		 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
		 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
		 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
		 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
		 || !intersect(flags.mood, first.flags.mood, second.flags.mood))
			return false;
		flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
		for (i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
			if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
		return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
			&& intersect(inverse, inverse_count, flags, first.root, second.root);
	case function_type::ADD_PLURAL:
		if (!has_intersection(second.flags.index_number, grammatical_num::PLURAL)
		 || !intersect(flags.index_number, first.flags.index_number, grammatical_num::NONE)
		 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
		 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
		 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
		 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
		 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
		 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
		 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
		 || !intersect(flags.mood, first.flags.mood, second.flags.mood))
			return false;
		flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
		for (i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
			if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
		return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
			&& intersect(inverse, inverse_count, flags, first.root, second.root);
	case function_type::TRY_ADD_SINGULAR:
		if (!has_intersection(second.flags.index_number, grammatical_num::SINGULAR)
		 || !intersect(flags.index_number, first.flags.index_number, grammatical_num::SINGULAR_OR_NONE)
		 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
		 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
		 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
		 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
		 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
		 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
		 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
		 || !intersect(flags.mood, first.flags.mood, second.flags.mood))
			return false;
		flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
		for (i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
			if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
		return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
			&& intersect(inverse, inverse_count, flags, first.root, second.root);
	case function_type::TRY_ADD_PLURAL:
		if (!has_intersection(second.flags.index_number, grammatical_num::PLURAL)
		 || !intersect(flags.index_number, first.flags.index_number, grammatical_num::PLURAL_OR_NONE)
		 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
		 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
		 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
		 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
		 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
		 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
		 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
		 || !intersect(flags.mood, first.flags.mood, second.flags.mood))
			return false;
		flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
		for (i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
			if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
		return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
			&& intersect(inverse, inverse_count, flags, first.root, second.root);
	case function_type::TRY_REMOVE_NUMBER:
		if (!has_intersection(second.flags.index_number, grammatical_num::NONE)
		 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
		 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
		 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
		 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
		 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
		 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
		 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
		 || !intersect(flags.mood, first.flags.mood, second.flags.mood))
			return false;
		flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
		flags.index_number = first.flags.index_number;
		for (i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
			if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
		return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
			&& intersect(inverse, inverse_count, flags, first.root, second.root);
	case function_type::ADD_CONCORD_SINGULAR:
		if ((second.flags.concord_number != grammatical_num::SINGULAR && second.flags.concord_number != grammatical_num::ANY)
		 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
		 || !intersect(flags.concord_number, first.flags.concord_number, grammatical_num::NONE)
		 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
		 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
		 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
		 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
		 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
		 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
		 || !intersect(flags.mood, first.flags.mood, second.flags.mood))
			return false;
		flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
		for (i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
			if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
		return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
			&& intersect(inverse, inverse_count, flags, first.root, second.root);
	case function_type::ADD_CONCORD_PLURAL:
		if ((second.flags.concord_number != grammatical_num::PLURAL && second.flags.concord_number != grammatical_num::ANY)
		 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
		 || !intersect(flags.concord_number, first.flags.concord_number, grammatical_num::NONE)
		 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
		 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
		 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
		 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
		 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
		 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
		 || !intersect(flags.mood, first.flags.mood, second.flags.mood))
			return false;
		flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
		for (i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
			if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
		return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
			&& intersect(inverse, inverse_count, flags, first.root, second.root);
	case function_type::ADD_THAT:
		return invert_add_conjunction(inverse, inverse_count, first, second, grammatical_conjunction::THAT);
	case function_type::REMOVE_THAT:
		return invert_remove_conjunction(inverse, inverse_count, first, second, grammatical_conjunction::THAT);
	case function_type::REQUIRE_NO_THAT:
		return invert_require_no_conjunction(inverse, inverse_count, first, second, grammatical_conjunction::THAT);
	case function_type::ADD_WHETHER:
		return invert_add_conjunction(inverse, inverse_count, first, second, grammatical_conjunction::WHETHER);
	case function_type::REMOVE_WHETHER:
		return invert_remove_conjunction(inverse, inverse_count, first, second, grammatical_conjunction::WHETHER);
	case function_type::ADD_IF:
		return invert_add_conjunction(inverse, inverse_count, first, second, grammatical_conjunction::IF);
	case function_type::REMOVE_IF:
		return invert_remove_conjunction(inverse, inverse_count, first, second, grammatical_conjunction::IF);
	case function_type::ADD_BECAUSE:
		return invert_add_conjunction(inverse, inverse_count, first, second, grammatical_conjunction::BECAUSE);
	case function_type::REMOVE_BECAUSE:
		return invert_remove_conjunction(inverse, inverse_count, first, second, grammatical_conjunction::BECAUSE);
	case function_type::ADD_FOR:
		return invert_add_conjunction(inverse, inverse_count, first, second, grammatical_conjunction::FOR);
	case function_type::REMOVE_FOR:
		return invert_remove_conjunction(inverse, inverse_count, first, second, grammatical_conjunction::FOR);
	case function_type::REQUIRE_NO_CONJUNCTION:
		if ((second.flags.cnj != grammatical_conjunction::NONE && second.flags.cnj != grammatical_conjunction::ANY)
		 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
		 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
		 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
		 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
		 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
		 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
		 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
		 || !intersect(flags.mood, first.flags.mood, second.flags.mood)
		 || !intersect(flags.cnj, first.flags.cnj, grammatical_conjunction::NONE))
			return false;
		flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
		for (i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
			if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
		return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
			&& intersect(inverse, inverse_count, flags, first.root, second.root);
	case function_type::ADD_IS_ADJUNCT:
		return invert_add_flag(inverse, inverse_count, first, second, grammatical_flag::IS_ADJUNCT);
	case function_type::TRY_REMOVE_IS_ADJUNCT:
		return invert_try_remove_flag(inverse, inverse_count, first, second, grammatical_flag::IS_ADJUNCT);
	case function_type::REQUIRE_NOT_ADJUNCT:
		return invert_require_no_flag(inverse, inverse_count, first, second, grammatical_flag::IS_ADJUNCT);
	case function_type::ADD_NULLABLE_SUBJECT:
		return invert_add_flag(inverse, inverse_count, first, second, grammatical_flag::NULLABLE_SUBJECT);
	case function_type::REMOVE_NULLABLE_SUBJECT:
		return invert_remove_flag(inverse, inverse_count, first, second, grammatical_flag::NULLABLE_SUBJECT);
	case function_type::TRY_REMOVE_NULLABLE_SUBJECT:
		return invert_try_remove_flag(inverse, inverse_count, first, second, grammatical_flag::NULLABLE_SUBJECT);
	case function_type::ADD_SUBORDINATE:
		return invert_add_flag(inverse, inverse_count, first, second, grammatical_flag::SUBORDINATE);
	case function_type::REMOVE_SUBORDINATE:
		return invert_remove_flag(inverse, inverse_count, first, second, grammatical_flag::SUBORDINATE);
	case function_type::TRY_REMOVE_SUBORDINATE:
		return invert_try_remove_flag(inverse, inverse_count, first, second, grammatical_flag::SUBORDINATE);
	case function_type::REQUIRE_NO_SUBORDINATE:
		return invert_require_no_flag(inverse, inverse_count, first, second, grammatical_flag::SUBORDINATE);
	case function_type::ADD_PREPOSITION:
		return invert_add_flag(inverse, inverse_count, first, second, grammatical_flag::PREPOSITION, make_array_finder(find_head<built_in_predicates>));
	case function_type::REQUIRE_PREPOSITION:
		return invert_require_flag(inverse, inverse_count, first, second, grammatical_flag::PREPOSITION, make_array_finder(find_head<built_in_predicates>));
	case function_type::REQUIRE_NO_PREPOSITION:
		return invert_require_no_flag(inverse, inverse_count, first, second, grammatical_flag::PREPOSITION, make_array_finder(find_head<built_in_predicates>));
	case function_type::ADD_PARTICLE:
		return invert_add_flag(inverse, inverse_count, first, second, grammatical_flag::PARTICLE);
	case function_type::ADD_AUX:
	{
		grammatical_flags flags;
		if (!intersect(flags.aux, auxiliary_flag::AUX | auxiliary_flag::REQ_SUBJECT, second.flags.aux)
		 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
		 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
		 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
		 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
		 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
		 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
		 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
		 || !intersect(flags.mood, first.flags.mood, second.flags.mood))
			return false;
		if (flags.aux == auxiliary_flag::AUX) {
			flags.aux = auxiliary_flag::NONE;
		} else if (flags.aux == auxiliary_flag::REQ_SUBJECT) {
			flags.aux = auxiliary_flag::REQ_AUX;
		} else {
			flags.aux = auxiliary_flag::NONE | auxiliary_flag::REQ_AUX;
		}
		if (!has_intersection(flags.aux, first.flags.aux))
			return false;
		flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
		for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
			if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
		return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
			&& intersect(inverse, inverse_count, flags, first.root, second.root);
	}
	case function_type::TRY_REMOVE_AUX:
		return invert_apply_auxiliary(inverse, inverse_count, first, second, ~auxiliary_flag::REQ_AUX, auxiliary_flag::NONE);
	case function_type::ADD_REQ_AUX:
		return invert_apply_auxiliary(inverse, inverse_count, first, second, auxiliary_flag::NONE, auxiliary_flag::REQ_AUX);
	case function_type::TRY_ADD_REQ_AUX:
		return invert_apply_auxiliary(inverse, inverse_count, first, second, ~auxiliary_flag::REQ_NO_AUX, auxiliary_flag::REQ_AUX);
	case function_type::REMOVE_REQ_AUX:
		return invert_apply_auxiliary(inverse, inverse_count, first, second, auxiliary_flag::REQ_AUX, auxiliary_flag::NONE);
	case function_type::TRY_REMOVE_REQ_AUX:
		return invert_apply_auxiliary(inverse, inverse_count, first, second, ~auxiliary_flag::REQ_NO_AUX, auxiliary_flag::NONE, make_array_finder(find_head<built_in_predicates>));
	case function_type::ADD_REQ_NO_AUX:
		return invert_apply_auxiliary(inverse, inverse_count, first, second, auxiliary_flag::NONE, auxiliary_flag::REQ_NO_AUX);
	case function_type::REMOVE_REQ_SUBJECT:
		return invert_apply_auxiliary(inverse, inverse_count, first, second, auxiliary_flag::REQ_SUBJECT, auxiliary_flag::NONE);
	case function_type::TRY_REMOVE_REQ_SUBJECT:
		return invert_apply_auxiliary(inverse, inverse_count, first, second, auxiliary_flag::ANY, auxiliary_flag::NONE);
	case function_type::ADD_INFINITIVE:
		return invert_add_mood(inverse, inverse_count, first, second, grammatical_mood::BARE_INFINITIVE);
	case function_type::ADD_TO_INFINITIVE:
		return invert_add_mood(inverse, inverse_count, first, second, grammatical_mood::TO_INFINITIVE);
	case function_type::REMOVE_TO_INFINITIVE:
		return invert_remove_mood(inverse, inverse_count, first, second, grammatical_mood::TO_INFINITIVE);
	case function_type::ADD_SUBJUNCTIVE:
		return invert_add_mood(inverse, inverse_count, first, second, grammatical_mood::SUBJUNCTIVE);
	case function_type::ADD_BOTH:
		return invert_add_correlator(inverse, inverse_count, first, second, correlator::BOTH);
	case function_type::ADD_EITHER:
		return invert_add_correlator(inverse, inverse_count, first, second, correlator::EITHER);
	case function_type::ADD_NEITHER:
		return invert_add_correlator(inverse, inverse_count, first, second, correlator::NEITHER);
	case function_type::REMOVE_BOTH:
		return invert_remove_correlator(inverse, inverse_count, first, second, correlator::BOTH);
	case function_type::REMOVE_EITHER:
		return invert_remove_correlator(inverse, inverse_count, first, second, correlator::EITHER);
	case function_type::REMOVE_NEITHER:
		return invert_remove_correlator(inverse, inverse_count, first, second, correlator::NEITHER);
	case function_type::TRY_REMOVE_CORRELATOR:
		if ((second.flags.corr != correlator::NONE && second.flags.corr != correlator::ANY)
		 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
		 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
		 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
		 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
		 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
		 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
		 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
		 || !intersect(flags.mood, first.flags.mood, second.flags.mood)
		 || !intersect(flags.corr, first.flags.corr, correlator::ANY))
			return false;
		flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
		for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
			if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
		return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
			&& intersect(inverse, inverse_count, flags, first.root, second.root);
	case function_type::REQUIRE_NO_CORRELATOR:
		if ((second.flags.corr != correlator::NONE && second.flags.corr != correlator::ANY)
		 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
		 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
		 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
		 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
		 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
		 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
		 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
		 || !intersect(flags.mood, first.flags.mood, second.flags.mood)
		 || !intersect(flags.corr, first.flags.corr, correlator::NONE))
			return false;
		flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
		for (i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
			if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
		if (flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)) {
			auto head_finder = find_head<built_in_predicates>;
			return intersect_with_head(inverse, inverse_count, flags, first.root, second.root, make_array_finder(head_finder));
		} else {
			return false;
		}
	case function_type::REQUIRE_NO_CORRELATOR_PREDICATIVE:
		if ((second.flags.corr != correlator::NONE && second.flags.corr != correlator::ANY)
		 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
		 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
		 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
		 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
		 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
		 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
		 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
		 || !intersect(flags.mood, first.flags.mood, second.flags.mood)
		 || !intersect(flags.corr, first.flags.corr, correlator::NONE))
			return false;
		flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
		for (i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
			if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
		if (flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)) {
			unsigned int lambda_variable;
			if (second.root->type == hol_term_type::LAMBDA)
				lambda_variable = second.root->quantifier.variable;
			else return false;
			auto head_finder = predicative_head_finder<built_in_predicates>(lambda_variable);
			return intersect_with_head(inverse, inverse_count, flags, first.root, second.root, make_array_finder(head_finder));
		} else {
			return false;
		}
	case function_type::ADD_CORRELATED_BY_BOTH:
		return invert_add_correlated_by(inverse, inverse_count, first, second, correlator::BOTH);
	case function_type::ADD_CORRELATED_BY_EITHER:
		return invert_add_correlated_by(inverse, inverse_count, first, second, correlator::EITHER);
	case function_type::ADD_CORRELATED_BY_NEITHER:
		return invert_add_correlated_by(inverse, inverse_count, first, second, correlator::NEITHER);
	case function_type::TRY_REMOVE_CORRELATED:
		if ((second.flags.correlated_by != correlator::NONE && second.flags.correlated_by != correlator::ANY)
		 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
		 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
		 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
		 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
		 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
		 || !intersect(flags.correlated_by, first.flags.correlated_by, correlator::ANY)
		 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
		 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
		 || !intersect(flags.mood, first.flags.mood, second.flags.mood))
			return false;
		flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
		for (uint_fast8_t i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
			if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
		return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
			&& intersect(inverse, inverse_count, flags, first.root, second.root);
	case function_type::REQUIRE_NOT_CORRELATED:
		if ((second.flags.correlated_by != correlator::NONE && second.flags.correlated_by != correlator::ANY)
		 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
		 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
		 || !intersect(flags.comp, first.flags.comp, second.flags.comp)
		 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
		 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
		 || !intersect(flags.correlated_by, first.flags.correlated_by, correlator::NONE)
		 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
		 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
		 || !intersect(flags.mood, first.flags.mood, second.flags.mood))
			return false;
		flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
		for (i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
			if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
		return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
			&& intersect(inverse, inverse_count, flags, first.root, second.root);
	case function_type::ADD_PAST_PARTICIPLE:
		return invert_add_mood(inverse, inverse_count, first, second, grammatical_mood::PAST_PARTICIPLE);
	case function_type::ADD_PRESENT_PARTICIPLE:
		return invert_add_mood(inverse, inverse_count, first, second, grammatical_mood::PRESENT_PARTICIPLE);
	case function_type::TRY_REMOVE_PARTICIPLE:
		return invert_try_remove_mood(inverse, inverse_count, first, second);
	case function_type::ADD_NEGATIVE:
		return invert_add_flag(inverse, inverse_count, first, second, grammatical_flag::NEGATIVE, make_array_finder(find_head<built_in_predicates>));
	case function_type::ADD_NEGATIVE_PREDICATIVE:
	{
		unsigned int lambda_variable;
		if (second.root->type == hol_term_type::LAMBDA) {
			lambda_variable = second.root->quantifier.variable;
		} else {
			return false;
		}
		auto head_finder = predicative_head_finder<built_in_predicates>(lambda_variable);
		return invert_add_flag(inverse, inverse_count, first, second, grammatical_flag::NEGATIVE, head_finder);
	}
	case function_type::REQUIRE_NEGATIVE:
		return invert_require_flag(inverse, inverse_count, first, second, grammatical_flag::NEGATIVE);
	case function_type::ADD_ADV:
		return invert_add_flag(inverse, inverse_count, first, second, grammatical_flag::ADV);
	case function_type::REMOVE_ADV:
		return invert_remove_flag(inverse, inverse_count, first, second, grammatical_flag::ADV);
	case function_type::TRY_REMOVE_ADV:
		return invert_try_remove_flag(inverse, inverse_count, first, second, grammatical_flag::ADV);
	case function_type::REQUIRE_NO_ADV:
		return invert_require_no_flag(inverse, inverse_count, first, second, grammatical_flag::ADV);
	case function_type::ADD_TION:
		return invert_add_flag(inverse, inverse_count, first, second, grammatical_flag::TION);
	case function_type::ADD_LY:
		return invert_add_flag(inverse, inverse_count, first, second, grammatical_flag::LY);
	case function_type::ADD_GENITIVE:
		return invert_add_flag(inverse, inverse_count, first, second, grammatical_flag::GENITIVE);
	case function_type::TRY_REMOVE_GENITIVE:
		return invert_try_remove_flag(inverse, inverse_count, first, second, grammatical_flag::GENITIVE);
	case function_type::REQUIRE_NO_GENITIVE:
		return invert_require_no_flag(inverse, inverse_count, first, second, grammatical_flag::GENITIVE);
	case function_type::ADD_COMMA:
		return invert_add_flag(inverse, inverse_count, first, second, grammatical_flag::COMMA);
	case function_type::REMOVE_COMMA:
		return invert_remove_flag(inverse, inverse_count, first, second, grammatical_flag::COMMA);
	case function_type::REQUIRE_NO_COMMA:
		return invert_require_no_flag(inverse, inverse_count, first, second, grammatical_flag::COMMA);
	case function_type::ADD_WH_MINUS:
		return invert_add_flag(inverse, inverse_count, first, second, grammatical_flag::WH_MINUS);
	case function_type::REMOVE_WH_MINUS:
		return invert_remove_flag(inverse, inverse_count, first, second, grammatical_flag::WH_MINUS);
	case function_type::TRY_REMOVE_WH_MINUS:
		return invert_try_remove_flag(inverse, inverse_count, first, second, grammatical_flag::WH_MINUS);
	case function_type::REQUIRE_NO_WH_MINUS:
		return invert_require_no_flag(inverse, inverse_count, first, second, grammatical_flag::WH_MINUS);
	case function_type::HAS_ARG2:
		{
			grammatical_flag_value has_arg;
			if (!compute_has_arg(second, second.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2], has_arg, find_head<built_in_predicates>, do_compute_has_arg<(unsigned int) built_in_predicates::ARG2>))
				return false;
			inverse = (flagged_logical_form<hol_term>*) malloc(sizeof(flagged_logical_form<hol_term>));
			if (inverse == nullptr) return false;
			inverse[0] = second;
			inverse[0].flags.flags[(unsigned int) grammatical_flag::HAS_ARG2] = first.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2];
			inverse_count = 1;
			return true;
		}
	case function_type::TRY_HAS_ARG2:
		{
			grammatical_flag_value has_arg;
			if (first.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2] == grammatical_flag_value::TRUE) {
				inverse = (flagged_logical_form<hol_term>*) malloc(sizeof(flagged_logical_form<hol_term>));
				if (inverse == nullptr) return false;
				inverse[0] = second;
				inverse[0].flags.flags[(unsigned int) grammatical_flag::HAS_ARG2] = first.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2];
				inverse_count = 1;
			} else if (first.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2] == grammatical_flag_value::FALSE) {
				if (!compute_has_arg(second, second.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2], has_arg, find_head<built_in_predicates>, do_compute_has_arg<(unsigned int) built_in_predicates::ARG2>))
					return false;
				inverse = (flagged_logical_form<hol_term>*) malloc(sizeof(flagged_logical_form<hol_term>));
				if (inverse == nullptr) return false;
				inverse[0] = second;
				inverse[0].flags.flags[(unsigned int) grammatical_flag::HAS_ARG2] = first.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2];
				inverse_count = 1;
			} else {
				grammatical_flag_value expected_value = second.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2];
				if (expected_value == grammatical_flag_value::TRUE)
					expected_value = grammatical_flag_value::ANY;
				if (!compute_has_arg(second, expected_value, has_arg, find_head<built_in_predicates>, do_compute_has_arg<(unsigned int) built_in_predicates::ARG2>))
					return false;
				inverse[0] = second;
				if (has_arg == grammatical_flag_value::FALSE)
					inverse[0].flags.flags[(unsigned int) grammatical_flag::HAS_ARG2] = grammatical_flag_value::FALSE;
				else inverse[0].flags.flags[(unsigned int) grammatical_flag::HAS_ARG2] = first.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2];
				inverse_count = 1;
			}
			return true;
		}
	case function_type::HAS_ARG2_IN_SET:
		{
			unsigned int lambda_variable;
			if (second.root->type == hol_term_type::LAMBDA) {
				lambda_variable = second.root->quantifier.variable;
			} else if (second.root->type == hol_term_type::ANY || second.root->type == hol_term_type::ANY_RIGHT) {
				inverse = (flagged_logical_form<hol_term>*) malloc(sizeof(flagged_logical_form<hol_term>));
				if (inverse == nullptr) return false;
				inverse[0] = second;
				inverse[0].flags.flags[(unsigned int) grammatical_flag::HAS_ARG2] = first.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2];
				inverse_count = 1;
				return true;
			} else {
				return false;
			}
			auto head_finder = predicative_head_finder<built_in_predicates>(lambda_variable);
			grammatical_flag_value has_arg;
			if (!compute_has_arg(second, second.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2], has_arg, head_finder, do_compute_has_arg_in_set<(unsigned int) built_in_predicates::ARG2_OF, true>))
				return false;
			inverse = (flagged_logical_form<hol_term>*) malloc(sizeof(flagged_logical_form<hol_term>));
			if (inverse == nullptr) return false;
			inverse[0] = second;
			inverse[0].flags.flags[(unsigned int) grammatical_flag::HAS_ARG2] = first.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2];
			inverse_count = 1;
			return true;
		}
	case function_type::TRY_HAS_ARG2_IN_SET:
		{
			unsigned int lambda_variable;
			if (second.root->type == hol_term_type::LAMBDA) {
				lambda_variable = second.root->quantifier.variable;
			} else if (second.root->type == hol_term_type::ANY || second.root->type == hol_term_type::ANY_RIGHT) {
				inverse = (flagged_logical_form<hol_term>*) malloc(sizeof(flagged_logical_form<hol_term>));
				if (inverse == nullptr) return false;
				inverse[0] = second;
				if (second.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2] == grammatical_flag_value::FALSE)
					inverse[0].flags.flags[(unsigned int) grammatical_flag::HAS_ARG2] = grammatical_flag_value::FALSE;
				else inverse[0].flags.flags[(unsigned int) grammatical_flag::HAS_ARG2] = first.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2];
				inverse_count = 1;
				return true;
			} else {
				return false;
			}
			auto head_finder = predicative_head_finder<built_in_predicates>(lambda_variable);
			grammatical_flag_value has_arg;
			if (first.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2] == grammatical_flag_value::TRUE) {
				inverse = (flagged_logical_form<hol_term>*) malloc(sizeof(flagged_logical_form<hol_term>));
				if (inverse == nullptr) return false;
				inverse[0] = second;
				inverse[0].flags.flags[(unsigned int) grammatical_flag::HAS_ARG2] = first.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2];
				inverse_count = 1;
			} else if (first.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2] == grammatical_flag_value::FALSE) {
				if (!compute_has_arg(second, second.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2], has_arg, head_finder, do_compute_has_arg_in_set<(unsigned int) built_in_predicates::ARG2_OF, true>))
					return false;
				inverse = (flagged_logical_form<hol_term>*) malloc(sizeof(flagged_logical_form<hol_term>));
				if (inverse == nullptr) return false;
				inverse[0] = second;
				inverse[0].flags.flags[(unsigned int) grammatical_flag::HAS_ARG2] = first.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2];
				inverse_count = 1;
			} else {
				grammatical_flag_value expected_value = second.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2];
				if (expected_value == grammatical_flag_value::TRUE)
					expected_value = grammatical_flag_value::ANY;
				if (!compute_has_arg(second, expected_value, has_arg, head_finder, do_compute_has_arg_in_set<(unsigned int) built_in_predicates::ARG2_OF, true>))
					return false;
				inverse[0] = second;
				if (has_arg == grammatical_flag_value::FALSE)
					inverse[0].flags.flags[(unsigned int) grammatical_flag::HAS_ARG2] = grammatical_flag_value::FALSE;
				else inverse[0].flags.flags[(unsigned int) grammatical_flag::HAS_ARG2] = first.flags.flags[(unsigned int) grammatical_flag::HAS_ARG2];
				inverse_count = 1;
			}
			return true;
		}
	case function_type::TRY_ADD_HAS_ARG2:
		return invert_try_add_flag(inverse, inverse_count, first, second, grammatical_flag::HAS_ARG2);
	case function_type::ADD_MODIFIES_EVENT:
		return invert_add_flag(inverse, inverse_count, first, second, grammatical_flag::MODIFIES_EVENT);
	case function_type::TRY_REMOVE_MODIFIES_EVENT:
		return invert_try_remove_flag(inverse, inverse_count, first, second, grammatical_flag::MODIFIES_EVENT);
	case function_type::ADD_MEASURE:
		return invert_add_flag(inverse, inverse_count, first, second, grammatical_flag::MEASURE);
	case function_type::TRY_REMOVE_MEASURE:
		return invert_try_remove_flag(inverse, inverse_count, first, second, grammatical_flag::MEASURE);
	case function_type::REQUIRE_NO_MEASURE:
		return invert_require_no_flag(inverse, inverse_count, first, second, grammatical_flag::MEASURE);
	case function_type::ADD_EMPTY_VERB:
		return invert_add_flag(inverse, inverse_count, first, second, grammatical_flag::EMPTY_VERB);
	case function_type::TRY_REMOVE_EMPTY_VERB:
		return invert_try_remove_flag(inverse, inverse_count, first, second, grammatical_flag::EMPTY_VERB);
	case function_type::REMOVE_EMPTY_VERB:
		return invert_remove_flag(inverse, inverse_count, first, second, grammatical_flag::EMPTY_VERB);
	case function_type::REQUIRE_NO_EMPTY_VERB:
		return invert_require_no_flag(inverse, inverse_count, first, second, grammatical_flag::EMPTY_VERB);
	case function_type::ADD_PASSIVE:
		return invert_add_flag(inverse, inverse_count, first, second, grammatical_flag::PASSIVE);
	case function_type::REMOVE_PASSIVE:
		return invert_remove_flag(inverse, inverse_count, first, second, grammatical_flag::PASSIVE);
	case function_type::REQUIRE_NO_PASSIVE:
		return invert_require_no_flag(inverse, inverse_count, first, second, grammatical_flag::PASSIVE);
	case function_type::ADD_BE:
		return invert_add_flag(inverse, inverse_count, first, second, grammatical_flag::BE);
	case function_type::REMOVE_BE:
		return invert_remove_flag(inverse, inverse_count, first, second, grammatical_flag::BE);
	case function_type::TRY_REMOVE_BE:
		return invert_try_remove_flag(inverse, inverse_count, first, second, grammatical_flag::BE);
	case function_type::REQUIRE_NO_BE:
		return invert_require_no_flag(inverse, inverse_count, first, second, grammatical_flag::BE);
	case function_type::ADD_AND:
		return invert_add_coordination(inverse, inverse_count, first, second, coordination::AND);
	case function_type::ADD_OR:
		return invert_add_coordination(inverse, inverse_count, first, second, coordination::OR);
	case function_type::ADD_NOR:
		return invert_add_coordination(inverse, inverse_count, first, second, coordination::NOR);
	case function_type::REMOVE_AND:
		return invert_remove_coordination(inverse, inverse_count, first, second, coordination::AND);
	case function_type::REMOVE_OR:
		return invert_remove_coordination(inverse, inverse_count, first, second, coordination::OR);
	case function_type::REMOVE_NOR:
		return invert_remove_coordination(inverse, inverse_count, first, second, coordination::NOR);
	case function_type::REMOVE_COORD:
		return invert_remove_coordination(inverse, inverse_count, first, second, coordination::NOT_NONE);
	case function_type::ADD_COMPARATIVE:
		if ((second.flags.comp != grammatical_comparison::COMPARATIVE && second.flags.comp != grammatical_comparison::ANY)
		 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
		 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
		 || !intersect(flags.comp, first.flags.comp, grammatical_comparison::NONE)
		 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
		 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
		 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
		 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
		 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
		 || !intersect(flags.mood, first.flags.mood, second.flags.mood))
			return false;
		flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
		for (i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
			if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
		return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
			&& intersect(inverse, inverse_count, flags, first.root, second.root);
	case function_type::ADD_SUPERLATIVE:
		if ((second.flags.comp != grammatical_comparison::SUPERLATIVE && second.flags.comp != grammatical_comparison::ANY)
		 || !intersect(flags.index_number, first.flags.index_number, second.flags.index_number)
		 || !intersect(flags.concord_number, first.flags.concord_number, second.flags.concord_number)
		 || !intersect(flags.comp, first.flags.comp, grammatical_comparison::NONE)
		 || !intersect(flags.cnj, first.flags.cnj, second.flags.cnj)
		 || !intersect(flags.corr, first.flags.corr, second.flags.corr)
		 || !intersect(flags.correlated_by, first.flags.correlated_by, second.flags.correlated_by)
		 || !intersect(flags.coord, first.flags.coord, second.flags.coord)
		 || !intersect(flags.aux, first.flags.aux, second.flags.aux)
		 || !intersect(flags.mood, first.flags.mood, second.flags.mood))
			return false;
		flags.is_first_token_capital = (first.flags.is_first_token_capital || second.flags.is_first_token_capital);
		for (i = 0; i < (uint_fast8_t) grammatical_flag::COUNT; i++)
			if (!intersect(flags.flags[i], first.flags.flags[i], second.flags.flags[i])) return false;
		return flags.intersect_aux_or_subjunctive_or_inf_or_to_inf(first.flags.aux_or_subjunctive_or_inf_or_to_inf, second.flags.aux_or_subjunctive_or_inf_or_to_inf)
			&& intersect(inverse, inverse_count, flags, first.root, second.root);
	}
	fprintf(stderr, "invert ERROR: Unrecognized transformation function.\n");
	return false;
}

template<typename Formula>
inline bool is_subset(
		const flagged_logical_form<Formula>& first,
		const flagged_logical_form<Formula>& second)
{
	if (!is_subset(first.flags, second.flags))
		return false;

/* TODO: for debugging; remove this */
#if defined(DEBUG_PARSER)
print("first.root:  ", stderr); print(*first.root, stderr, *debug_terminal_printer); print('\n', stderr);
print("second.root: ", stderr); print(*second.root, stderr, *debug_terminal_printer); print('\n', stderr);
#endif
	array<pair<hol_term*, variable_map>> intersection(2);
	intersect<built_in_predicates>(intersection, first.root, second.root);
	if (intersection.length == 0)
		return false;
	free_all(intersection);
	return true;
}

template<typename Formula>
static void is_separable(
		const transformation<flagged_logical_form<Formula>>* functions,
		unsigned int rule_length, bool* separable)
{
	for (unsigned int i = 0; i < rule_length; i++)
		separable[i] = false;
}

inline bool copy_array(
		const unsigned int* src, unsigned int src_length,
		unsigned int*& dst, unsigned int& dst_length)
{
	if (src_length == 0) {
		dst_length = 0;
		return true;
	}
	dst = (unsigned int*) malloc(sizeof(unsigned int) * src_length);
	if (dst == nullptr) {
		fprintf(stderr, "copy_array ERROR: Out of memory.\n");
		return false;
	}
	memcpy(dst, src, sizeof(unsigned int) * src_length);
	dst_length = src_length;
	return true;
}

bool get_constant(hol_term* src, unsigned int& value,
		unsigned int*& excluded, unsigned int& excluded_count)
{
	hol_term* term = hol_term::new_any_constant_except();
	if (term == nullptr) return false;

	array<hol_term*> intersection(2);
	intersect<built_in_predicates>(intersection, term, src);
	free(*term); if (term->reference_count == 0) free(term);
	if (intersection.length == 0) {
		return false;
	} else if (intersection.length != 1) {
		fprintf(stderr, "get_constant ERROR: Expected intersection size to be 1.\n");
		for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
		return false;
	}

	if (intersection[0]->type == hol_term_type::CONSTANT) {
		value = intersection[0]->constant;
		excluded_count = 0;
	} else if (intersection[0]->type == hol_term_type::ANY_CONSTANT) {
		value = UNION_NODE;
		if (!copy_array(intersection[0]->any_constant.constants, intersection[0]->any_constant.length, excluded, excluded_count)) {
			for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
			return false;
		}
	} else {
#if !defined(NDEBUG)
		if (intersection[0]->type != hol_term_type::ANY_CONSTANT_EXCEPT)
			fprintf(stderr, "get_constant WARNING: Unexpected formula type in intersection.\n");
#endif
		value = IMPLICIT_NODE;
		if (intersection[0]->any_constant.length > 0 && !copy_array(intersection[0]->any_constant.constants, intersection[0]->any_constant.length, excluded, excluded_count)) {
			for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
			return false;
		}
		excluded_count = intersection[0]->any_constant.length;
	}
	for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
	return true;
}

bool get_predicate(hol_term* src, unsigned int& value,
		unsigned int*& excluded, unsigned int& excluded_count)
{
	if ((src->type == hol_term_type::ANY || src->type == hol_term_type::ANY_RIGHT)
	 && src->any.included != nullptr && src->any.included->type == hol_term_type::EXISTS)
		src = src->any.included;

	hol_term* term;
	if (src->type == hol_term_type::EXISTS) {
		hol_term* excluded_tree = hol_term::new_any(hol_term::new_exists(src->quantifier.variable, &HOL_ANY));
		if (excluded_tree == nullptr)
			return false;
		HOL_ANY.reference_count++;

		term = hol_term::new_exists(src->quantifier.variable,
				hol_term::new_and(hol_term::new_apply(hol_term::new_any_constant_except(), hol_term::new_variable(src->quantifier.variable)), hol_term::new_any(nullptr, &excluded_tree, 1)));
		if (term == nullptr) {
			free(*excluded_tree); free(excluded_tree);
			return false;
		}
	} else {
		term = hol_term::new_any_quantifier(hol_quantifier_type::EXISTS,
				hol_term::new_and(hol_term::new_apply(hol_term::new_any_constant_except(), &HOL_ANY), &HOL_ANY));
		if (term == nullptr) return false;
		HOL_ANY.reference_count += 2;
	}

	array<hol_term*> intersection(2);
	intersect<built_in_predicates>(intersection, term, src);
	free(*term); if (term->reference_count == 0) free(term);
	if (intersection.length == 0) {
		return false;
	} else if (intersection.length != 1) {
		fprintf(stderr, "get_predicate ERROR: Expected intersection size to be 1.\n");
		for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
		return false;
	}

	hol_term* operand;
	if (intersection[0]->type == hol_term_type::EXISTS) {
		operand = intersection[0]->quantifier.operand;
	} else {
		operand = intersection[0]->any_quantifier.operand;
	}

	hol_term* predicate;
	if (operand->type == hol_term_type::AND) {
		predicate = operand->array.operands[0]->binary.left;
	} else if (operand->type == hol_term_type::ANY_ARRAY) {
		predicate = operand->any_array.left.operands[0]->binary.left;
	} else {
		predicate = operand->binary.left;
	}

	if (predicate->type == hol_term_type::CONSTANT) {
		value = predicate->constant;
		excluded_count = 0;
	} else if (predicate->type == hol_term_type::ANY_CONSTANT) {
		value = UNION_NODE;
		if (!copy_array(predicate->any_constant.constants, predicate->any_constant.length, excluded, excluded_count)) {
			for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
			return false;
		}
	} else {
#if !defined(NDEBUG)
		if (predicate->type != hol_term_type::ANY_CONSTANT_EXCEPT)
			fprintf(stderr, "get_predicate WARNING: Unexpected formula type in intersection.\n");
#endif
		value = IMPLICIT_NODE;
		if (!copy_array(predicate->any_constant.constants, predicate->any_constant.length, excluded, excluded_count)) {
			for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
			return false;
		}
	}
	for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
	return true;
}

bool get_predicate_only(hol_term* src, unsigned int& value,
		unsigned int*& excluded, unsigned int& excluded_count)
{
	hol_term* head = src;
	if ((src->type == hol_term_type::ANY || src->type == hol_term_type::ANY_RIGHT) && src->any.included != nullptr
	 && (src->any.included->type == hol_term_type::EXISTS || src->any.included->type == hol_term_type::ANY_ARRAY))
		head = head->any.included;

	unsigned int head_variable;
	if (head->type == hol_term_type::EXISTS) {
		head_variable = head->quantifier.variable;
	} else if (head->type == hol_term_type::ANY_ARRAY) {
		if (head->any_array.any.length > 1 || head->any_array.left.length > 1 || head->any_array.right.length > 1)
			return false;
		if (head->any_array.left.length == 1 && head->any_array.left.operands[0]->type == hol_term_type::EXISTS) {
			head_variable = head->any_array.left.operands[0]->quantifier.variable;
		} else if (head->any_array.left.length == 1 && head->any_array.left.operands[0]->type == hol_term_type::ANY_RIGHT
		 && head->any_array.left.operands[0]->any.included != nullptr && head->any_array.left.operands[0]->any.included->type == hol_term_type::EXISTS)
		{
			head_variable = head->any_array.left.operands[0]->any.included->quantifier.variable;
		} else if (head->any_array.right.length == 1 && head->any_array.right.operands[0]->type == hol_term_type::EXISTS) {
			head_variable = head->any_array.right.operands[0]->quantifier.variable;
		} else if (head->any_array.right.length == 1 && head->any_array.right.operands[0]->type == hol_term_type::ANY_RIGHT
				&& head->any_array.right.operands[0]->any.included != nullptr && head->any_array.right.operands[0]->any.included->type == hol_term_type::EXISTS)
		{
			head_variable = head->any_array.right.operands[0]->any.included->quantifier.variable;
		} else if (head->any_array.any.length == 1 && head->any_array.any.operands[0]->type == hol_term_type::EXISTS) {
			head_variable = head->any_array.any.operands[0]->quantifier.variable;
		} else if (head->any_array.any.length == 1 && head->any_array.any.operands[0]->type == hol_term_type::ANY_RIGHT
				&& head->any_array.any.operands[0]->any.included != nullptr && head->any_array.any.operands[0]->any.included->type == hol_term_type::EXISTS)
		{
			head_variable = head->any_array.any.operands[0]->any.included->quantifier.variable;
		} else if (head->any_array.all->type == hol_term_type::EXISTS) {
			head_variable = head->any_array.all->quantifier.variable;
		} else if (head->any_array.all->type == hol_term_type::ANY_RIGHT && head->any_array.all->any.included != nullptr && head->any_array.all->any.included->type == hol_term_type::EXISTS) {
			head_variable = head->any_array.all->any.included->quantifier.variable;
		} else {
			unsigned int max_variable = 0;
			max_bound_variable(*head, max_variable);
			head_variable = ++max_variable;
		}
	} else {
		unsigned int max_variable = 0;
		max_bound_variable(*head, max_variable);
		head_variable = ++max_variable;
	}

	hol_term* term = hol_term::new_exists(head_variable,
			hol_term::new_apply(hol_term::new_any_constant_except(), hol_term::new_variable(head_variable)));
	if (term == nullptr)
		return false;

	array<hol_term*> intersection(2);
	intersect<built_in_predicates>(intersection, term, src);
	free(*term); if (term->reference_count == 0) free(term);
	if (intersection.length == 0) {
		return false;
	} else if (intersection.length != 1) {
		fprintf(stderr, "get_predicate_only ERROR: Expected intersection size to be 1.\n");
		for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
		return false;
	}

	hol_term* operand;
	if (intersection[0]->type == hol_term_type::EXISTS) {
		operand = intersection[0]->quantifier.operand;
	} else {
		operand = intersection[0]->any_quantifier.operand;
	}

	hol_term* predicate = operand->binary.left;
	if (predicate->type == hol_term_type::CONSTANT) {
		value = predicate->constant;
		excluded_count = 0;
	} else if (predicate->type == hol_term_type::ANY_CONSTANT) {
		value = UNION_NODE;
		if (!copy_array(predicate->any_constant.constants, predicate->any_constant.length, excluded, excluded_count)) {
			for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
			return false;
		}
	} else {
#if !defined(NDEBUG)
		if (predicate->type != hol_term_type::ANY_CONSTANT_EXCEPT)
			fprintf(stderr, "get_predicate_only WARNING: Unexpected formula type in intersection.\n");
#endif
		value = IMPLICIT_NODE;
		if (!copy_array(predicate->any_constant.constants, predicate->any_constant.length, excluded, excluded_count)) {
			for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
			return false;
		}
	}
	for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
	return true;
}

bool get_head_predicate(hol_term* src, unsigned int& value,
		unsigned int*& excluded, unsigned int& excluded_count)
{
	head_index predicate_index; no_op apply;
	hol_term* head = find_head(src, predicate_index, find_head<built_in_predicates>, apply);
	if (head == nullptr)
		return false;

	if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
		head = head->any.included;
	while (head->type == hol_term_type::NOT)
		head = head->unary.operand;

	if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) {
		value = IMPLICIT_NODE;
		excluded_count = 0;
		return true;
	} else {
#if !defined(NDEBUG)
		if (head->type != hol_term_type::EXISTS) {
			fprintf(stderr, "get_head_predicate ERROR: Expected existential quantification.\n");
			return false;
		}
#endif
	}

	unsigned int head_variable = head->quantifier.variable;
	hol_term* operand = head->quantifier.operand;
	hol_term* predicate = find_predicate<built_in_predicates>(head_variable, operand, predicate_index);
	if (predicate_index.position == head_position::NONE) {
		value = (unsigned int) built_in_predicates::ZERO;
		excluded_count = 0;
		return true;
	} else if (operand->type == hol_term_type::AND) {
		predicate = operand->array.operands[predicate_index.index];
	} else if (operand->type == hol_term_type::ANY_ARRAY) {
		if (predicate_index.position == head_position::LEFT) {
			predicate = operand->any_array.left.operands[predicate_index.index];
		} else if (predicate_index.position == head_position::RIGHT) {
			predicate = operand->any_array.right.operands[operand->any_array.right.length - predicate_index.index - 1];
		} else {
			predicate = operand->any_array.any.operands[predicate_index.index];
		}
	} else {
		predicate = operand;
	}

	hol_term* expected_predicate = hol_term::new_apply(
			hol_term::new_any_constant_except(make_array_view(hol_non_head_constants<built_in_predicates>::CONSTANTS, array_length(hol_non_head_constants<built_in_predicates>::CONSTANTS))),
			hol_term::new_variable(head_variable));
	if (expected_predicate == nullptr)
		return false;

	bool can_be_empty = !is_subset<built_in_predicates>(predicate, expected_predicate);

	array<hol_term*> intersection(2);
	intersect<built_in_predicates>(intersection, expected_predicate, predicate);
	free(*expected_predicate); if (expected_predicate->reference_count == 0) free(expected_predicate);
	if (intersection.length == 0) {
		value = (unsigned int) built_in_predicates::ZERO;
		excluded_count = 0;
		return true;
	} else if (intersection.length != 1) {
		fprintf(stderr, "get_head_predicate ERROR: Expected intersection size to be 1.\n");
		free_all(intersection);
		return false;
	}

	hol_term* actual_predicate = intersection[0]->binary.left;
	if (actual_predicate->type == hol_term_type::CONSTANT) {
		if (can_be_empty) {
			value = UNION_NODE;
			excluded = (unsigned int*) malloc(sizeof(unsigned int) * 2);
			if (excluded == nullptr) {
				fprintf(stderr, "get_head_predicate ERROR: Out of memory.\n");
				free_all(intersection);
				return false;
			}
			excluded[0] = (unsigned int) built_in_predicates::ZERO;
			excluded[1] = actual_predicate->constant;
			excluded_count = 2;
		} else {
			value = actual_predicate->constant;
			excluded_count = 0;
		}
	} else if (actual_predicate->type == hol_term_type::ANY_CONSTANT) {
		if (can_be_empty) {
			value = UNION_NODE;
			excluded = (unsigned int*) malloc(sizeof(unsigned int) * (actual_predicate->any_constant.length + 1));
			if (excluded == nullptr) {
				fprintf(stderr, "get_head_predicate ERROR: Out of memory.\n");
				free_all(intersection);
				return false;
			}
			excluded[0] = (unsigned int) built_in_predicates::ZERO;
			for (unsigned int i = 0; i < actual_predicate->any_constant.length; i++)
				excluded[1 + i] = actual_predicate->any_constant.constants[i];
			excluded_count = actual_predicate->any_constant.length + 1;
		} else {
			value = UNION_NODE;
			if (!copy_array(actual_predicate->any_constant.constants, actual_predicate->any_constant.length, excluded, excluded_count)) {
				free_all(intersection);
				return false;
			}
		}
	} else {
#if !defined(NDEBUG)
		if (actual_predicate->type != hol_term_type::ANY_CONSTANT_EXCEPT)
			fprintf(stderr, "get_head_predicate WARNING: Unexpected formula type in intersection.\n");
#endif
		if (!can_be_empty) {
			value = IMPLICIT_NODE;
			excluded = (unsigned int*) malloc(sizeof(unsigned int) * (actual_predicate->any_constant.length + 1));
			if (excluded == nullptr) {
				fprintf(stderr, "get_head_predicate ERROR: Out of memory.\n");
				free_all(intersection);
				return false;
			}
			excluded[0] = (unsigned int) built_in_predicates::ZERO;
			for (unsigned int i = 0; i < actual_predicate->any_constant.length; i++)
				excluded[1 + i] = actual_predicate->any_constant.constants[i];
			excluded_count = actual_predicate->any_constant.length + 1;
		} else {
			value = IMPLICIT_NODE;
			if (!copy_array(actual_predicate->any_constant.constants, actual_predicate->any_constant.length, excluded, excluded_count)) {
				free_all(intersection);
				return false;
			}
		}
	}
	free_all(intersection);
	return true;
}

bool get_set_definition(hol_term* src, unsigned int& value,
		unsigned int*& excluded, unsigned int& excluded_count)
{
	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else {
		return false;
	}

	head_index predicate_index; no_op apply;
	auto head_finder = predicative_head_finder<built_in_predicates>(lambda_variable);
	hol_term* head = find_head(src, predicate_index, head_finder, apply);
	if (head == nullptr)
		return false;

	if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
		head = head->any.included;

	unsigned int set_variable;
	if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) {
		value = IMPLICIT_NODE;
		excluded_count = 0;
		return true;
	} else {
#if !defined(NDEBUG)
		if (head->type != hol_term_type::EXISTS) {
			fprintf(stderr, "get_set_definition ERROR: Expected existential quantification of set.\n");
			return false;
		}
#endif
		set_variable = head->quantifier.variable;
	}

	hol_term* expected_left = hol_term::new_equals(hol_term::new_variable(set_variable), &HOL_ANY);
	if (expected_left == nullptr)
		return false;
	HOL_ANY.reference_count++;

	hol_term* expected_head = hol_term::new_exists(set_variable, hol_term::new_any_array(hol_term_type::AND, &HOL_ANY,
			make_array_view((hol_term**) nullptr, 0), make_array_view(&expected_left, 1), make_array_view((hol_term**) nullptr, 0)));
	if (expected_head == nullptr) {
		free(*expected_left); free(expected_left);
		return (hol_term*) nullptr;
	}
	HOL_ANY.reference_count++;

	bool is_complement = false;
	array<unsigned int> allowed_set_definitions(4);
	if (has_intersection<built_in_predicates>(head, expected_head))
		allowed_set_definitions[allowed_set_definitions.length++] = (unsigned int) built_in_predicates::EQUALS;
	free(*expected_head); free(expected_head);

	expected_left = hol_term::new_apply(hol_term::new_any_constant_except(), hol_term::new_variable(set_variable), &HOL_ANY);
	if (expected_left == nullptr)
		return false;
	HOL_ANY.reference_count++;

	expected_head = hol_term::new_exists(set_variable, hol_term::new_any_array(hol_term_type::AND, &HOL_ANY,
			make_array_view((hol_term**) nullptr, 0), make_array_view(&expected_left, 1), make_array_view((hol_term**) nullptr, 0)));
	if (expected_head == nullptr) {
		free(*expected_left); free(expected_left);
		return (hol_term*) nullptr;
	}
	HOL_ANY.reference_count++;

	array<hol_term*> intersection(4);
	intersect<built_in_predicates>(intersection, head, expected_head);
	free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
	for (hol_term* new_head : intersection) {
		hol_term* predicate;
		hol_term* operand = new_head->quantifier.operand;
		if (operand->type == hol_term_type::ANY_ARRAY) {
			predicate = operand->any_array.left.operands[0]->ternary.first;
		} else {
			predicate = operand->array.operands[0]->ternary.first;
		}

		if (predicate->type == hol_term_type::CONSTANT) {
			if (is_complement) {
				unsigned int index = allowed_set_definitions.index_of(predicate->constant);
				if (index < allowed_set_definitions.length) allowed_set_definitions.remove(index);
			} else {
				if (!allowed_set_definitions.contains(predicate->constant)) {
					if (!allowed_set_definitions.add(predicate->constant)) {
						free_all(intersection);
						return false;
					}
					insertion_sort(allowed_set_definitions);
				}
			}
		} else if (predicate->type == hol_term_type::ANY_CONSTANT) {
			if (is_complement) {
				set_subtract(allowed_set_definitions.data, allowed_set_definitions.length, predicate->any_constant.constants, predicate->any_constant.length);
			} else {
				array<unsigned int> new_allowed_set_definitions(allowed_set_definitions.length + predicate->any_constant.length);
				set_union(new_allowed_set_definitions.data, new_allowed_set_definitions.length,
						allowed_set_definitions.data, allowed_set_definitions.length,
						predicate->any_constant.constants, predicate->any_constant.length);
				swap(new_allowed_set_definitions, allowed_set_definitions);
			}
		} else if (predicate->type == hol_term_type::ANY_CONSTANT_EXCEPT) {
			if (is_complement) {
				set_intersect(allowed_set_definitions, predicate->any_constant.constants, predicate->any_constant.length);
			} else {
				array<unsigned int> new_allowed_set_definitions(max(1u, predicate->any_constant.length));
				set_subtract(new_allowed_set_definitions.data, new_allowed_set_definitions.length,
						predicate->any_constant.constants, predicate->any_constant.length,
						allowed_set_definitions.data, allowed_set_definitions.length);
				swap(new_allowed_set_definitions, allowed_set_definitions);
				is_complement = true;
			}
		}
	}
	free_all(intersection);

	if (allowed_set_definitions.length == 0) {
		if (!is_complement)
			return false;
		value = IMPLICIT_NODE;
		excluded_count = 0;
		return true;
	} else if (allowed_set_definitions.length == 1 && !is_complement) {
		value = allowed_set_definitions[0];
		excluded_count = 0;
		return true;
	} else {
		if (is_complement) value = IMPLICIT_NODE;
		else value = UNION_NODE;
		return copy_array(allowed_set_definitions.data, allowed_set_definitions.length, excluded, excluded_count);
	}
}

bool get_set_predicate(hol_term* src, unsigned int& value,
		unsigned int*& excluded, unsigned int& excluded_count)
{
	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else if (src->type == hol_term_type::ANY || src->type == hol_term_type::ANY_RIGHT) {
		value = IMPLICIT_NODE;
		excluded_count = 0;
		return true;
	} else {
		return false;
	}

	head_index predicate_index; no_op apply;
	auto head_finder = predicative_head_finder<built_in_predicates>(lambda_variable);
	hol_term* head = find_head(src, predicate_index, head_finder, apply);
	if (head == nullptr)
		return false;

	bool any = false;
	if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr) {
		any = true;
		head = head->any.included;
	}

	if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) {
		value = IMPLICIT_NODE;
		excluded_count = 0;
		return true;
	} else if (head->type == hol_term_type::UNARY_APPLICATION) {
		if (any && head->binary.left->type == hol_term_type::VARIABLE && head->binary.left->variable == lambda_variable && head->binary.right->type == hol_term_type::VARIABLE) {
			value = IMPLICIT_NODE;
			excluded_count = 0;
			return true;
		} else {
			value = (unsigned int) built_in_predicates::ZERO;
			excluded_count = 0;
			return true;
		}
	} else {
#if !defined(NDEBUG)
		if (head->type != hol_term_type::EXISTS) {
			fprintf(stderr, "get_set_predicate ERROR: Expected existential quantification of set.\n");
			return false;
		}
#endif
	}

	hol_term* left;
	hol_term* operand = head->quantifier.operand;
	if (operand->type == hol_term_type::ANY || operand->type == hol_term_type::ANY_RIGHT) {
		value = IMPLICIT_NODE;
		excluded_count = 0;
		return true;
	} else if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
		if (operand->any_array.left.length == 0) {
			value = IMPLICIT_NODE;
			excluded_count = 0;
			return true;
		} else {
			left = operand->any_array.left.operands[0];
		}
	} else if (operand->type == hol_term_type::AND) {
		left = operand->array.operands[0];
	} else {
		return false;
	}

	hol_term* set_definition;
	if (left->type == hol_term_type::ANY_RIGHT && left->any.included != nullptr && left->any.included->type == hol_term_type::LAMBDA) {
		set_definition = left->any.included;
	} else if (left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT) {
		value = IMPLICIT_NODE;
		excluded_count = 0;
		return true;
	} else if (left->type == hol_term_type::EQUALS) {
		set_definition = left->binary.right;
	} else if (left->type == hol_term_type::BINARY_APPLICATION) {
		set_definition = left->ternary.third;
	} else {
		return false;
	}

	hol_term* inner_operand;
	unsigned int element_variable;
	if (set_definition->type == hol_term_type::ANY || set_definition->type == hol_term_type::ANY_RIGHT) {
		value = IMPLICIT_NODE;
		excluded_count = 0;
		return true;
	} else if (set_definition->type == hol_term_type::LAMBDA) {
		element_variable = set_definition->quantifier.variable;
		inner_operand = set_definition->quantifier.operand;
	} else {
		return false;
	}

	/* find the predicate in `inner_operand` */
	head_index inner_predicate_index;
	hol_term* predicate = find_predicate<built_in_predicates>(element_variable, inner_operand, inner_predicate_index);
	if (inner_predicate_index.position != head_position::NONE) {
		if (predicate == nullptr) {
			if (inner_operand->type == hol_term_type::AND) {
				predicate = inner_operand->array.operands[inner_predicate_index.index];
			} else if (inner_operand->type == hol_term_type::ANY_ARRAY) {
				if (inner_predicate_index.position == head_position::LEFT)
					predicate = inner_operand->any_array.left.operands[inner_predicate_index.index];
				else if (inner_predicate_index.position == head_position::RIGHT)
					predicate = inner_operand->any_array.right.operands[inner_operand->any_array.right.length - inner_predicate_index.index - 1];
				else predicate = inner_operand->any_array.any.operands[inner_predicate_index.index];
			} else {
				predicate = inner_operand;
			}
		}

		hol_term* predicator;
		if (predicate->type == hol_term_type::ANY || predicate->type == hol_term_type::ANY_RIGHT) {
			value = IMPLICIT_NODE;
			excluded_count = 0;
			return true;
		} else if (predicate->type == hol_term_type::UNARY_APPLICATION) {
			predicator = predicate->binary.left;
		} else {
			value = (unsigned int) built_in_predicates::ZERO;
			excluded_count = 0;
			return true;
		}

		hol_term* expected_predicator = hol_term::new_any_constant_except();
		if (expected_predicator == nullptr)
			return false;
		array<hol_term*> intersection(2);
		intersect<built_in_predicates>(intersection, expected_predicator, predicator);
		free(*expected_predicator); if (expected_predicator->reference_count == 0) free(expected_predicator);
		if (intersection.length == 1) {
			if (intersection[0]->type == hol_term_type::ANY_CONSTANT_EXCEPT) {
				value = IMPLICIT_NODE;
				bool success = copy_array(intersection[0]->any_constant.constants, intersection[0]->any_constant.length, excluded, excluded_count);
				free_all(intersection);
				return success;
			} else if (intersection[0]->type == hol_term_type::ANY_CONSTANT) {
				value = UNION_NODE;
				bool success = copy_array(intersection[0]->any_constant.constants, intersection[0]->any_constant.length, excluded, excluded_count);
				free_all(intersection);
				return success;
			} else {
				value = intersection[0]->constant;
				excluded_count = 0;
				free_all(intersection);
				return true;
			}
		} else if (intersection.length > 1) {
			fprintf(stderr, "get_set_predicate ERROR: Intersection is not unique.\n");
			free_all(intersection); return false;
		}
	}

	predicate = find_variable_definition<built_in_predicates>(element_variable, inner_operand, inner_predicate_index);
	if (inner_predicate_index.position != head_position::NONE) {
		if (predicate == nullptr) {
			if (inner_operand->type == hol_term_type::AND) {
				predicate = inner_operand->array.operands[inner_predicate_index.index];
			} else if (inner_operand->type == hol_term_type::ANY_ARRAY) {
				if (inner_predicate_index.position == head_position::LEFT)
					predicate = inner_operand->any_array.left.operands[inner_predicate_index.index];
				else if (inner_predicate_index.position == head_position::RIGHT)
					predicate = inner_operand->any_array.right.operands[inner_operand->any_array.right.length - inner_predicate_index.index - 1];
				else predicate = inner_operand->any_array.any.operands[inner_predicate_index.index];
			} else {
				predicate = inner_operand;
			}
		}

		hol_term* predicator;
		if (predicate->type == hol_term_type::ANY || predicate->type == hol_term_type::ANY_RIGHT) {
			value = IMPLICIT_NODE;
			excluded_count = 0;
			return true;
		} else if (predicate->type == hol_term_type::EQUALS) {
			predicator = predicate->binary.right;
		} else {
			value = (unsigned int) built_in_predicates::ZERO;
			excluded_count = 0;
			return true;
		}

		hol_term* expected_predicator = hol_term::new_any_constant_except();
		if (expected_predicator == nullptr)
			return false;
		array<hol_term*> intersection(2);
		intersect<built_in_predicates>(intersection, expected_predicator, predicator);
		free(*expected_predicator); if (expected_predicator->reference_count == 0) free(expected_predicator);
		if (intersection.length == 1) {
			if (intersection[0]->type == hol_term_type::ANY_CONSTANT_EXCEPT) {
				value = IMPLICIT_NODE;
				bool success = copy_array(intersection[0]->any_constant.constants, intersection[0]->any_constant.length, excluded, excluded_count);
				free_all(intersection);
				return success;
			} else if (intersection[0]->type == hol_term_type::ANY_CONSTANT) {
				value = UNION_NODE;
				bool success = copy_array(intersection[0]->any_constant.constants, intersection[0]->any_constant.length, excluded, excluded_count);
				free_all(intersection);
				return success;
			} else {
				value = intersection[0]->constant;
				excluded_count = 0;
				free_all(intersection);
				return true;
			}
		} else if (intersection.length > 1) {
			fprintf(stderr, "get_set_predicate ERROR: Intersection is not unique.\n");
			free_all(intersection); return false;
		}
	}

	/* find the scope in `inner_operand` */
	predicate = find_scope<built_in_predicates, (unsigned int) built_in_predicates::NAME>(element_variable, inner_operand, inner_predicate_index);
	if (inner_predicate_index.position != head_position::NONE) {
		value = (unsigned int) built_in_predicates::NAMED_ENTITY;
		excluded_count = 0;
		return true;
	} else {
		value = (unsigned int) built_in_predicates::ZERO;
		excluded_count = 0;
		return true;
	}
}

template<typename BuiltInPredicates>
struct arg_finder {
	unsigned int head_variable;

	arg_finder(unsigned int head_variable) : head_variable(head_variable) { }

	inline void operator () (
			hol_term* src, hol_term*& head,
			head_index& predicate_index)
	{
		if (src->type == hol_term_type::EQUALS
		 && src->binary.left->type == hol_term_type::UNARY_APPLICATION
		 && src->binary.left->binary.right->type == hol_term_type::VARIABLE
		 && src->binary.left->binary.right->variable == head_variable
		 && (src->binary.left->binary.left->type == hol_term_type::CONSTANT
		  || src->binary.left->binary.left->type == hol_term_type::ANY_CONSTANT))
		{
			head = src->binary.left->binary.left;
		} else {
			head = nullptr;
		}
	}
};

template<int_fast8_t ConjunctIndex>
bool get_arg(hol_term* src, unsigned int& value,
		unsigned int*& excluded, unsigned int& excluded_count)
{
	head_index predicate_index; no_op apply;
	hol_term* head = find_head(src, predicate_index, find_head<built_in_predicates>, apply);
	if (head == nullptr)
		return false;

	unsigned int head_variable;
	if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
		head = head->any.included;
	while (head->type == hol_term_type::NOT)
		head = head->unary.operand;
	if (head->type == hol_term_type::EXISTS) {
		head_variable = head->quantifier.variable;
	} else if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) {
		value = UNION_NODE;
		excluded = (unsigned int*) malloc(sizeof(unsigned int) * 4);
		if (excluded == nullptr) {
			fprintf(stderr, "get_arg ERROR: Out of memory.\n");
			return false;
		}
		excluded[0] = (unsigned int) built_in_predicates::UNKNOWN;
		excluded[1] = (unsigned int) built_in_predicates::ARG1;
		excluded[2] = (unsigned int) built_in_predicates::ARG2;
		excluded[3] = (unsigned int) built_in_predicates::ARG3;
		excluded_count = 4;
		return true;
	} else {
		return false;
	}

	hol_term* excluded_quantifiers[3];
	excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(head_variable, &HOL_ANY));
	excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(head_variable, &HOL_ANY));
	excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(head_variable, &HOL_ANY));
	if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
	if (excluded_quantifiers[1] != nullptr) HOL_ANY.reference_count++;
	if (excluded_quantifiers[2] != nullptr) HOL_ANY.reference_count++;
	if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr) {
		if (excluded_quantifiers[0] != nullptr) { free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]); }
		if (excluded_quantifiers[1] != nullptr) { free(*excluded_quantifiers[1]); free(excluded_quantifiers[1]); }
		return (hol_term*) nullptr;
	}

	hol_term* excluded_tree = hol_term::new_any(nullptr, excluded_quantifiers, array_length(excluded_quantifiers));
	if (excluded_tree == nullptr) {
		for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
		return (hol_term*) nullptr;
	}

	hol_term* expected_conjunct = hol_term::new_any_right(hol_term::new_equals(
			hol_term::new_apply(hol_term::new_any_constant(
				(unsigned int) built_in_predicates::ARG1,
				(unsigned int) built_in_predicates::ARG2,
				(unsigned int) built_in_predicates::ARG3),
			hol_term::new_variable(head_variable)), excluded_tree));
	if (expected_conjunct == nullptr) {
		free(*excluded_tree); free(excluded_tree);
		return false;
	}
	excluded_tree->reference_count++;

	hol_term* expected_head;
	if (ConjunctIndex >= 0) {
		expected_head = hol_term::new_exists(head_variable, hol_term::new_any_array(
				hol_term_type::AND, excluded_tree, make_array_view((hol_term**) nullptr, 0),
				make_appended_array_view(make_repeated_array_view(excluded_tree, ConjunctIndex), expected_conjunct),
				make_array_view((hol_term**) nullptr, 0)));
		if (expected_head == nullptr) {
			free(*expected_conjunct); free(expected_conjunct);
			free(*excluded_tree); free(excluded_tree);
			return false;
		}
		excluded_tree->reference_count += ConjunctIndex;
	} else {
		unsigned int index = (unsigned int) (-ConjunctIndex) - 1;
		expected_head = hol_term::new_exists(head_variable, hol_term::new_any_array(
				hol_term_type::AND, excluded_tree, make_array_view((hol_term**) nullptr, 0),
				make_array_view((hol_term**) nullptr, 0),
				make_prepended_array_view(expected_conjunct, make_repeated_array_view(excluded_tree, index))));
		if (expected_head == nullptr) {
			free(*expected_conjunct); free(expected_conjunct);
			free(*excluded_tree); free(excluded_tree);
			return false;
		}
		excluded_tree->reference_count += index;
	}

	array<hol_term*> intersection(2);
	intersect<built_in_predicates>(intersection, head, expected_head);
	free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
	if (intersection.length == 0) {
		value = (unsigned int) built_in_predicates::UNKNOWN;
		return true;
	} else if (intersection.length != 1) {
		fprintf(stderr, "get_arg ERROR: Intersection is not unique.\n");
		free_all(intersection); return false;
	}

	bool is_subset = (intersection[0] == head || *intersection[0] == *head);

	hol_term* conjunct;
	hol_term* operand = intersection[0]->quantifier.operand;
	if (operand->type == hol_term_type::AND) {
		if (ConjunctIndex >= 0)
			conjunct = operand->array.operands[ConjunctIndex];
		else conjunct = operand->array.operands[operand->array.length + ConjunctIndex];
	} else {
		if (ConjunctIndex >= 0)
			conjunct = operand->any_array.left.operands[ConjunctIndex];
		else conjunct = operand->any_array.right.operands[operand->any_array.right.length + ConjunctIndex];
	}

	arg_finder<built_in_predicates> find_arg(head_variable);
	hol_term* arg = find_head(conjunct, predicate_index, find_arg, apply);

	if (arg->type == hol_term_type::CONSTANT) {
		if (!is_subset) {
			value = UNION_NODE;
			excluded = (unsigned int*) malloc(sizeof(unsigned int) * 2);
			if (excluded == nullptr) {
				fprintf(stderr, "get_arg ERROR: Out of memory.\n");
				free_all(intersection); return false;
			}
			excluded[0] = (unsigned int) built_in_predicates::UNKNOWN;
			excluded[1] = arg->constant;
			excluded_count = 2;
		} else {
			value = arg->constant;
			excluded_count = 0;
		}
	} else if (arg->type == hol_term_type::ANY_CONSTANT) {
		if (!is_subset) {
			value = UNION_NODE;
			excluded = (unsigned int*) malloc(sizeof(unsigned int) * (arg->any_constant.length + 1));
			if (excluded == nullptr) {
				fprintf(stderr, "get_arg ERROR: Out of memory.\n");
				free_all(intersection); return false;
			}
			excluded[0] = (unsigned int) built_in_predicates::UNKNOWN;
			for (unsigned int i = 0; i < arg->any_constant.length; i++)
				excluded[1 + i] = arg->any_constant.constants[i];
			excluded_count = arg->any_constant.length + 1;
		} else {
			value = UNION_NODE;
			if (!copy_array(arg->any_constant.constants, arg->any_constant.length, excluded, excluded_count)) {
				free_all(intersection);
				return false;
			}
		}
	}
	free_all(intersection);
	return true;
}

template<grammatical_flag Flag, typename Formula>
bool get_flag(
		const flagged_logical_form<Formula>& src, unsigned int& value,
		unsigned int*& excluded, unsigned int& excluded_count)
{
	grammatical_flag_value src_value = src.flags.flags[(unsigned int) Flag];
	if (src_value == grammatical_flag_value::ANY) {
		value = IMPLICIT_NODE;
		excluded_count = 0;
	} else {
		value = (unsigned int) src_value;
		excluded_count = 0;
	}
	return true;
}

bool get_tense_from_head(hol_term* head, unsigned int& value,
		unsigned int*& excluded, unsigned int& excluded_count)
{
	if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
		head = head->any.included;

	while (head->type == hol_term_type::NOT)
		head = head->unary.operand;

	if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) {
		return true;
	} else if (head->type == hol_term_type::EXISTS) {
		unsigned int head_variable = head->quantifier.variable;
		hol_term* operand = head->quantifier.operand;

		head_index predicate_index;
		find_predicate<built_in_predicates>(head_variable, operand, predicate_index);
		if (predicate_index.position == head_position::NONE)
			return false;
		hol_term* tense_predicate = nullptr;
		if (operand->type == hol_term_type::AND) {
			if (predicate_index.index == operand->array.length - 1)
				return false;
			tense_predicate = operand->array.operands[predicate_index.index + 1];
		} else if (operand->type == hol_term_type::ANY_ARRAY) {
			if (predicate_index.position == head_position::LEFT) {
				if (predicate_index.index == operand->any_array.left.length - 1)
					tense_predicate = operand->any_array.all;
				else tense_predicate = operand->any_array.left.operands[predicate_index.index + 1];
			} else if (predicate_index.position == head_position::ANY) {
				if (predicate_index.index == operand->any_array.any.length - 1)
					tense_predicate = operand->any_array.all;
				else tense_predicate = operand->any_array.any.operands[predicate_index.index + 1];
			} else if (predicate_index.position == head_position::RIGHT) {
				if (predicate_index.index == 0)
					return false;
				tense_predicate = operand->any_array.right.operands[operand->any_array.right.length - predicate_index.index];
			}
		} else if (operand->type == hol_term_type::ANY || operand->type == hol_term_type::ANY_RIGHT) {
			return true;
		} else {
			return false;
		}

		hol_term* expected_tense_term = hol_term::new_apply(hol_term::new_any_constant_except(), hol_term::new_variable(head_variable));
		if (expected_tense_term == nullptr)
			return false;
		array<hol_term*> intersection(2);
		intersect<built_in_predicates>(intersection, expected_tense_term, tense_predicate);
		free(*expected_tense_term); if (expected_tense_term->reference_count == 0) free(expected_tense_term);
		if (intersection.length == 0) {
			return false;
		} else if (intersection.length != 1) {
			fprintf(stderr, "get_tense_from_head ERROR: Intersection is not unique.\n");
			free_all(intersection); return false;
		}

		if (intersection[0]->binary.left->type == hol_term_type::ANY_CONSTANT_EXCEPT) {
			if (value == IMPLICIT_NODE) {
				unsigned int* new_constants = (unsigned int*) malloc(max(1, sizeof(unsigned int) * (intersection[0]->binary.left->any_constant.length + excluded_count)));
				if (new_constants == nullptr) {
					fprintf(stderr, "get_tense_from_head ERROR: Out of memory.\n");
					free_all(intersection); return false;
				}
				unsigned int new_constant_length = 0;
				set_union(new_constants, new_constant_length,
						intersection[0]->binary.left->any_constant.constants, intersection[0]->binary.left->any_constant.length,
						excluded, excluded_count);
				free_all(intersection);
				if (excluded_count > 0)
					free(excluded);
				excluded = new_constants;
				excluded_count = new_constant_length;
			} else if (value == UNION_NODE) {
				set_subtract(excluded, excluded_count, intersection[0]->binary.left->any_constant.constants, intersection[0]->binary.left->any_constant.length);
				free_all(intersection);
				if (excluded_count == 0) {
					return false;
				} else if (excluded_count == 1) {
					value = excluded[0];
					free(excluded);
					excluded_count = 0;
				}
			} else {
				if (index_of(value, intersection[0]->binary.left->any_constant.constants, intersection[0]->binary.left->any_constant.length) < intersection[0]->binary.left->any_constant.length) {
					free_all(intersection);
					return false;
				}
				free_all(intersection);
			}
		} else if (intersection[0]->binary.left->type == hol_term_type::ANY_CONSTANT) {
			if (value == IMPLICIT_NODE) {
				unsigned int* new_constants = (unsigned int*) malloc(max(1, sizeof(unsigned int) * intersection[0]->binary.left->any_constant.length));
				if (new_constants == nullptr) {
					fprintf(stderr, "get_tense_from_head ERROR: Out of memory.\n");
					free_all(intersection); return false;
				}
				unsigned int new_constant_length = 0;
				set_subtract(new_constants, new_constant_length,
						intersection[0]->binary.left->any_constant.constants, intersection[0]->binary.left->any_constant.length,
						excluded, excluded_count);
				free_all(intersection);
				if (excluded_count > 0)
					free(excluded);
				value = UNION_NODE;
				excluded = new_constants;
				excluded_count = new_constant_length;
				if (excluded_count == 0) {
					return false;
				} else if (excluded_count == 1) {
					value = excluded[0];
					free(excluded);
					excluded_count = 0;
				}
			} else if (value == UNION_NODE) {
				set_intersect(excluded, excluded_count, intersection[0]->binary.left->any_constant.constants, intersection[0]->binary.left->any_constant.length);
				free_all(intersection);
				if (excluded_count == 0) {
					return false;
				} else if (excluded_count == 1) {
					value = excluded[0];
					free(excluded);
					excluded_count = 0;
				}
			} else {
				if (index_of(value, intersection[0]->binary.left->any_constant.constants, intersection[0]->binary.left->any_constant.length) < intersection[0]->binary.left->any_constant.length) {
					free_all(intersection);
					return false;
				}
				free_all(intersection);
			}
		} else {
			unsigned int constant = intersection[0]->binary.left->constant;
			free_all(intersection);
			if (value == IMPLICIT_NODE) {
				if (index_of(constant, excluded, excluded_count) < excluded_count)
					return false;
				if (excluded_count > 0)
					free(excluded);
			} else if (value == UNION_NODE) {
				if (index_of(constant, excluded, excluded_count) == excluded_count)
					return false;
				if (excluded_count > 0)
					free(excluded);
			} else {
				if (constant != value)
					return false;
			}
			value = constant;
			excluded_count = 0;
		}
		return true;
	} else {
		return false;
	}
}

bool get_tense(hol_term* src, unsigned int& value,
		unsigned int*& excluded, unsigned int& excluded_count)
{
	head_index predicate_index; no_op apply;
	auto find_array_head = make_array_finder(find_head<built_in_predicates>);
	hol_term* head = find_head(src, predicate_index, find_array_head, apply);
	if (head == nullptr)
		return false;

	if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
		head = head->any.included;

	value = IMPLICIT_NODE;
	excluded_count = 0;

	if (head->type == hol_term_type::AND) {
		for (unsigned int i = 0; i < head->array.length; i++) {
			if (!get_tense_from_head(head->array.operands[i], value, excluded, excluded_count))
				return false;
		}
	} else if (head->type == hol_term_type::ANY_ARRAY) {
		if (!get_tense_from_head(head->any_array.all, value, excluded, excluded_count))
			return false;
		for (unsigned int i = 0; i < head->any_array.left.length; i++) {
			if (!get_tense_from_head(head->any_array.left.operands[i], value, excluded, excluded_count))
				return false;
		} for (unsigned int i = 0; i < head->any_array.right.length; i++) {
			if (!get_tense_from_head(head->any_array.right.operands[i], value, excluded, excluded_count))
				return false;
		} for (unsigned int i = 0; i < head->any_array.any.length; i++) {
			if (!get_tense_from_head(head->any_array.any.operands[i], value, excluded, excluded_count))
				return false;
		}
	} else {
		if (!get_tense_from_head(head, value, excluded, excluded_count))
			return false;
	}
	return true;
}

template<typename Formula>
bool get_feature(
		typename flagged_logical_form<Formula>::feature feature,
		const flagged_logical_form<Formula>& src, unsigned int& value,
		unsigned int*& excluded, unsigned int& excluded_count)
{
	typedef typename flagged_logical_form<Formula>::feature feature_type;
	switch (feature) {
	case feature_type::CONSTANT:
		return get_constant(src.root, value, excluded, excluded_count);
	case feature_type::PREDICATE:
		return get_predicate(src.root, value, excluded, excluded_count);
	case feature_type::PREDICATE_ONLY:
	case feature_type::UNAMBIGUOUS_PREDICATE_ONLY:
		return get_predicate_only(src.root, value, excluded, excluded_count);
	case feature_type::HEAD_PREDICATE:
		return get_head_predicate(src.root, value, excluded, excluded_count);
	case feature_type::SET_DEFINITION:
		return get_set_definition(src.root, value, excluded, excluded_count);
	case feature_type::SET_PREDICATE:
		return get_set_predicate(src.root, value, excluded, excluded_count);
	case feature_type::LEFT_ARG:
		return get_arg<0>(src.root, value, excluded, excluded_count);
	case feature_type::HAS_ARG2:
		return get_flag<grammatical_flag::HAS_ARG2>(src, value, excluded, excluded_count);
	case feature_type::MODIFIES_EVENT:
		return get_flag<grammatical_flag::MODIFIES_EVENT>(src, value, excluded, excluded_count);
	case feature_type::MEASURE:
		return get_flag<grammatical_flag::MEASURE>(src, value, excluded, excluded_count);
	case feature_type::EMPTY: break;
	}
	fprintf(stderr, "get_feature ERROR: Unrecognized semantic feature.\n");
	return false;
}

bool set_constant(hol_term* src, hol_term*& dst, unsigned int value)
{
	hol_term* term = hol_term::new_constant(value);
	if (term == nullptr) return false;

	array<hol_term*> intersection(2);
	intersect<built_in_predicates>(intersection, term, src);
	free(*term); if (term->reference_count == 0) free(term);
	if (intersection.length == 0) {
		return false;
	} else if (intersection.length != 1) {
		fprintf(stderr, "set_constant ERROR: Expected intersection size to be 1.\n");
		for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
		return false;
	}
	dst = intersection[0];
	return true;
}

bool set_predicate(hol_term* src, hol_term*& dst, unsigned int value)
{
	if ((src->type == hol_term_type::ANY || src->type == hol_term_type::ANY_RIGHT)
	 && src->any.included != nullptr && src->any.included->type == hol_term_type::EXISTS)
		src = src->any.included;

	hol_term* term;
	if (src->type == hol_term_type::EXISTS) {
		hol_term* excluded_tree = hol_term::new_any(hol_term::new_exists(src->quantifier.variable, &HOL_ANY));
		if (excluded_tree == nullptr)
			return false;
		HOL_ANY.reference_count++;

		term = hol_term::new_exists(src->quantifier.variable,
				hol_term::new_and(hol_term::new_apply(hol_term::new_constant(value), hol_term::new_variable(src->quantifier.variable)), hol_term::new_any(nullptr, &excluded_tree, 1)));
		if (term == nullptr) {
			free(*excluded_tree); free(excluded_tree);
			return false;
		}
	} else {
		term = hol_term::new_any_quantifier(hol_quantifier_type::EXISTS,
				hol_term::new_and(hol_term::new_apply(hol_term::new_constant(value), &HOL_ANY), &HOL_ANY));
		if (term == nullptr) return false;
		HOL_ANY.reference_count += 2;
	}

	array<hol_term*> intersection(2);
	intersect<built_in_predicates>(intersection, term, src);
	free(*term); if (term->reference_count == 0) free(term);
	if (intersection.length == 0) {
		return false;
	} else if (intersection.length != 1) {
		fprintf(stderr, "set_predicate ERROR: Expected intersection size to be 1.\n");
		for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
		return false;
	}
	dst = intersection[0];
	return true;
}

bool set_predicate_only(hol_term* src, hol_term*& dst, unsigned int value)
{
	hol_term* head = src;
	if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
		head = head->any.included;

	unsigned int head_variable;
	if (head->type == hol_term_type::EXISTS) {
		head_variable = head->quantifier.variable;
	} else if (head->type == hol_term_type::ANY_ARRAY) {
		if (head->any_array.any.length > 1 || head->any_array.left.length > 1 || head->any_array.right.length > 1)
			return false;
		if (head->any_array.left.length == 1 && head->any_array.left.operands[0]->type == hol_term_type::EXISTS) {
			head_variable = head->any_array.left.operands[0]->quantifier.variable;
		} else if (head->any_array.left.length == 1 && head->any_array.left.operands[0]->type == hol_term_type::ANY_RIGHT
		 && head->any_array.left.operands[0]->any.included != nullptr && head->any_array.left.operands[0]->any.included->type == hol_term_type::EXISTS)
		{
			head_variable = head->any_array.left.operands[0]->any.included->quantifier.variable;
		} else if (head->any_array.right.length == 1 && head->any_array.right.operands[0]->type == hol_term_type::EXISTS) {
			head_variable = head->any_array.right.operands[0]->quantifier.variable;
		} else if (head->any_array.right.length == 1 && head->any_array.right.operands[0]->type == hol_term_type::ANY_RIGHT
				&& head->any_array.right.operands[0]->any.included != nullptr && head->any_array.right.operands[0]->any.included->type == hol_term_type::EXISTS)
		{
			head_variable = head->any_array.right.operands[0]->any.included->quantifier.variable;
		} else if (head->any_array.any.length == 1 && head->any_array.any.operands[0]->type == hol_term_type::EXISTS) {
			head_variable = head->any_array.any.operands[0]->quantifier.variable;
		} else if (head->any_array.any.length == 1 && head->any_array.any.operands[0]->type == hol_term_type::ANY_RIGHT
				&& head->any_array.any.operands[0]->any.included != nullptr && head->any_array.any.operands[0]->any.included->type == hol_term_type::EXISTS)
		{
			head_variable = head->any_array.any.operands[0]->any.included->quantifier.variable;
		} else if (head->any_array.all->type == hol_term_type::EXISTS) {
			head_variable = head->any_array.all->quantifier.variable;
		} else if (head->any_array.all->type == hol_term_type::ANY_RIGHT && head->any_array.all->any.included != nullptr && head->any_array.all->any.included->type == hol_term_type::EXISTS) {
			head_variable = head->any_array.all->any.included->quantifier.variable;
		} else {
			unsigned int max_variable = 0;
			max_bound_variable(*head, max_variable);
			head_variable = ++max_variable;
		}
	} else {
		unsigned int max_variable = 0;
		max_bound_variable(*head, max_variable);
		head_variable = ++max_variable;
	}

	hol_term* term = hol_term::new_exists(head_variable,
			hol_term::new_apply(hol_term::new_constant(value), hol_term::new_variable(head_variable)));
	if (term == nullptr)
		return false;

	array<hol_term*> intersection(2);
	intersect<built_in_predicates>(intersection, term, src);
	free(*term); if (term->reference_count == 0) free(term);
	if (intersection.length == 0) {
		return false;
	} else if (intersection.length != 1) {
		fprintf(stderr, "set_predicate_only ERROR: Expected intersection size to be 1.\n");
		for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
		return false;
	}
	dst = intersection[0];
	return true;
}

bool set_head_predicate(hol_term* src, hol_term*& dst, unsigned int value)
{
	head_index predicate_index; no_op apply;
	auto find_array_head = make_array_finder(find_head<built_in_predicates>);
	hol_term* head = find_head(src, predicate_index, find_array_head, apply);
	if (head == nullptr)
		return false;

	hol_term* parent = head;
	if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr) {
		head = head->any.included;
		parent = head;
	} else if (head->type == hol_term_type::ANY_ARRAY) {
		if (head->any_array.right.length != 0)
			head = head->any_array.right.operands[head->any_array.right.length - 1];
		else head = head->any_array.all;
	} else if (head->type == hol_term_type::AND || head->type == hol_term_type::OR) {
		head = head->array.operands[head->array.length - 1];
	}

	if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
		head = head->any.included;
	unsigned int negation_count = 0;
	while (head->type == hol_term_type::NOT) {
		head = head->unary.operand;
		negation_count++;
	}

	unsigned int head_variable;
	if (head->type == hol_term_type::EXISTS) {
		head_variable = head->quantifier.variable;
	} else {
		unsigned int max_variable = 0;
		max_bound_variable(*head, max_variable);
		head_variable = ++max_variable;
	}

	hol_term* expected_head;
	if (value != (unsigned int) built_in_predicates::ZERO) {
		hol_term* head_var = hol_term::new_variable(head_variable);
		if (head_var == nullptr) return false;
		constexpr unsigned int excluded_tree_count = 2;
		hol_term** excluded_trees = (hol_term**) alloca(sizeof(hol_term) * (excluded_tree_count));
		excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
					(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
					(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
				&HOL_ANY), head_var));
		excluded_trees[1] = hol_term::new_any(hol_term::new_exists(head_variable, &HOL_ANY));
		if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
		if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
		if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr) {
			if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
			free(*head_var); free(head_var);
			return false;
		}

		hol_term* expected_predicate = hol_term::new_apply(hol_term::new_constant(value), head_var);
		if (expected_predicate == nullptr) {
			for (unsigned int i = 0; i < excluded_tree_count; i++) {
				free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
			}
			free(*head_var); free(head_var);
			return false;
		}

		expected_head = hol_term::new_exists(head_variable, hol_term::new_any_array(hol_term_type::AND,
				hol_term::new_any(nullptr, excluded_trees, excluded_tree_count), make_array_view(&expected_predicate, 1),
				make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0)));
		if (expected_head == nullptr) {
			free(*expected_predicate); free(expected_predicate);
			for (unsigned int i = 0; i < excluded_tree_count; i++) {
				free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
			}
			return false;
		}
	} else {
		hol_term* head_var = hol_term::new_variable(head_variable);
		if (head_var == nullptr) return false;
		constexpr unsigned int excluded_tree_count = 3;
		hol_term** excluded_trees = (hol_term**) alloca(sizeof(hol_term) * (excluded_tree_count));
		excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
					(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
					(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
				&HOL_ANY), head_var));
		excluded_trees[1] = hol_term::new_any(hol_term::new_exists(head_variable, &HOL_ANY));
		excluded_trees[2] = hol_term::new_apply(
				hol_term::new_any_constant_except(make_array_view(hol_non_head_constants<built_in_predicates>::CONSTANTS, array_length(hol_non_head_constants<built_in_predicates>::CONSTANTS))), head_var);
		if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
		if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
		if (excluded_trees[2] != nullptr) { head_var->reference_count++; }
		if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr || excluded_trees[2] == nullptr) {
			if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
			if (excluded_trees[1] != nullptr) { free(*excluded_trees[1]); free(excluded_trees[1]); }
			free(*head_var); free(head_var);
			return false;
		}
		free(*head_var);

		expected_head = hol_term::new_exists(head_variable, hol_term::new_any_array(hol_term_type::AND,
				hol_term::new_any(nullptr, excluded_trees, excluded_tree_count), make_array_view((hol_term**) nullptr, 0),
				make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0)));
		if (expected_head == nullptr) {
			for (unsigned int i = 0; i < excluded_tree_count; i++) {
				free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
			}
			return false;
		}
	}

	array<hol_term*> intersection(2);
	intersect<built_in_predicates>(intersection, expected_head, head);
	free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
	if (intersection.length == 0) {
		return false;
	} else if (intersection.length != 1) {
		fprintf(stderr, "set_head_predicate ERROR: Expected intersection size to be 1.\n");
		free_all(intersection);
		return false;
	}

	hol_term* new_head = intersection[0];
	for (unsigned int i = 0; i < negation_count; i++) {
		hol_term* temp = hol_term::new_not(new_head);
		if (temp == nullptr) {
			free(*new_head); if (new_head->reference_count == 0) free(new_head);
			return false;
		}
		new_head = temp;
	}

	hol_term* new_parent;
	if (parent->type == hol_term_type::ANY_ARRAY) {
		new_parent = hol_term::new_any_array(parent->any_array.oper, parent->any_array.all,
				make_array_view(parent->any_array.any.operands, parent->any_array.any.length),
				make_array_view(parent->any_array.left.operands, parent->any_array.left.length),
				make_appended_array_view(make_array_view(parent->any_array.right.operands, max(1, parent->any_array.right.length) - 1), new_head));
		if (new_parent == nullptr) {
			free(*new_head); if (new_head->reference_count == 0) free(new_head);
			return false;
		}
		parent->any_array.all->reference_count++;
		for (unsigned int i = 0; i < parent->any_array.any.length; i++)
			parent->any_array.any.operands[i]->reference_count++;
		for (unsigned int i = 0; i < parent->any_array.left.length; i++)
			parent->any_array.left.operands[i]->reference_count++;
		for (unsigned int i = 0; i + 1 < parent->any_array.right.length; i++)
			parent->any_array.right.operands[i]->reference_count++;
	} else if (parent->type == hol_term_type::AND || parent->type == hol_term_type::OR) {
		if (parent->type == hol_term_type::AND)
			new_parent = hol_term::new_and(make_appended_array_view(make_array_view(parent->array.operands, max(1, parent->array.length) - 1), new_head));
		else new_parent = hol_term::new_or(make_appended_array_view(make_array_view(parent->array.operands, max(1, parent->array.length) - 1), new_head));
		if (new_parent == nullptr) {
			free(*new_head); if (new_head->reference_count == 0) free(new_head);
			return false;
		}
		for (unsigned int i = 0; i + 1 < parent->array.length; i++)
			parent->array.operands[i]->reference_count++;
	} else {
		new_parent = new_head;
	}

	dst = substitute_head<any_node_position::NONE>(src, parent, new_parent);
	free(*new_parent); if (new_parent->reference_count == 0) free(new_parent);
	return (dst != nullptr);
}

bool set_set_definition(hol_term* src, hol_term*& dst, unsigned int value)
{
	unsigned int max_variable = 0;
	max_bound_variable(*src, max_variable);

	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else if (src->type == hol_term_type::ANY) {
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	array<hol_term*> siblings(8);
	array<unsigned int> dst_variables(8);
	bool removed_quantifier, remove_wide_scope_marker = false, remove_negations = false;
	bool result = apply_head<true>(src, dst, dst_variables, siblings, 0, removed_quantifier, remove_negations, remove_wide_scope_marker,
			predicative_head_finder<built_in_predicates>(lambda_variable),
			[&max_variable, value](hol_term* head, unsigned int head_variable, head_index predicate_index, bool is_array, bool& remove_wide_scope_marker, array<hol_term*>& siblings)
			{
				if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
					head = head->any.included;

				unsigned int set_variable;
				if (head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) {
					set_variable = ++max_variable;
				} else {
#if !defined(NDEBUG)
					if (head->type != hol_term_type::EXISTS) {
						fprintf(stderr, "set_set_definition ERROR: Expected existential quantification of set.\n");
						return (hol_term*) nullptr;
					}
#endif
					set_variable = head->quantifier.variable;
				}

				hol_term* expected_left;
				if (value == (unsigned int) built_in_predicates::EQUALS) {
					expected_left = hol_term::new_equals(hol_term::new_variable(set_variable), &HOL_ANY);
				} else {
					expected_left = hol_term::new_apply(hol_term::new_constant(value), hol_term::new_variable(set_variable), &HOL_ANY);
				}
				if (expected_left == nullptr)
					return (hol_term*) nullptr;
				HOL_ANY.reference_count++;

				hol_term* expected_head = hol_term::new_exists(set_variable, hol_term::new_any_array(hol_term_type::AND, &HOL_ANY,
						make_array_view((hol_term**) nullptr, 0), make_array_view(&expected_left, 1), make_array_view((hol_term**) nullptr, 0)));
				if (expected_head == nullptr) {
					free(*expected_left); free(expected_left);
					return (hol_term*) nullptr;
				}
				HOL_ANY.reference_count++;

				array<hol_term*> intersection(2);
				intersect<built_in_predicates>(intersection, head, expected_head);
				free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
				if (intersection.length == 0) {
					return (hol_term*) nullptr;
				} else if (intersection.length != 1) {
					fprintf(stderr, "set_set_definition ERROR: Intersection is not unique.\n");
					free_all(intersection);
					return (hol_term*) nullptr;
				}
				return intersection[0];
			}, no_op());

	if (!result) return false;
	else return dst;
}

inline bool set_set_predicate(hol_term* src, hol_term*& dst, unsigned int predicate_value)
{
	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else {
		return false;
	}

	head_index predicate_index; no_op apply;
	auto head_finder = predicative_head_finder<built_in_predicates>(lambda_variable);
	hol_term* head = find_head(src, predicate_index, head_finder, apply);
	if (head == nullptr)
		return false;

	hol_term* old_head = head;
	if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
		head = head->any.included;

	if (head->type == hol_term_type::UNARY_APPLICATION) {
		if (predicate_value != (unsigned int) built_in_predicates::ZERO)
			return false;
		dst = src;
		src->reference_count++;
		return true;
	}

	if (head->type != hol_term_type::EXISTS) {
		fprintf(stderr, "set_set_predicate ERROR: Expected existential quantification of set.\n");
		return false;
	}

	hol_term* left;
	hol_term* operand = head->quantifier.operand;
	if (operand->type == hol_term_type::ANY || operand->type == hol_term_type::ANY_RIGHT) {
		fprintf(stderr, "set_set_predicate ERROR: Expected conjunction.\n");
		return false;
	} else if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
		if (operand->any_array.left.length == 0) {
			fprintf(stderr, "set_set_predicate ERROR: Expected left conjunct.\n");
			return false;
		} else {
			left = operand->any_array.left.operands[0];
		}
	} else if (operand->type == hol_term_type::AND) {
		left = operand->array.operands[0];
	} else {
		return false;
	}

	hol_term* set_definition;
	if (left->type == hol_term_type::ANY_RIGHT && left->any.included != nullptr && left->any.included->type == hol_term_type::LAMBDA) {
		set_definition = left->any.included;
	} else if (left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT) {
		fprintf(stderr, "set_set_predicate ERROR: Expected set definition.\n");
		return false;
	} else if (left->type == hol_term_type::EQUALS) {
		set_definition = left->binary.right;
	} else if (left->type == hol_term_type::BINARY_APPLICATION) {
		set_definition = left->ternary.third;
	} else {
		return false;
	}

	hol_term* inner_operand;
	unsigned int element_variable;
	if (set_definition->type == hol_term_type::ANY || set_definition->type == hol_term_type::ANY_RIGHT) {
		fprintf(stderr, "set_set_predicate ERROR: Expected set definition.\n");
		return false;
	} else if (set_definition->type == hol_term_type::LAMBDA) {
		element_variable = set_definition->quantifier.variable;
		inner_operand = set_definition->quantifier.operand;
	} else {
		return false;
	}

	hol_term* element_var = hol_term::new_variable(element_variable);
	if (element_var == nullptr)
		return false;

	hol_term* expected_inner_operand;
	if (predicate_value == (unsigned int) built_in_predicates::ZERO) {
		constexpr unsigned int excluded_tree_count = 3;
		hol_term* excluded_trees[excluded_tree_count];
		excluded_trees[0] = hol_term::new_apply(
				hol_term::new_any_constant_except(make_array_view(hol_non_head_constants<built_in_predicates>::CONSTANTS, array_length(hol_non_head_constants<built_in_predicates>::CONSTANTS))),
				element_var);
		excluded_trees[1] = hol_term::new_equals(element_var, hol_term::new_any_constant_except());
		excluded_trees[2] = hol_term::new_any_quantifier(hol_quantifier_type::EXISTS, hol_term::new_and(
				hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::NAME>::value, &HOL_ANY),
				hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG1_OF>::value, element_var), &HOL_ANY),
				hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value, &HOL_ANY), &HOL_ANY)
			));
		if (excluded_trees[0] != nullptr) element_var->reference_count++;
		if (excluded_trees[1] != nullptr) element_var->reference_count++;
		if (excluded_trees[2] != nullptr) {
			hol_term::constants<(unsigned int) built_in_predicates::NAME>::value.reference_count++;
			hol_term::constants<(unsigned int) built_in_predicates::ARG1_OF>::value.reference_count++;
			hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value.reference_count++;
			element_var->reference_count++;
			HOL_ANY.reference_count += 4;
		}
		if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr || excluded_trees[2] == nullptr) {
			if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
			if (excluded_trees[1] != nullptr) { free(*excluded_trees[1]); free(excluded_trees[1]); }
			free(*element_var); free(element_var);
			return false;
		}
		free(*element_var);

		expected_inner_operand = hol_term::new_any_array(hol_term_type::AND, hol_term::new_any(nullptr, excluded_trees, excluded_tree_count),
				make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0));
		if (expected_inner_operand == nullptr) {
			for (unsigned int i = 0; i < excluded_tree_count; i++) {
				free(*excluded_trees[i]); free(excluded_trees[i]);
			}
			return false;
		}
	} else if (predicate_value == (unsigned int) built_in_predicates::NAMED_ENTITY) {
		hol_term* predicate = hol_term::new_any_quantifier(hol_quantifier_type::EXISTS, hol_term::new_and(
				hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::NAME>::value, &HOL_ANY),
				hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG1_OF>::value, element_var), &HOL_ANY),
				hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value, &HOL_ANY), &HOL_ANY)
			));
		if (predicate == nullptr) {
			free(*element_var); free(element_var);
			return false;
		}
		hol_term::constants<(unsigned int) built_in_predicates::NAME>::value.reference_count++;
		hol_term::constants<(unsigned int) built_in_predicates::ARG1_OF>::value.reference_count++;
		hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value.reference_count++;
		HOL_ANY.reference_count += 4;

		expected_inner_operand = hol_term::new_any_array(hol_term_type::AND, &HOL_ANY,
				make_array_view(&predicate, 1), make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0));
		if (expected_inner_operand == nullptr) {
			free(*predicate); free(predicate);
			return false;
		}
		HOL_ANY.reference_count++;
	} else {
		hol_term* expected_predicate = nullptr;
		head_index inner_predicate_index;
		hol_term* predicate = find_predicate<built_in_predicates>(set_definition->quantifier.variable, inner_operand, inner_predicate_index);
		if (inner_predicate_index.position != head_position::NONE) {
			if (predicate == nullptr) {
				if (inner_operand->type == hol_term_type::AND) {
					predicate = inner_operand->array.operands[inner_predicate_index.index];
				} else if (inner_operand->type == hol_term_type::ANY_ARRAY) {
					if (inner_predicate_index.position == head_position::LEFT)
						predicate = inner_operand->any_array.left.operands[inner_predicate_index.index];
					else if (inner_predicate_index.position == head_position::RIGHT)
						predicate = inner_operand->any_array.right.operands[inner_operand->any_array.right.length - inner_predicate_index.index - 1];
					else predicate = inner_operand->any_array.any.operands[inner_predicate_index.index];
				} else {
					predicate = inner_operand;
				}
			}

			if (predicate->type == hol_term_type::UNARY_APPLICATION
			 && (predicate->binary.left->type == hol_term_type::ANY_CONSTANT_EXCEPT
			  || predicate->binary.left->type == hol_term_type::ANY_CONSTANT
			  || predicate->binary.left->type == hol_term_type::CONSTANT))
			{
				expected_predicate = hol_term::new_apply(hol_term::new_constant(predicate_value), element_var);
				if (expected_predicate == nullptr) {
					free(*element_var); free(element_var);
					return false;
				}
			} else if (predicate->type == hol_term_type::ANY
					|| predicate->type == hol_term_type::ANY_RIGHT
					|| predicate->binary.left->type == hol_term_type::ANY
					|| predicate->binary.left->type == hol_term_type::ANY_RIGHT)
			{
				fprintf(stderr, "set_set_predicate ERROR: The set definition is ambiguous. It may or may not contain a predicate.\n");
				return false;
			}
		}

		if (expected_predicate == nullptr) {
			/* the set definition must contain a variable definition rather than a predicate */
			expected_predicate = hol_term::new_equals(element_var, hol_term::new_constant(predicate_value));
			if (expected_predicate == nullptr) {
				free(*element_var); free(element_var);
				return false;
			}
		}

		expected_inner_operand = hol_term::new_any_array(hol_term_type::AND, &HOL_ANY,
				make_array_view(&expected_predicate, 1), make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0));
		if (expected_inner_operand == nullptr) {
			free(*predicate); free(predicate);
			return false;
		}
		HOL_ANY.reference_count++;
	}

	array<hol_term*> intersection(2);
	intersect<built_in_predicates>(intersection, inner_operand, expected_inner_operand);
	free(*expected_inner_operand); if (expected_inner_operand->reference_count == 0) free(expected_inner_operand);
	if (intersection.length == 0) {
		return false;
	} else if (intersection.length != 1) {
		fprintf(stderr, "set_set_predicate ERROR: Intersection is not unique.\n");
		free_all(intersection); return false;
	}

	/* reconstruct `dst` using `new_inner_operand` */
	hol_term* new_inner_operand = intersection[0];
	hol_term* new_set_definition = hol_term::new_lambda(set_definition->quantifier.variable, new_inner_operand);
	if (new_set_definition == nullptr) {
		free(*new_inner_operand); if (new_inner_operand->reference_count == 0) free(new_inner_operand);
		return false;
	}

	hol_term* new_left;
	if (left->type == hol_term_type::ANY_RIGHT && left->any.included != nullptr && left->any.included->type == hol_term_type::LAMBDA) {
		new_left = hol_term::new_any_right(new_set_definition, left->any.excluded_trees, left->any.excluded_tree_count);
		if (new_left == nullptr) {
			free(*new_set_definition); if (new_set_definition->reference_count == 0) free(new_set_definition);
			return false;
		}
		for (unsigned int i = 0; i < left->any.excluded_tree_count; i++)
			left->any.excluded_trees[i]->reference_count++;
	} else if (left->type == hol_term_type::EQUALS) {
		new_left = hol_term::new_equals(left->binary.left, new_set_definition);
		if (new_left == nullptr) {
			free(*new_set_definition); if (new_set_definition->reference_count == 0) free(new_set_definition);
			return false;
		}
		left->binary.left->reference_count++;	
	} else {
		new_left = hol_term::new_apply(left->ternary.first, left->ternary.second, new_set_definition);
		if (new_left == nullptr) {
			free(*new_set_definition); if (new_set_definition->reference_count == 0) free(new_set_definition);
			return false;
		}
		left->ternary.first->reference_count++;
		left->ternary.second->reference_count++;
	}

	hol_term* new_operand;
	if (operand->type == hol_term_type::ANY_ARRAY) {
		new_operand = hol_term::new_any_array(operand->any_array.oper, operand->any_array.all,
				make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
				make_prepended_array_view(new_left, make_array_view(operand->any_array.left.operands + 1, max(1u, operand->any_array.left.length) - 1)),
				make_array_view(operand->any_array.right.operands, operand->any_array.right.length));
		if (new_operand == nullptr) {
			free(*new_left); if (new_left->reference_count == 0) free(new_left);
			return false;
		}
		new_operand->any_array.all->reference_count++;
		for (unsigned int i = 0; i < new_operand->any_array.any.length; i++)
			new_operand->any_array.any.operands[i]->reference_count++;
		for (unsigned int i = 1; i < new_operand->any_array.left.length; i++)
			new_operand->any_array.left.operands[i]->reference_count++;
		for (unsigned int i = 0; i < new_operand->any_array.right.length; i++)
			new_operand->any_array.right.operands[i]->reference_count++;
	} else if (operand->type == hol_term_type::AND) {
		new_operand = hol_term::new_and(make_prepended_array_view(new_left, make_array_view(operand->array.operands + 1, operand->array.length - 1)));
		if (new_operand == nullptr) {
			free(*new_left); if (new_left->reference_count == 0) free(new_left);
			return false;
		}
		for (unsigned int i = 1; i < new_operand->array.length; i++)
			new_operand->array.operands[i]->reference_count++;
	} else {
		new_operand = new_left;
	}

	hol_term* new_head = hol_term::new_exists(head->quantifier.variable, new_operand);
	if (new_head == nullptr) {
		free(*new_operand); if (new_operand->reference_count == 0) free(new_operand);
		return false;
	}
	if (old_head->type == hol_term_type::ANY || old_head->type == hol_term_type::ANY_RIGHT) {
		hol_term* temp = hol_term::new_any_right(new_head, old_head->any.excluded_trees, old_head->any.excluded_tree_count);
		if (temp == nullptr) {
			free(*new_head); if (new_head->reference_count == 0) free(new_head);
			return false;
		}
		for (unsigned int i = 0; i < temp->any.excluded_tree_count; i++)
			temp->any.excluded_trees[i]->reference_count++;
		new_head = temp;
	}

	dst = substitute_head<any_node_position::NONE>(src, old_head, new_head);
	free(*new_head); if (new_head->reference_count == 0) free(new_head);
	return (dst != nullptr);
}

template<int_fast8_t ConjunctIndex>
bool set_arg(hol_term* src, hol_term*& dst, unsigned int value)
{
	head_index predicate_index; no_op apply;
	hol_term* head = find_head(src, predicate_index, find_head<built_in_predicates>, apply);
	if (head == nullptr)
		return false;

	unsigned int head_variable;
	if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
		head = head->any.included;
	while (head->type == hol_term_type::NOT)
		head = head->unary.operand;
	if (head->type == hol_term_type::EXISTS) {
		head_variable = head->quantifier.variable;
	} else {
		unsigned int max_variable = 0;
		max_bound_variable(*src, max_variable);
		head_variable = ++max_variable;
	}

	hol_term* excluded_quantifiers[3];
	excluded_quantifiers[0] = hol_term::new_any(hol_term::new_exists(head_variable, &HOL_ANY));
	excluded_quantifiers[1] = hol_term::new_any(hol_term::new_for_all(head_variable, &HOL_ANY));
	excluded_quantifiers[2] = hol_term::new_any(hol_term::new_lambda(head_variable, &HOL_ANY));
	if (excluded_quantifiers[0] != nullptr) HOL_ANY.reference_count++;
	if (excluded_quantifiers[1] != nullptr) HOL_ANY.reference_count++;
	if (excluded_quantifiers[2] != nullptr) HOL_ANY.reference_count++;
	if (excluded_quantifiers[0] == nullptr || excluded_quantifiers[1] == nullptr || excluded_quantifiers[2] == nullptr) {
		if (excluded_quantifiers[0] != nullptr) { free(*excluded_quantifiers[0]); free(excluded_quantifiers[0]); }
		if (excluded_quantifiers[1] != nullptr) { free(*excluded_quantifiers[1]); free(excluded_quantifiers[1]); }
		return (hol_term*) nullptr;
	}

	hol_term* excluded_tree = hol_term::new_any(nullptr, excluded_quantifiers, array_length(excluded_quantifiers));
	if (excluded_tree == nullptr) {
		for (unsigned int i = 0; i < array_length(excluded_quantifiers); i++) { free(*excluded_quantifiers[i]); free(excluded_quantifiers[i]); }
		return (hol_term*) nullptr;
	}

	hol_term* expected_conjunct;
	if (value == (unsigned int) built_in_predicates::UNKNOWN) {
		expected_conjunct = hol_term::new_any_right(hol_term::new_equals(
				hol_term::new_apply(hol_term::new_any_constant(
					(unsigned int) built_in_predicates::ARG1,
					(unsigned int) built_in_predicates::ARG2,
					(unsigned int) built_in_predicates::ARG3),
				hol_term::new_variable(head_variable)), excluded_tree));
	} else {
		expected_conjunct = hol_term::new_any_right(hol_term::new_equals(
				hol_term::new_apply(hol_term::new_constant(value),
				hol_term::new_variable(head_variable)), excluded_tree));
	}
	if (expected_conjunct == nullptr) {
		free(*excluded_tree); free(excluded_tree);
		return false;
	}
	excluded_tree->reference_count++;

	hol_term* expected_head;
	if (ConjunctIndex >= 0) {
		expected_head = hol_term::new_exists(head_variable, hol_term::new_any_array(
				hol_term_type::AND, excluded_tree, make_array_view((hol_term**) nullptr, 0),
				make_appended_array_view(make_repeated_array_view(excluded_tree, ConjunctIndex), expected_conjunct),
				make_array_view((hol_term**) nullptr, 0)));
		if (expected_head == nullptr) {
			free(*expected_conjunct); free(expected_conjunct);
			free(*excluded_tree); free(excluded_tree);
			return false;
		}
		excluded_tree->reference_count += ConjunctIndex;
	} else {
		unsigned int index = (unsigned int) (-ConjunctIndex) - 1;
		expected_head = hol_term::new_exists(head_variable, hol_term::new_any_array(
				hol_term_type::AND, excluded_tree, make_array_view((hol_term**) nullptr, 0),
				make_array_view((hol_term**) nullptr, 0),
				make_prepended_array_view(expected_conjunct, make_repeated_array_view(excluded_tree, index))));
		if (expected_head == nullptr) {
			free(*expected_conjunct); free(expected_conjunct);
			free(*excluded_tree); free(excluded_tree);
			return false;
		}
		excluded_tree->reference_count += index;
	}

	array<hol_term*> result(2);
	if (value == (unsigned int) built_in_predicates::UNKNOWN)
		subtract<built_in_predicates>(result, head, expected_head);
	else intersect<built_in_predicates>(result, head, expected_head);
	free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
	if (result.length == 0) {
		return false;
	} else if (result.length != 1) {
		fprintf(stderr, "set_arg ERROR: Set operation result is not unique.\n");
		free_all(result); return false;
	}

	dst = substitute_head<any_node_position::NONE>(src, head, result[0]);
	free_all(result);
	return (dst != nullptr);
}

template<grammatical_flag Flag, typename Formula>
bool set_flag(flagged_logical_form<Formula>& exp, grammatical_flag_value value)
{
	return intersect(exp.flags.flags[(unsigned int) Flag], exp.flags.flags[(unsigned int) Flag], value);
}

bool require_lambda(hol_term* src, hol_term*& dst)
{
	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		dst = src;
		dst->reference_count++;
		return true;
	} else if (src->type == hol_term_type::ANY || src->type == hol_term_type::ANY_RIGHT) {
		unsigned int max_variable = 0;
		max_bound_variable(*src, max_variable);
		lambda_variable = ++max_variable;
	} else {
		return false;
	}

	hol_term* expected = hol_term::new_lambda(lambda_variable, &HOL_ANY);
	if (expected == nullptr)
		return false;
	HOL_ANY.reference_count++;

	array<hol_term*> intersection(2);
	intersect<built_in_predicates>(intersection, src, expected);
	free(*expected); if (expected->reference_count == 0) free(expected);
	if (intersection.length == 0) {
		return false;
	} else if (intersection.length != 1) {
		fprintf(stderr, "require_lambda ERROR: Intersection is not unique.\n");
		return false;
	}

	dst = intersection[0];
	return true;
}

bool require_no_lambda(hol_term* src, hol_term*& dst)
{
	hol_term* excluded_lambda = hol_term::new_any_quantifier(hol_quantifier_type::LAMBDA, &HOL_ANY);
	if (excluded_lambda == nullptr)
		return false;
	HOL_ANY.reference_count++;

	hol_term* expected = hol_term::new_any(nullptr, &excluded_lambda, 1);
	if (expected == nullptr) {
		free(*excluded_lambda); free(excluded_lambda);
		return false;
	}

	array<hol_term*> intersection(2);
	intersect<built_in_predicates>(intersection, src, expected);
	free(*expected); if (expected->reference_count == 0) free(expected);
	if (intersection.length == 0) {
		return false;
	} else if (intersection.length != 1) {
		fprintf(stderr, "require_no_lambda ERROR: Intersection is not unique.\n");
		return false;
	}

	dst = intersection[0];
	return true;
}

bool set_tense(hol_term* src, hol_term*& dst, unsigned int value)
{
	unsigned int predicates[1];
	predicates[0] = value;
	return apply_tense_predicate(src, dst, predicates, predicates);
}

template<typename Formula>
bool set_feature(
		typename flagged_logical_form<Formula>::feature feature,
		flagged_logical_form<Formula>& exp, unsigned int value)
{
	typedef typename flagged_logical_form<Formula>::feature feature_type;
	hol_term* new_logical_form;
	switch (feature) {
	case feature_type::CONSTANT:
		if (!set_constant(exp.root, new_logical_form, value))
			return false;
		free(*exp.root); if (exp.root->reference_count == 0) free(exp.root);
		exp.root = new_logical_form;
		return true;
	case feature_type::PREDICATE:
		if (!set_predicate(exp.root, new_logical_form, value))
			return false;
		free(*exp.root); if (exp.root->reference_count == 0) free(exp.root);
		exp.root = new_logical_form;
		return true;
	case feature_type::PREDICATE_ONLY:
	case feature_type::UNAMBIGUOUS_PREDICATE_ONLY:
		if (!set_predicate_only(exp.root, new_logical_form, value))
			return false;
		free(*exp.root); if (exp.root->reference_count == 0) free(exp.root);
		exp.root = new_logical_form;
		return true;
	case feature_type::HEAD_PREDICATE:
		if (!set_head_predicate(exp.root, new_logical_form, value))
			return false;
		free(*exp.root); if (exp.root->reference_count == 0) free(exp.root);
		exp.root = new_logical_form;
		return true;
	case feature_type::SET_DEFINITION:
		if (!set_set_definition(exp.root, new_logical_form, value))
			return false;
		free(*exp.root); if (exp.root->reference_count == 0) free(exp.root);
		exp.root = new_logical_form;
		return true;
	case feature_type::SET_PREDICATE:
		if (!set_set_predicate(exp.root, new_logical_form, value))
			return false;
		free(*exp.root); if (exp.root->reference_count == 0) free(exp.root);
		exp.root = new_logical_form;
		return true;
	case feature_type::LEFT_ARG:
		if (!set_arg<0>(exp.root, new_logical_form, value))
			return false;
		free(*exp.root); if (exp.root->reference_count == 0) free(exp.root);
		exp.root = new_logical_form;
		return true;
	case feature_type::HAS_ARG2:
		return set_flag<grammatical_flag::HAS_ARG2>(exp, (grammatical_flag_value) value);
	case feature_type::MODIFIES_EVENT:
		return set_flag<grammatical_flag::MODIFIES_EVENT>(exp, (grammatical_flag_value) value);
	case feature_type::MEASURE:
		return set_flag<grammatical_flag::MEASURE>(exp, (grammatical_flag_value) value);
	case feature_type::EMPTY: break;
	}
	fprintf(stderr, "set_feature ERROR: Unrecognized semantic feature.\n");
	exit(EXIT_FAILURE);
}

bool exclude_constants(hol_term* src, hol_term*& dst,
		const unsigned int* values, unsigned int count)
{
	hol_term* term = hol_term::new_any_constant_except(make_array_view(values, count));
	if (term == nullptr) return false;

	array<hol_term*> intersection(2);
	intersect<built_in_predicates>(intersection, term, src);
	free(*term); if (term->reference_count == 0) free(term);
	if (intersection.length == 0) {
		return false;
	} else if (intersection.length != 1) {
		fprintf(stderr, "exclude_constants ERROR: Expected intersection size to be 1.\n");
		for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
		return false;
	}
	dst = intersection[0];
	return true;
}

bool exclude_predicates(hol_term* src, hol_term*& dst,
		const unsigned int* values, unsigned int count)
{
	hol_term* term = hol_term::new_any_quantifier(hol_quantifier_type::EXISTS,
			hol_term::new_and(hol_term::new_apply(hol_term::new_any_constant_except(make_array_view(values, count)), &HOL_ANY), &HOL_ANY));
	if (term == nullptr) return false;
	HOL_ANY.reference_count += 2;

	array<hol_term*> intersection(2);
	intersect<built_in_predicates>(intersection, term, src);
	free(*term); if (term->reference_count == 0) free(term);
	if (intersection.length == 0) {
		return false;
	} else if (intersection.length != 1) {
		fprintf(stderr, "exclude_predicates ERROR: Expected intersection size to be 1.\n");
		for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
		return false;
	}
	dst = intersection[0];
	return true;
}

bool exclude_predicates_only(hol_term* src, hol_term*& dst,
		const unsigned int* values, unsigned int count)
{
	hol_term* head = src;
	if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
		head = head->any.included;

	unsigned int head_variable;
	if (head->type == hol_term_type::EXISTS) {
		head_variable = head->quantifier.variable;
	} else {
		unsigned int max_variable = 0;
		max_bound_variable(*head, max_variable);
		head_variable = ++max_variable;
	}

	hol_term* term = hol_term::new_exists(head_variable,
			hol_term::new_apply(hol_term::new_any_constant_except(make_array_view(values, count)), hol_term::new_variable(head_variable)));
	if (term == nullptr)
		return false;

	array<hol_term*> intersection(2);
	intersect<built_in_predicates>(intersection, term, src);
	free(*term); if (term->reference_count == 0) free(term);
	if (intersection.length == 0) {
		return false;
	} else if (intersection.length != 1) {
		fprintf(stderr, "exclude_predicates_only ERROR: Expected intersection size to be 1.\n");
		for (hol_term* term : intersection) { free(*term); if (term->reference_count == 0) free(term); }
		return false;
	}
	dst = intersection[0];
	return true;
}

bool exclude_head_predicates(hol_term* src, hol_term*& dst,
		const unsigned int* values, unsigned int count)
{
	head_index predicate_index; no_op apply;
	auto find_array_head = make_array_finder(find_head<built_in_predicates>);
	hol_term* head = find_head(src, predicate_index, find_array_head, apply);
	if (head == nullptr)
		return false;

	hol_term* parent = head;
	if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr) {
		head = head->any.included;
		parent = head;
	} else if (head->type == hol_term_type::ANY_ARRAY) {
		if (head->any_array.right.length != 0)
			head = head->any_array.right.operands[head->any_array.right.length - 1];
		else head = head->any_array.all;
	} else if (head->type == hol_term_type::AND || head->type == hol_term_type::OR) {
		head = head->array.operands[head->array.length - 1];
	}

	if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
		head = head->any.included;
	unsigned int negation_count = 0;
	while (head->type == hol_term_type::NOT) {
		head = head->unary.operand;
		negation_count++;
	}

	unsigned int head_variable;
	if (head->type == hol_term_type::EXISTS) {
		head_variable = head->quantifier.variable;
	} else {
		unsigned int max_variable = 0;
		max_bound_variable(*head, max_variable);
		head_variable = ++max_variable;
	}

	hol_term* expected_head;
	unsigned int zero_index = index_of((unsigned int) built_in_predicates::ZERO, values, count);
	if (zero_index < count) {
		hol_term* head_var = hol_term::new_variable(head_variable);
		if (head_var == nullptr) return false;
		constexpr unsigned int excluded_tree_count = 3;
		hol_term** excluded_trees = (hol_term**) alloca(sizeof(hol_term) * (excluded_tree_count));
		excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
					(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
					(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
				&HOL_ANY), head_var));
		excluded_trees[1] = hol_term::new_any(hol_term::new_exists(head_variable, &HOL_ANY));
		excluded_trees[2] = hol_term::new_apply(
				hol_term::new_any_constant(make_excluded_array_view(values, count, zero_index)), head_var);
		if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
		if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
		if (excluded_trees[2] != nullptr) { head_var->reference_count++; }
		if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr || excluded_trees[2] == nullptr) {
			if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
			if (excluded_trees[1] != nullptr) { free(*excluded_trees[1]); free(excluded_trees[1]); }
			free(*head_var); free(head_var);
			return false;
		}
		free(*head_var);

		hol_term* expected_predicate = hol_term::new_apply(
				hol_term::new_any_constant_except(make_excluded_array_view(values, count, zero_index)), head_var);
		if (expected_predicate == nullptr) {
			for (unsigned int i = 0; i < excluded_tree_count; i++) {
				free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
			}
			return false;
		}
		head_var->reference_count++;

		expected_head = hol_term::new_exists(head_variable, hol_term::new_any_array(hol_term_type::AND,
				hol_term::new_any(nullptr, excluded_trees, excluded_tree_count), make_array_view(&expected_predicate, 1),
				make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0)));
		if (expected_head == nullptr) {
			free(*expected_predicate); free(expected_predicate);
			for (unsigned int i = 0; i < excluded_tree_count; i++) {
				free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
			}
			return false;
		}
	} else {
		hol_term* head_var = hol_term::new_variable(head_variable);
		if (head_var == nullptr) return false;
		constexpr unsigned int excluded_tree_count = 3;
		hol_term** excluded_trees = (hol_term**) alloca(sizeof(hol_term) * (excluded_tree_count));
		excluded_trees[0] = hol_term::new_any(hol_term::new_equals(hol_term::new_apply(hol_term::new_any_constant(
					(unsigned int) built_in_predicates::ARG1, (unsigned int) built_in_predicates::ARG2, (unsigned int) built_in_predicates::ARG3,
					(unsigned int) built_in_predicates::ARG1_OF, (unsigned int) built_in_predicates::ARG2_OF, (unsigned int) built_in_predicates::ARG3_OF),
				&HOL_ANY), head_var));
		excluded_trees[1] = hol_term::new_any(hol_term::new_exists(head_variable, &HOL_ANY));
		excluded_trees[2] = hol_term::new_apply(hol_term::new_any_constant(make_array_view(values, count)), head_var);
		if (excluded_trees[0] != nullptr) { HOL_ANY.reference_count++; head_var->reference_count++; }
		if (excluded_trees[1] != nullptr) { HOL_ANY.reference_count++; }
		if (excluded_trees[2] != nullptr) { head_var->reference_count++; }
		if (excluded_trees[0] == nullptr || excluded_trees[1] == nullptr || excluded_trees[2] == nullptr) {
			if (excluded_trees[0] != nullptr) { free(*excluded_trees[0]); free(excluded_trees[0]); }
			if (excluded_trees[1] != nullptr) { free(*excluded_trees[1]); free(excluded_trees[1]); }
			free(*head_var); free(head_var);
			return false;
		}
		free(*head_var);

		expected_head = hol_term::new_exists(head_variable, hol_term::new_any_array(hol_term_type::AND,
				hol_term::new_any(nullptr, excluded_trees, excluded_tree_count), make_array_view((hol_term**) nullptr, 0),
				make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0)));
		if (expected_head == nullptr) {
			for (unsigned int i = 0; i < excluded_tree_count; i++) {
				free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
			}
			return false;
		}
	}

	array<hol_term*> intersection(2);
	intersect<built_in_predicates>(intersection, expected_head, head);
	free(*expected_head); if (expected_head->reference_count == 0) free(expected_head);
	if (intersection.length == 0) {
		return false;
	} else if (intersection.length != 1) {
		fprintf(stderr, "exclude_head_predicates ERROR: Expected intersection size to be 1.\n");
		free_all(intersection);
		return false;
	}

	hol_term* new_head = intersection[0];
	for (unsigned int i = 0; i < negation_count; i++) {
		hol_term* temp = hol_term::new_not(new_head);
		if (temp == nullptr) {
			free(*new_head); if (new_head->reference_count == 0) free(new_head);
			return false;
		}
		new_head = temp;
	}

	hol_term* new_parent;
	if (parent->type == hol_term_type::ANY_ARRAY) {
		new_parent = hol_term::new_any_array(parent->any_array.oper, parent->any_array.all,
				make_array_view(parent->any_array.any.operands, parent->any_array.any.length),
				make_array_view(parent->any_array.left.operands, parent->any_array.left.length),
				make_appended_array_view(make_array_view(parent->any_array.right.operands, max(1, parent->any_array.right.length) - 1), new_head));
		if (new_parent == nullptr) {
			free(*new_head); if (new_head->reference_count == 0) free(new_head);
			return false;
		}
		parent->any_array.all->reference_count++;
		for (unsigned int i = 0; i < parent->any_array.any.length; i++)
			parent->any_array.any.operands[i]->reference_count++;
		for (unsigned int i = 0; i < parent->any_array.left.length; i++)
			parent->any_array.left.operands[i]->reference_count++;
		for (unsigned int i = 0; i + 1 < parent->any_array.right.length; i++)
			parent->any_array.right.operands[i]->reference_count++;
	} else if (parent->type == hol_term_type::AND || parent->type == hol_term_type::OR) {
		if (parent->type == hol_term_type::AND)
			new_parent = hol_term::new_and(make_appended_array_view(make_array_view(parent->array.operands, max(1, parent->array.length) - 1), new_head));
		else new_parent = hol_term::new_or(make_appended_array_view(make_array_view(parent->array.operands, max(1, parent->array.length) - 1), new_head));
		if (new_parent == nullptr) {
			free(*new_head); if (new_head->reference_count == 0) free(new_head);
			return false;
		}
		for (unsigned int i = 0; i + 1 < parent->array.length; i++)
			parent->array.operands[i]->reference_count++;
	} else {
		new_parent = new_head;
	}

	dst = substitute_head<any_node_position::NONE>(src, parent, new_parent);
	free(*new_parent); if (new_parent->reference_count == 0) free(new_parent);
	return (dst != nullptr);
}

inline bool exclude_set_predicates(
		hol_term* src, hol_term*& dst,
		const unsigned int* values,
		unsigned int count)
{
	unsigned int lambda_variable = 0;
	if (src->type == hol_term_type::LAMBDA) {
		lambda_variable = src->quantifier.variable;
	} else {
		return false;
	}

	head_index predicate_index; no_op apply;
	auto head_finder = predicative_head_finder<built_in_predicates>(lambda_variable);
	hol_term* head = find_head(src, predicate_index, head_finder, apply);
	if (head == nullptr)
		return false;

	hol_term* old_head = head;
	if ((head->type == hol_term_type::ANY || head->type == hol_term_type::ANY_RIGHT) && head->any.included != nullptr)
		head = head->any.included;

	if (head->type == hol_term_type::UNARY_APPLICATION) {
		if (index_of((unsigned int) built_in_predicates::ZERO, values, count) < count)
			return false;
		dst = src;
		src->reference_count++;
		return true;
	}

	if (head->type != hol_term_type::EXISTS) {
		fprintf(stderr, "exclude_set_predicates ERROR: Expected existential quantification of set.\n");
		return false;
	}

	hol_term* left;
	hol_term* operand = head->quantifier.operand;
	if (operand->type == hol_term_type::ANY || operand->type == hol_term_type::ANY_RIGHT) {
		fprintf(stderr, "exclude_set_predicates ERROR: Expected conjunction.\n");
		return false;
	} else if (operand->type == hol_term_type::ANY_ARRAY && operand->any_array.oper == hol_term_type::AND) {
		if (operand->any_array.left.length == 0) {
			fprintf(stderr, "exclude_set_predicates ERROR: Expected left conjunct.\n");
			return false;
		} else {
			left = operand->any_array.left.operands[0];
		}
	} else if (operand->type == hol_term_type::AND) {
		left = operand->array.operands[0];
	} else {
		return false;
	}

	hol_term* set_definition;
	if (left->type == hol_term_type::ANY_RIGHT && left->any.included != nullptr && left->any.included->type == hol_term_type::LAMBDA) {
		set_definition = left->any.included;
	} else if (left->type == hol_term_type::ANY || left->type == hol_term_type::ANY_RIGHT) {
		fprintf(stderr, "exclude_set_predicates ERROR: Expected set definition.\n");
		return false;
	} else if (left->type == hol_term_type::EQUALS) {
		set_definition = left->binary.right;
	} else if (left->type == hol_term_type::BINARY_APPLICATION) {
		set_definition = left->ternary.third;
	} else {
		return false;
	}

	hol_term* inner_operand;
	unsigned int element_variable;
	if (set_definition->type == hol_term_type::ANY || set_definition->type == hol_term_type::ANY_RIGHT) {
		fprintf(stderr, "exclude_set_predicates ERROR: Expected set definition.\n");
		return false;
	} else if (set_definition->type == hol_term_type::LAMBDA) {
		element_variable = set_definition->quantifier.variable;
		inner_operand = set_definition->quantifier.operand;
	} else {
		return false;
	}

	hol_term* element_var = hol_term::new_variable(element_variable);
	if (element_var == nullptr)
		return false;

	array<unsigned int> non_scope_predicates(count);
	bool named_entity_excluded = false;
	for (unsigned int i = 0; i < count; i++) {
		if (values[i] == (unsigned int) built_in_predicates::ZERO) continue;
		if (values[i] == (unsigned int) built_in_predicates::NAMED_ENTITY) {
			named_entity_excluded = true;
			continue;
		}
		non_scope_predicates[non_scope_predicates.length++] = values[i];
	}

	unsigned int excluded_tree_count = 0;
	hol_term** excluded_trees = (hol_term**) alloca(sizeof(hol_term*) * 2);
	if (non_scope_predicates.length != 0) {
		if (non_scope_predicates.length == 1)
			excluded_trees[excluded_tree_count] = hol_term::new_apply(hol_term::new_constant(non_scope_predicates[0]), element_var);
		else excluded_trees[excluded_tree_count] = hol_term::new_apply(hol_term::new_any_constant(make_array_view(non_scope_predicates.data, non_scope_predicates.length)), element_var);
		if (excluded_trees[excluded_tree_count] == nullptr) {
			free(*element_var); free(element_var);
			return false;
		}
		element_var->reference_count++;
		excluded_tree_count++;
	} if (named_entity_excluded) {
		excluded_trees[excluded_tree_count] = hol_term::new_any_quantifier(hol_quantifier_type::EXISTS, hol_term::new_and(
				hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::NAME>::value, &HOL_ANY),
				hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG1_OF>::value, element_var), &HOL_ANY),
				hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value, &HOL_ANY), &HOL_ANY)
			));
		if (excluded_trees[excluded_tree_count] == nullptr) {
			for (unsigned int i = 0; i < excluded_tree_count; i++) { free(*excluded_trees[i]); free(excluded_trees[i]); }
			free(*element_var); free(element_var);
			return false;
		}
		hol_term::constants<(unsigned int) built_in_predicates::NAME>::value.reference_count++;
		hol_term::constants<(unsigned int) built_in_predicates::ARG1_OF>::value.reference_count++;
		hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value.reference_count++;
		element_var->reference_count++;
		HOL_ANY.reference_count += 4;
		excluded_tree_count++;
	}

	hol_term* expected_conjunct = hol_term::new_any(nullptr, excluded_trees, excluded_tree_count);
	if (expected_conjunct == nullptr) {
		for (unsigned int i = 0; i < excluded_tree_count; i++) { free(*excluded_trees[i]); free(excluded_trees[i]); }
		free(*element_var); free(element_var);
		return false;
	}

	array<hol_term*> new_inner_operands(2);
	if (index_of((unsigned int) built_in_predicates::ZERO, values, count) < count) {
		/* first consider the case where the predicate is not a scope (which is
		   always possible since there are an infinite number of possible non-
		   scope predicates) */
		unsigned int excluded_tree_count = hol_non_head_constants<built_in_predicates>::count();
		hol_term** excluded_trees = (hol_term**) alloca(sizeof(hol_term) * (excluded_tree_count + 1));
		if (non_scope_predicates.length != 0) {
			excluded_trees[excluded_tree_count] = hol_term::new_apply(hol_term::new_any_constant(make_array_view(non_scope_predicates.data, non_scope_predicates.length)), element_var);
			if (excluded_trees[excluded_tree_count] == nullptr) {
				free(*expected_conjunct); free(expected_conjunct);
				free(*element_var); free(element_var);
				return false;
			}
			element_var->reference_count++;
			excluded_tree_count++;
		}

		for (unsigned int i = 0; i < hol_non_head_constants<built_in_predicates>::count(); i++) {
			excluded_trees[i] = hol_non_head_constants<built_in_predicates>::get_terms()[i];
			excluded_trees[i]->reference_count++;
		}

		hol_term* expected_predicate = hol_term::new_apply(
					hol_term::new_any(nullptr, excluded_trees, excluded_tree_count), element_var);
		if (expected_predicate == nullptr) {
			for (unsigned int i = 0; i < excluded_tree_count; i++) {
				free(*excluded_trees[i]); if (excluded_trees[i]->reference_count == 0) free(excluded_trees[i]);
			}
			free(*expected_conjunct); free(expected_conjunct);
			free(*element_var); free(element_var);
			return false;
		}
		element_var->reference_count++;

		hol_term* expected_inner_operand = hol_term::new_any_array(hol_term_type::AND, expected_conjunct,
				make_array_view(&expected_predicate, 1), make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0));
		if (expected_inner_operand == nullptr) {
			free(*expected_predicate); free(expected_predicate);
			free(*expected_conjunct); free(expected_conjunct);
			free(*element_var); free(element_var);
			return false;
		}
		expected_conjunct->reference_count++;

		intersect<built_in_predicates>(new_inner_operands, inner_operand, expected_inner_operand);
		free(*expected_inner_operand); if (expected_inner_operand->reference_count == 0) free(expected_inner_operand);

		/* next consider the case where the predicate is a scope */
		if (!named_entity_excluded) {
			expected_predicate = hol_term::new_any_quantifier(hol_quantifier_type::EXISTS, hol_term::new_and(
					hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::NAME>::value, &HOL_ANY),
					hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG1_OF>::value, element_var), &HOL_ANY),
					hol_term::new_equals(hol_term::new_apply(&hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value, &HOL_ANY), &HOL_ANY)
				));
			if (expected_predicate == nullptr) {
				free_all(new_inner_operands);
				free(*expected_conjunct); if (expected_conjunct->reference_count == 0) free(expected_conjunct);
				free(*element_var); free(element_var);
				return false;
			}
			hol_term::constants<(unsigned int) built_in_predicates::NAME>::value.reference_count++;
			hol_term::constants<(unsigned int) built_in_predicates::ARG1_OF>::value.reference_count++;
			hol_term::constants<(unsigned int) built_in_predicates::ARG2>::value.reference_count++;
			HOL_ANY.reference_count += 4;
			element_var->reference_count++;

			expected_inner_operand = hol_term::new_any_array(hol_term_type::AND, expected_conjunct,
					make_array_view(&expected_predicate, 1), make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0));
			if (expected_inner_operand == nullptr) {
				free_all(new_inner_operands);
				free(*expected_predicate); free(expected_predicate);
				free(*expected_conjunct); if (expected_conjunct->reference_count == 0) free(expected_conjunct);
				free(*element_var); free(element_var);
				return false;
			}

			intersect<built_in_predicates>(new_inner_operands, inner_operand, expected_inner_operand);
			free(*expected_inner_operand); if (expected_inner_operand->reference_count == 0) free(expected_inner_operand);
		} else {
			free(*expected_conjunct); if (expected_conjunct->reference_count == 0) free(expected_conjunct);
		}
	} else {
		hol_term* expected_inner_operand = hol_term::new_any_array(hol_term_type::AND, expected_conjunct,
				make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0), make_array_view((hol_term**) nullptr, 0));
		if (expected_inner_operand == nullptr) {
			free(*expected_conjunct); free(expected_conjunct);
			free(*element_var); free(element_var);
			return false;
		}

		intersect<built_in_predicates>(new_inner_operands, inner_operand, expected_inner_operand);
		free(*expected_inner_operand); if (expected_inner_operand->reference_count == 0) free(expected_inner_operand);
	}
	free(*element_var); if (element_var->reference_count == 0) free(element_var);

	if (new_inner_operands.length == 0) {
		return false;
	} else if (new_inner_operands.length != 1) {
		fprintf(stderr, "exclude_set_predicates ERROR: Intersection is not unique.\n");
		free_all(new_inner_operands); return false;
	}

	/* reconstruct `dst` using `new_inner_operand` */
	hol_term* new_inner_operand = new_inner_operands[0];
	hol_term* new_set_definition = hol_term::new_lambda(set_definition->quantifier.variable, new_inner_operand);
	if (new_set_definition == nullptr) {
		free(*new_inner_operand); if (new_inner_operand->reference_count == 0) free(new_inner_operand);
		return false;
	}

	hol_term* new_left;
	if (left->type == hol_term_type::ANY_RIGHT && left->any.included != nullptr && left->any.included->type == hol_term_type::LAMBDA) {
		new_left = hol_term::new_any_right(new_set_definition, left->any.excluded_trees, left->any.excluded_tree_count);
		if (new_left == nullptr) {
			free(*new_set_definition); if (new_set_definition->reference_count == 0) free(new_set_definition);
			return false;
		}
		for (unsigned int i = 0; i < left->any.excluded_tree_count; i++)
			left->any.excluded_trees[i]->reference_count++;
	} else if (left->type == hol_term_type::EQUALS) {
		new_left = hol_term::new_equals(left->binary.left, new_set_definition);
		if (new_left == nullptr) {
			free(*new_set_definition); if (new_set_definition->reference_count == 0) free(new_set_definition);
			return false;
		}
		left->binary.left->reference_count++;	
	} else {
		new_left = hol_term::new_apply(left->ternary.first, left->ternary.second, new_set_definition);
		if (new_left == nullptr) {
			free(*new_set_definition); if (new_set_definition->reference_count == 0) free(new_set_definition);
			return false;
		}
		left->ternary.first->reference_count++;
		left->ternary.second->reference_count++;
	}

	hol_term* new_operand;
	if (operand->type == hol_term_type::ANY_ARRAY) {
		new_operand = hol_term::new_any_array(operand->any_array.oper, operand->any_array.all,
				make_array_view(operand->any_array.any.operands, operand->any_array.any.length),
				make_prepended_array_view(new_left, make_array_view(operand->any_array.left.operands + 1, max(1u, operand->any_array.left.length) - 1)),
				make_array_view(operand->any_array.right.operands, operand->any_array.right.length));
		if (new_operand == nullptr) {
			free(*new_left); if (new_left->reference_count == 0) free(new_left);
			return false;
		}
		new_operand->any_array.all->reference_count++;
		for (unsigned int i = 0; i < new_operand->any_array.any.length; i++)
			new_operand->any_array.any.operands[i]->reference_count++;
		for (unsigned int i = 1; i < new_operand->any_array.left.length; i++)
			new_operand->any_array.left.operands[i]->reference_count++;
		for (unsigned int i = 0; i < new_operand->any_array.right.length; i++)
			new_operand->any_array.right.operands[i]->reference_count++;
	} else if (operand->type == hol_term_type::AND) {
		new_operand = hol_term::new_and(make_prepended_array_view(new_left, make_array_view(operand->array.operands + 1, operand->array.length - 1)));
		if (new_operand == nullptr) {
			free(*new_left); if (new_left->reference_count == 0) free(new_left);
			return false;
		}
		for (unsigned int i = 1; i < new_operand->array.length; i++)
			new_operand->array.operands[i]->reference_count++;
	} else {
		new_operand = new_left;
	}

	hol_term* new_head = hol_term::new_exists(head->quantifier.variable, new_operand);
	if (new_head == nullptr) {
		free(*new_operand); if (new_operand->reference_count == 0) free(new_operand);
		return false;
	}
	if (old_head->type == hol_term_type::ANY || old_head->type == hol_term_type::ANY_RIGHT) {
		hol_term* temp = hol_term::new_any_right(new_head, old_head->any.excluded_trees, old_head->any.excluded_tree_count);
		if (temp == nullptr) {
			free(*new_head); if (new_head->reference_count == 0) free(new_head);
			return false;
		}
		for (unsigned int i = 0; i < temp->any.excluded_tree_count; i++)
			temp->any.excluded_trees[i]->reference_count++;
		new_head = temp;
	}

	dst = substitute_head<any_node_position::NONE>(src, old_head, new_head);
	free(*new_head); if (new_head->reference_count == 0) free(new_head);
	return (dst != nullptr);
}

template<typename Formula>
bool exclude_features(typename flagged_logical_form<Formula>::feature feature,
		flagged_logical_form<Formula>& exp, const unsigned int* values, unsigned int count)
{
	typedef typename flagged_logical_form<Formula>::feature feature_type;
	hol_term* new_logical_form;
	switch (feature) {
	case feature_type::CONSTANT:
		if (!exclude_constants(exp.root, new_logical_form, values, count))
			return false;
		free(*exp.root); if (exp.root->reference_count == 0) free(exp.root);
		exp.root = new_logical_form;
		return true;
	case feature_type::PREDICATE:
		if (!exclude_predicates(exp.root, new_logical_form, values, count))
			return false;
		free(*exp.root); if (exp.root->reference_count == 0) free(exp.root);
		exp.root = new_logical_form;
		return true;
	case feature_type::PREDICATE_ONLY:
		if (!exclude_predicates_only(exp.root, new_logical_form, values, count))
			return false;
		free(*exp.root); if (exp.root->reference_count == 0) free(exp.root);
		exp.root = new_logical_form;
		return true;
	case feature_type::HEAD_PREDICATE:
		if (!exclude_head_predicates(exp.root, new_logical_form, values, count))
			return false;
		free(*exp.root); if (exp.root->reference_count == 0) free(exp.root);
		exp.root = new_logical_form;
		return true;
	case feature_type::HAS_ARG2:
		if (count == 0) return true;
		else if (count == 2) return false;
		else if (values[0] == (unsigned int) grammatical_flag_value::TRUE)
			return set_flag<grammatical_flag::HAS_ARG2>(exp, grammatical_flag_value::FALSE);
		else return set_flag<grammatical_flag::HAS_ARG2>(exp, grammatical_flag_value::TRUE);
	case feature_type::MODIFIES_EVENT:
		if (count == 0) return true;
		else if (count == 2) return false;
		else if (values[0] == (unsigned int) grammatical_flag_value::TRUE)
			return set_flag<grammatical_flag::MODIFIES_EVENT>(exp, grammatical_flag_value::FALSE);
		else return set_flag<grammatical_flag::MODIFIES_EVENT>(exp, grammatical_flag_value::TRUE);
	case feature_type::MEASURE:
		if (count == 0) return true;
		else if (count == 2) return false;
		else if (values[0] == (unsigned int) grammatical_flag_value::TRUE)
			return set_flag<grammatical_flag::MEASURE>(exp, grammatical_flag_value::FALSE);
		else return set_flag<grammatical_flag::MEASURE>(exp, grammatical_flag_value::TRUE);
	case feature_type::SET_PREDICATE:
		if (!exclude_set_predicates(exp.root, new_logical_form, values, count))
			return false;
		free(*exp.root); if (exp.root->reference_count == 0) free(exp.root);
		exp.root = new_logical_form;
		return true;
	case feature_type::SET_DEFINITION:
	case feature_type::LEFT_ARG:
	case feature_type::UNAMBIGUOUS_PREDICATE_ONLY:
		return false;
	case feature_type::EMPTY: break;
	}
	fprintf(stderr, "exclude_features ERROR: Unrecognized semantic feature.\n");
	exit(EXIT_FAILURE);
}

template<typename Formula>
inline bool any_number(const flagged_logical_form<Formula>& src) {
	return any_number(*src.root);
}

template<typename Formula>
inline bool get_number(
			const flagged_logical_form<Formula>& src,
			int64_t& integer, uint64_t& decimal)
{
	return get_number(*src.root, integer, decimal);
}

template<typename Formula>
inline bool set_number(
		flagged_logical_form<Formula>& exp,
		const flagged_logical_form<Formula>& set,
		int64_t integer, uint64_t decimal)
{
	exp.root = (Formula*) malloc(sizeof(Formula));
	if (exp.root == nullptr) return false;
	exp.flags = set.flags;
	if (!set_number(*exp.root, *set.root, integer, decimal)) {
		free(exp.root);
		return false;
	}
	return true;
}

template<typename Formula>
inline bool any_string(const flagged_logical_form<Formula>& src) {
	return any_string(*src.root);
}

template<typename Formula>
inline bool get_string(const flagged_logical_form<Formula>& src, string& value) {
	return get_string(*src.root, value);
}

template<typename Formula>
inline bool set_string(flagged_logical_form<Formula>& exp,
		const flagged_logical_form<Formula>& set, const string& value)
{
	exp.root = (Formula*) malloc(sizeof(Formula));
	if (exp.root == nullptr) return false;
	exp.flags = set.flags;
	if (!set_string(*exp.root, *set.root, value)) {
		free(exp.root);
		return false;
	}
	return true;
}

bool parse_written_hundreds(const number_parser_en& parser,
		unsigned int* terminals, unsigned int& length,
		unsigned int& index, int& integer)
{
	integer = 0;
	for (unsigned int i = 0; i < array_length(parser.ones_name_ids); i++) {
		if (terminals[index] == parser.ones_name_ids[i]) {
			integer = parser.ONES_NAMES[i].key;
			break;
		}
	}
	if (integer != 0) {
		index++;
		if (index == length)
			return true;
	}

	bool is_teen = false;
	if (integer == 0) {
		for (unsigned int i = 0; i < array_length(parser.teens_name_ids); i++) {
			if (terminals[index] == parser.teens_name_ids[i]) {
				integer = parser.TEENS_NAMES[i].key;
				is_teen = true;
				break;
			}
		}
		if (integer != 0) {
			index++;
			if (index == length)
				return true;
		}
	}

	if (terminals[index] == parser.hundred_id) {
		if (integer == 0)
			integer = 100;
		else integer *= 100;
		index++;
		if (index == length)
			return true;
		is_teen = false;
	} else if (integer != 0) {
		/* there is only a ones/teens digit */
		return true;
	}

	int tens = 0;
	for (unsigned int i = 0; i < array_length(parser.tens_name_ids); i++) {
		if (terminals[index] == parser.tens_name_ids[i]) {
			tens = parser.TENS_NAMES[i].key;
			break;
		}
	}
	if (tens != 0) {
		integer += tens;
		index++;
		if (index == length)
			return true;

		/* the next token could be a hyphen */
		if (terminals[index] == parser.hyphen_id) {
			index++;
			if (index == length)
				return false; /* dangling hyphen */
		}
	}

	if (tens == 0) {
		int teens = 0;
		for (unsigned int i = 0; i < array_length(parser.teens_name_ids); i++) {
			if (terminals[index] == parser.teens_name_ids[i]) {
				teens = parser.TEENS_NAMES[i].key;
				is_teen = true;
				break;
			}
		}
		if (teens != 0) {
			integer += teens;
			index++;
			if (index == length)
				return true;
		}
	}

	if (!is_teen) {
		int ones = 0;
		for (unsigned int i = 0; i < array_length(parser.ones_name_ids); i++) {
			if (terminals[index] == parser.ones_name_ids[i]) {
				ones = parser.ONES_NAMES[i].key;
				break;
			}
		}
		if (ones != 0) {
			integer += ones;
			index++;
			if (index == length)
				return true;
		}
	}

	return integer != 0;
}

template<typename Formula>
bool parse_written_number(const hdp_parser<Formula>& parser,
		unsigned int* terminals, unsigned int length, int64_t& integer)
{
	if (length == 0) {
		return false;
	} else if (length == 1 && terminals[0] == parser.number_parser.zero_id) {
		integer = 0;
		return true;
	}

	unsigned int index = 0;
	unsigned int large_number_index = 0;
	integer = 0;
	while (true) {
		int leading_hundreds;
		parse_written_hundreds(parser.number_parser, terminals, length, index, leading_hundreds);
		if (index == length) {
			integer += leading_hundreds;
			return true;
		}

		/* find the next large number that matches */
		while (large_number_index < array_length(parser.number_parser.large_name_ids) && terminals[index] != parser.number_parser.large_name_ids[large_number_index])
			large_number_index++;

		if (large_number_index < array_length(parser.number_parser.large_name_ids)) {
			if (leading_hundreds != 0)
				integer += leading_hundreds * parser.number_parser.LARGE_NUMBER_NAMES[large_number_index].key;
			else integer += parser.number_parser.LARGE_NUMBER_NAMES[large_number_index].key;
		} else {
			/* no large number matches */
			return false;
		}
	}
}


/**
 * Code to perform morphological parsing and generation.
 */


template<typename PartOfSpeechType, typename Formula>
constexpr bool morphology_is_valid(const morphology_en& morph,
		const sequence& terminal, PartOfSpeechType pos,
		const flagged_logical_form<Formula>& logical_form)
{
	return true;
}

template<bool First, typename Formula, typename PartOfSpeechType, typename EmitRootFunction>
bool morphology_parse(
		const morphology_en& morphology_parser, const sequence& words, PartOfSpeechType pos,
		const flagged_logical_form<Formula>& logical_form, EmitRootFunction emit_root)
{
	if (First) {
		/* try to decapitalize the word */
		unsigned int decapitalized_word;
		if (morphology_parser.decapitalize(words[0], decapitalized_word)) {
			sequence decapitalized_words(NULL, 0); decapitalized_words = words;
			decapitalized_words[0] = decapitalized_word;
			bool result = morphology_parse<false>(morphology_parser, decapitalized_words, pos, logical_form, emit_root);
			free(decapitalized_words);
			if (!result) return false;
		}
	}

	if (pos == POS_VERB) {
		bool contains;
		const array<inflected_verb>& forms = morphology_parser.inflected_verbs.get(words, contains);
		if (!contains) return true;

		flagged_logical_form<Formula> marked_logical_form = logical_form;
		marked_logical_form.flags.is_first_token_capital = (First ? morphology_parser.is_capitalized(words[0]) : false);
		for (const inflected_verb& form : forms) {
			if (!has_intersection(grammatical_person::THIRD, form.person)
			 || !intersect(marked_logical_form.flags.mood, logical_form.flags.mood, form.mood)
			 || !intersect(marked_logical_form.flags.index_number, logical_form.flags.index_number, form.number))
				continue;

			hol_term* new_logical_form;
			switch (form.tense) {
			case grammatical_tense::PRESENT:
				if (!set_tense(marked_logical_form.root, new_logical_form, (unsigned int) built_in_predicates::PRESENT))
					continue;
				free(*marked_logical_form.root); if (marked_logical_form.root->reference_count == 0) free(marked_logical_form.root);
				marked_logical_form.root = new_logical_form;
				break;
			case grammatical_tense::PAST:
				if (!set_tense(marked_logical_form.root, new_logical_form, (unsigned int) built_in_predicates::PAST))
					continue;
				free(*marked_logical_form.root); if (marked_logical_form.root->reference_count == 0) free(marked_logical_form.root);
				marked_logical_form.root = new_logical_form;
				break;
			case grammatical_tense::ANY:
				break;
			}

			if (!emit_root(form.root, marked_logical_form))
				return false;
			free(*marked_logical_form.root); if (marked_logical_form.root->reference_count == 0) free(marked_logical_form.root);
			marked_logical_form.root = logical_form.root;
			logical_form.root->reference_count++;
		}
		return true;
	} else if (pos == POS_NOUN) {
		bool contains;
		const array<inflected_noun>& forms = morphology_parser.inflected_nouns.get(words, contains);
		if (!contains) return true;

		flagged_logical_form<Formula> marked_logical_form = logical_form;
		marked_logical_form.flags.is_first_token_capital = (First ? morphology_parser.is_capitalized(words[0]) : false);
		for (const inflected_noun& form : forms) {
			/* TODO: should we prevent proper nouns from being parsed as `N` rather than `STRING`? e.g. "Solar System" */
			/*if (form.is_proper == properness::PROPER)
				continue;*/
			if (!intersect(marked_logical_form.flags.index_number, logical_form.flags.index_number, form.number))
				continue;

			if (!emit_root(form.root, marked_logical_form))
				return false;
			free(*marked_logical_form.root); if (marked_logical_form.root->reference_count == 0) free(marked_logical_form.root);
			marked_logical_form.root = logical_form.root;
			logical_form.root->reference_count++;
		}
		return true;
	} else if (pos == POS_ADJECTIVE) {
		/* check if its an adverb formed from an adjective and '-ly' */
		flagged_logical_form<Formula> marked_logical_form = logical_form;
		marked_logical_form.flags.is_first_token_capital = (First ? morphology_parser.is_capitalized(words[0]) : false);
		if (intersect(marked_logical_form.flags.flags[(unsigned int) grammatical_flag::LY], logical_form.flags.flags[(unsigned int) grammatical_flag::LY], grammatical_flag_value::TRUE)) {
			bool contains;
			const array<inflected_adverb>& forms = morphology_parser.inflected_adverbs.get(words, contains);
			if (contains) {
				for (const inflected_adverb& form : forms) {
					if (!intersect(marked_logical_form.flags.comp, logical_form.flags.comp, form.comp))
						continue;

					const adverb_root& root = morphology_parser.adverbs.get(form.root);
					if (root.adj_root.length == 0)
						continue;

					if (!emit_root(root.adj_root, marked_logical_form))
						return false;
					free(*marked_logical_form.root); if (marked_logical_form.root->reference_count == 0) free(marked_logical_form.root);
					marked_logical_form.root = logical_form.root;
					marked_logical_form.flags.flags[(unsigned int) grammatical_flag::LY] = grammatical_flag_value::TRUE;
					logical_form.root->reference_count++;
				}
			}
		}

		if (intersect(marked_logical_form.flags.flags[(unsigned int) grammatical_flag::LY], logical_form.flags.flags[(unsigned int) grammatical_flag::LY], grammatical_flag_value::FALSE)) {
			bool contains;
			const array<inflected_adjective>& forms = morphology_parser.inflected_adjectives.get(words, contains);
			if (contains) {
				for (const inflected_adjective& form : forms) {
					/* add grammatical flags for comparative, superlative, adverb formation using '-ly' */
					if (!intersect(marked_logical_form.flags.comp, logical_form.flags.comp, form.comp))
						continue;

					if (!emit_root(form.root, marked_logical_form))
						return false;
					free(*marked_logical_form.root); if (marked_logical_form.root->reference_count == 0) free(marked_logical_form.root);
					marked_logical_form.root = logical_form.root;
					marked_logical_form.flags.flags[(unsigned int) grammatical_flag::LY] = grammatical_flag_value::FALSE;
					logical_form.root->reference_count++;
				}
			}
		}
		return true;
	} else if (pos == POS_ADVERB) {
		/* TODO: implement this */
		return false;
		//return emit_root(words, logical_form);
	} else {
		flagged_logical_form<Formula> marked_logical_form = logical_form;
		marked_logical_form.flags.is_first_token_capital = (First ? morphology_parser.is_capitalized(words[0]) : false);
		return emit_root(words, marked_logical_form);
	}
}

template<bool First, typename Formula, typename PartOfSpeechType>
bool morphology_inflect(
		const morphology_en& morphology_parser, const sequence& root, PartOfSpeechType pos,
		const flagged_logical_form<Formula>& logical_form, array<sequence>& inflections)
{
	if (First) {
		if (!morphology_inflect<false>(morphology_parser, root, pos, logical_form, inflections))
			return false;
		for (sequence& inflection : inflections) {
			unsigned int capitalized_word;
			if (morphology_parser.capitalize(inflection[0], capitalized_word))
				inflection[0] = capitalized_word;
		}
		return true;
	}

	if (pos == POS_VERB) {
		grammatical_tense tense;
		unsigned int tense_value; unsigned int* excluded; unsigned int excluded_count;
		if (!get_tense(logical_form.root, tense_value, excluded, excluded_count))
			return false;
		if (tense_value == IMPLICIT_NODE) {
			if (index_of((unsigned int) built_in_predicates::PRESENT, excluded, excluded_count) < excluded_count) {
				if (index_of((unsigned int) built_in_predicates::PAST, excluded, excluded_count) < excluded_count) {
					free(excluded);
					return false;
				}
				tense = grammatical_tense::PAST;
			} else {
				if (index_of((unsigned int) built_in_predicates::PAST, excluded, excluded_count) < excluded_count)
					tense = grammatical_tense::PRESENT;
				else tense = grammatical_tense::ANY;
			}
			free(excluded);
		} else if (tense_value == UNION_NODE) {
			if (index_of((unsigned int) built_in_predicates::PRESENT, excluded, excluded_count) < excluded_count) {
				if (index_of((unsigned int) built_in_predicates::PAST, excluded, excluded_count) < excluded_count)
					tense = grammatical_tense::ANY;
				else tense = grammatical_tense::PRESENT;
			} else {
				if (index_of((unsigned int) built_in_predicates::PAST, excluded, excluded_count) < excluded_count) {
					tense = grammatical_tense::PAST;
				} else {
					free(excluded);
					return false;
				}
			}
			free(excluded);
		} else if (tense_value == (unsigned int) built_in_predicates::PRESENT) {
			tense = grammatical_tense::PRESENT;
		} else if (tense_value == (unsigned int) built_in_predicates::PAST) {
			tense = grammatical_tense::PAST;
		} else {
			return false;
		}

		return morphology_parser.inflect_verb({root, grammatical_person::THIRD, logical_form.flags.index_number, logical_form.flags.mood, tense}, inflections);

	} else if (pos == POS_NOUN) {
		return morphology_parser.inflect_noun({root, properness::BOTH /* ignored */, logical_form.flags.index_number}, inflections);

	} else if (pos == POS_ADJECTIVE) {
		if (has_intersection(logical_form.flags.flags[(unsigned int) grammatical_flag::LY], grammatical_flag_value::TRUE)) {
			bool contains;
			const array<sequence>& adverb_roots = morphology_parser.adjective_adverb_map.get(root, contains);
			if (contains) {
				for (const sequence& adverb_root : adverb_roots)
					if (!morphology_parser.inflect_adverb({adverb_root, logical_form.flags.comp}, inflections)) return false;
			}
		}

		if (has_intersection(logical_form.flags.flags[(unsigned int) grammatical_flag::LY], grammatical_flag_value::FALSE))
			if (!morphology_parser.inflect_adjective({root, logical_form.flags.comp}, inflections)) return false;
		return true;

	} else if (pos == POS_ADVERB) {
		/* TODO: implement this */
		return false;

	} else {
		if (!inflections.ensure_capacity(inflections.length + 1)
		 || !init(inflections[inflections.length], root))
			return false;
		inflections.length++;
		return true;
	}
}

#endif /* HDP_PARSER_H_ */
